$DIR/config_test.go: `.GenerateDocs()`
$DIR/gethwrappers/abigen_test.go: `.NewBackend(types.GenesisAlloc{
		owner.From: {
			Balance: big.NewInt(0).Mul(big.NewInt(10), big.NewInt(1e18)),
		},
	}, simulated.WithBlockGasLimit(10e6))`
$DIR/gethwrappers/abigen_test.go: `.NewInt(0)`
$DIR/gethwrappers/abigen_test.go: `.Mul(big.NewInt(10), big.NewInt(1e18))`
$DIR/gethwrappers/abigen_test.go: `.NewInt(10)`
$DIR/gethwrappers/abigen_test.go: `.NewInt(1e18)`
$DIR/gethwrappers/abigen_test.go: `.WithBlockGasLimit(10e6)`
$DIR/gethwrappers/abigen_test.go: `.Client()`
$DIR/gethwrappers/abigen_test.go: `.DeployLogEmitter(owner, ec)`
$DIR/gethwrappers/abigen_test.go: `.Address()`
$DIR/gethwrappers/generation/generate_link/utils/json_normalization_test.go: `t.Run(test.name, func(t *testing.T) {
			jsonBytes, err := json.Marshal(test.input)
			assert.NoError(t, err)

			str, err := utils.NormalizedJSON(jsonBytes)

			assert.Equal(t, test.wantError, err != nil)
			assert.Equal(t, test.want, str)
		})`
$DIR/gethwrappers/generation/generate_link/utils/json_normalization_test.go: `.Run(test.name, func(t *testing.T) {
			jsonBytes, err := json.Marshal(test.input)
			assert.NoError(t, err)

			str, err := utils.NormalizedJSON(jsonBytes)

			assert.Equal(t, test.wantError, err != nil)
			assert.Equal(t, test.want, str)
		})`
$DIR/gethwrappers/generation/generate_link/utils/json_normalization_test.go: `.Marshal(test.input)`
$DIR/gethwrappers/generation/generate_link/utils/json_normalization_test.go: `.NormalizedJSON(jsonBytes)`
$DIR/gethwrappers/go_generate_test.go: `SkipShort(t, "requires compiled artifacts")`
$DIR/gethwrappers/go_generate_test.go: `wd = "<directory containing this test>"`
$DIR/gethwrappers/go_generate_test.go: `compareCurrentCompilerArtifactAgainstRecordsAndSoliditySources(t, contractVersionInfo)`
$DIR/gethwrappers/go_generate_test.go: `.Getwd()`
$DIR/gethwrappers/go_generate_test.go: `.ReadFile(filepath.Join(getProjectRoot(t), "../contracts/LinkToken.json"))`
$DIR/gethwrappers/go_generate_test.go: `.Join(getProjectRoot(t), "../contracts/LinkToken.json")`
$DIR/gethwrappers/go_generate_test.go: `.Sprintf("%x", sha256.Sum256(linkDetails))`
$DIR/gethwrappers/go_generate_test.go: `.Sum256(linkDetails)`
$DIR/gethwrappers/utils_test.go: `.BoxOutput("some error %d %s", 123, "foo")`
$DIR/pkg/abi/selector_parser_test.go: `result = append(result, abi.ArgumentMarshaling{Name: name, Type: typeName, InternalType: typeName, Components: nil, Indexed: false})`
$DIR/pkg/abi/selector_parser_test.go: `result = append(result, abi.ArgumentMarshaling{Name: name, Type: "tuple", InternalType: "tuple", Components: components, Indexed: false})`
$DIR/pkg/abi/selector_parser_test.go: `result = append(result, abi.ArgumentMarshaling{Name: name, Type: "tuple[]", InternalType: "tuple[]", Components: components[0], Indexed: false})`
$DIR/pkg/abi/selector_parser_test.go: `t.Run(scenario.description, func(t *testing.T) {
			_, err := ParseSelector(scenario.input)
			require.Error(t, err)
			assert.Equal(t, scenario.expectedError, err.Error())
		})`
$DIR/pkg/abi/selector_parser_test.go: `.Sprintf("name%d", i)`
$DIR/pkg/abi/selector_parser_test.go: `.DeepEqual(selector.Inputs, tt.args)`
$DIR/pkg/abi/selector_parser_test.go: `.DeepEqual(selector.Inputs, tt.args)`
$DIR/pkg/abi/selector_parser_test.go: `.Run(scenario.description, func(t *testing.T) {
			_, err := ParseSelector(scenario.input)
			require.Error(t, err)
			assert.Equal(t, scenario.expectedError, err.Error())
		})`
$DIR/pkg/assets/assets_test.go: `eth.SetInt64(1)`
$DIR/pkg/assets/assets_test.go: `eth.SetString("900000000000000000", 10)`
$DIR/pkg/assets/assets_test.go: `eth.SetString("115792089237316195423570985008687907853269984665640564039457584007913129639935", 10)`
$DIR/pkg/assets/assets_test.go: `eth.SetString("115792089237316195423570985008687907853269984665640564039457584007913129639936", 10)`
$DIR/pkg/assets/assets_test.go: `err = json.Unmarshal([]byte(`1`), &eth)`
$DIR/pkg/assets/assets_test.go: `err = eth2.Scan(v)`
$DIR/pkg/assets/assets_test.go: `.NewEth(0)`
$DIR/pkg/assets/assets_test.go: `.SetInt64(1)`
$DIR/pkg/assets/assets_test.go: `.SetString("900000000000000000", 10)`
$DIR/pkg/assets/assets_test.go: `.SetString("115792089237316195423570985008687907853269984665640564039457584007913129639935", 10)`
$DIR/pkg/assets/assets_test.go: `.SetString("115792089237316195423570985008687907853269984665640564039457584007913129639936", 10)`
$DIR/pkg/assets/assets_test.go: `.String()`
$DIR/pkg/assets/assets_test.go: `.NewEth(0)`
$DIR/pkg/assets/assets_test.go: `.NewEth(1)`
$DIR/pkg/assets/assets_test.go: `.IsZero()`
$DIR/pkg/assets/assets_test.go: `.NewEth(1)`
$DIR/pkg/assets/assets_test.go: `.Marshal(eth)`
$DIR/pkg/assets/assets_test.go: `.Unmarshal([]byte(`"1"`), &eth)`
$DIR/pkg/assets/assets_test.go: `.String()`
$DIR/pkg/assets/assets_test.go: `.Unmarshal([]byte(`"x"`), &eth)`
$DIR/pkg/assets/assets_test.go: `.Unmarshal([]byte(`1`), &eth)`
$DIR/pkg/assets/assets_test.go: `.NewEth(123)`
$DIR/pkg/assets/assets_test.go: `.NewEthValue(123)`
$DIR/pkg/assets/assets_test.go: `.NewEthValueS(ethRef.String())`
$DIR/pkg/assets/assets_test.go: `.String()`
$DIR/pkg/assets/assets_test.go: `.NewEth(123)`
$DIR/pkg/assets/assets_test.go: `.Symbol()`
$DIR/pkg/assets/assets_test.go: `.NewEth(123)`
$DIR/pkg/assets/assets_test.go: `.Value()`
$DIR/pkg/assets/assets_test.go: `.NewEth(0)`
$DIR/pkg/assets/assets_test.go: `.Scan(v)`
$DIR/pkg/assets/assets_test.go: `.NewEth(123)`
$DIR/pkg/assets/assets_test.go: `.NewEth(321)`
$DIR/pkg/assets/assets_test.go: `.NewEth(321)`
$DIR/pkg/assets/assets_test.go: `.Cmp(eth2)`
$DIR/pkg/assets/units_test.go: `t.Run(test.name, func(t *testing.T) {
			t.Parallel()

			expected := assets.NewWeiI(0)
			assert.Equal(t, expected, test.fn(0))

			expected = assets.NewWeiI(100)
			expected = expected.Mul(test.factor)
			assert.Equal(t, expected, test.fn(100))
		})`
$DIR/pkg/assets/units_test.go: `expected = assets.NewWeiI(100)`
$DIR/pkg/assets/units_test.go: `expected = expected.Mul(test.factor)`
$DIR/pkg/assets/units_test.go: `.NewInt(params.Wei)`
$DIR/pkg/assets/units_test.go: `.NewInt(params.GWei)`
$DIR/pkg/assets/units_test.go: `.NewInt(params.GWei * 1000)`
$DIR/pkg/assets/units_test.go: `.NewInt(params.Ether)`
$DIR/pkg/assets/units_test.go: `.Run(test.name, func(t *testing.T) {
			t.Parallel()

			expected := assets.NewWeiI(0)
			assert.Equal(t, expected, test.fn(0))

			expected = assets.NewWeiI(100)
			expected = expected.Mul(test.factor)
			assert.Equal(t, expected, test.fn(100))
		})`
$DIR/pkg/assets/units_test.go: `.NewWeiI(0)`
$DIR/pkg/assets/units_test.go: `.NewWeiI(100)`
$DIR/pkg/assets/units_test.go: `.Mul(test.factor)`
$DIR/pkg/assets/wei_test.go: `t.Run(tt.input, func(t *testing.T) {
			var w Wei
			err := w.UnmarshalText([]byte(tt.input))
			require.NoError(t, err)
			b, err := w.MarshalText()
			require.NoError(t, err)
			assert.Equal(t, tt.exp, string(b))
			assert.Equal(t, tt.exp, w.String())
		})`
$DIR/pkg/assets/wei_test.go: `got = tryParseExp("0e-80000800")`
$DIR/pkg/assets/wei_test.go: `got = tryParseExp("0e+802444440")`
$DIR/pkg/assets/wei_test.go: `.Run(tt.input, func(t *testing.T) {
			var w Wei
			err := w.UnmarshalText([]byte(tt.input))
			require.NoError(t, err)
			b, err := w.MarshalText()
			require.NoError(t, err)
			assert.Equal(t, tt.exp, string(b))
			assert.Equal(t, tt.exp, w.String())
		})`
$DIR/pkg/assets/wei_test.go: `.UnmarshalText([]byte(tt.input))`
$DIR/pkg/assets/wei_test.go: `.MarshalText()`
$DIR/pkg/chains/chain_kv_test.go: `kv = chains.NewChainsKV[*testChainService](onechain)`
$DIR/pkg/chains/chain_kv_test.go: `c, err = kv.Get(testChainID)`
$DIR/pkg/chains/chain_kv_test.go: `cs, err = kv.List()`
$DIR/pkg/chains/chain_kv_test.go: `cs, err = kv.List(testChainID)`
$DIR/pkg/chains/chain_kv_test.go: `cs, err = kv.List("no such id")`
$DIR/pkg/chains/chain_kv_test.go: `.Get(testChainID)`
$DIR/pkg/chains/chain_kv_test.go: `.List()`
$DIR/pkg/chains/chain_kv_test.go: `.Get(testChainID)`
$DIR/pkg/chains/chain_kv_test.go: `.List()`
$DIR/pkg/chains/chain_kv_test.go: `.List(testChainID)`
$DIR/pkg/chains/chain_kv_test.go: `.List("no such id")`
$DIR/pkg/chains/legacyevm/chain_test.go: `c.On("ID").Return(big.NewInt(7))`
$DIR/pkg/chains/legacyevm/chain_test.go: `t.Run(tt.name, func(t *testing.T) {
			if err := tt.opts.Validate(); (err != nil) != tt.wantErr {
				t.Errorf("ChainOpts.Validate() error = %v, wantErr %v", err, tt.wantErr)
			}
		})`
$DIR/pkg/chains/legacyevm/chain_test.go: `.NewChain(t)`
$DIR/pkg/chains/legacyevm/chain_test.go: `.On("ID")`
$DIR/pkg/chains/legacyevm/chain_test.go: `.Return(big.NewInt(7))`
$DIR/pkg/chains/legacyevm/chain_test.go: `.NewInt(7)`
$DIR/pkg/chains/legacyevm/chain_test.go: `.ID()`
$DIR/pkg/chains/legacyevm/chain_test.go: `.String()`
$DIR/pkg/chains/legacyevm/chain_test.go: `.NewLegacyChains(m)`
$DIR/pkg/chains/legacyevm/chain_test.go: `.Get(c.ID().String())`
$DIR/pkg/chains/legacyevm/chain_test.go: `.ID()`
$DIR/pkg/chains/legacyevm/chain_test.go: `.String()`
$DIR/pkg/chains/legacyevm/chain_test.go: `.Listener()`
$DIR/pkg/chains/legacyevm/chain_test.go: `.NewNoOpDataSource()`
$DIR/pkg/chains/legacyevm/chain_test.go: `.Run(tt.name, func(t *testing.T) {
			if err := tt.opts.Validate(); (err != nil) != tt.wantErr {
				t.Errorf("ChainOpts.Validate() error = %v, wantErr %v", err, tt.wantErr)
			}
		})`
$DIR/pkg/chains/legacyevm/chain_test.go: `.opts.Validate()`
$DIR/pkg/client/chain_client_test.go: `err = json.Unmarshal(response, &resp)`
$DIR/pkg/client/chain_client_test.go: `t.Run("happy path", func(t *testing.T) {
		result := mustReadResult(t, "../testdata/jsonrpc/getTransactionReceipt.json")

		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			}
			if assert.Equal(t, "eth_getTransactionReceipt", method) && assert.True(t, params.IsArray()) &&
				assert.Equal(t, txHash, params.Array()[0].String()) {
				resp.Result = string(result)
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		hash := common.HexToHash(txHash)
		receipt, err := ethClient.TransactionReceipt(tests.Context(t), hash)
		require.NoError(t, err)
		assert.Equal(t, hash, receipt.TxHash)
		assert.Equal(t, big.NewInt(11), receipt.BlockNumber)
	})`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = string(result)`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = string(result)`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x100"``
$DIR/pkg/client/chain_client_test.go: `t.Run(test.name, func(t *testing.T) {
			wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				switch method {
				case "eth_subscribe":
					resp.Result = `"0x00"`
					resp.Notify = headResult
					return
				case "eth_unsubscribe":
					resp.Result = "true"
					return
				}
				if assert.Equal(t, "eth_getBalance", method) && assert.True(t, params.IsArray()) &&
					assert.Equal(t, strings.ToLower(address.Hex()), strings.ToLower(params.Array()[0].String())) {
					resp.Result = `"` + hexutil.EncodeBig(test.balance) + `"`
				}
				return
			}).WSURL().String()

			ethClient := mustNewChainClient(t, wsURL)

			result, err := ethClient.BalanceAt(tests.Context(t), address, nil)
			require.NoError(t, err)
			assert.Equal(t, test.balance, result)
		})`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"` + hexutil.EncodeBig(test.balance) + `"``
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x100"``
$DIR/pkg/client/chain_client_test.go: `t.Run(test.name, func(t *testing.T) {
			contractAddress := testutils.NewAddress()
			userAddress := testutils.NewAddress()
			functionSelector := evmtypes.HexToFunctionSelector(client.BALANCE_OF_ADDRESS_FUNCTION_SELECTOR) // balanceOf(address)
			txData := utils.ConcatBytes(functionSelector.Bytes(), common.LeftPadBytes(userAddress.Bytes(), utils.EVMWordByteLen))

			wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				switch method {
				case "eth_subscribe":
					resp.Result = `"0x00"`
					resp.Notify = headResult
					return
				case "eth_unsubscribe":
					resp.Result = "true"
					return
				}
				if !assert.Equal(t, "eth_call", method) || !assert.True(t, params.IsArray()) {
					return
				}
				arr := params.Array()
				callArgs := arr[0]
				if assert.True(t, callArgs.IsObject()) &&
					assert.Equal(t, strings.ToLower(contractAddress.Hex()), callArgs.Get("to").String()) &&
					assert.Equal(t, hexutil.Encode(txData), callArgs.Get("data").String()) &&
					assert.Equal(t, "latest", arr[1].String()) {
					resp.Result = `"` + hexutil.EncodeBig(test.balance) + `"`
				}
				return
			}).WSURL().String()

			ethClient := mustNewChainClient(t, wsURL)

			result, err := ethClient.TokenBalance(ctx, userAddress, contractAddress)
			require.NoError(t, err)
			assert.Equal(t, test.balance, result)
		})`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"` + hexutil.EncodeBig(test.balance) + `"``
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = rpcResp`
$DIR/pkg/client/chain_client_test.go: `t.Run(test.name, func(t *testing.T) {
			wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				switch method {
				case "eth_subscribe":
					resp.Result = `"0x00"`
					resp.Notify = headResult
					return
				case "eth_unsubscribe":
					resp.Result = "true"
					return
				}
				if !assert.Equal(t, "eth_getBlockByNumber", method) || !assert.True(t, params.IsArray()) {
					return
				}
				arr := params.Array()
				blockNumStr := arr[0].String()
				var blockNum hexutil.Big
				err := blockNum.UnmarshalText([]byte(blockNumStr))
				if assert.NoError(t, err) && assert.Equal(t, test.expectedRequestBlock, blockNum.ToInt()) &&
					assert.False(t, arr[1].Bool()) {
					resp.Result = test.rpcResp
				}
				return
			}).WSURL().String()

			ethClient := mustNewChainClient(t, wsURL)

			ctx, cancel := context.WithTimeout(tests.Context(t), 5*time.Second)
			result, err := ethClient.HeadByNumber(ctx, expectedBlockNum)
			if test.error != nil {
				require.EqualError(t, err, test.error.Error())
			} else {
				require.NoError(t, err)
				require.Equal(t, expectedBlockHash, result.Hash.Hex())
				require.Equal(t, test.expectedResponseBlock, result.Number)
				require.Zero(t, testutils.FixtureChainID.Cmp(result.EVMChainID.ToInt()))
			}
			cancel()
		})`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = test.rpcResp`
$DIR/pkg/client/chain_client_test.go: `cancel()`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"` + tx.Hash().Hex() + `"``
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"` + tx.Hash().Hex() + `"``
$DIR/pkg/client/chain_client_test.go: `t.Cleanup(rpcSrv.Stop)`
$DIR/pkg/client/chain_client_test.go: `t.Cleanup(ts.Close)`
$DIR/pkg/client/chain_client_test.go: `err = ethClient.SendTransaction(tests.Context(t), tx)`
$DIR/pkg/client/chain_client_test.go: `t.Run("returns Fatal error type when error message is fatal", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "invalid sender"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.Fatal, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"` + tx.Hash().Hex() + `"``
$DIR/pkg/client/chain_client_test.go: `resp.Error.Message = "invalid sender"`
$DIR/pkg/client/chain_client_test.go: `t.Run("returns TransactionAlreadyKnown error type when error message is nonce too low", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "nonce too low"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.TransactionAlreadyKnown, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"` + tx.Hash().Hex() + `"``
$DIR/pkg/client/chain_client_test.go: `resp.Error.Message = "nonce too low"`
$DIR/pkg/client/chain_client_test.go: `t.Run("returns Successful error type when there is no error message", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.NoError(t, err)
		assert.Equal(t, multinode.Successful, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"` + tx.Hash().Hex() + `"``
$DIR/pkg/client/chain_client_test.go: `t.Run("returns Underpriced error type when transaction is terminally underpriced", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "transaction underpriced"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.Underpriced, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"` + tx.Hash().Hex() + `"``
$DIR/pkg/client/chain_client_test.go: `resp.Error.Message = "transaction underpriced"`
$DIR/pkg/client/chain_client_test.go: `t.Run("returns Unsupported error type when error message is queue full", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "queue full"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.Unsupported, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"` + tx.Hash().Hex() + `"``
$DIR/pkg/client/chain_client_test.go: `resp.Error.Message = "queue full"`
$DIR/pkg/client/chain_client_test.go: `t.Run("returns Retryable error type when there is a transaction gap", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "NonceGap"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.Retryable, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"` + tx.Hash().Hex() + `"``
$DIR/pkg/client/chain_client_test.go: `resp.Error.Message = "NonceGap"`
$DIR/pkg/client/chain_client_test.go: `t.Run("returns InsufficientFunds error type when the sender address doesn't have enough funds", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "insufficient funds for transfer"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.InsufficientFunds, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"` + tx.Hash().Hex() + `"``
$DIR/pkg/client/chain_client_test.go: `resp.Error.Message = "insufficient funds for transfer"`
$DIR/pkg/client/chain_client_test.go: `t.Run("returns ExceedsFeeCap error type when gas price is too high for the node", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "Transaction fee cap exceeded"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.ExceedsMaxFee, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"` + tx.Hash().Hex() + `"``
$DIR/pkg/client/chain_client_test.go: `resp.Error.Message = "Transaction fee cap exceeded"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"` + tx.Hash().Hex() + `"``
$DIR/pkg/client/chain_client_test.go: `resp.Error.Message = "some random error"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/chain_client_test.go: `resp.Notify = headResult`
$DIR/pkg/client/chain_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/chain_client_test.go: `resp.Error.Code = -1`
$DIR/pkg/client/chain_client_test.go: `resp.Error.Message = rpcError.Error()`
$DIR/pkg/client/chain_client_test.go: `resp.Result = ""`
$DIR/pkg/client/chain_client_test.go: `err = erroringClient.BatchCallContext(ctx, nil)`
$DIR/pkg/client/chain_client_test.go: `err = erroringClient.BatchCallContextAll(ctx, nil)`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.BlockByHash(ctx, common.Hash{})`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.BlockByNumber(ctx, nil)`
$DIR/pkg/client/chain_client_test.go: `err = erroringClient.CallContext(ctx, nil, "")`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.CallContract(ctx, ethereum.CallMsg{}, nil)`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.CodeAt(ctx, common.Address{}, nil)`
$DIR/pkg/client/chain_client_test.go: `id = erroringClient.ConfiguredChainID()`
$DIR/pkg/client/chain_client_test.go: `err = erroringClient.Dial(ctx)`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.EstimateGas(ctx, ethereum.CallMsg{})`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.FilterLogs(ctx, ethereum.FilterQuery{})`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.HeaderByHash(ctx, common.Hash{})`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.HeaderByNumber(ctx, nil)`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.HeadByHash(ctx, common.Hash{})`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.HeadByNumber(ctx, nil)`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.LINKBalance(ctx, common.Address{}, common.Address{})`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.LatestBlockHeight(ctx)`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.PendingCodeAt(ctx, common.Address{})`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.PendingNonceAt(ctx, common.Address{})`
$DIR/pkg/client/chain_client_test.go: `err = erroringClient.SendTransaction(ctx, nil)`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.NonceAt(ctx, common.Address{}, nil)`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, nil)`
$DIR/pkg/client/chain_client_test.go: `_, _, err = erroringClient.SubscribeToHeads(ctx)`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.SuggestGasPrice(ctx)`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.SuggestGasTipCap(ctx)`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.TokenBalance(ctx, common.Address{}, common.Address{})`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.TransactionByHash(ctx, common.Hash{})`
$DIR/pkg/client/chain_client_test.go: `_, err = erroringClient.TransactionReceipt(ctx, common.Hash{})`
$DIR/pkg/client/chain_client_test.go: `.ReadFile(file)`
$DIR/pkg/client/chain_client_test.go: `.Unmarshal(response, &resp)`
$DIR/pkg/client/chain_client_test.go: `.Run("happy path", func(t *testing.T) {
		result := mustReadResult(t, "../testdata/jsonrpc/getTransactionReceipt.json")

		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			}
			if assert.Equal(t, "eth_getTransactionReceipt", method) && assert.True(t, params.IsArray()) &&
				assert.Equal(t, txHash, params.Array()[0].String()) {
				resp.Result = string(result)
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		hash := common.HexToHash(txHash)
		receipt, err := ethClient.TransactionReceipt(tests.Context(t), hash)
		require.NoError(t, err)
		assert.Equal(t, hash, receipt.TxHash)
		assert.Equal(t, big.NewInt(11), receipt.BlockNumber)
	})`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			}
			if assert.Equal(t, "eth_getTransactionReceipt", method) && assert.True(t, params.IsArray()) &&
				assert.Equal(t, txHash, params.Array()[0].String()) {
				resp.Result = string(result)
			}
			return
		})`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.HexToHash(txHash)`
$DIR/pkg/client/chain_client_test.go: `.TransactionReceipt(tests.Context(t), hash)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			}
			if assert.Equal(t, "eth_getTransactionReceipt", method) && assert.True(t, params.IsArray()) &&
				assert.Equal(t, txHash, params.Array()[0].String()) {
				resp.Result = string(result)
			}
			return
		})`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.HexToHash(txHash)`
$DIR/pkg/client/chain_client_test.go: `.TransactionReceipt(tests.Context(t), hash)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.NewAddress()`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
		switch method {
		case "eth_subscribe":
			resp.Result = `"0x00"`
			resp.Notify = headResult
			return
		case "eth_unsubscribe":
			resp.Result = "true"
			return
		}
		if !assert.Equal(t, "eth_getTransactionCount", method) || !assert.True(t, params.IsArray()) {
			return
		}
		arr := params.Array()
		if assert.Equal(t, strings.ToLower(address.Hex()), strings.ToLower(arr[0].String())) &&
			assert.Equal(t, "pending", arr[1].String()) {
			resp.Result = `"0x100"`
		}
		return
	})`
$DIR/pkg/client/chain_client_test.go: `.Array()`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.PendingNonceAt(tests.Context(t), address)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.NewInt(0)`
$DIR/pkg/client/chain_client_test.go: `.SetString("100000000000000000000", 10)`
$DIR/pkg/client/chain_client_test.go: `.NewAddress()`
$DIR/pkg/client/chain_client_test.go: `.NewInt(256)`
$DIR/pkg/client/chain_client_test.go: `.Run(test.name, func(t *testing.T) {
			wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				switch method {
				case "eth_subscribe":
					resp.Result = `"0x00"`
					resp.Notify = headResult
					return
				case "eth_unsubscribe":
					resp.Result = "true"
					return
				}
				if assert.Equal(t, "eth_getBalance", method) && assert.True(t, params.IsArray()) &&
					assert.Equal(t, strings.ToLower(address.Hex()), strings.ToLower(params.Array()[0].String())) {
					resp.Result = `"` + hexutil.EncodeBig(test.balance) + `"`
				}
				return
			}).WSURL().String()

			ethClient := mustNewChainClient(t, wsURL)

			result, err := ethClient.BalanceAt(tests.Context(t), address, nil)
			require.NoError(t, err)
			assert.Equal(t, test.balance, result)
		})`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				switch method {
				case "eth_subscribe":
					resp.Result = `"0x00"`
					resp.Notify = headResult
					return
				case "eth_unsubscribe":
					resp.Result = "true"
					return
				}
				if assert.Equal(t, "eth_getBalance", method) && assert.True(t, params.IsArray()) &&
					assert.Equal(t, strings.ToLower(address.Hex()), strings.ToLower(params.Array()[0].String())) {
					resp.Result = `"` + hexutil.EncodeBig(test.balance) + `"`
				}
				return
			})`
$DIR/pkg/client/chain_client_test.go: `.EncodeBig(test.balance)`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.BalanceAt(tests.Context(t), address, nil)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
		switch method {
		case "eth_subscribe":
			resp.Result = `"0x00"`
			resp.Notify = headResult
			return
		case "eth_unsubscribe":
			resp.Result = "true"
			return
		}
		if !assert.Equal(t, "eth_blockNumber", method) {
			return
		}
		resp.Result = `"0x100"`
		return
	})`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.LatestBlockHeight(tests.Context(t))`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.NewInt(256)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.NewInt(0)`
$DIR/pkg/client/chain_client_test.go: `.SetString("100000000000000000000000000000000000000", 10)`
$DIR/pkg/client/chain_client_test.go: `.NewInt(256)`
$DIR/pkg/client/chain_client_test.go: `.Run(test.name, func(t *testing.T) {
			contractAddress := testutils.NewAddress()
			userAddress := testutils.NewAddress()
			functionSelector := evmtypes.HexToFunctionSelector(client.BALANCE_OF_ADDRESS_FUNCTION_SELECTOR) // balanceOf(address)
			txData := utils.ConcatBytes(functionSelector.Bytes(), common.LeftPadBytes(userAddress.Bytes(), utils.EVMWordByteLen))

			wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				switch method {
				case "eth_subscribe":
					resp.Result = `"0x00"`
					resp.Notify = headResult
					return
				case "eth_unsubscribe":
					resp.Result = "true"
					return
				}
				if !assert.Equal(t, "eth_call", method) || !assert.True(t, params.IsArray()) {
					return
				}
				arr := params.Array()
				callArgs := arr[0]
				if assert.True(t, callArgs.IsObject()) &&
					assert.Equal(t, strings.ToLower(contractAddress.Hex()), callArgs.Get("to").String()) &&
					assert.Equal(t, hexutil.Encode(txData), callArgs.Get("data").String()) &&
					assert.Equal(t, "latest", arr[1].String()) {
					resp.Result = `"` + hexutil.EncodeBig(test.balance) + `"`
				}
				return
			}).WSURL().String()

			ethClient := mustNewChainClient(t, wsURL)

			result, err := ethClient.TokenBalance(ctx, userAddress, contractAddress)
			require.NoError(t, err)
			assert.Equal(t, test.balance, result)
		})`
$DIR/pkg/client/chain_client_test.go: `.NewAddress()`
$DIR/pkg/client/chain_client_test.go: `.NewAddress()`
$DIR/pkg/client/chain_client_test.go: `.HexToFunctionSelector(client.BALANCE_OF_ADDRESS_FUNCTION_SELECTOR)`
$DIR/pkg/client/chain_client_test.go: `.ConcatBytes(functionSelector.Bytes(), common.LeftPadBytes(userAddress.Bytes(), utils.EVMWordByteLen))`
$DIR/pkg/client/chain_client_test.go: `.Bytes()`
$DIR/pkg/client/chain_client_test.go: `.LeftPadBytes(userAddress.Bytes(), utils.EVMWordByteLen)`
$DIR/pkg/client/chain_client_test.go: `.Bytes()`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				switch method {
				case "eth_subscribe":
					resp.Result = `"0x00"`
					resp.Notify = headResult
					return
				case "eth_unsubscribe":
					resp.Result = "true"
					return
				}
				if !assert.Equal(t, "eth_call", method) || !assert.True(t, params.IsArray()) {
					return
				}
				arr := params.Array()
				callArgs := arr[0]
				if assert.True(t, callArgs.IsObject()) &&
					assert.Equal(t, strings.ToLower(contractAddress.Hex()), callArgs.Get("to").String()) &&
					assert.Equal(t, hexutil.Encode(txData), callArgs.Get("data").String()) &&
					assert.Equal(t, "latest", arr[1].String()) {
					resp.Result = `"` + hexutil.EncodeBig(test.balance) + `"`
				}
				return
			})`
$DIR/pkg/client/chain_client_test.go: `.Array()`
$DIR/pkg/client/chain_client_test.go: `.EncodeBig(test.balance)`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.TokenBalance(ctx, userAddress, contractAddress)`
$DIR/pkg/client/chain_client_test.go: `.Unmarshal([]byte(input), &receipt)`
$DIR/pkg/client/chain_client_test.go: `.NewInt(123)`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, expectedChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
		switch method {
		case "eth_subscribe":
			resp.Result = `"0x00"`
			resp.Notify = headResult
			return
		case "eth_unsubscribe":
			resp.Result = "true"
			return
		}
		if method == "eth_getBlockByNumber" && params.IsArray() {
			arr := params.Array()
			if arr[0].String() == "safe" {
				resp.Result = rpcResp
			}
		}
		return
	})`
$DIR/pkg/client/chain_client_test.go: `.IsArray()`
$DIR/pkg/client/chain_client_test.go: `.Array()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.WithTimeout(t.Context(), 25*time.Second)`
$DIR/pkg/client/chain_client_test.go: `.Context()`
$DIR/pkg/client/chain_client_test.go: `.LatestSafeBlock(ctx)`
$DIR/pkg/client/chain_client_test.go: `.Cmp(result.EVMChainID.ToInt())`
$DIR/pkg/client/chain_client_test.go: `.EVMChainID.ToInt()`
$DIR/pkg/client/chain_client_test.go: `.NewInt(1)`
$DIR/pkg/client/chain_client_test.go: `.Int64()`
$DIR/pkg/client/chain_client_test.go: `.Int64()`
$DIR/pkg/client/chain_client_test.go: `.New("RPC call failed: not found")`
$DIR/pkg/client/chain_client_test.go: `.Run(test.name, func(t *testing.T) {
			wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				switch method {
				case "eth_subscribe":
					resp.Result = `"0x00"`
					resp.Notify = headResult
					return
				case "eth_unsubscribe":
					resp.Result = "true"
					return
				}
				if !assert.Equal(t, "eth_getBlockByNumber", method) || !assert.True(t, params.IsArray()) {
					return
				}
				arr := params.Array()
				blockNumStr := arr[0].String()
				var blockNum hexutil.Big
				err := blockNum.UnmarshalText([]byte(blockNumStr))
				if assert.NoError(t, err) && assert.Equal(t, test.expectedRequestBlock, blockNum.ToInt()) &&
					assert.False(t, arr[1].Bool()) {
					resp.Result = test.rpcResp
				}
				return
			}).WSURL().String()

			ethClient := mustNewChainClient(t, wsURL)

			ctx, cancel := context.WithTimeout(tests.Context(t), 5*time.Second)
			result, err := ethClient.HeadByNumber(ctx, expectedBlockNum)
			if test.error != nil {
				require.EqualError(t, err, test.error.Error())
			} else {
				require.NoError(t, err)
				require.Equal(t, expectedBlockHash, result.Hash.Hex())
				require.Equal(t, test.expectedResponseBlock, result.Number)
				require.Zero(t, testutils.FixtureChainID.Cmp(result.EVMChainID.ToInt()))
			}
			cancel()
		})`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				switch method {
				case "eth_subscribe":
					resp.Result = `"0x00"`
					resp.Notify = headResult
					return
				case "eth_unsubscribe":
					resp.Result = "true"
					return
				}
				if !assert.Equal(t, "eth_getBlockByNumber", method) || !assert.True(t, params.IsArray()) {
					return
				}
				arr := params.Array()
				blockNumStr := arr[0].String()
				var blockNum hexutil.Big
				err := blockNum.UnmarshalText([]byte(blockNumStr))
				if assert.NoError(t, err) && assert.Equal(t, test.expectedRequestBlock, blockNum.ToInt()) &&
					assert.False(t, arr[1].Bool()) {
					resp.Result = test.rpcResp
				}
				return
			})`
$DIR/pkg/client/chain_client_test.go: `.Array()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.UnmarshalText([]byte(blockNumStr))`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.WithTimeout(tests.Context(t), 5*time.Second)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.HeadByNumber(ctx, expectedBlockNum)`
$DIR/pkg/client/chain_client_test.go: `.NewLegacyTransaction(uint64(42), testutils.NewAddress(), big.NewInt(142), 242, big.NewInt(342), []byte{1, 2, 3})`
$DIR/pkg/client/chain_client_test.go: `.NewAddress()`
$DIR/pkg/client/chain_client_test.go: `.NewInt(142)`
$DIR/pkg/client/chain_client_test.go: `.NewInt(342)`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
		switch method {
		case "eth_subscribe":
			resp.Result = `"0x00"`
			resp.Notify = headResult
			return
		case "eth_unsubscribe":
			resp.Result = "true"
			return
		}
		if !assert.Equal(t, "eth_sendRawTransaction", method) {
			return
		}
		resp.Result = `"` + tx.Hash().Hex() + `"`
		return
	})`
$DIR/pkg/client/chain_client_test.go: `.Hash()`
$DIR/pkg/client/chain_client_test.go: `.Hex()`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.SendTransaction(tests.Context(t), tx)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.NewLegacyTransaction(uint64(42), testutils.NewAddress(), big.NewInt(142), 242, big.NewInt(342), []byte{1, 2, 3})`
$DIR/pkg/client/chain_client_test.go: `.NewAddress()`
$DIR/pkg/client/chain_client_test.go: `.NewInt(142)`
$DIR/pkg/client/chain_client_test.go: `.NewInt(342)`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
		switch method {
		case "eth_subscribe":
			resp.Result = `"0x00"`
			resp.Notify = headResult
			return
		case "eth_unsubscribe":
			resp.Result = "true"
			return
		case "eth_sendRawTransaction":
			resp.Result = `"` + tx.Hash().Hex() + `"`
		}
		return
	})`
$DIR/pkg/client/chain_client_test.go: `.Hash()`
$DIR/pkg/client/chain_client_test.go: `.Hex()`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.NewServer()`
$DIR/pkg/client/chain_client_test.go: `.Cleanup(rpcSrv.Stop)`
$DIR/pkg/client/chain_client_test.go: `.RegisterName("eth", &service)`
$DIR/pkg/client/chain_client_test.go: `.NewServer(rpcSrv)`
$DIR/pkg/client/chain_client_test.go: `.Cleanup(ts.Close)`
$DIR/pkg/client/chain_client_test.go: `.Parse(ts.URL)`
$DIR/pkg/client/chain_client_test.go: `.SendTransaction(tests.Context(t), tx)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.sentCount.Load()`
$DIR/pkg/client/chain_client_test.go: `.WaitTimeout(t)`
$DIR/pkg/client/chain_client_test.go: `.NewAddress()`
$DIR/pkg/client/chain_client_test.go: `.NewLegacyTransaction(uint64(42), testutils.NewAddress(), big.NewInt(142), 242, big.NewInt(342), []byte{1, 2, 3})`
$DIR/pkg/client/chain_client_test.go: `.NewAddress()`
$DIR/pkg/client/chain_client_test.go: `.NewInt(142)`
$DIR/pkg/client/chain_client_test.go: `.NewInt(342)`
$DIR/pkg/client/chain_client_test.go: `.Run("returns Fatal error type when error message is fatal", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "invalid sender"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.Fatal, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "invalid sender"
			}
			return
		})`
$DIR/pkg/client/chain_client_test.go: `.Hash()`
$DIR/pkg/client/chain_client_test.go: `.Hex()`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.Run("returns TransactionAlreadyKnown error type when error message is nonce too low", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "nonce too low"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.TransactionAlreadyKnown, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "nonce too low"
			}
			return
		})`
$DIR/pkg/client/chain_client_test.go: `.Hash()`
$DIR/pkg/client/chain_client_test.go: `.Hex()`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.Run("returns Successful error type when there is no error message", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.NoError(t, err)
		assert.Equal(t, multinode.Successful, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
			}
			return
		})`
$DIR/pkg/client/chain_client_test.go: `.Hash()`
$DIR/pkg/client/chain_client_test.go: `.Hex()`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.Run("returns Underpriced error type when transaction is terminally underpriced", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "transaction underpriced"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.Underpriced, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "transaction underpriced"
			}
			return
		})`
$DIR/pkg/client/chain_client_test.go: `.Hash()`
$DIR/pkg/client/chain_client_test.go: `.Hex()`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.Run("returns Unsupported error type when error message is queue full", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "queue full"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.Unsupported, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "queue full"
			}
			return
		})`
$DIR/pkg/client/chain_client_test.go: `.Hash()`
$DIR/pkg/client/chain_client_test.go: `.Hex()`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.Run("returns Retryable error type when there is a transaction gap", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "NonceGap"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.Retryable, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "NonceGap"
			}
			return
		})`
$DIR/pkg/client/chain_client_test.go: `.Hash()`
$DIR/pkg/client/chain_client_test.go: `.Hex()`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.Run("returns InsufficientFunds error type when the sender address doesn't have enough funds", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "insufficient funds for transfer"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.InsufficientFunds, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "insufficient funds for transfer"
			}
			return
		})`
$DIR/pkg/client/chain_client_test.go: `.Hash()`
$DIR/pkg/client/chain_client_test.go: `.Hex()`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.Run("returns ExceedsFeeCap error type when gas price is too high for the node", func(t *testing.T) {
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "Transaction fee cap exceeded"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		errType, err := ethClient.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)
		assert.Error(t, err)
		assert.Equal(t, multinode.ExceedsMaxFee, errType)
	})`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "Transaction fee cap exceeded"
			}
			return
		})`
$DIR/pkg/client/chain_client_test.go: `.Hash()`
$DIR/pkg/client/chain_client_test.go: `.Hex()`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_sendRawTransaction":
				resp.Result = `"` + tx.Hash().Hex() + `"`
				resp.Error.Message = "some random error"
			}
			return
		})`
$DIR/pkg/client/chain_client_test.go: `.Hash()`
$DIR/pkg/client/chain_client_test.go: `.Hex()`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.SendTransactionReturnCode(tests.Context(t), tx, fromAddress)`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.WithTimeout(tests.Context(t), tests.WaitTimeout(t))`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.WaitTimeout(t)`
$DIR/pkg/client/chain_client_test.go: `.NewInt(123456)`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, chainId, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
		if method == "eth_unsubscribe" {
			resp.Result = "true"
			return
		}
		assert.Equal(t, "eth_subscribe", method)
		if assert.True(t, params.IsArray()) && assert.Equal(t, "newHeads", params.Array()[0].String()) {
			resp.Result = `"0x00"`
			resp.Notify = headResult
		}
		return
	})`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.SubscribeToHeads(ctx)`
$DIR/pkg/client/chain_client_test.go: `.Err()`
$DIR/pkg/client/chain_client_test.go: `.Done()`
$DIR/pkg/client/chain_client_test.go: `.New("something went wrong")`
$DIR/pkg/client/chain_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			}
			require.Equal(t, "eth_call", method)
			resp.Error.Code = -1
			resp.Error.Message = rpcError.Error()
			resp.Result = ""
			return
		})`
$DIR/pkg/client/chain_client_test.go: `.WSURL()`
$DIR/pkg/client/chain_client_test.go: `.String()`
$DIR/pkg/client/chain_client_test.go: `.BatchCallContext(context.Background(), b)`
$DIR/pkg/client/chain_client_test.go: `.Background()`
$DIR/pkg/client/chain_client_test.go: `.Context(t)`
$DIR/pkg/client/chain_client_test.go: `.NewChainClientWithEmptyNode(t, multinode.NodeSelectionModeRoundRobin, time.Second*0, time.Second*0, testutils.FixtureChainID)`
$DIR/pkg/client/chain_client_test.go: `.BalanceAt(ctx, common.Address{}, nil)`
$DIR/pkg/client/chain_client_test.go: `.BatchCallContext(ctx, nil)`
$DIR/pkg/client/chain_client_test.go: `.BatchCallContextAll(ctx, nil)`
$DIR/pkg/client/chain_client_test.go: `.BlockByHash(ctx, common.Hash{})`
$DIR/pkg/client/chain_client_test.go: `.BlockByNumber(ctx, nil)`
$DIR/pkg/client/chain_client_test.go: `.CallContext(ctx, nil, "")`
$DIR/pkg/client/chain_client_test.go: `.CallContract(ctx, ethereum.CallMsg{}, nil)`
$DIR/pkg/client/chain_client_test.go: `.ConfiguredChainID()`
$DIR/pkg/client/chain_client_test.go: `.CodeAt(ctx, common.Address{}, nil)`
$DIR/pkg/client/chain_client_test.go: `.ConfiguredChainID()`
$DIR/pkg/client/chain_client_test.go: `.Dial(ctx)`
$DIR/pkg/client/chain_client_test.go: `.EstimateGas(ctx, ethereum.CallMsg{})`
$DIR/pkg/client/chain_client_test.go: `.FilterLogs(ctx, ethereum.FilterQuery{})`
$DIR/pkg/client/chain_client_test.go: `.HeaderByHash(ctx, common.Hash{})`
$DIR/pkg/client/chain_client_test.go: `.HeaderByNumber(ctx, nil)`
$DIR/pkg/client/chain_client_test.go: `.HeadByHash(ctx, common.Hash{})`
$DIR/pkg/client/chain_client_test.go: `.HeadByNumber(ctx, nil)`
$DIR/pkg/client/chain_client_test.go: `.LINKBalance(ctx, common.Address{}, common.Address{})`
$DIR/pkg/client/chain_client_test.go: `.LatestBlockHeight(ctx)`
$DIR/pkg/client/chain_client_test.go: `.PendingCodeAt(ctx, common.Address{})`
$DIR/pkg/client/chain_client_test.go: `.PendingNonceAt(ctx, common.Address{})`
$DIR/pkg/client/chain_client_test.go: `.New("TransactionSender not started")`
$DIR/pkg/client/chain_client_test.go: `.SendTransaction(ctx, nil)`
$DIR/pkg/client/chain_client_test.go: `.NewLegacyTransaction(uint64(42), testutils.NewAddress(), big.NewInt(142), 242, big.NewInt(342), []byte{1, 2, 3})`
$DIR/pkg/client/chain_client_test.go: `.NewAddress()`
$DIR/pkg/client/chain_client_test.go: `.NewInt(142)`
$DIR/pkg/client/chain_client_test.go: `.NewInt(342)`
$DIR/pkg/client/chain_client_test.go: `.SendTransactionReturnCode(ctx, tx, common.Address{})`
$DIR/pkg/client/chain_client_test.go: `.NonceAt(ctx, common.Address{}, nil)`
$DIR/pkg/client/chain_client_test.go: `.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, nil)`
$DIR/pkg/client/chain_client_test.go: `.SubscribeToHeads(ctx)`
$DIR/pkg/client/chain_client_test.go: `.SuggestGasPrice(ctx)`
$DIR/pkg/client/chain_client_test.go: `.SuggestGasTipCap(ctx)`
$DIR/pkg/client/chain_client_test.go: `.TokenBalance(ctx, common.Address{}, common.Address{})`
$DIR/pkg/client/chain_client_test.go: `.TransactionByHash(ctx, common.Hash{})`
$DIR/pkg/client/chain_client_test.go: `.TransactionReceipt(ctx, common.Hash{})`
$DIR/pkg/client/config_builder_test.go: `t.Run("parsing unique node configs succeeds", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("ws://foo1.test"),
				HTTPURL: ptr("http://foo1.test"),
			},
			{
				Name:    ptr("foo2"),
				WSURL:   ptr("ws://foo2.test"),
				HTTPURL: ptr("http://foo2.test"),
			},
		}
		tomlNodes, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.NoError(t, err)
		require.Len(t, tomlNodes, len(nodeConfigs))
	})`
$DIR/pkg/client/config_builder_test.go: `t.Run("ws can be optional", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				HTTPURL: ptr("http://foo1.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.NoError(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `t.Run("parsing missing http url fails", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:  ptr("foo1"),
				WSURL: ptr("ws://foo1.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.Error(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `t.Run("parsing invalid ws url fails", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("http://foo1.test"),
				HTTPURL: ptr("http://foo1.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.Error(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `t.Run("parsing duplicate http url fails", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("ws://foo1.test"),
				HTTPURL: ptr("ws://foo1.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.Error(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `t.Run("parsing duplicate node names fails", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("ws://foo1.test"),
				HTTPURL: ptr("http://foo1.test"),
			},
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("ws://foo2.test"),
				HTTPURL: ptr("http://foo2.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.Error(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `t.Run("parsing duplicate node ws urls fails", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("ws://foo1.test"),
				HTTPURL: ptr("http://foo1.test"),
			},
			{
				Name:    ptr("foo2"),
				WSURL:   ptr("ws://foo2.test"),
				HTTPURL: ptr("http://foo1.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.Error(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `t.Run("parsing duplicate node http urls fails", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("ws://foo1.test"),
				HTTPURL: ptr("http://foo1.test"),
			},
			{
				Name:    ptr("foo2"),
				WSURL:   ptr("ws://foo1.test"),
				HTTPURL: ptr("http://foo2.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.Error(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `.NewClientConfigs(selectionMode, leaseDuration, chainTypeStr, nodeConfigs,
		pollFailureThreshold, pollInterval, syncThreshold, nodeIsSyncingEnabled, noNewHeadsThreshold, finalityDepth,
		finalityTagEnabled, finalizedBlockOffset, enforceRepeatableRead, deathDeclarationDelay, noNewFinalizedBlocksThreshold,
		pollInterval, newHeadsPollInterval, confirmationTimeout, safeDepth)`
$DIR/pkg/client/config_builder_test.go: `.NewEvmClient(nodePool, chainCfg, nil, logger.Test(t), big.NewInt(10), nodes, chaintype.ChainType(chainTypeStr))`
$DIR/pkg/client/config_builder_test.go: `.Test(t)`
$DIR/pkg/client/config_builder_test.go: `.NewInt(10)`
$DIR/pkg/client/config_builder_test.go: `.ChainType(chainTypeStr)`
$DIR/pkg/client/config_builder_test.go: `.Run("parsing unique node configs succeeds", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("ws://foo1.test"),
				HTTPURL: ptr("http://foo1.test"),
			},
			{
				Name:    ptr("foo2"),
				WSURL:   ptr("ws://foo2.test"),
				HTTPURL: ptr("http://foo2.test"),
			},
		}
		tomlNodes, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.NoError(t, err)
		require.Len(t, tomlNodes, len(nodeConfigs))
	})`
$DIR/pkg/client/config_builder_test.go: `.ParseTestNodeConfigs(nodeConfigs)`
$DIR/pkg/client/config_builder_test.go: `.Run("ws can be optional", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				HTTPURL: ptr("http://foo1.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.NoError(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `.ParseTestNodeConfigs(nodeConfigs)`
$DIR/pkg/client/config_builder_test.go: `.Run("parsing missing http url fails", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:  ptr("foo1"),
				WSURL: ptr("ws://foo1.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.Error(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `.ParseTestNodeConfigs(nodeConfigs)`
$DIR/pkg/client/config_builder_test.go: `.Run("parsing invalid ws url fails", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("http://foo1.test"),
				HTTPURL: ptr("http://foo1.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.Error(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `.ParseTestNodeConfigs(nodeConfigs)`
$DIR/pkg/client/config_builder_test.go: `.Run("parsing duplicate http url fails", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("ws://foo1.test"),
				HTTPURL: ptr("ws://foo1.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.Error(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `.ParseTestNodeConfigs(nodeConfigs)`
$DIR/pkg/client/config_builder_test.go: `.Run("parsing duplicate node names fails", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("ws://foo1.test"),
				HTTPURL: ptr("http://foo1.test"),
			},
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("ws://foo2.test"),
				HTTPURL: ptr("http://foo2.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.Error(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `.ParseTestNodeConfigs(nodeConfigs)`
$DIR/pkg/client/config_builder_test.go: `.Run("parsing duplicate node ws urls fails", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("ws://foo1.test"),
				HTTPURL: ptr("http://foo1.test"),
			},
			{
				Name:    ptr("foo2"),
				WSURL:   ptr("ws://foo2.test"),
				HTTPURL: ptr("http://foo1.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.Error(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `.ParseTestNodeConfigs(nodeConfigs)`
$DIR/pkg/client/config_builder_test.go: `.Run("parsing duplicate node http urls fails", func(t *testing.T) {
		nodeConfigs := []client.NodeConfig{
			{
				Name:    ptr("foo1"),
				WSURL:   ptr("ws://foo1.test"),
				HTTPURL: ptr("http://foo1.test"),
			},
			{
				Name:    ptr("foo2"),
				WSURL:   ptr("ws://foo1.test"),
				HTTPURL: ptr("http://foo2.test"),
			},
		}
		_, err := client.ParseTestNodeConfigs(nodeConfigs)
		require.Error(t, err)
	})`
$DIR/pkg/client/config_builder_test.go: `.ParseTestNodeConfigs(nodeConfigs)`
$DIR/pkg/client/config_builder_test.go: `.ParseTestNodeConfigs(nodeConfigs)`
$DIR/pkg/client/errors_test.go: `t.Run("IsNonceTooLowError", func(t *testing.T) {
		tests := []errorCase{
			{"nonce too low", true, "Geth"},
			{"nonce too low: address 0x336394A3219e71D9d9bd18201d34E95C1Bb7122C, tx: 8089 state: 8090", true, "Arbitrum"},
			{"Nonce too low", true, "Besu"},
			{"nonce too low", true, "Erigon"},
			{"nonce too low", true, "Klaytn"},
			{"Transaction nonce is too low. Try incrementing the nonce.", true, "Parity"},
			{"transaction rejected: nonce too low", true, "Arbitrum"},
			{"invalid transaction nonce", true, "Arbitrum"},
			{"call failed: nonce too low: address 0x0499BEA33347cb62D79A9C0b1EDA01d8d329894c current nonce (5833) > tx nonce (5511)", true, "Avalanche"},
			{"call failed: OldNonce", true, "Nethermind"},
			{"call failed: OldNonce, Current nonce: 22, nonce of rejected tx: 17", true, "Nethermind"},
			{"nonce too low. allowed nonce range: 427 - 447, actual: 426", true, "zkSync"},
			{"client error nonce too low", true, "tomlConfig"},
			{"[Request ID: 2e952947-ffad-408b-aed9-35f3ed152001] Nonce too low. Provided nonce: 15, current nonce: 15", true, "hedera"},
			{"failed to forward tx to sequencer, please try again. Error message: 'nonce too low'", true, "Mantle"},
		}

		for _, test := range tests {
			t.Run(test.network, func(t *testing.T) {
				err = evmclient.NewSendErrorS(test.message)
				assert.Equal(t, err.IsNonceTooLowError(clientErrors), test.expect)
				err = newSendErrorWrapped(test.message)
				assert.Equal(t, err.IsNonceTooLowError(clientErrors), test.expect)
			})
		}
	})`
$DIR/pkg/client/errors_test.go: `t.Run(test.network, func(t *testing.T) {
				err = evmclient.NewSendErrorS(test.message)
				assert.Equal(t, err.IsNonceTooLowError(clientErrors), test.expect)
				err = newSendErrorWrapped(test.message)
				assert.Equal(t, err.IsNonceTooLowError(clientErrors), test.expect)
			})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped(test.message)`
$DIR/pkg/client/errors_test.go: `t.Run("IsNonceTooHigh", func(t *testing.T) {
		tests := []errorCase{
			{"call failed: NonceGap", true, "Nethermind"},
			{"call failed: NonceGap, Future nonce. Expected nonce: 10", true, "Nethermind"},
			{"nonce too high: address 0x336394A3219e71D9d9bd18201d34E95C1Bb7122C, tx: 8089 state: 8090", true, "Arbitrum"},
			{"nonce too high", true, "Geth"},
			{"nonce too high", true, "Erigon"},
			{"nonce too high. allowed nonce range: 427 - 477, actual: 527", true, "zkSync"},
			{"client error nonce too high", true, "tomlConfig"},
			{"[Request ID: 3ec591b4-9396-49f4-a03f-06c415a7cc6a] Nonce too high. Provided nonce: 16, current nonce: 15", true, "hedera"},
		}

		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsNonceTooHighError(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsNonceTooHighError(clientErrors), test.expect)
		}
	})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped(test.message)`
$DIR/pkg/client/errors_test.go: `t.Run("IsTransactionAlreadyMined", func(t *testing.T) {
		assert.False(t, randomError.IsTransactionAlreadyMined(clientErrors))

		tests := []errorCase{
			{"transaction already finalized", true, "Harmony"},
			{"client error transaction already mined", true, "tomlConfig"},
		}

		for _, test := range tests {
			t.Run(test.network, func(t *testing.T) {
				err = evmclient.NewSendErrorS(test.message)
				assert.Equal(t, err.IsTransactionAlreadyMined(clientErrors), test.expect)
				err = newSendErrorWrapped(test.message)
				assert.Equal(t, err.IsTransactionAlreadyMined(clientErrors), test.expect)
			})
		}
	})`
$DIR/pkg/client/errors_test.go: `t.Run(test.network, func(t *testing.T) {
				err = evmclient.NewSendErrorS(test.message)
				assert.Equal(t, err.IsTransactionAlreadyMined(clientErrors), test.expect)
				err = newSendErrorWrapped(test.message)
				assert.Equal(t, err.IsTransactionAlreadyMined(clientErrors), test.expect)
			})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped(test.message)`
$DIR/pkg/client/errors_test.go: `t.Run("IsReplacementUnderpriced", func(t *testing.T) {
		tests := []errorCase{
			{"replacement transaction underpriced", true, "geth"},
			{"Replacement transaction underpriced", true, "Besu"},
			{"replacement transaction underpriced", true, "Erigon"},
			{"replacement transaction underpriced", true, "Klaytn"},
			{"there is another tx which has the same nonce in the tx pool", true, "Klaytn"},
			{"Transaction gas price 100wei is too low. There is another transaction with same nonce in the queue with gas price 150wei. Try increasing the gas price or incrementing the nonce.", true, "Parity"},
			{"There are too many transactions in the queue. Your transaction was dropped due to limit. Try increasing the fee.", false, "Parity"},
			{"gas price too low", false, "Arbitrum"},
			{"client error replacement underpriced", true, "tomlConfig"},
			{"", false, "tomlConfig"},
			{"failed to forward tx to sequencer, please try again. Error message: 'replacement transaction underpriced'", true, "Mantle"},
		}

		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsReplacementUnderpriced(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsReplacementUnderpriced(clientErrors), test.expect)
		}
	})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped(test.message)`
$DIR/pkg/client/errors_test.go: `t.Run("IsTransactionAlreadyInMempool", func(t *testing.T) {
		assert.False(t, randomError.IsTransactionAlreadyInMempool(clientErrors))

		tests := []errorCase{
			// I have seen this in log output
			{"known transaction: 0x7f657507aee0511e36d2d1972a6b22e917cc89f92b6c12c4dbd57eaabb236960", true, "Geth"},
			// This comes from the geth source - https://github.com/ethereum/go-ethereum/blob/eb9d7d15ecf08cd5104e01a8af64489f01f700b0/core/tx_pool.go#L57
			{"already known", true, "Geth"},
			// This one is present in the light client (?!)
			{"Known transaction (7f65)", true, "Geth"},
			{"Known transaction", true, "Besu"},
			{"already known", true, "Erigon"},
			{"block already known", true, "Erigon"},
			{"Transaction with the same hash was already imported.", true, "Parity"},
			{"call failed: AlreadyKnown", true, "Nethermind"},
			{"call failed: OwnNonceAlreadyUsed", true, "Nethermind"},
			{"known transaction", true, "Klaytn"},
			{"known transaction. transaction with hash 0x60133053 is already in the system", true, "zkSync"},
			// This seems to be an erroneous message from the zkSync client, we'll have to match it anyway
			{"ErrorObject { code: ServerError(3), message: \\\"known transaction. transaction with hash 0xf016ad63 is already in the system\\\", data: Some(RawValue(\\\"0x\\\")) }", true, "zkSync"},
			{"client error transaction already in mempool", true, "tomlConfig"},
			{"alreadyknown", true, "Gnosis"},
			{"tx already exists in cache", true, "Sei"},
			{"failed to forward tx to sequencer, please try again. Error message: 'already known'", true, "Mantle"},
			{"tx already exists in cache", true, "Sei"},
		}
		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsTransactionAlreadyInMempool(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsTransactionAlreadyInMempool(clientErrors), test.expect)
		}
	})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped(test.message)`
$DIR/pkg/client/errors_test.go: `t.Run("IsTerminallyUnderpriced", func(t *testing.T) {
		assert.False(t, randomError.IsTerminallyUnderpriced(clientErrors))

		tests := []errorCase{
			{"transaction underpriced", true, "geth"},
			{"replacement transaction underpriced", false, "geth"},
			{"Gas price below configured minimum gas price", true, "Besu"},
			{"transaction underpriced", true, "Erigon"},
			{"There are too many transactions in the queue. Your transaction was dropped due to limit. Try increasing the fee.", false, "Parity"},
			{"Transaction gas price is too low. It does not satisfy your node's minimal gas price (minimal: 100 got: 50). Try increasing the gas price.", true, "Parity"},
			{"gas price too low", true, "Arbitrum"},
			{"FeeTooLow", true, "Nethermind"},
			{"FeeTooLow, MaxFeePerGas too low. MaxFeePerGas: 50, BaseFee: 100, MaxPriorityFeePerGas:200, Block number: 5", true, "Nethermind"},
			{"FeeTooLow, EffectivePriorityFeePerGas too low 10 < 20, BaseFee: 30", true, "Nethermind"},
			{"FeeTooLow, FeePerGas needs to be higher than 100 to be added to the TxPool. Affordable FeePerGas of rejected tx: 50.", true, "Nethermind"},
			{"FeeTooLowToCompete", true, "Nethermind"},
			{"transaction underpriced", true, "Klaytn"},
			{"intrinsic gas too low", true, "Klaytn"},
			{"max fee per gas less than block base fee", true, "zkSync"},
			{"virtual machine entered unexpected state. please contact developers and provide transaction details that caused this error. Error description: The operator included transaction with an unacceptable gas price", true, "zkSync"},
			{"failed to validate the transaction. reason: Validation revert: virtual machine entered unexpected state. Please contact developers and provide transaction details that caused this error. Error description: Assertion error: Fair pubdata price too high", true, "zkSync"},
			{"client error terminally underpriced", true, "tomlConfig"},
			{"gas price less than block base fee", true, "aStar"},
			{"[Request ID: e4d09e44-19a4-4eb7-babe-270db4c2ebc9] Gas price '830000000000' is below configured minimum gas price '950000000000'", true, "hedera"},
		}

		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsTerminallyUnderpriced(clientErrors), test.expect, "expected %q to match %s for client %s", err, "IsTerminallyUnderpriced", test.network)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsTerminallyUnderpriced(clientErrors), test.expect, "expected %q to match %s for client %s", err, "IsTerminallyUnderpriced", test.network)
		}
	})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped(test.message)`
$DIR/pkg/client/errors_test.go: `t.Run("IsTemporarilyUnderpriced", func(t *testing.T) {
		tests := []errorCase{
			{"There are too many transactions in the queue. Your transaction was dropped due to limit. Try increasing the fee.", true, "Parity"},
			{"There are too many transactions in the queue. Your transaction was dropped due to limit. Try increasing the fee.", true, "Parity"},
			{"Transaction gas price is too low. It does not satisfy your node's minimal gas price (minimal: 100 got: 50). Try increasing the gas price.", false, "Parity"},
			{"client error transaction underpriced", false, "tomlConfig"},
		}
		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsTemporarilyUnderpriced(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsTemporarilyUnderpriced(clientErrors), test.expect)
		}
	})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped(test.message)`
$DIR/pkg/client/errors_test.go: `t.Run("IsInsufficientEth", func(t *testing.T) {
		tests := []errorCase{
			{"insufficient funds for transfer", true, "Geth"},
			{"insufficient funds for gas * price + value", true, "Geth"},
			{"insufficient balance for transfer", true, "Geth"},
			{"Upfront cost exceeds account balance", true, "Besu"},
			{"insufficient funds for transfer", true, "Erigon"},
			{"insufficient funds for gas * price + value", true, "Erigon"},
			{"insufficient balance for transfer", true, "Erigon"},
			{"Insufficient balance for transaction. Balance=100.25, Cost=200.50", true, "Parity"},
			{"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 200.50 and got: 100.25.", true, "Parity"},
			{"transaction rejected: insufficient funds for gas * price + value", true, "Arbitrum"},
			{"not enough funds for gas", true, "Arbitrum"},
			{"insufficient funds for gas * price + value: address 0xb68D832c1241bc50db1CF09e96c0F4201D5539C9 have 9934612900000000 want 9936662900000000", true, "Arbitrum"},
			{"call failed: InsufficientFunds", true, "Nethermind"},
			{"call failed: InsufficientFunds, Account balance: 4740799397601480913, cumulative cost: 22019342038993800000", true, "Nethermind"},
			{"call failed: InsufficientFunds, Balance is 1092404690719251702 less than sending value + gas 7165512000464000000", true, "Nethermind"},
			{"insufficient funds", true, "Klaytn"},
			{"insufficient funds for gas * price + value + gatewayFee", true, "celo"},
			{"insufficient balance for transfer", true, "zkSync"},
			{"insufficient funds for gas + value. balance: 42719769622667482000, fee: 48098250000000, value: 42719769622667482000", true, "celo"},
			{"client error insufficient eth", true, "tomlConfig"},
			{"transaction would cause overdraft", true, "Geth"},
			{"failed to forward tx to sequencer, please try again. Error message: 'insufficient funds for gas * price + value'", true, "Mantle"},
			{"[Request ID: 9dd78806-58c8-4e6d-89a8-a60962abe705] Error invoking RPC: transaction 0.0.3041916@1717691931.680570179 failed precheck with status INSUFFICIENT_PAYER_BALANCE", true, "hedera"},
			{"[Request ID: 6198d2a3-590f-4724-aae5-69fecead0c49] Insufficient funds for transfer", true, "hedera"},
			{"insufficient funds for gas * price + value: balance 0, tx cost 9327080000000000, overshot 9327080000000000", true, "Geth"},
		}
		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsInsufficientEth(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsInsufficientEth(clientErrors), test.expect)
		}
	})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped(test.message)`
$DIR/pkg/client/errors_test.go: `t.Run("IsServiceUnavailable", func(t *testing.T) {
		tests := []errorCase{
			{"call failed: 503 Service Unavailable: <html>\r\n<head><title>503 Service Temporarily Unavailable</title></head>\r\n<body>\r\n<center><h1>503 Service Temporarily Unavailable</h1></center>\r\n</body>\r\n</html>\r\n", true, "Nethermind"},
			{"call failed: 502 Bad Gateway: <html>\r\n<head><title>502 Bad Gateway</title></head>\r\n<body>\r\n<center><h1>502 Bad Gateway</h1></center>\r\n<hr><center>", true, "Arbitrum"},
			{"i/o timeout", true, "Arbitrum"},
			{"network is unreachable", true, "Arbitrum"},
			{"client error service unavailable", true, "tomlConfig"},
			{"[Request ID: 825608a8-fd8a-4b5b-aea7-92999509306d] Error invoking RPC: [Request ID: 825608a8-fd8a-4b5b-aea7-92999509306d] Transaction execution returns a null value for transaction", true, "hedera"},
			{"call failed: 503 Service Temporarily Unavailable: <html>\r\n<head><title>503 Service Temporarily Unavailable</title></head>\r\n<body>\r\n<center><h1>503 Service Temporarily Unavailable</h1></center>\r\n</body>\r\n</html>\r\n", true, "Arbitrum"},
		}
		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsServiceUnavailable(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsServiceUnavailable(clientErrors), test.expect)
		}
		{
			err = evmclient.NewSendError(multinode.ErrNodeError)
			assert.True(t, err.IsServiceUnavailable(clientErrors))
			err = evmclient.NewSendError(fmt.Errorf("failed to send transaction: %w", multinode.ErrNodeError))
			assert.True(t, err.IsServiceUnavailable(clientErrors))
		}
	})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped(test.message)`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendError(multinode.ErrNodeError)`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendError(fmt.Errorf("failed to send transaction: %w", multinode.ErrNodeError))`
$DIR/pkg/client/errors_test.go: `t.Run("IsServiceTimeout", func(t *testing.T) {
		tests := []errorCase{
			{"call failed: 408 Request Timeout: {", true, "Arbitrum"},
			{"408 Request Timeout: {\"id\":303,\"jsonrpc\":\"2.0\",\"error\":{\"code\\\":-32009,\\\"message\\\":\\\"request timeout\\\"}}\",\"errVerbose\":\"408 Request Timeout:\n", true, "Arbitrum"},
			{"request timeout", false, "tomlConfig"},
		}
		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsServiceTimeout(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsServiceTimeout(clientErrors), test.expect)
		}
	})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped(test.message)`
$DIR/pkg/client/errors_test.go: `t.Run("IsTxFeeExceedsCap", func(t *testing.T) {
		tests := []errorCase{
			{"tx fee (1.10 ether) exceeds the configured cap (1.00 ether)", true, "geth"},
			{"tx fee (1.10 FTM) exceeds the configured cap (1.00 FTM)", true, "geth"},
			{"tx fee (1.10 foocoin) exceeds the configured cap (1.00 foocoin)", true, "geth"},
			{"Transaction fee cap exceeded", true, "Besu"},
			{"tx fee (1.10 ether) exceeds the configured cap (1.00 ether)", true, "Erigon"},
			{"invalid gas fee cap", true, "Klaytn"},
			{"max fee per gas higher than max priority fee per gas", true, "Klaytn"},
			{"tx fee (1.10 of currency celo) exceeds the configured cap (1.00 celo)", true, "celo"},
			{"max priority fee per gas higher than max fee per gas", true, "zkSync"},
			{"client error tx fee exceeds cap", true, "tomlConfig"},
		}
		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsTxFeeExceedsCap(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsTxFeeExceedsCap(clientErrors), test.expect)
		}

		assert.False(t, randomError.IsTxFeeExceedsCap(clientErrors))
		// Nil
		err = evmclient.NewSendError(nil)
		assert.False(t, err.IsTxFeeExceedsCap(clientErrors))
	})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped(test.message)`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendError(nil)`
$DIR/pkg/client/errors_test.go: `t.Run("L2 Fees errors", func(t *testing.T) {
		err = evmclient.NewSendErrorS("max fee per gas less than block base fee")
		assert.False(t, err.IsL2FeeTooHigh(clientErrors))
		assert.True(t, err.L2FeeTooLow(clientErrors))
		err = newSendErrorWrapped("max fee per gas less than block base fee")
		assert.False(t, err.IsL2FeeTooHigh(clientErrors))
		assert.True(t, err.L2FeeTooLow(clientErrors))

		err = evmclient.NewSendErrorS("queue full")
		assert.True(t, err.IsL2Full(clientErrors))
		err = evmclient.NewSendErrorS("sequencer pending tx pool full, please try again")
		assert.True(t, err.IsL2Full(clientErrors))

		assert.False(t, randomError.IsL2FeeTooHigh(clientErrors))
		assert.False(t, randomError.L2FeeTooLow(clientErrors))
		// Nil
		err = evmclient.NewSendError(nil)
		assert.False(t, err.IsL2FeeTooHigh(clientErrors))
		assert.False(t, err.L2FeeTooLow(clientErrors))
	})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS("max fee per gas less than block base fee")`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped("max fee per gas less than block base fee")`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS("queue full")`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS("sequencer pending tx pool full, please try again")`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendError(nil)`
$DIR/pkg/client/errors_test.go: `t.Run("Metis gas price errors", func(t *testing.T) {
		err = evmclient.NewSendErrorS("primary websocket (wss://ws-mainnet.metis.io) call failed: gas price too low: 18000000000 wei, use at least tx.gasPrice = 19500000000 wei")
		assert.True(t, err.L2FeeTooLow(clientErrors))
		err = newSendErrorWrapped("primary websocket (wss://ws-mainnet.metis.io) call failed: gas price too low: 18000000000 wei, use at least tx.gasPrice = 19500000000 wei")
		assert.True(t, err.L2FeeTooLow(clientErrors))

		assert.False(t, randomError.L2FeeTooLow(clientErrors))
		// Nil
		err = evmclient.NewSendError(nil)
		assert.False(t, err.L2FeeTooLow(clientErrors))
	})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS("primary websocket (wss://ws-mainnet.metis.io) call failed: gas price too low: 18000000000 wei, use at least tx.gasPrice = 19500000000 wei")`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped("primary websocket (wss://ws-mainnet.metis.io) call failed: gas price too low: 18000000000 wei, use at least tx.gasPrice = 19500000000 wei")`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendError(nil)`
$DIR/pkg/client/errors_test.go: `t.Run("moonriver errors", func(t *testing.T) {
		err = evmclient.NewSendErrorS("primary http (http://***REDACTED***:9933) call failed: submit transaction to pool failed: Pool(Stale)")
		assert.True(t, err.IsNonceTooLowError(clientErrors))
		assert.False(t, err.IsTransactionAlreadyInMempool(clientErrors))
		assert.False(t, err.Fatal(clientErrors))
		err = evmclient.NewSendErrorS("primary http (http://***REDACTED***:9933) call failed: submit transaction to pool failed: Pool(AlreadyImported)")
		assert.True(t, err.IsTransactionAlreadyInMempool(clientErrors))
		assert.False(t, err.IsNonceTooLowError(clientErrors))
		assert.False(t, err.Fatal(clientErrors))
	})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS("primary http (http://***REDACTED***:9933) call failed: submit transaction to pool failed: Pool(Stale)")`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS("primary http (http://***REDACTED***:9933) call failed: submit transaction to pool failed: Pool(AlreadyImported)")`
$DIR/pkg/client/errors_test.go: `t.Run(test.network, func(t *testing.T) {
				err = evmclient.NewSendErrorS(test.message)
				assert.Equal(t, err.IsTerminallyStuckConfigError(clientErrors), test.expect)
				err = newSendErrorWrapped(test.message)
				assert.Equal(t, err.IsTerminallyStuckConfigError(clientErrors), test.expect)
			})`
$DIR/pkg/client/errors_test.go: `err = evmclient.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `err = newSendErrorWrapped(test.message)`
$DIR/pkg/client/errors_test.go: `t.Run(test.message, func(t *testing.T) {
			err := evmclient.NewSendError(pkgerrors.New(test.message))
			assert.Equal(t, test.expect, err.Fatal(clientErrors))
		})`
$DIR/pkg/client/errors_test.go: `t.Run(test.network, func(t *testing.T) {
			jsonRPCErr := evmclient.JsonError{}
			err := json.Unmarshal([]byte(test.message), &jsonRPCErr)
			if err == nil {
				err = jsonRPCErr
			}
			assert.Equal(t, test.expect, evmclient.IsTooManyResults(err, &customErrors))
		})`
$DIR/pkg/client/errors_test.go: `err = jsonRPCErr`
$DIR/pkg/client/errors_test.go: `t.Run(test.network, func(t *testing.T) {
			jsonRPCErr := evmclient.JsonError{}
			err := json.Unmarshal([]byte(test.message), &jsonRPCErr)
			if err == nil {
				err = jsonRPCErr
			}
			assert.Equal(t, test.expect, evmclient.IsMissingBlocks(err, &customErrors), err)
		})`
$DIR/pkg/client/errors_test.go: `err = jsonRPCErr`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS("some old bollocks")`
$DIR/pkg/client/errors_test.go: `.NewTestClientErrors()`
$DIR/pkg/client/errors_test.go: `.ClientErrorRegexes(&testErrors)`
$DIR/pkg/client/errors_test.go: `.Run("IsNonceTooLowError", func(t *testing.T) {
		tests := []errorCase{
			{"nonce too low", true, "Geth"},
			{"nonce too low: address 0x336394A3219e71D9d9bd18201d34E95C1Bb7122C, tx: 8089 state: 8090", true, "Arbitrum"},
			{"Nonce too low", true, "Besu"},
			{"nonce too low", true, "Erigon"},
			{"nonce too low", true, "Klaytn"},
			{"Transaction nonce is too low. Try incrementing the nonce.", true, "Parity"},
			{"transaction rejected: nonce too low", true, "Arbitrum"},
			{"invalid transaction nonce", true, "Arbitrum"},
			{"call failed: nonce too low: address 0x0499BEA33347cb62D79A9C0b1EDA01d8d329894c current nonce (5833) > tx nonce (5511)", true, "Avalanche"},
			{"call failed: OldNonce", true, "Nethermind"},
			{"call failed: OldNonce, Current nonce: 22, nonce of rejected tx: 17", true, "Nethermind"},
			{"nonce too low. allowed nonce range: 427 - 447, actual: 426", true, "zkSync"},
			{"client error nonce too low", true, "tomlConfig"},
			{"[Request ID: 2e952947-ffad-408b-aed9-35f3ed152001] Nonce too low. Provided nonce: 15, current nonce: 15", true, "hedera"},
			{"failed to forward tx to sequencer, please try again. Error message: 'nonce too low'", true, "Mantle"},
		}

		for _, test := range tests {
			t.Run(test.network, func(t *testing.T) {
				err = evmclient.NewSendErrorS(test.message)
				assert.Equal(t, err.IsNonceTooLowError(clientErrors), test.expect)
				err = newSendErrorWrapped(test.message)
				assert.Equal(t, err.IsNonceTooLowError(clientErrors), test.expect)
			})
		}
	})`
$DIR/pkg/client/errors_test.go: `.Run(test.network, func(t *testing.T) {
				err = evmclient.NewSendErrorS(test.message)
				assert.Equal(t, err.IsNonceTooLowError(clientErrors), test.expect)
				err = newSendErrorWrapped(test.message)
				assert.Equal(t, err.IsNonceTooLowError(clientErrors), test.expect)
			})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `.Run("IsNonceTooHigh", func(t *testing.T) {
		tests := []errorCase{
			{"call failed: NonceGap", true, "Nethermind"},
			{"call failed: NonceGap, Future nonce. Expected nonce: 10", true, "Nethermind"},
			{"nonce too high: address 0x336394A3219e71D9d9bd18201d34E95C1Bb7122C, tx: 8089 state: 8090", true, "Arbitrum"},
			{"nonce too high", true, "Geth"},
			{"nonce too high", true, "Erigon"},
			{"nonce too high. allowed nonce range: 427 - 477, actual: 527", true, "zkSync"},
			{"client error nonce too high", true, "tomlConfig"},
			{"[Request ID: 3ec591b4-9396-49f4-a03f-06c415a7cc6a] Nonce too high. Provided nonce: 16, current nonce: 15", true, "hedera"},
		}

		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsNonceTooHighError(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsNonceTooHighError(clientErrors), test.expect)
		}
	})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `.Run("IsTransactionAlreadyMined", func(t *testing.T) {
		assert.False(t, randomError.IsTransactionAlreadyMined(clientErrors))

		tests := []errorCase{
			{"transaction already finalized", true, "Harmony"},
			{"client error transaction already mined", true, "tomlConfig"},
		}

		for _, test := range tests {
			t.Run(test.network, func(t *testing.T) {
				err = evmclient.NewSendErrorS(test.message)
				assert.Equal(t, err.IsTransactionAlreadyMined(clientErrors), test.expect)
				err = newSendErrorWrapped(test.message)
				assert.Equal(t, err.IsTransactionAlreadyMined(clientErrors), test.expect)
			})
		}
	})`
$DIR/pkg/client/errors_test.go: `.Run(test.network, func(t *testing.T) {
				err = evmclient.NewSendErrorS(test.message)
				assert.Equal(t, err.IsTransactionAlreadyMined(clientErrors), test.expect)
				err = newSendErrorWrapped(test.message)
				assert.Equal(t, err.IsTransactionAlreadyMined(clientErrors), test.expect)
			})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `.Run("IsReplacementUnderpriced", func(t *testing.T) {
		tests := []errorCase{
			{"replacement transaction underpriced", true, "geth"},
			{"Replacement transaction underpriced", true, "Besu"},
			{"replacement transaction underpriced", true, "Erigon"},
			{"replacement transaction underpriced", true, "Klaytn"},
			{"there is another tx which has the same nonce in the tx pool", true, "Klaytn"},
			{"Transaction gas price 100wei is too low. There is another transaction with same nonce in the queue with gas price 150wei. Try increasing the gas price or incrementing the nonce.", true, "Parity"},
			{"There are too many transactions in the queue. Your transaction was dropped due to limit. Try increasing the fee.", false, "Parity"},
			{"gas price too low", false, "Arbitrum"},
			{"client error replacement underpriced", true, "tomlConfig"},
			{"", false, "tomlConfig"},
			{"failed to forward tx to sequencer, please try again. Error message: 'replacement transaction underpriced'", true, "Mantle"},
		}

		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsReplacementUnderpriced(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsReplacementUnderpriced(clientErrors), test.expect)
		}
	})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `.Run("IsTransactionAlreadyInMempool", func(t *testing.T) {
		assert.False(t, randomError.IsTransactionAlreadyInMempool(clientErrors))

		tests := []errorCase{
			// I have seen this in log output
			{"known transaction: 0x7f657507aee0511e36d2d1972a6b22e917cc89f92b6c12c4dbd57eaabb236960", true, "Geth"},
			// This comes from the geth source - https://github.com/ethereum/go-ethereum/blob/eb9d7d15ecf08cd5104e01a8af64489f01f700b0/core/tx_pool.go#L57
			{"already known", true, "Geth"},
			// This one is present in the light client (?!)
			{"Known transaction (7f65)", true, "Geth"},
			{"Known transaction", true, "Besu"},
			{"already known", true, "Erigon"},
			{"block already known", true, "Erigon"},
			{"Transaction with the same hash was already imported.", true, "Parity"},
			{"call failed: AlreadyKnown", true, "Nethermind"},
			{"call failed: OwnNonceAlreadyUsed", true, "Nethermind"},
			{"known transaction", true, "Klaytn"},
			{"known transaction. transaction with hash 0x60133053 is already in the system", true, "zkSync"},
			// This seems to be an erroneous message from the zkSync client, we'll have to match it anyway
			{"ErrorObject { code: ServerError(3), message: \\\"known transaction. transaction with hash 0xf016ad63 is already in the system\\\", data: Some(RawValue(\\\"0x\\\")) }", true, "zkSync"},
			{"client error transaction already in mempool", true, "tomlConfig"},
			{"alreadyknown", true, "Gnosis"},
			{"tx already exists in cache", true, "Sei"},
			{"failed to forward tx to sequencer, please try again. Error message: 'already known'", true, "Mantle"},
			{"tx already exists in cache", true, "Sei"},
		}
		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsTransactionAlreadyInMempool(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsTransactionAlreadyInMempool(clientErrors), test.expect)
		}
	})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `.Run("IsTerminallyUnderpriced", func(t *testing.T) {
		assert.False(t, randomError.IsTerminallyUnderpriced(clientErrors))

		tests := []errorCase{
			{"transaction underpriced", true, "geth"},
			{"replacement transaction underpriced", false, "geth"},
			{"Gas price below configured minimum gas price", true, "Besu"},
			{"transaction underpriced", true, "Erigon"},
			{"There are too many transactions in the queue. Your transaction was dropped due to limit. Try increasing the fee.", false, "Parity"},
			{"Transaction gas price is too low. It does not satisfy your node's minimal gas price (minimal: 100 got: 50). Try increasing the gas price.", true, "Parity"},
			{"gas price too low", true, "Arbitrum"},
			{"FeeTooLow", true, "Nethermind"},
			{"FeeTooLow, MaxFeePerGas too low. MaxFeePerGas: 50, BaseFee: 100, MaxPriorityFeePerGas:200, Block number: 5", true, "Nethermind"},
			{"FeeTooLow, EffectivePriorityFeePerGas too low 10 < 20, BaseFee: 30", true, "Nethermind"},
			{"FeeTooLow, FeePerGas needs to be higher than 100 to be added to the TxPool. Affordable FeePerGas of rejected tx: 50.", true, "Nethermind"},
			{"FeeTooLowToCompete", true, "Nethermind"},
			{"transaction underpriced", true, "Klaytn"},
			{"intrinsic gas too low", true, "Klaytn"},
			{"max fee per gas less than block base fee", true, "zkSync"},
			{"virtual machine entered unexpected state. please contact developers and provide transaction details that caused this error. Error description: The operator included transaction with an unacceptable gas price", true, "zkSync"},
			{"failed to validate the transaction. reason: Validation revert: virtual machine entered unexpected state. Please contact developers and provide transaction details that caused this error. Error description: Assertion error: Fair pubdata price too high", true, "zkSync"},
			{"client error terminally underpriced", true, "tomlConfig"},
			{"gas price less than block base fee", true, "aStar"},
			{"[Request ID: e4d09e44-19a4-4eb7-babe-270db4c2ebc9] Gas price '830000000000' is below configured minimum gas price '950000000000'", true, "hedera"},
		}

		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsTerminallyUnderpriced(clientErrors), test.expect, "expected %q to match %s for client %s", err, "IsTerminallyUnderpriced", test.network)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsTerminallyUnderpriced(clientErrors), test.expect, "expected %q to match %s for client %s", err, "IsTerminallyUnderpriced", test.network)
		}
	})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `.Run("IsTemporarilyUnderpriced", func(t *testing.T) {
		tests := []errorCase{
			{"There are too many transactions in the queue. Your transaction was dropped due to limit. Try increasing the fee.", true, "Parity"},
			{"There are too many transactions in the queue. Your transaction was dropped due to limit. Try increasing the fee.", true, "Parity"},
			{"Transaction gas price is too low. It does not satisfy your node's minimal gas price (minimal: 100 got: 50). Try increasing the gas price.", false, "Parity"},
			{"client error transaction underpriced", false, "tomlConfig"},
		}
		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsTemporarilyUnderpriced(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsTemporarilyUnderpriced(clientErrors), test.expect)
		}
	})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `.Run("IsInsufficientEth", func(t *testing.T) {
		tests := []errorCase{
			{"insufficient funds for transfer", true, "Geth"},
			{"insufficient funds for gas * price + value", true, "Geth"},
			{"insufficient balance for transfer", true, "Geth"},
			{"Upfront cost exceeds account balance", true, "Besu"},
			{"insufficient funds for transfer", true, "Erigon"},
			{"insufficient funds for gas * price + value", true, "Erigon"},
			{"insufficient balance for transfer", true, "Erigon"},
			{"Insufficient balance for transaction. Balance=100.25, Cost=200.50", true, "Parity"},
			{"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 200.50 and got: 100.25.", true, "Parity"},
			{"transaction rejected: insufficient funds for gas * price + value", true, "Arbitrum"},
			{"not enough funds for gas", true, "Arbitrum"},
			{"insufficient funds for gas * price + value: address 0xb68D832c1241bc50db1CF09e96c0F4201D5539C9 have 9934612900000000 want 9936662900000000", true, "Arbitrum"},
			{"call failed: InsufficientFunds", true, "Nethermind"},
			{"call failed: InsufficientFunds, Account balance: 4740799397601480913, cumulative cost: 22019342038993800000", true, "Nethermind"},
			{"call failed: InsufficientFunds, Balance is 1092404690719251702 less than sending value + gas 7165512000464000000", true, "Nethermind"},
			{"insufficient funds", true, "Klaytn"},
			{"insufficient funds for gas * price + value + gatewayFee", true, "celo"},
			{"insufficient balance for transfer", true, "zkSync"},
			{"insufficient funds for gas + value. balance: 42719769622667482000, fee: 48098250000000, value: 42719769622667482000", true, "celo"},
			{"client error insufficient eth", true, "tomlConfig"},
			{"transaction would cause overdraft", true, "Geth"},
			{"failed to forward tx to sequencer, please try again. Error message: 'insufficient funds for gas * price + value'", true, "Mantle"},
			{"[Request ID: 9dd78806-58c8-4e6d-89a8-a60962abe705] Error invoking RPC: transaction 0.0.3041916@1717691931.680570179 failed precheck with status INSUFFICIENT_PAYER_BALANCE", true, "hedera"},
			{"[Request ID: 6198d2a3-590f-4724-aae5-69fecead0c49] Insufficient funds for transfer", true, "hedera"},
			{"insufficient funds for gas * price + value: balance 0, tx cost 9327080000000000, overshot 9327080000000000", true, "Geth"},
		}
		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsInsufficientEth(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsInsufficientEth(clientErrors), test.expect)
		}
	})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `.Run("IsServiceUnavailable", func(t *testing.T) {
		tests := []errorCase{
			{"call failed: 503 Service Unavailable: <html>\r\n<head><title>503 Service Temporarily Unavailable</title></head>\r\n<body>\r\n<center><h1>503 Service Temporarily Unavailable</h1></center>\r\n</body>\r\n</html>\r\n", true, "Nethermind"},
			{"call failed: 502 Bad Gateway: <html>\r\n<head><title>502 Bad Gateway</title></head>\r\n<body>\r\n<center><h1>502 Bad Gateway</h1></center>\r\n<hr><center>", true, "Arbitrum"},
			{"i/o timeout", true, "Arbitrum"},
			{"network is unreachable", true, "Arbitrum"},
			{"client error service unavailable", true, "tomlConfig"},
			{"[Request ID: 825608a8-fd8a-4b5b-aea7-92999509306d] Error invoking RPC: [Request ID: 825608a8-fd8a-4b5b-aea7-92999509306d] Transaction execution returns a null value for transaction", true, "hedera"},
			{"call failed: 503 Service Temporarily Unavailable: <html>\r\n<head><title>503 Service Temporarily Unavailable</title></head>\r\n<body>\r\n<center><h1>503 Service Temporarily Unavailable</h1></center>\r\n</body>\r\n</html>\r\n", true, "Arbitrum"},
		}
		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsServiceUnavailable(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsServiceUnavailable(clientErrors), test.expect)
		}
		{
			err = evmclient.NewSendError(multinode.ErrNodeError)
			assert.True(t, err.IsServiceUnavailable(clientErrors))
			err = evmclient.NewSendError(fmt.Errorf("failed to send transaction: %w", multinode.ErrNodeError))
			assert.True(t, err.IsServiceUnavailable(clientErrors))
		}
	})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `.NewSendError(multinode.ErrNodeError)`
$DIR/pkg/client/errors_test.go: `.NewSendError(fmt.Errorf("failed to send transaction: %w", multinode.ErrNodeError))`
$DIR/pkg/client/errors_test.go: `.Run("IsServiceTimeout", func(t *testing.T) {
		tests := []errorCase{
			{"call failed: 408 Request Timeout: {", true, "Arbitrum"},
			{"408 Request Timeout: {\"id\":303,\"jsonrpc\":\"2.0\",\"error\":{\"code\\\":-32009,\\\"message\\\":\\\"request timeout\\\"}}\",\"errVerbose\":\"408 Request Timeout:\n", true, "Arbitrum"},
			{"request timeout", false, "tomlConfig"},
		}
		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsServiceTimeout(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsServiceTimeout(clientErrors), test.expect)
		}
	})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `.Run("IsTxFeeExceedsCap", func(t *testing.T) {
		tests := []errorCase{
			{"tx fee (1.10 ether) exceeds the configured cap (1.00 ether)", true, "geth"},
			{"tx fee (1.10 FTM) exceeds the configured cap (1.00 FTM)", true, "geth"},
			{"tx fee (1.10 foocoin) exceeds the configured cap (1.00 foocoin)", true, "geth"},
			{"Transaction fee cap exceeded", true, "Besu"},
			{"tx fee (1.10 ether) exceeds the configured cap (1.00 ether)", true, "Erigon"},
			{"invalid gas fee cap", true, "Klaytn"},
			{"max fee per gas higher than max priority fee per gas", true, "Klaytn"},
			{"tx fee (1.10 of currency celo) exceeds the configured cap (1.00 celo)", true, "celo"},
			{"max priority fee per gas higher than max fee per gas", true, "zkSync"},
			{"client error tx fee exceeds cap", true, "tomlConfig"},
		}
		for _, test := range tests {
			err = evmclient.NewSendErrorS(test.message)
			assert.Equal(t, err.IsTxFeeExceedsCap(clientErrors), test.expect)
			err = newSendErrorWrapped(test.message)
			assert.Equal(t, err.IsTxFeeExceedsCap(clientErrors), test.expect)
		}

		assert.False(t, randomError.IsTxFeeExceedsCap(clientErrors))
		// Nil
		err = evmclient.NewSendError(nil)
		assert.False(t, err.IsTxFeeExceedsCap(clientErrors))
	})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `.NewSendError(nil)`
$DIR/pkg/client/errors_test.go: `.Run("L2 Fees errors", func(t *testing.T) {
		err = evmclient.NewSendErrorS("max fee per gas less than block base fee")
		assert.False(t, err.IsL2FeeTooHigh(clientErrors))
		assert.True(t, err.L2FeeTooLow(clientErrors))
		err = newSendErrorWrapped("max fee per gas less than block base fee")
		assert.False(t, err.IsL2FeeTooHigh(clientErrors))
		assert.True(t, err.L2FeeTooLow(clientErrors))

		err = evmclient.NewSendErrorS("queue full")
		assert.True(t, err.IsL2Full(clientErrors))
		err = evmclient.NewSendErrorS("sequencer pending tx pool full, please try again")
		assert.True(t, err.IsL2Full(clientErrors))

		assert.False(t, randomError.IsL2FeeTooHigh(clientErrors))
		assert.False(t, randomError.L2FeeTooLow(clientErrors))
		// Nil
		err = evmclient.NewSendError(nil)
		assert.False(t, err.IsL2FeeTooHigh(clientErrors))
		assert.False(t, err.L2FeeTooLow(clientErrors))
	})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS("max fee per gas less than block base fee")`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS("queue full")`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS("sequencer pending tx pool full, please try again")`
$DIR/pkg/client/errors_test.go: `.NewSendError(nil)`
$DIR/pkg/client/errors_test.go: `.Run("Metis gas price errors", func(t *testing.T) {
		err = evmclient.NewSendErrorS("primary websocket (wss://ws-mainnet.metis.io) call failed: gas price too low: 18000000000 wei, use at least tx.gasPrice = 19500000000 wei")
		assert.True(t, err.L2FeeTooLow(clientErrors))
		err = newSendErrorWrapped("primary websocket (wss://ws-mainnet.metis.io) call failed: gas price too low: 18000000000 wei, use at least tx.gasPrice = 19500000000 wei")
		assert.True(t, err.L2FeeTooLow(clientErrors))

		assert.False(t, randomError.L2FeeTooLow(clientErrors))
		// Nil
		err = evmclient.NewSendError(nil)
		assert.False(t, err.L2FeeTooLow(clientErrors))
	})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS("primary websocket (wss://ws-mainnet.metis.io) call failed: gas price too low: 18000000000 wei, use at least tx.gasPrice = 19500000000 wei")`
$DIR/pkg/client/errors_test.go: `.NewSendError(nil)`
$DIR/pkg/client/errors_test.go: `.Run("moonriver errors", func(t *testing.T) {
		err = evmclient.NewSendErrorS("primary http (http://***REDACTED***:9933) call failed: submit transaction to pool failed: Pool(Stale)")
		assert.True(t, err.IsNonceTooLowError(clientErrors))
		assert.False(t, err.IsTransactionAlreadyInMempool(clientErrors))
		assert.False(t, err.Fatal(clientErrors))
		err = evmclient.NewSendErrorS("primary http (http://***REDACTED***:9933) call failed: submit transaction to pool failed: Pool(AlreadyImported)")
		assert.True(t, err.IsTransactionAlreadyInMempool(clientErrors))
		assert.False(t, err.IsNonceTooLowError(clientErrors))
		assert.False(t, err.Fatal(clientErrors))
	})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS("primary http (http://***REDACTED***:9933) call failed: submit transaction to pool failed: Pool(Stale)")`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS("primary http (http://***REDACTED***:9933) call failed: submit transaction to pool failed: Pool(AlreadyImported)")`
$DIR/pkg/client/errors_test.go: `.Run(test.network, func(t *testing.T) {
				err = evmclient.NewSendErrorS(test.message)
				assert.Equal(t, err.IsTerminallyStuckConfigError(clientErrors), test.expect)
				err = newSendErrorWrapped(test.message)
				assert.Equal(t, err.IsTerminallyStuckConfigError(clientErrors), test.expect)
			})`
$DIR/pkg/client/errors_test.go: `.NewSendErrorS(test.message)`
$DIR/pkg/client/errors_test.go: `.NewTestClientErrors()`
$DIR/pkg/client/errors_test.go: `.ClientErrorRegexes(&testErrors)`
$DIR/pkg/client/errors_test.go: `.Run(test.message, func(t *testing.T) {
			err := evmclient.NewSendError(pkgerrors.New(test.message))
			assert.Equal(t, test.expect, err.Fatal(clientErrors))
		})`
$DIR/pkg/client/errors_test.go: `.NewSendError(pkgerrors.New(test.message))`
$DIR/pkg/client/errors_test.go: `.New(test.message)`
$DIR/pkg/client/errors_test.go: `.NewTestClientErrors()`
$DIR/pkg/client/errors_test.go: `.ClientErrorRegexes(&testErrors)`
$DIR/pkg/client/errors_test.go: `.NewTestClientErrors()`
$DIR/pkg/client/errors_test.go: `.Sprintf(`{
		"code" : -43106,
		"message" : "%s"}`, customErrors.TooManyResults())`
$DIR/pkg/client/errors_test.go: `.TooManyResults()`
$DIR/pkg/client/errors_test.go: `.Run(test.network, func(t *testing.T) {
			jsonRPCErr := evmclient.JsonError{}
			err := json.Unmarshal([]byte(test.message), &jsonRPCErr)
			if err == nil {
				err = jsonRPCErr
			}
			assert.Equal(t, test.expect, evmclient.IsTooManyResults(err, &customErrors))
		})`
$DIR/pkg/client/errors_test.go: `.Unmarshal([]byte(test.message), &jsonRPCErr)`
$DIR/pkg/client/errors_test.go: `.NewTestClientErrors()`
$DIR/pkg/client/errors_test.go: `.Sprintf(`{
		"code" : -43106,
		"message" : "%s"}`, customErrors.MissingBlocks())`
$DIR/pkg/client/errors_test.go: `.MissingBlocks()`
$DIR/pkg/client/errors_test.go: `.Run(test.network, func(t *testing.T) {
			jsonRPCErr := evmclient.JsonError{}
			err := json.Unmarshal([]byte(test.message), &jsonRPCErr)
			if err == nil {
				err = jsonRPCErr
			}
			assert.Equal(t, test.expect, evmclient.IsMissingBlocks(err, &customErrors), err)
		})`
$DIR/pkg/client/errors_test.go: `.Unmarshal([]byte(test.message), &jsonRPCErr)`
$DIR/pkg/client/evm_client_test.go: `err = evmClient.Dial(ctx)`
$DIR/pkg/client/evm_client_test.go: `.NewClientConfigs(selectionMode, leaseDuration, chainTypeStr, nodeConfigs,
		pollFailureThreshold, pollInterval, syncThreshold, nodeIsSyncingEnabled, noNewHeadsThreshold, finalityDepth,
		finalityTagEnabled, finalizedBlockOffset, enforceRepeatableRead, deathDeclarationDelay, noNewFinalizedBlocksThreshold,
		finalizedBlockPollInterval, newHeadsPollInterval, confirmationTimeout, safeDepth)`
$DIR/pkg/client/evm_client_test.go: `.NewEvmClient(nodePool, chainCfg, nil, logger.Test(t), testutils.FixtureChainID, nodes, chaintype.ChainType(chainTypeStr))`
$DIR/pkg/client/evm_client_test.go: `.Test(t)`
$DIR/pkg/client/evm_client_test.go: `.ChainType(chainTypeStr)`
$DIR/pkg/client/evm_client_test.go: `.WithTimeout(tests.Context(t), tests.WaitTimeout(t))`
$DIR/pkg/client/evm_client_test.go: `.Context(t)`
$DIR/pkg/client/evm_client_test.go: `.WaitTimeout(t)`
$DIR/pkg/client/evm_client_test.go: `.NewClientConfigs(ptr("HighestHead"), time.Duration(0), "", nodeConfigs,
		ptr[uint32](5), 10*time.Second, ptr[uint32](5), ptr(false), time.Minute, ptr[uint32](5), ptr(false),
		ptr[uint32](5), ptr(false), 10*time.Second, 10*time.Second, 10*time.Second, 10*time.Second, 60*time.Second, ptr[uint32](10))`
$DIR/pkg/client/evm_client_test.go: `.Duration(0)`
$DIR/pkg/client/evm_client_test.go: `.NewInt(68472)`
$DIR/pkg/client/evm_client_test.go: `.NewEvmClient(nodePool, chainCfg, nil, logger.Test(t), chainID, nodes, "")`
$DIR/pkg/client/evm_client_test.go: `.Test(t)`
$DIR/pkg/client/evm_client_test.go: `.Dial(ctx)`
$DIR/pkg/client/null_client_test.go: `t.Run("chain id", func(t *testing.T) {
		lggr := logger.Test(t)
		cid := big.NewInt(123)
		nc := client.NewNullClient(cid, lggr)
		require.Equal(t, cid, nc.ConfiguredChainID())

		nc = client.NewNullClient(nil, lggr)
		require.Equal(t, big.NewInt(client.NullClientChainID), nc.ConfiguredChainID())
	})`
$DIR/pkg/client/null_client_test.go: `nc = client.NewNullClient(nil, lggr)`
$DIR/pkg/client/null_client_test.go: `t.Run("CL client methods", func(t *testing.T) {
		lggr, logs := logger.TestObserved(t, zapcore.DebugLevel)
		nc := client.NewNullClient(nil, lggr)
		ctx := tests.Context(t)

		err := nc.Dial(ctx)
		require.NoError(t, err)
		require.Equal(t, 1, logs.FilterMessage("Dial").Len())

		nc.Close()
		require.Equal(t, 1, logs.FilterMessage("Close").Len())

		b, err := nc.TokenBalance(ctx, common.Address{}, common.Address{})
		require.NoError(t, err)
		require.Zero(t, b.Int64())
		require.Equal(t, 1, logs.FilterMessage("TokenBalance").Len())

		l, err := nc.LINKBalance(ctx, common.Address{}, common.Address{})
		require.NoError(t, err)
		require.True(t, l.IsZero())
		require.Equal(t, 1, logs.FilterMessage("LINKBalance").Len())

		err = nc.CallContext(ctx, nil, "")
		require.NoError(t, err)
		require.Equal(t, 1, logs.FilterMessage("CallContext").Len())

		h, err := nc.HeadByNumber(ctx, nil)
		require.NoError(t, err)
		require.Nil(t, h)
		require.Equal(t, 1, logs.FilterMessage("HeadByNumber").Len())

		_, sub, err := nc.SubscribeToHeads(ctx)
		require.NoError(t, err)
		require.Equal(t, 1, logs.FilterMessage("SubscribeToHeads").Len())
		require.Nil(t, sub.Err())
		require.Equal(t, 1, logs.FilterMessage("Err").Len())
		sub.Unsubscribe()
		require.Equal(t, 1, logs.FilterMessage("Unsubscribe").Len())

		chLogs := make(chan types.Log)
		_, err = nc.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, chLogs)
		require.NoError(t, err)
		require.Equal(t, 1, logs.FilterMessage("SubscribeFilterLogs").Len())
	})`
$DIR/pkg/client/null_client_test.go: `err = nc.CallContext(ctx, nil, "")`
$DIR/pkg/client/null_client_test.go: `sub.Unsubscribe()`
$DIR/pkg/client/null_client_test.go: `_, err = nc.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, chLogs)`
$DIR/pkg/client/null_client_test.go: `err = nc.SendTransaction(ctx, nil)`
$DIR/pkg/client/null_client_test.go: `b, err = nc.BlockByHash(ctx, common.Hash{})`
$DIR/pkg/client/null_client_test.go: `err = nc.BatchCallContext(ctx, []rpc.BatchElem{})`
$DIR/pkg/client/null_client_test.go: `err = nc.BatchCallContextAll(ctx, []rpc.BatchElem{})`
$DIR/pkg/client/null_client_test.go: `.Run("chain id", func(t *testing.T) {
		lggr := logger.Test(t)
		cid := big.NewInt(123)
		nc := client.NewNullClient(cid, lggr)
		require.Equal(t, cid, nc.ConfiguredChainID())

		nc = client.NewNullClient(nil, lggr)
		require.Equal(t, big.NewInt(client.NullClientChainID), nc.ConfiguredChainID())
	})`
$DIR/pkg/client/null_client_test.go: `.Test(t)`
$DIR/pkg/client/null_client_test.go: `.NewInt(123)`
$DIR/pkg/client/null_client_test.go: `.NewNullClient(cid, lggr)`
$DIR/pkg/client/null_client_test.go: `.NewNullClient(nil, lggr)`
$DIR/pkg/client/null_client_test.go: `.Run("CL client methods", func(t *testing.T) {
		lggr, logs := logger.TestObserved(t, zapcore.DebugLevel)
		nc := client.NewNullClient(nil, lggr)
		ctx := tests.Context(t)

		err := nc.Dial(ctx)
		require.NoError(t, err)
		require.Equal(t, 1, logs.FilterMessage("Dial").Len())

		nc.Close()
		require.Equal(t, 1, logs.FilterMessage("Close").Len())

		b, err := nc.TokenBalance(ctx, common.Address{}, common.Address{})
		require.NoError(t, err)
		require.Zero(t, b.Int64())
		require.Equal(t, 1, logs.FilterMessage("TokenBalance").Len())

		l, err := nc.LINKBalance(ctx, common.Address{}, common.Address{})
		require.NoError(t, err)
		require.True(t, l.IsZero())
		require.Equal(t, 1, logs.FilterMessage("LINKBalance").Len())

		err = nc.CallContext(ctx, nil, "")
		require.NoError(t, err)
		require.Equal(t, 1, logs.FilterMessage("CallContext").Len())

		h, err := nc.HeadByNumber(ctx, nil)
		require.NoError(t, err)
		require.Nil(t, h)
		require.Equal(t, 1, logs.FilterMessage("HeadByNumber").Len())

		_, sub, err := nc.SubscribeToHeads(ctx)
		require.NoError(t, err)
		require.Equal(t, 1, logs.FilterMessage("SubscribeToHeads").Len())
		require.Nil(t, sub.Err())
		require.Equal(t, 1, logs.FilterMessage("Err").Len())
		sub.Unsubscribe()
		require.Equal(t, 1, logs.FilterMessage("Unsubscribe").Len())

		chLogs := make(chan types.Log)
		_, err = nc.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, chLogs)
		require.NoError(t, err)
		require.Equal(t, 1, logs.FilterMessage("SubscribeFilterLogs").Len())
	})`
$DIR/pkg/client/null_client_test.go: `.TestObserved(t, zapcore.DebugLevel)`
$DIR/pkg/client/null_client_test.go: `.NewNullClient(nil, lggr)`
$DIR/pkg/client/null_client_test.go: `.Context(t)`
$DIR/pkg/client/null_client_test.go: `.Dial(ctx)`
$DIR/pkg/client/null_client_test.go: `.TokenBalance(ctx, common.Address{}, common.Address{})`
$DIR/pkg/client/null_client_test.go: `.LINKBalance(ctx, common.Address{}, common.Address{})`
$DIR/pkg/client/null_client_test.go: `.CallContext(ctx, nil, "")`
$DIR/pkg/client/null_client_test.go: `.HeadByNumber(ctx, nil)`
$DIR/pkg/client/null_client_test.go: `.SubscribeToHeads(ctx)`
$DIR/pkg/client/null_client_test.go: `.Unsubscribe()`
$DIR/pkg/client/null_client_test.go: `.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, chLogs)`
$DIR/pkg/client/null_client_test.go: `.TestObserved(t, zapcore.DebugLevel)`
$DIR/pkg/client/null_client_test.go: `.NewNullClient(nil, lggr)`
$DIR/pkg/client/null_client_test.go: `.Context(t)`
$DIR/pkg/client/null_client_test.go: `.HeaderByNumber(ctx, nil)`
$DIR/pkg/client/null_client_test.go: `.SendTransaction(ctx, nil)`
$DIR/pkg/client/null_client_test.go: `.PendingCodeAt(ctx, common.Address{})`
$DIR/pkg/client/null_client_test.go: `.PendingNonceAt(ctx, common.Address{})`
$DIR/pkg/client/null_client_test.go: `.NonceAt(ctx, common.Address{}, nil)`
$DIR/pkg/client/null_client_test.go: `.TransactionReceipt(ctx, common.Hash{})`
$DIR/pkg/client/null_client_test.go: `.BlockByNumber(ctx, nil)`
$DIR/pkg/client/null_client_test.go: `.BlockByHash(ctx, common.Hash{})`
$DIR/pkg/client/null_client_test.go: `.BalanceAt(ctx, common.Address{}, nil)`
$DIR/pkg/client/null_client_test.go: `.FilterLogs(ctx, ethereum.FilterQuery{})`
$DIR/pkg/client/null_client_test.go: `.EstimateGas(ctx, ethereum.CallMsg{})`
$DIR/pkg/client/null_client_test.go: `.SuggestGasPrice(ctx)`
$DIR/pkg/client/null_client_test.go: `.CallContract(ctx, ethereum.CallMsg{}, nil)`
$DIR/pkg/client/null_client_test.go: `.CodeAt(ctx, common.Address{}, nil)`
$DIR/pkg/client/null_client_test.go: `.BatchCallContext(ctx, []rpc.BatchElem{})`
$DIR/pkg/client/null_client_test.go: `.BatchCallContextAll(ctx, []rpc.BatchElem{})`
$DIR/pkg/client/null_client_test.go: `.SuggestGasTipCap(ctx)`
$DIR/pkg/client/null_client_test.go: `.NodeStates()`
$DIR/pkg/client/rpc_client_internal_test.go: `t.Run(ct.Name, func(t *testing.T) {
			for _, tc := range testCases {
				t.Run(tc.Name, func(t *testing.T) {
					rpc := NewTestRPCClient(t, RPCClientOpts{ChainType: ct.ChainType})
					log, err := rpc.makeLogValid(ethtypes.Log{TxIndex: tc.TxIndex, Index: tc.LogIndex})
					if tc.ExpectedError != nil {
						require.EqualError(t, err, tc.ExpectedError.Error())
						return
					}
					require.Equal(t, tc.ExpectedLogIndex, log.Index)
					require.Equal(t, tc.TxIndex, log.TxIndex)
				})
			}
		})`
$DIR/pkg/client/rpc_client_internal_test.go: `t.Run(tc.Name, func(t *testing.T) {
					rpc := NewTestRPCClient(t, RPCClientOpts{ChainType: ct.ChainType})
					log, err := rpc.makeLogValid(ethtypes.Log{TxIndex: tc.TxIndex, Index: tc.LogIndex})
					if tc.ExpectedError != nil {
						require.EqualError(t, err, tc.ExpectedError.Error())
						return
					}
					require.Equal(t, tc.ExpectedLogIndex, log.Index)
					require.Equal(t, tc.TxIndex, log.TxIndex)
				})`
$DIR/pkg/client/rpc_client_internal_test.go: `t.Run(tc.Name, func(t *testing.T) {
				rpc := NewTestRPCClient(t, RPCClientOpts{})
				log, err := rpc.makeLogValid(ethtypes.Log{TxIndex: tc.TxIndex, Index: tc.LogIndex})
				// other chains should return as is
				require.NoError(t, err)
				require.Equal(t, tc.TxIndex, log.TxIndex)
				require.Equal(t, tc.LogIndex, log.Index)
			})`
$DIR/pkg/client/rpc_client_internal_test.go: `t.Run(tc.Name, func(t *testing.T) {
			wsURL := testutils.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				switch method {
				case "eth_call":
					resp.Result = fmt.Sprintf(`"%s"`, tc.EthCallResult)
					resp.Error.Message = tc.EthCallError
				case "eth_getBlockByNumber":
					require.True(t, params.IsArray())
					require.Equal(t, params.Array()[0].String(), tc.ExpectedTag)
					resp.Result = tc.BlockByNumberResult
					resp.Error.Message = tc.BlockByNumberError
				default:
					require.Fail(t, "unexpected method: "+method)
				}
				return
			}).WSURL()
			rpcClient := NewDialedTestRPCClient(t, RPCClientOpts{HTTP: wsURL, FinalityTagsEnabled: true, ChainID: chainID})
			var result hexutil.Bytes
			err := rpcClient.doWithConfidence(t.Context(), rpc.BatchElem{Method: "eth_call", Result: &result}, tc.CallBlockNumber, tc.Confidence)
			if tc.ExpectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tc.ExpectedError)
			} else {
				require.NoError(t, err)
				require.Equal(t, tc.ExpectedResult, string(result))
			}
		})`
$DIR/pkg/client/rpc_client_internal_test.go: `resp.Result = fmt.Sprintf(`"%s"`, tc.EthCallResult)`
$DIR/pkg/client/rpc_client_internal_test.go: `resp.Error.Message = tc.EthCallError`
$DIR/pkg/client/rpc_client_internal_test.go: `resp.Result = tc.BlockByNumberResult`
$DIR/pkg/client/rpc_client_internal_test.go: `resp.Error.Message = tc.BlockByNumberError`
$DIR/pkg/client/rpc_client_internal_test.go: `t.Run(tc.Name, func(t *testing.T) {
			rpcClient := NewTestRPCClient(t, RPCClientOpts{FinalityTagsEnabled: tc.FinalityTagEnabled})
			block, err := rpcClient.confidenceToBlockNumber(tc.ConfidenceLevel)
			if tc.ExpectedError != "" {
				require.ErrorContains(t, err, tc.ExpectedError)
			} else {
				require.NoError(t, err)
				require.Equal(t, tc.ExpectedBlock, block)
			}
		})`
$DIR/pkg/client/rpc_client_internal_test.go: `t.Run(tc.Name, func(t *testing.T) {
			rpcClient := NewTestRPCClient(t, RPCClientOpts{
				FinalityTagsEnabled: tc.FinalityTagEnabled,
				FinalityDepth:       tc.FinalityDepth,
				SafeDepth:           tc.SafeDepth,
			})

			block, err := rpcClient.referenceHeadToMaxAvailableHeight(tc.ConfidenceLevel, tc.ReferenceHeadHeight)
			if tc.ExpectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tc.ExpectedError)
			} else {
				require.NoError(t, err)
				require.Equal(t, tc.ExpectedBlock, block)
			}
		})`
$DIR/pkg/client/rpc_client_internal_test.go: `.New("log's index 4294967296 of tx 0x0000000000000000000000000000000000000000000000000000000000000000 exceeds max supported value of 4294967295")`
$DIR/pkg/client/rpc_client_internal_test.go: `.New("TxIndex of tx 0x0000000000000000000000000000000000000000000000000000000000000000 exceeds max supported value of 4294967295")`
$DIR/pkg/client/rpc_client_internal_test.go: `.Run(ct.Name, func(t *testing.T) {
			for _, tc := range testCases {
				t.Run(tc.Name, func(t *testing.T) {
					rpc := NewTestRPCClient(t, RPCClientOpts{ChainType: ct.ChainType})
					log, err := rpc.makeLogValid(ethtypes.Log{TxIndex: tc.TxIndex, Index: tc.LogIndex})
					if tc.ExpectedError != nil {
						require.EqualError(t, err, tc.ExpectedError.Error())
						return
					}
					require.Equal(t, tc.ExpectedLogIndex, log.Index)
					require.Equal(t, tc.TxIndex, log.TxIndex)
				})
			}
		})`
$DIR/pkg/client/rpc_client_internal_test.go: `.Run(tc.Name, func(t *testing.T) {
					rpc := NewTestRPCClient(t, RPCClientOpts{ChainType: ct.ChainType})
					log, err := rpc.makeLogValid(ethtypes.Log{TxIndex: tc.TxIndex, Index: tc.LogIndex})
					if tc.ExpectedError != nil {
						require.EqualError(t, err, tc.ExpectedError.Error())
						return
					}
					require.Equal(t, tc.ExpectedLogIndex, log.Index)
					require.Equal(t, tc.TxIndex, log.TxIndex)
				})`
$DIR/pkg/client/rpc_client_internal_test.go: `.makeLogValid(ethtypes.Log{TxIndex: tc.TxIndex, Index: tc.LogIndex})`
$DIR/pkg/client/rpc_client_internal_test.go: `.Run(tc.Name, func(t *testing.T) {
				rpc := NewTestRPCClient(t, RPCClientOpts{})
				log, err := rpc.makeLogValid(ethtypes.Log{TxIndex: tc.TxIndex, Index: tc.LogIndex})
				// other chains should return as is
				require.NoError(t, err)
				require.Equal(t, tc.TxIndex, log.TxIndex)
				require.Equal(t, tc.LogIndex, log.Index)
			})`
$DIR/pkg/client/rpc_client_internal_test.go: `.makeLogValid(ethtypes.Log{TxIndex: tc.TxIndex, Index: tc.LogIndex})`
$DIR/pkg/client/rpc_client_internal_test.go: `.NewInt(1234567)`
$DIR/pkg/client/rpc_client_internal_test.go: `.NewInt(1)`
$DIR/pkg/client/rpc_client_internal_test.go: `.NewInt(5)`
$DIR/pkg/client/rpc_client_internal_test.go: `.NewInt(5)`
$DIR/pkg/client/rpc_client_internal_test.go: `.NewInt(5)`
$DIR/pkg/client/rpc_client_internal_test.go: `.NewInt(9)`
$DIR/pkg/client/rpc_client_internal_test.go: `.NewInt(9)`
$DIR/pkg/client/rpc_client_internal_test.go: `.NewInt(8)`
$DIR/pkg/client/rpc_client_internal_test.go: `.EncodeToString([]byte("happy path result"))`
$DIR/pkg/client/rpc_client_internal_test.go: `.Run(tc.Name, func(t *testing.T) {
			wsURL := testutils.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				switch method {
				case "eth_call":
					resp.Result = fmt.Sprintf(`"%s"`, tc.EthCallResult)
					resp.Error.Message = tc.EthCallError
				case "eth_getBlockByNumber":
					require.True(t, params.IsArray())
					require.Equal(t, params.Array()[0].String(), tc.ExpectedTag)
					resp.Result = tc.BlockByNumberResult
					resp.Error.Message = tc.BlockByNumberError
				default:
					require.Fail(t, "unexpected method: "+method)
				}
				return
			}).WSURL()
			rpcClient := NewDialedTestRPCClient(t, RPCClientOpts{HTTP: wsURL, FinalityTagsEnabled: true, ChainID: chainID})
			var result hexutil.Bytes
			err := rpcClient.doWithConfidence(t.Context(), rpc.BatchElem{Method: "eth_call", Result: &result}, tc.CallBlockNumber, tc.Confidence)
			if tc.ExpectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tc.ExpectedError)
			} else {
				require.NoError(t, err)
				require.Equal(t, tc.ExpectedResult, string(result))
			}
		})`
$DIR/pkg/client/rpc_client_internal_test.go: `.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				switch method {
				case "eth_call":
					resp.Result = fmt.Sprintf(`"%s"`, tc.EthCallResult)
					resp.Error.Message = tc.EthCallError
				case "eth_getBlockByNumber":
					require.True(t, params.IsArray())
					require.Equal(t, params.Array()[0].String(), tc.ExpectedTag)
					resp.Result = tc.BlockByNumberResult
					resp.Error.Message = tc.BlockByNumberError
				default:
					require.Fail(t, "unexpected method: "+method)
				}
				return
			})`
$DIR/pkg/client/rpc_client_internal_test.go: `.Sprintf(`"%s"`, tc.EthCallResult)`
$DIR/pkg/client/rpc_client_internal_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_internal_test.go: `.doWithConfidence(t.Context(), rpc.BatchElem{Method: "eth_call", Result: &result}, tc.CallBlockNumber, tc.Confidence)`
$DIR/pkg/client/rpc_client_internal_test.go: `.Context()`
$DIR/pkg/client/rpc_client_internal_test.go: `.Run(tc.Name, func(t *testing.T) {
			rpcClient := NewTestRPCClient(t, RPCClientOpts{FinalityTagsEnabled: tc.FinalityTagEnabled})
			block, err := rpcClient.confidenceToBlockNumber(tc.ConfidenceLevel)
			if tc.ExpectedError != "" {
				require.ErrorContains(t, err, tc.ExpectedError)
			} else {
				require.NoError(t, err)
				require.Equal(t, tc.ExpectedBlock, block)
			}
		})`
$DIR/pkg/client/rpc_client_internal_test.go: `.confidenceToBlockNumber(tc.ConfidenceLevel)`
$DIR/pkg/client/rpc_client_internal_test.go: `.Run(tc.Name, func(t *testing.T) {
			rpcClient := NewTestRPCClient(t, RPCClientOpts{
				FinalityTagsEnabled: tc.FinalityTagEnabled,
				FinalityDepth:       tc.FinalityDepth,
				SafeDepth:           tc.SafeDepth,
			})

			block, err := rpcClient.referenceHeadToMaxAvailableHeight(tc.ConfidenceLevel, tc.ReferenceHeadHeight)
			if tc.ExpectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tc.ExpectedError)
			} else {
				require.NoError(t, err)
				require.Equal(t, tc.ExpectedBlock, block)
			}
		})`
$DIR/pkg/client/rpc_client_internal_test.go: `.referenceHeadToMaxAvailableHeight(tc.ConfidenceLevel, tc.ReferenceHeadHeight)`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/rpc_client_test.go: `rpcClient.UnsubscribeAllExcept()`
$DIR/pkg/client/rpc_client_test.go: `t.Run("WS and HTTP URL cannot be both empty", func(t *testing.T) {
		// ws is optional when LogBroadcaster is disabled, however SubscribeFilterLogs will return error if ws is missing
		rpcClient := client.NewTestRPCClient(t, client.RPCClientOpts{})
		require.Equal(t, errors.New("cannot dial rpc client when both ws and http info are missing"), rpcClient.Dial(ctx))
	})`
$DIR/pkg/client/rpc_client_test.go: `t.Run("Updates chain info on new blocks", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()

		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))
		// set to default values
		latest, highestUserObservations := rpc.GetInterceptedChainInfo()
		assert.Equal(t, int64(0), latest.BlockNumber)
		assert.Equal(t, int64(0), latest.FinalizedBlockNumber)
		assert.Nil(t, latest.TotalDifficulty)
		assert.Equal(t, int64(0), highestUserObservations.BlockNumber)
		assert.Equal(t, int64(0), highestUserObservations.FinalizedBlockNumber)
		assert.Nil(t, highestUserObservations.TotalDifficulty)

		ch, sub, err := rpc.SubscribeToHeads(tests.Context(t))
		require.NoError(t, err)
		defer sub.Unsubscribe()
		go server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256, TotalDifficulty: big.NewInt(1000)}))
		// received 256 head
		<-ch
		go server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 128, TotalDifficulty: big.NewInt(500)}))
		// received 128 head
		<-ch

		latest, highestUserObservations = rpc.GetInterceptedChainInfo()
		assert.Equal(t, int64(128), latest.BlockNumber)
		assert.Equal(t, int64(0), latest.FinalizedBlockNumber)
		assert.Equal(t, big.NewInt(500), latest.TotalDifficulty)

		assertHighestUserObservations := func(highestUserObservations multinode.ChainInfo) {
			assert.Equal(t, int64(256), highestUserObservations.BlockNumber)
			assert.Equal(t, int64(0), highestUserObservations.FinalizedBlockNumber)
			assert.Equal(t, big.NewInt(1000), highestUserObservations.TotalDifficulty)
		}

		assertHighestUserObservations(highestUserObservations)

		// Close resets latest
		rpc.Close()

		latest, highestUserObservations = rpc.GetInterceptedChainInfo()
		assert.Equal(t, int64(0), latest.BlockNumber)
		assert.Equal(t, int64(0), latest.FinalizedBlockNumber)
		assert.Nil(t, latest.TotalDifficulty)

		assertHighestUserObservations(highestUserObservations)
	})`
$DIR/pkg/client/rpc_client_test.go: `go server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256, TotalDifficulty: big.NewInt(1000)}))`
$DIR/pkg/client/rpc_client_test.go: `<-ch`
$DIR/pkg/client/rpc_client_test.go: `go server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 128, TotalDifficulty: big.NewInt(500)}))`
$DIR/pkg/client/rpc_client_test.go: `<-ch`
$DIR/pkg/client/rpc_client_test.go: `latest, highestUserObservations = rpc.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `assertHighestUserObservations(highestUserObservations)`
$DIR/pkg/client/rpc_client_test.go: `latest, highestUserObservations = rpc.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `assertHighestUserObservations(highestUserObservations)`
$DIR/pkg/client/rpc_client_test.go: `t.Run("App layer observations are not affected by new block if health check flag is present", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()

		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))

		ch, sub, err := rpc.SubscribeToHeads(multinode.CtxAddHealthCheckFlag(tests.Context(t)))
		require.NoError(t, err)
		defer sub.Unsubscribe()
		go server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256, TotalDifficulty: big.NewInt(1000)}))
		// received 256 head
		<-ch

		latest, highestUserObservations := rpc.GetInterceptedChainInfo()
		assert.Equal(t, int64(256), latest.BlockNumber)
		assert.Equal(t, int64(0), latest.FinalizedBlockNumber)
		assert.Equal(t, big.NewInt(1000), latest.TotalDifficulty)

		assert.Equal(t, int64(0), highestUserObservations.BlockNumber)
		assert.Equal(t, int64(0), highestUserObservations.FinalizedBlockNumber)
		assert.Nil(t, highestUserObservations.TotalDifficulty)
	})`
$DIR/pkg/client/rpc_client_test.go: `go server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256, TotalDifficulty: big.NewInt(1000)}))`
$DIR/pkg/client/rpc_client_test.go: `<-ch`
$DIR/pkg/client/rpc_client_test.go: `t.Run("SubscribeToHeads with http polling enabled will update new heads", func(t *testing.T) {
		type rpcServer struct {
			Head *evmtypes.Head
			URL  *url.URL
		}
		createRPCServer := func() *rpcServer {
			server := &rpcServer{}
			server.URL = testutils.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				assert.Equal(t, "eth_getBlockByNumber", method)
				if assert.True(t, params.IsArray()) && assert.Equal(t, "latest", params.Array()[0].String()) {
					head := server.Head
					jsonHead, err := json.Marshal(head)
					if assert.NoError(t, err, "failed to marshal head") {
						resp.Result = string(jsonHead)
					}
				}

				return
			}).WSURL()
			return server
		}

		server := createRPCServer()
		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: server.URL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))
		latest, highestUserObservations := rpc.GetInterceptedChainInfo()
		// latest chain info hasn't been initialized
		assert.Equal(t, int64(0), latest.BlockNumber)
		assert.Equal(t, int64(0), highestUserObservations.BlockNumber)

		server.Head = &evmtypes.Head{Number: 127}
		headCh, sub, err := rpc.SubscribeToHeads(tests.Context(t))
		require.NoError(t, err)
		defer sub.Unsubscribe()

		head := <-headCh
		assert.Equal(t, server.Head.Number, head.BlockNumber())
		// should update both latest and user observations
		latest, highestUserObservations = rpc.GetInterceptedChainInfo()
		assert.Equal(t, int64(127), latest.BlockNumber)
		assert.Equal(t, int64(127), highestUserObservations.BlockNumber)

		// subscription with health check flag won't affect user observations
		sub.Unsubscribe() // stop prev subscription
		server.Head = &evmtypes.Head{Number: 256}
		headCh, sub, err = rpc.SubscribeToHeads(multinode.CtxAddHealthCheckFlag(tests.Context(t)))
		require.NoError(t, err)
		defer sub.Unsubscribe()

		head = <-headCh
		assert.Equal(t, server.Head.Number, head.BlockNumber())
		// should only update latest
		latest, highestUserObservations = rpc.GetInterceptedChainInfo()
		assert.Equal(t, int64(256), latest.BlockNumber)
		assert.Equal(t, int64(127), highestUserObservations.BlockNumber)
	})`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = string(jsonHead)`
$DIR/pkg/client/rpc_client_test.go: `server.Head = &evmtypes.Head{Number: 127}`
$DIR/pkg/client/rpc_client_test.go: `latest, highestUserObservations = rpc.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `sub.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `server.Head = &evmtypes.Head{Number: 256}`
$DIR/pkg/client/rpc_client_test.go: `headCh, sub, err = rpc.SubscribeToHeads(multinode.CtxAddHealthCheckFlag(tests.Context(t)))`
$DIR/pkg/client/rpc_client_test.go: `head = <-headCh`
$DIR/pkg/client/rpc_client_test.go: `latest, highestUserObservations = rpc.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `t.Run("Concurrent Unsubscribe and onNewHead calls do not lead to a deadlock", func(t *testing.T) {
		const numberOfAttempts = 1000 // need a large number to increase the odds of reproducing the issue
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()

		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))
		var wg sync.WaitGroup
		for i := 0; i < numberOfAttempts; i++ {
			_, sub, err := rpc.SubscribeToHeads(tests.Context(t))
			require.NoError(t, err)
			wg.Add(2)
			go func() {
				server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256, TotalDifficulty: big.NewInt(1000)}))
				wg.Done()
			}()
			go func() {
				rpc.UnsubscribeAllExcept()
				sub.Unsubscribe()
				wg.Done()
			}()
			wg.Wait()
		}
	})`
$DIR/pkg/client/rpc_client_test.go: `wg.Add(2)`
$DIR/pkg/client/rpc_client_test.go: `server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256, TotalDifficulty: big.NewInt(1000)}))`
$DIR/pkg/client/rpc_client_test.go: `wg.Done()`
$DIR/pkg/client/rpc_client_test.go: `rpc.UnsubscribeAllExcept()`
$DIR/pkg/client/rpc_client_test.go: `sub.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `wg.Done()`
$DIR/pkg/client/rpc_client_test.go: `wg.Wait()`
$DIR/pkg/client/rpc_client_test.go: `t.Run("Block's chain ID matched configured", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()
		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL, ChainID: chainID})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))
		ch, sub, err := rpc.SubscribeToHeads(tests.Context(t))
		require.NoError(t, err)
		defer sub.Unsubscribe()
		go server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256}))
		head := <-ch
		require.Equal(t, chainID, head.ChainID())
	})`
$DIR/pkg/client/rpc_client_test.go: `go server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256}))`
$DIR/pkg/client/rpc_client_test.go: `t.Run("Failed SubscribeToHeads returns and logs proper error", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, func(reqMethod string, reqParams gjson.Result) (resp testutils.JSONRPCResponse) {
			return resp
		})
		wsURL := server.WSURL()
		observedLggr, observed := logger.TestObserved(t, zap.DebugLevel)
		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL, Lggr: observedLggr})
		require.NoError(t, rpc.Dial(ctx))
		server.Close()
		_, _, err := rpc.SubscribeToHeads(ctx)
		require.ErrorContains(t, err, "RPC call failed")
		tests.AssertLogEventually(t, observed, "evmclient.Client#EthSubscribe RPC call failure")
	})`
$DIR/pkg/client/rpc_client_test.go: `tests.AssertLogEventually(t, observed, "evmclient.Client#EthSubscribe RPC call failure")`
$DIR/pkg/client/rpc_client_test.go: `t.Run("Closed rpc client should remove existing SubscribeToHeads subscription with WS", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()
		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))

		_, sub, err := rpc.SubscribeToHeads(tests.Context(t))
		require.NoError(t, err)
		checkClosedRPCClientShouldRemoveExistingSub(t, ctx, sub, rpc)
	})`
$DIR/pkg/client/rpc_client_test.go: `checkClosedRPCClientShouldRemoveExistingSub(t, ctx, sub, rpc)`
$DIR/pkg/client/rpc_client_test.go: `t.Run("Closed rpc client should remove existing SubscribeToHeads subscription with HTTP polling", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()

		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgHeadPolling, WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))

		_, sub, err := rpc.SubscribeToHeads(tests.Context(t))
		require.NoError(t, err)
		checkClosedRPCClientShouldRemoveExistingSub(t, ctx, sub, rpc)
	})`
$DIR/pkg/client/rpc_client_test.go: `checkClosedRPCClientShouldRemoveExistingSub(t, ctx, sub, rpc)`
$DIR/pkg/client/rpc_client_test.go: `t.Run("Closed rpc client should remove existing SubscribeToFinalizedHeads subscription", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()

		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgHeadPolling, WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))

		_, sub, err := rpc.SubscribeToFinalizedHeads(tests.Context(t))
		require.NoError(t, err)
		checkClosedRPCClientShouldRemoveExistingSub(t, ctx, sub, rpc)
	})`
$DIR/pkg/client/rpc_client_test.go: `checkClosedRPCClientShouldRemoveExistingSub(t, ctx, sub, rpc)`
$DIR/pkg/client/rpc_client_test.go: `go server.MustWriteBinaryMessageSync(t, "invalid msg")`
$DIR/pkg/client/rpc_client_test.go: `t.Run("Failed SubscribeFilterLogs when WSURL is empty", func(t *testing.T) {
		// ws is optional when LogBroadcaster is disabled, however SubscribeFilterLogs will return error if ws is missing
		httpURL, err := url.Parse("https://valid_url.com")
		require.NoError(t, err)
		rpcClient := client.NewTestRPCClient(t, client.RPCClientOpts{HTTP: httpURL})
		require.NoError(t, rpcClient.Dial(ctx))

		_, err = rpcClient.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, make(chan types.Log))
		require.Equal(t, errors.New("SubscribeFilterLogs is not allowed without ws url"), err)
	})`
$DIR/pkg/client/rpc_client_test.go: `_, err = rpcClient.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, make(chan types.Log))`
$DIR/pkg/client/rpc_client_test.go: `t.Run("Failed SubscribeFilterLogs logs and returns proper error", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, func(reqMethod string, reqParams gjson.Result) (resp testutils.JSONRPCResponse) {
			return resp
		})
		wsURL := server.WSURL()
		observedLggr, observed := logger.TestObserved(t, zap.DebugLevel)
		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL, Lggr: observedLggr})
		require.NoError(t, rpc.Dial(ctx))
		server.Close()
		_, err := rpc.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, make(chan types.Log))
		require.ErrorContains(t, err, "RPC call failed")
		tests.AssertLogEventually(t, observed, "evmclient.Client#SubscribeFilterLogs RPC call failure")
	})`
$DIR/pkg/client/rpc_client_test.go: `tests.AssertLogEventually(t, observed, "evmclient.Client#SubscribeFilterLogs RPC call failure")`
$DIR/pkg/client/rpc_client_test.go: `t.Run("Subscription error is properly wrapper", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			assert.Equal(t, "eth_subscribe", method)
			if assert.True(t, params.IsArray()) && assert.Equal(t, "logs", params.Array()[0].String()) {
				resp.Result = `"0x00"`
				resp.Notify = "{}"
			}
			return resp
		})
		wsURL := server.WSURL()
		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))
		sub, err := rpc.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, make(chan types.Log))
		require.NoError(t, err)
		go server.MustWriteBinaryMessageSync(t, "invalid msg")
		errorCtx, cancel := context.WithTimeout(ctx, tests.DefaultWaitTimeout)
		defer cancel()
		select {
		case err = <-sub.Err():
			require.ErrorContains(t, err, "RPC call failed: invalid character 'i' looking for beginning of value")
		case <-errorCtx.Done():
			t.Errorf("Expected subscription to return an error, but test timeout instead")
		}
	})`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/rpc_client_test.go: `resp.Notify = "{}"`
$DIR/pkg/client/rpc_client_test.go: `go server.MustWriteBinaryMessageSync(t, "invalid msg")`
$DIR/pkg/client/rpc_client_test.go: `t.Run(ct.Name, func(t *testing.T) {
				server := testutils.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
					if method == "eth_unsubscribe" {
						resp.Result = "true"
						return
					} else if method == "eth_subscribe" {
						if assert.True(t, params.IsArray()) && assert.Equal(t, "logs", params.Array()[0].String()) {
							resp.Result = `"0x00"`
						}
						return
					}
					return
				})
				wsURL := server.WSURL()
				rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL, ChainType: ct.ChainType})
				defer rpc.Close()
				require.NoError(t, rpc.Dial(ctx))
				ch := make(chan types.Log)
				sub, err := rpc.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, ch)
				require.NoError(t, err)
				go func() {
					for _, testCase := range testCases {
						server.MustWriteBinaryMessageSync(t, makeNewWSMessage(types.Log{TxIndex: testCase.TxIndex, Index: testCase.Index, Topics: []common.Hash{{}}}))
					}
				}()
				defer sub.Unsubscribe()
				for _, testCase := range testCases {
					select {
					//nolint:staticcheck //SA1019 ignoring deprecated
					case <-tests.Context(t).Done():
						require.Fail(t, "context timed out")
					case err := <-sub.Err():
						require.NoError(t, err)
						require.Fail(t, "Did not expect error channel to be closed or return error before all testcases were consumed")
					case log := <-ch:
						require.Equal(t, testCase.ExpectedIndex, log.Index, "[%s] Unexpected log index %d for test case %v", ct.Name, log.Index, testCase)
					}
				}
			})`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = "true"`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/rpc_client_test.go: `server.MustWriteBinaryMessageSync(t, makeNewWSMessage(types.Log{TxIndex: testCase.TxIndex, Index: testCase.Index, Topics: []common.Hash{{}}}))`
$DIR/pkg/client/rpc_client_test.go: `logs = append(logs, types.Log{TxIndex: testCase.TxIndex, Index: testCase.Index, Topics: []common.Hash{{}}})`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = string(raw)`
$DIR/pkg/client/rpc_client_test.go: `t.Run(ct.Name, func(t *testing.T) {
				rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL, ChainType: ct.ChainType})
				defer rpc.Close()
				require.NoError(t, rpc.Dial(ctx))
				logs, err := rpc.FilterLogs(ctx, ethereum.FilterQuery{})
				require.NoError(t, err)
				for i, testCase := range testCases {
					require.Equal(t, testCase.ExpectedIndex, logs[i].Index, "Unexpected log index %d for test case %v", logs[i].Index, testCase)
				}
			})`
$DIR/pkg/client/rpc_client_test.go: `t.Run("Other chains", func(t *testing.T) {
			// other networks should return index as is
			rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL})
			defer rpc.Close()
			require.NoError(t, rpc.Dial(ctx))
			logs, err := rpc.FilterLogs(ctx, ethereum.FilterQuery{})
			require.NoError(t, err)
			for i, testCase := range testCases {
				require.Equal(t, testCase.Index, logs[i].Index, "Expected other chains log to be returned as is")
				require.Equal(t, testCase.TxIndex, logs[i].TxIndex, "Expected other chains log to be returned as is")
			}
		})`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = string(jsonHead)`
$DIR/pkg/client/rpc_client_test.go: `server.Head.Store(&evmtypes.Head{Number: 128})`
$DIR/pkg/client/rpc_client_test.go: `server.Head.Store(&evmtypes.Head{Number: 127})`
$DIR/pkg/client/rpc_client_test.go: `_, err = rpc.LatestFinalizedBlock(ctx)`
$DIR/pkg/client/rpc_client_test.go: `latest, highestUserObservations = rpc.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `server.Head.Store(&evmtypes.Head{Number: 256})`
$DIR/pkg/client/rpc_client_test.go: `_, err = rpc.LatestFinalizedBlock(multinode.CtxAddHealthCheckFlag(ctx))`
$DIR/pkg/client/rpc_client_test.go: `latest, highestUserObservations = rpc.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `server.Head.Store(&evmtypes.Head{Number: 512})`
$DIR/pkg/client/rpc_client_test.go: `latest, highestUserObservations = rpc.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `sub.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `server.Head.Store(&evmtypes.Head{Number: 1024})`
$DIR/pkg/client/rpc_client_test.go: `ch, sub, err = rpc.SubscribeToFinalizedHeads(multinode.CtxAddHealthCheckFlag(ctx))`
$DIR/pkg/client/rpc_client_test.go: `head = <-ch`
$DIR/pkg/client/rpc_client_test.go: `latest, highestUserObservations = rpc.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `latest, highestUserObservations = rpc.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `t.Run(testCase.Name, func(t *testing.T) {
			t.Parallel()
			// use background context to ensure that the DeadlineExceeded is caused by timeout we've set on request
			// level, instead of one that was set on test level.
			ctx, cancel := context.WithCancel(context.Background())
			defer cancel()

			chainID := big.NewInt(123456)
			rpcURL := testutils.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				// block until test is done
				<-ctx.Done()
				return
			}).WSURL()

			// use something unreasonably large for RPC timeout to ensure that we use largePayloadRPCTimeout
			const rpcTimeout = time.Hour
			const largePayloadRPCTimeout = tests.TestInterval
			rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: rpcURL, LargePayloadRPCTimeout: ptr(largePayloadRPCTimeout), RPCTimeout: ptr(rpcTimeout)})
			require.NoError(t, rpc.Dial(ctx))
			defer rpc.Close()
			err := testCase.Fn(ctx, rpc)
			assert.ErrorIs(t, err, context.DeadlineExceeded, "Expected DedlineExceeded error, but got: %v", err)
		})`
$DIR/pkg/client/rpc_client_test.go: `<-ctx.Done()`
$DIR/pkg/client/rpc_client_test.go: `t.Run("SendTransaction", func(t *testing.T) {
		// Create a simple transaction
		tx := types.NewTx(&types.LegacyTx{
			Nonce:    0,
			GasPrice: big.NewInt(1000000000),
			Gas:      21000,
			To:       &common.Address{},
			Value:    big.NewInt(1),
			Data:     nil,
		})

		// Call SendTransaction
		_, _, err := rpc.SendTransaction(ctx, tx)

		// Verify it returns the expected error for Tron
		require.Error(t, err)
		assert.Equal(t, "SendTransaction not implemented for Tron, this should never be called", err.Error())
	})`
$DIR/pkg/client/rpc_client_test.go: `t.Run("NonceAt", func(t *testing.T) {
		// Call NonceAt with a test address
		_, err := rpc.NonceAt(ctx, testAddr, nil)

		// Verify it returns an error
		require.Error(t, err, "tron does not support eth_getTransactionCount")
	})`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = `"0xf14c499253fd7bbcba142e5dd77dad8b5ad598c1dc414a66bacdd8dae14a6759"``
$DIR/pkg/client/rpc_client_test.go: `resp.Result = `{"parentHash":"0x1311773bc6b4efc8f438ed1f094524b2a1233baf8a35396f641fcc42a378fc62","number":"0x4","stateRoot":"0x0e4920dc5516b587e1f74a0b65963134523a12cc11478bb314e52895758fbfa2","extrinsicsRoot":"0x5b02446dcab0659eb07d4a38f28f181c1b78a71b2aba207bb0ea1f0f3468e6bd","digest":{"logs":["0x066175726120ad678e0800000000","0x04525053529023158dc8e8fd0180bf26d88233a3d94eed2f4e43480395f0809f28791965e4d34e9b3905","0x0466726f6e88017441e97acf83f555e0deefef86db636bc8a37eb84747603412884e4df4d2280400","0x056175726101018a0a57edf70cc5474323114a47ee1e7f645b8beea5a1560a996416458e89f42bdf4955e24d32b5da54e1bf628aaa7ce4b8c0fa2b95c175a139d88786af12a88c"]}}``
$DIR/pkg/client/rpc_client_test.go: `resp.Result = `{"author":"0x5accb3bf9194a5f81b2087d4bd6ac47c62775d49","baseFeePerGas":"0xb576270823","difficulty":"0x0","extraData":"0x","gasLimit":"0xe4e1c0","gasUsed":"0x0","hash":"0x7441e97acf83f555e0deefef86db636bc8a37eb84747603412884e4df4d22804","logsBloom":"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","miner":"0x5accb3bf9194a5f81b2087d4bd6ac47c62775d49","nonce":"0x0000000000000000","number":"0x4","parentHash":"0x6ba069c318b692bf2cc0bd7ea070a9382a20c2f52413c10554b57c2e381bf2bb","receiptsRoot":"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421","sha3Uncles":"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347","size":"0x201","stateRoot":"0x17c46d359b9af773312c747f1d20032c67658d9a2923799f00533b73789cf49b","timestamp":"0x66acdc22","totalDifficulty":"0x0","transactions":[],"transactionsRoot":"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421","uncles":[]}``
$DIR/pkg/client/rpc_client_test.go: `resp.Result = `{"author":"0x1687736326c9fea17e25fc5287613693c912909c","baseFeePerGas":"0x3b9aca00","difficulty":"0x0","extraData":"0x","gasLimit":"0xe4e1c0","gasUsed":"0x0","hash":"0x62f03413681948b06882e7d9f91c4949bc39ded98d36336ab03faea038ec8e3d","logsBloom":"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","miner":"0x1687736326c9fea17e25fc5287613693c912909c","nonce":"0x0000000000000000","number":"0x8","parentHash":"0x43f504afdc639cbb8daf5fd5328a37762164b73f9c70ed54e1928c1fca6d8f23","receiptsRoot":"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421","sha3Uncles":"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347","size":"0x200","stateRoot":"0x0cb938d51ad83bdf401e3f5f7f989e60df64fdea620d394af41a3e72629f7495","timestamp":"0x61bd8d1a","totalDifficulty":"0x0","transactions":[],"transactionsRoot":"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421","uncles":[]}``
$DIR/pkg/client/rpc_client_test.go: `t.Run(testCase.Name, func(t *testing.T) {
			lf, err := testCase.GetLatestFinalized(tests.Context(t))
			require.NoError(t, err)
			require.NotNil(t, lf)
			assert.Equal(t, expectedFinalizedBlockHash, lf.Hash.String())
			assert.Equal(t, expectedFinalizedBlockNumber, lf.Number)
		})`
$DIR/pkg/client/rpc_client_test.go: `resp.Error.Message = stubErr`
$DIR/pkg/client/rpc_client_test.go: `resp.Error.Code = -32000`
$DIR/pkg/client/rpc_client_test.go: `expectedMethod = method`
$DIR/pkg/client/rpc_client_test.go: `expectedParams = params.String()`
$DIR/pkg/client/rpc_client_test.go: `resp.Error.Message = stubErr`
$DIR/pkg/client/rpc_client_test.go: `resp.Error.Code = -32000`
$DIR/pkg/client/rpc_client_test.go: `t.Cleanup(rpcClient.Close)`
$DIR/pkg/client/rpc_client_test.go: `t.Run(tc.Name, func(t *testing.T) {
			rpcClient := newRPCClient(t)
			err := tc.OriginalCall(t, rpcClient)
			require.ErrorContains(t, err, stubErr)
			err = tc.WithOptsCall(t, rpcClient)
			require.ErrorContains(t, err, stubErr)
		})`
$DIR/pkg/client/rpc_client_test.go: `err = tc.WithOptsCall(t, rpcClient)`
$DIR/pkg/client/rpc_client_test.go: `t.Run("Happy path", func(t *testing.T) {
		const expectedResult = "call contract happy path result"
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_call":
				resp.Result = fmt.Sprintf(`"%s"`, "0x"+hex.EncodeToString([]byte(expectedResult)))
			case "eth_getBlockByNumber":
				require.True(t, params.IsArray())
				require.Equal(t, "finalized", params.Array()[0].String())
				resp.Result = client.MakeHeadMsgForNumber(10)
			default:
				require.Fail(t, "unexpected method: "+method)
			}
			return
		}).WSURL()
		rpcClient := client.NewDialedTestRPCClient(t, client.RPCClientOpts{WS: wsURL, FinalityTagsEnabled: true})
		result, err := rpcClient.CallContractWithOpts(t.Context(), ethereum.CallMsg{}, big.NewInt(9), evmtypes.CallContractOpts{ConfidenceLevel: primitives.Finalized})
		require.NoError(t, err)
		require.Equal(t, expectedResult, string(result))
	})`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = fmt.Sprintf(`"%s"`, "0x"+hex.EncodeToString([]byte(expectedResult)))`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = client.MakeHeadMsgForNumber(10)`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = fmt.Sprintf(`"%s"`, "0x"+hex.EncodeToString(make([]byte, responseLimit+1)))`
$DIR/pkg/client/rpc_client_test.go: `_, err = rpcClient.CallContractWithOpts(t.Context(), ethereum.CallMsg{}, big.NewInt(9), evmtypes.CallContractOpts{IsExternalRequest: true})`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = fmt.Sprintf(`"%s"`, hexutil.EncodeBig(expectedResult))`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = client.MakeHeadMsgForNumber(10)`
$DIR/pkg/client/rpc_client_test.go: `t.Run("Happy path", func(t *testing.T) {

		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_getLogs":
				logsAsJSON, err := json.Marshal(validLogs)
				require.NoError(t, err)
				resp.Result = string(logsAsJSON)
			case "eth_getBlockByNumber":
				require.True(t, params.IsArray())
				require.Equal(t, "finalized", params.Array()[0].String())
				resp.Result = client.MakeHeadMsgForNumber(10)
			default:
				require.Fail(t, "unexpected method: "+method)
			}
			return
		}).WSURL()
		rpcClient := client.NewDialedTestRPCClient(t, client.RPCClientOpts{WS: wsURL, FinalityTagsEnabled: true})
		filter := ethereum.FilterQuery{FromBlock: big.NewInt(0), ToBlock: big.NewInt(10), Topics: [][]common.Hash{topics}}
		result, err := rpcClient.FilterLogsWithOpts(t.Context(), filter, evmtypes.FilterLogsOpts{ConfidenceLevel: primitives.Finalized})
		require.NoError(t, err)
		require.Equal(t, validLogs, result)
	})`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = string(logsAsJSON)`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = client.MakeHeadMsgForNumber(10)`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = string(logsAsJSON)`
$DIR/pkg/client/rpc_client_test.go: `_, err = rpcClient.FilterLogsWithOpts(t.Context(), filter, evmtypes.FilterLogsOpts{IsExternalRequest: false})`
$DIR/pkg/client/rpc_client_test.go: `_, err = rpcClient.FilterLogsWithOpts(t.Context(), filter, evmtypes.FilterLogsOpts{IsExternalRequest: true})`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = client.MakeHeadMsgForNumber(10)`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = string(asJSON)`
$DIR/pkg/client/rpc_client_test.go: `head.EVMChainID = ubig.New(chainID)`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = string(receiptsAsJSON)`
$DIR/pkg/client/rpc_client_test.go: `_, err = rpcClient.TransactionReceiptGethWithOpts(t.Context(), common.Hash{}, evmtypes.TransactionReceiptOpts{IsExternalRequest: false})`
$DIR/pkg/client/rpc_client_test.go: `_, err = rpcClient.TransactionReceiptGethWithOpts(t.Context(), common.Hash{}, evmtypes.TransactionReceiptOpts{IsExternalRequest: true})`
$DIR/pkg/client/rpc_client_test.go: `resp.Result = string(txAsJSON)`
$DIR/pkg/client/rpc_client_test.go: `_, err = rpcClient.TransactionByHashWithOpts(t.Context(), common.Hash{}, evmtypes.TransactionByHashOpts{IsExternalRequest: false})`
$DIR/pkg/client/rpc_client_test.go: `_, err = rpcClient.TransactionByHashWithOpts(t.Context(), common.Hash{}, evmtypes.TransactionByHashOpts{IsExternalRequest: true})`
$DIR/pkg/client/rpc_client_test.go: `.WithTimeout(tests.Context(t), tests.WaitTimeout(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.WaitTimeout(t)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(123456)`
$DIR/pkg/client/rpc_client_test.go: `.Err()`
$DIR/pkg/client/rpc_client_test.go: `.UnsubscribeAllExcept()`
$DIR/pkg/client/rpc_client_test.go: `.Run("WS and HTTP URL cannot be both empty", func(t *testing.T) {
		// ws is optional when LogBroadcaster is disabled, however SubscribeFilterLogs will return error if ws is missing
		rpcClient := client.NewTestRPCClient(t, client.RPCClientOpts{})
		require.Equal(t, errors.New("cannot dial rpc client when both ws and http info are missing"), rpcClient.Dial(ctx))
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{})`
$DIR/pkg/client/rpc_client_test.go: `.Run("Updates chain info on new blocks", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()

		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))
		// set to default values
		latest, highestUserObservations := rpc.GetInterceptedChainInfo()
		assert.Equal(t, int64(0), latest.BlockNumber)
		assert.Equal(t, int64(0), latest.FinalizedBlockNumber)
		assert.Nil(t, latest.TotalDifficulty)
		assert.Equal(t, int64(0), highestUserObservations.BlockNumber)
		assert.Equal(t, int64(0), highestUserObservations.FinalizedBlockNumber)
		assert.Nil(t, highestUserObservations.TotalDifficulty)

		ch, sub, err := rpc.SubscribeToHeads(tests.Context(t))
		require.NoError(t, err)
		defer sub.Unsubscribe()
		go server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256, TotalDifficulty: big.NewInt(1000)}))
		// received 256 head
		<-ch
		go server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 128, TotalDifficulty: big.NewInt(500)}))
		// received 128 head
		<-ch

		latest, highestUserObservations = rpc.GetInterceptedChainInfo()
		assert.Equal(t, int64(128), latest.BlockNumber)
		assert.Equal(t, int64(0), latest.FinalizedBlockNumber)
		assert.Equal(t, big.NewInt(500), latest.TotalDifficulty)

		assertHighestUserObservations := func(highestUserObservations multinode.ChainInfo) {
			assert.Equal(t, int64(256), highestUserObservations.BlockNumber)
			assert.Equal(t, int64(0), highestUserObservations.FinalizedBlockNumber)
			assert.Equal(t, big.NewInt(1000), highestUserObservations.TotalDifficulty)
		}

		assertHighestUserObservations(highestUserObservations)

		// Close resets latest
		rpc.Close()

		latest, highestUserObservations = rpc.GetInterceptedChainInfo()
		assert.Equal(t, int64(0), latest.BlockNumber)
		assert.Equal(t, int64(0), latest.FinalizedBlockNumber)
		assert.Nil(t, latest.TotalDifficulty)

		assertHighestUserObservations(highestUserObservations)
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, serverCallBack)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL})`
$DIR/pkg/client/rpc_client_test.go: `.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeToHeads(tests.Context(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256, TotalDifficulty: big.NewInt(1000)}))`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(1000)`
$DIR/pkg/client/rpc_client_test.go: `.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 128, TotalDifficulty: big.NewInt(500)}))`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(500)`
$DIR/pkg/client/rpc_client_test.go: `.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `.Run("App layer observations are not affected by new block if health check flag is present", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()

		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))

		ch, sub, err := rpc.SubscribeToHeads(multinode.CtxAddHealthCheckFlag(tests.Context(t)))
		require.NoError(t, err)
		defer sub.Unsubscribe()
		go server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256, TotalDifficulty: big.NewInt(1000)}))
		// received 256 head
		<-ch

		latest, highestUserObservations := rpc.GetInterceptedChainInfo()
		assert.Equal(t, int64(256), latest.BlockNumber)
		assert.Equal(t, int64(0), latest.FinalizedBlockNumber)
		assert.Equal(t, big.NewInt(1000), latest.TotalDifficulty)

		assert.Equal(t, int64(0), highestUserObservations.BlockNumber)
		assert.Equal(t, int64(0), highestUserObservations.FinalizedBlockNumber)
		assert.Nil(t, highestUserObservations.TotalDifficulty)
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, serverCallBack)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeToHeads(multinode.CtxAddHealthCheckFlag(tests.Context(t)))`
$DIR/pkg/client/rpc_client_test.go: `.CtxAddHealthCheckFlag(tests.Context(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256, TotalDifficulty: big.NewInt(1000)}))`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(1000)`
$DIR/pkg/client/rpc_client_test.go: `.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `.Run("SubscribeToHeads with http polling enabled will update new heads", func(t *testing.T) {
		type rpcServer struct {
			Head *evmtypes.Head
			URL  *url.URL
		}
		createRPCServer := func() *rpcServer {
			server := &rpcServer{}
			server.URL = testutils.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				assert.Equal(t, "eth_getBlockByNumber", method)
				if assert.True(t, params.IsArray()) && assert.Equal(t, "latest", params.Array()[0].String()) {
					head := server.Head
					jsonHead, err := json.Marshal(head)
					if assert.NoError(t, err, "failed to marshal head") {
						resp.Result = string(jsonHead)
					}
				}

				return
			}).WSURL()
			return server
		}

		server := createRPCServer()
		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: server.URL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))
		latest, highestUserObservations := rpc.GetInterceptedChainInfo()
		// latest chain info hasn't been initialized
		assert.Equal(t, int64(0), latest.BlockNumber)
		assert.Equal(t, int64(0), highestUserObservations.BlockNumber)

		server.Head = &evmtypes.Head{Number: 127}
		headCh, sub, err := rpc.SubscribeToHeads(tests.Context(t))
		require.NoError(t, err)
		defer sub.Unsubscribe()

		head := <-headCh
		assert.Equal(t, server.Head.Number, head.BlockNumber())
		// should update both latest and user observations
		latest, highestUserObservations = rpc.GetInterceptedChainInfo()
		assert.Equal(t, int64(127), latest.BlockNumber)
		assert.Equal(t, int64(127), highestUserObservations.BlockNumber)

		// subscription with health check flag won't affect user observations
		sub.Unsubscribe() // stop prev subscription
		server.Head = &evmtypes.Head{Number: 256}
		headCh, sub, err = rpc.SubscribeToHeads(multinode.CtxAddHealthCheckFlag(tests.Context(t)))
		require.NoError(t, err)
		defer sub.Unsubscribe()

		head = <-headCh
		assert.Equal(t, server.Head.Number, head.BlockNumber())
		// should only update latest
		latest, highestUserObservations = rpc.GetInterceptedChainInfo()
		assert.Equal(t, int64(256), latest.BlockNumber)
		assert.Equal(t, int64(127), highestUserObservations.BlockNumber)
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				assert.Equal(t, "eth_getBlockByNumber", method)
				if assert.True(t, params.IsArray()) && assert.Equal(t, "latest", params.Array()[0].String()) {
					head := server.Head
					jsonHead, err := json.Marshal(head)
					if assert.NoError(t, err, "failed to marshal head") {
						resp.Result = string(jsonHead)
					}
				}

				return
			})`
$DIR/pkg/client/rpc_client_test.go: `.Marshal(head)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{WS: server.URL})`
$DIR/pkg/client/rpc_client_test.go: `.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeToHeads(tests.Context(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeToHeads(multinode.CtxAddHealthCheckFlag(tests.Context(t)))`
$DIR/pkg/client/rpc_client_test.go: `.CtxAddHealthCheckFlag(tests.Context(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `.Run("Concurrent Unsubscribe and onNewHead calls do not lead to a deadlock", func(t *testing.T) {
		const numberOfAttempts = 1000 // need a large number to increase the odds of reproducing the issue
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()

		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))
		var wg sync.WaitGroup
		for i := 0; i < numberOfAttempts; i++ {
			_, sub, err := rpc.SubscribeToHeads(tests.Context(t))
			require.NoError(t, err)
			wg.Add(2)
			go func() {
				server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256, TotalDifficulty: big.NewInt(1000)}))
				wg.Done()
			}()
			go func() {
				rpc.UnsubscribeAllExcept()
				sub.Unsubscribe()
				wg.Done()
			}()
			wg.Wait()
		}
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, serverCallBack)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeToHeads(tests.Context(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.Add(2)`
$DIR/pkg/client/rpc_client_test.go: `.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256, TotalDifficulty: big.NewInt(1000)}))`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(1000)`
$DIR/pkg/client/rpc_client_test.go: `.Done()`
$DIR/pkg/client/rpc_client_test.go: `.UnsubscribeAllExcept()`
$DIR/pkg/client/rpc_client_test.go: `.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `.Done()`
$DIR/pkg/client/rpc_client_test.go: `.Wait()`
$DIR/pkg/client/rpc_client_test.go: `.Run("Block's chain ID matched configured", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()
		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL, ChainID: chainID})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))
		ch, sub, err := rpc.SubscribeToHeads(tests.Context(t))
		require.NoError(t, err)
		defer sub.Unsubscribe()
		go server.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256}))
		head := <-ch
		require.Equal(t, chainID, head.ChainID())
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, serverCallBack)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL, ChainID: chainID})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeToHeads(tests.Context(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `.MustWriteBinaryMessageSync(t, makeNewHeadWSMessage(&evmtypes.Head{Number: 256}))`
$DIR/pkg/client/rpc_client_test.go: `.Run("Failed SubscribeToHeads returns and logs proper error", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, func(reqMethod string, reqParams gjson.Result) (resp testutils.JSONRPCResponse) {
			return resp
		})
		wsURL := server.WSURL()
		observedLggr, observed := logger.TestObserved(t, zap.DebugLevel)
		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL, Lggr: observedLggr})
		require.NoError(t, rpc.Dial(ctx))
		server.Close()
		_, _, err := rpc.SubscribeToHeads(ctx)
		require.ErrorContains(t, err, "RPC call failed")
		tests.AssertLogEventually(t, observed, "evmclient.Client#EthSubscribe RPC call failure")
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, func(reqMethod string, reqParams gjson.Result) (resp testutils.JSONRPCResponse) {
			return resp
		})`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.TestObserved(t, zap.DebugLevel)`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL, Lggr: observedLggr})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeToHeads(ctx)`
$DIR/pkg/client/rpc_client_test.go: `.AssertLogEventually(t, observed, "evmclient.Client#EthSubscribe RPC call failure")`
$DIR/pkg/client/rpc_client_test.go: `.Run("Closed rpc client should remove existing SubscribeToHeads subscription with WS", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()
		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))

		_, sub, err := rpc.SubscribeToHeads(tests.Context(t))
		require.NoError(t, err)
		checkClosedRPCClientShouldRemoveExistingSub(t, ctx, sub, rpc)
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, serverCallBack)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeToHeads(tests.Context(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.Run("Closed rpc client should remove existing SubscribeToHeads subscription with HTTP polling", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()

		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgHeadPolling, WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))

		_, sub, err := rpc.SubscribeToHeads(tests.Context(t))
		require.NoError(t, err)
		checkClosedRPCClientShouldRemoveExistingSub(t, ctx, sub, rpc)
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, serverCallBack)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgHeadPolling, WS: wsURL})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeToHeads(tests.Context(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.Run("Closed rpc client should remove existing SubscribeToFinalizedHeads subscription", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, serverCallBack)
		wsURL := server.WSURL()

		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgHeadPolling, WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))

		_, sub, err := rpc.SubscribeToFinalizedHeads(tests.Context(t))
		require.NoError(t, err)
		checkClosedRPCClientShouldRemoveExistingSub(t, ctx, sub, rpc)
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, serverCallBack)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgHeadPolling, WS: wsURL})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeToFinalizedHeads(tests.Context(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, serverCallBack)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{Cfg: nodePoolCfgWSSub, WS: wsURL})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeToHeads(ctx)`
$DIR/pkg/client/rpc_client_test.go: `.MustWriteBinaryMessageSync(t, "invalid msg")`
$DIR/pkg/client/rpc_client_test.go: `.Err()`
$DIR/pkg/client/rpc_client_test.go: `.Done()`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(123456)`
$DIR/pkg/client/rpc_client_test.go: `.WithTimeout(tests.Context(t), tests.WaitTimeout(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.WaitTimeout(t)`
$DIR/pkg/client/rpc_client_test.go: `.Run("Failed SubscribeFilterLogs when WSURL is empty", func(t *testing.T) {
		// ws is optional when LogBroadcaster is disabled, however SubscribeFilterLogs will return error if ws is missing
		httpURL, err := url.Parse("https://valid_url.com")
		require.NoError(t, err)
		rpcClient := client.NewTestRPCClient(t, client.RPCClientOpts{HTTP: httpURL})
		require.NoError(t, rpcClient.Dial(ctx))

		_, err = rpcClient.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, make(chan types.Log))
		require.Equal(t, errors.New("SubscribeFilterLogs is not allowed without ws url"), err)
	})`
$DIR/pkg/client/rpc_client_test.go: `.Parse("https://valid_url.com")`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{HTTP: httpURL})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, make(chan types.Log))`
$DIR/pkg/client/rpc_client_test.go: `.Run("Failed SubscribeFilterLogs logs and returns proper error", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, func(reqMethod string, reqParams gjson.Result) (resp testutils.JSONRPCResponse) {
			return resp
		})
		wsURL := server.WSURL()
		observedLggr, observed := logger.TestObserved(t, zap.DebugLevel)
		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL, Lggr: observedLggr})
		require.NoError(t, rpc.Dial(ctx))
		server.Close()
		_, err := rpc.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, make(chan types.Log))
		require.ErrorContains(t, err, "RPC call failed")
		tests.AssertLogEventually(t, observed, "evmclient.Client#SubscribeFilterLogs RPC call failure")
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, func(reqMethod string, reqParams gjson.Result) (resp testutils.JSONRPCResponse) {
			return resp
		})`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.TestObserved(t, zap.DebugLevel)`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL, Lggr: observedLggr})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, make(chan types.Log))`
$DIR/pkg/client/rpc_client_test.go: `.AssertLogEventually(t, observed, "evmclient.Client#SubscribeFilterLogs RPC call failure")`
$DIR/pkg/client/rpc_client_test.go: `.Run("Subscription error is properly wrapper", func(t *testing.T) {
		server := testutils.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			assert.Equal(t, "eth_subscribe", method)
			if assert.True(t, params.IsArray()) && assert.Equal(t, "logs", params.Array()[0].String()) {
				resp.Result = `"0x00"`
				resp.Notify = "{}"
			}
			return resp
		})
		wsURL := server.WSURL()
		rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL})
		defer rpc.Close()
		require.NoError(t, rpc.Dial(ctx))
		sub, err := rpc.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, make(chan types.Log))
		require.NoError(t, err)
		go server.MustWriteBinaryMessageSync(t, "invalid msg")
		errorCtx, cancel := context.WithTimeout(ctx, tests.DefaultWaitTimeout)
		defer cancel()
		select {
		case err = <-sub.Err():
			require.ErrorContains(t, err, "RPC call failed: invalid character 'i' looking for beginning of value")
		case <-errorCtx.Done():
			t.Errorf("Expected subscription to return an error, but test timeout instead")
		}
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			assert.Equal(t, "eth_subscribe", method)
			if assert.True(t, params.IsArray()) && assert.Equal(t, "logs", params.Array()[0].String()) {
				resp.Result = `"0x00"`
				resp.Notify = "{}"
			}
			return resp
		})`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, make(chan types.Log))`
$DIR/pkg/client/rpc_client_test.go: `.MustWriteBinaryMessageSync(t, "invalid msg")`
$DIR/pkg/client/rpc_client_test.go: `.WithTimeout(ctx, tests.DefaultWaitTimeout)`
$DIR/pkg/client/rpc_client_test.go: `.Err()`
$DIR/pkg/client/rpc_client_test.go: `.Done()`
$DIR/pkg/client/rpc_client_test.go: `.Run(ct.Name, func(t *testing.T) {
				server := testutils.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
					if method == "eth_unsubscribe" {
						resp.Result = "true"
						return
					} else if method == "eth_subscribe" {
						if assert.True(t, params.IsArray()) && assert.Equal(t, "logs", params.Array()[0].String()) {
							resp.Result = `"0x00"`
						}
						return
					}
					return
				})
				wsURL := server.WSURL()
				rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL, ChainType: ct.ChainType})
				defer rpc.Close()
				require.NoError(t, rpc.Dial(ctx))
				ch := make(chan types.Log)
				sub, err := rpc.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, ch)
				require.NoError(t, err)
				go func() {
					for _, testCase := range testCases {
						server.MustWriteBinaryMessageSync(t, makeNewWSMessage(types.Log{TxIndex: testCase.TxIndex, Index: testCase.Index, Topics: []common.Hash{{}}}))
					}
				}()
				defer sub.Unsubscribe()
				for _, testCase := range testCases {
					select {
					//nolint:staticcheck //SA1019 ignoring deprecated
					case <-tests.Context(t).Done():
						require.Fail(t, "context timed out")
					case err := <-sub.Err():
						require.NoError(t, err)
						require.Fail(t, "Did not expect error channel to be closed or return error before all testcases were consumed")
					case log := <-ch:
						require.Equal(t, testCase.ExpectedIndex, log.Index, "[%s] Unexpected log index %d for test case %v", ct.Name, log.Index, testCase)
					}
				}
			})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
					if method == "eth_unsubscribe" {
						resp.Result = "true"
						return
					} else if method == "eth_subscribe" {
						if assert.True(t, params.IsArray()) && assert.Equal(t, "logs", params.Array()[0].String()) {
							resp.Result = `"0x00"`
						}
						return
					}
					return
				})`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL, ChainType: ct.ChainType})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeFilterLogs(ctx, ethereum.FilterQuery{}, ch)`
$DIR/pkg/client/rpc_client_test.go: `.MustWriteBinaryMessageSync(t, makeNewWSMessage(types.Log{TxIndex: testCase.TxIndex, Index: testCase.Index, Topics: []common.Hash{{}}}))`
$DIR/pkg/client/rpc_client_test.go: `.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.Done()`
$DIR/pkg/client/rpc_client_test.go: `.Err()`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(123456)`
$DIR/pkg/client/rpc_client_test.go: `.WithTimeout(tests.Context(t), tests.WaitTimeout(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.WaitTimeout(t)`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			if method != "eth_getLogs" {
				return
			}
			var logs []types.Log
			for _, testCase := range testCases {
				logs = append(logs, types.Log{TxIndex: testCase.TxIndex, Index: testCase.Index, Topics: []common.Hash{{}}})
			}
			raw, err := json.Marshal(logs)
			require.NoError(t, err)
			resp.Result = string(raw)
			return
		})`
$DIR/pkg/client/rpc_client_test.go: `.Marshal(logs)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.Run(ct.Name, func(t *testing.T) {
				rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL, ChainType: ct.ChainType})
				defer rpc.Close()
				require.NoError(t, rpc.Dial(ctx))
				logs, err := rpc.FilterLogs(ctx, ethereum.FilterQuery{})
				require.NoError(t, err)
				for i, testCase := range testCases {
					require.Equal(t, testCase.ExpectedIndex, logs[i].Index, "Unexpected log index %d for test case %v", logs[i].Index, testCase)
				}
			})`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL, ChainType: ct.ChainType})`
$DIR/pkg/client/rpc_client_test.go: `.FilterLogs(ctx, ethereum.FilterQuery{})`
$DIR/pkg/client/rpc_client_test.go: `.Run("Other chains", func(t *testing.T) {
			// other networks should return index as is
			rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL})
			defer rpc.Close()
			require.NoError(t, rpc.Dial(ctx))
			logs, err := rpc.FilterLogs(ctx, ethereum.FilterQuery{})
			require.NoError(t, err)
			for i, testCase := range testCases {
				require.Equal(t, testCase.Index, logs[i].Index, "Expected other chains log to be returned as is")
				require.Equal(t, testCase.TxIndex, logs[i].TxIndex, "Expected other chains log to be returned as is")
			}
		})`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL})`
$DIR/pkg/client/rpc_client_test.go: `.FilterLogs(ctx, ethereum.FilterQuery{})`
$DIR/pkg/client/rpc_client_test.go: `.WithTimeout(tests.Context(t), tests.WaitTimeout(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.WaitTimeout(t)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(123456)`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			assert.Equal(t, "eth_getBlockByNumber", method)
			if assert.True(t, params.IsArray()) && assert.Equal(t, "finalized", params.Array()[0].String()) {
				head := server.Head.Load()
				jsonHead, err := json.Marshal(head)
				if err != nil {
					panic(fmt.Errorf("failed to marshal head: %w", err))
				}
				resp.Result = string(jsonHead)
			}

			return
		})`
$DIR/pkg/client/rpc_client_test.go: `.Head.Load()`
$DIR/pkg/client/rpc_client_test.go: `.Marshal(head)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{WS: server.URL})`
$DIR/pkg/client/rpc_client_test.go: `.Head.Store(&evmtypes.Head{Number: 128})`
$DIR/pkg/client/rpc_client_test.go: `.LatestFinalizedBlock(ctx)`
$DIR/pkg/client/rpc_client_test.go: `.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `.Head.Store(&evmtypes.Head{Number: 127})`
$DIR/pkg/client/rpc_client_test.go: `.LatestFinalizedBlock(ctx)`
$DIR/pkg/client/rpc_client_test.go: `.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `.Head.Store(&evmtypes.Head{Number: 256})`
$DIR/pkg/client/rpc_client_test.go: `.LatestFinalizedBlock(multinode.CtxAddHealthCheckFlag(ctx))`
$DIR/pkg/client/rpc_client_test.go: `.CtxAddHealthCheckFlag(ctx)`
$DIR/pkg/client/rpc_client_test.go: `.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `.Head.Store(&evmtypes.Head{Number: 512})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeToFinalizedHeads(ctx)`
$DIR/pkg/client/rpc_client_test.go: `.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `.Head.Store(&evmtypes.Head{Number: 1024})`
$DIR/pkg/client/rpc_client_test.go: `.SubscribeToFinalizedHeads(multinode.CtxAddHealthCheckFlag(ctx))`
$DIR/pkg/client/rpc_client_test.go: `.CtxAddHealthCheckFlag(ctx)`
$DIR/pkg/client/rpc_client_test.go: `.Unsubscribe()`
$DIR/pkg/client/rpc_client_test.go: `.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `.GetInterceptedChainInfo()`
$DIR/pkg/client/rpc_client_test.go: `.SendTransaction(ctx, types.NewTx(&types.LegacyTx{}))`
$DIR/pkg/client/rpc_client_test.go: `.NewTx(&types.LegacyTx{})`
$DIR/pkg/client/rpc_client_test.go: `.EstimateGas(ctx, ethereum.CallMsg{})`
$DIR/pkg/client/rpc_client_test.go: `.CallContract(ctx, ethereum.CallMsg{}, nil)`
$DIR/pkg/client/rpc_client_test.go: `.CallContext(ctx, nil, "rpc_call", nil)`
$DIR/pkg/client/rpc_client_test.go: `.BatchCallContext(ctx, nil)`
$DIR/pkg/client/rpc_client_test.go: `.Run(testCase.Name, func(t *testing.T) {
			t.Parallel()
			// use background context to ensure that the DeadlineExceeded is caused by timeout we've set on request
			// level, instead of one that was set on test level.
			ctx, cancel := context.WithCancel(context.Background())
			defer cancel()

			chainID := big.NewInt(123456)
			rpcURL := testutils.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				// block until test is done
				<-ctx.Done()
				return
			}).WSURL()

			// use something unreasonably large for RPC timeout to ensure that we use largePayloadRPCTimeout
			const rpcTimeout = time.Hour
			const largePayloadRPCTimeout = tests.TestInterval
			rpc := client.NewTestRPCClient(t, client.RPCClientOpts{WS: rpcURL, LargePayloadRPCTimeout: ptr(largePayloadRPCTimeout), RPCTimeout: ptr(rpcTimeout)})
			require.NoError(t, rpc.Dial(ctx))
			defer rpc.Close()
			err := testCase.Fn(ctx, rpc)
			assert.ErrorIs(t, err, context.DeadlineExceeded, "Expected DedlineExceeded error, but got: %v", err)
		})`
$DIR/pkg/client/rpc_client_test.go: `.WithCancel(context.Background())`
$DIR/pkg/client/rpc_client_test.go: `.Background()`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(123456)`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
				// block until test is done
				<-ctx.Done()
				return
			})`
$DIR/pkg/client/rpc_client_test.go: `.Done()`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{WS: rpcURL, LargePayloadRPCTimeout: ptr(largePayloadRPCTimeout), RPCTimeout: ptr(rpcTimeout)})`
$DIR/pkg/client/rpc_client_test.go: `.Fn(ctx, rpc)`
$DIR/pkg/client/rpc_client_test.go: `.WithTimeout(t.Context(), tests.WaitTimeout(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.WaitTimeout(t)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(123456)`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
		assert.Fail(t, "Server should not be called for Tron methods")
		return resp
	})`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL, ChainType: chaintype.ChainTron})`
$DIR/pkg/client/rpc_client_test.go: `.HexToAddress("0x1234567890123456789012345678901234567890")`
$DIR/pkg/client/rpc_client_test.go: `.Run("SendTransaction", func(t *testing.T) {
		// Create a simple transaction
		tx := types.NewTx(&types.LegacyTx{
			Nonce:    0,
			GasPrice: big.NewInt(1000000000),
			Gas:      21000,
			To:       &common.Address{},
			Value:    big.NewInt(1),
			Data:     nil,
		})

		// Call SendTransaction
		_, _, err := rpc.SendTransaction(ctx, tx)

		// Verify it returns the expected error for Tron
		require.Error(t, err)
		assert.Equal(t, "SendTransaction not implemented for Tron, this should never be called", err.Error())
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewTx(&types.LegacyTx{
			Nonce:    0,
			GasPrice: big.NewInt(1000000000),
			Gas:      21000,
			To:       &common.Address{},
			Value:    big.NewInt(1),
			Data:     nil,
		})`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(1000000000)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(1)`
$DIR/pkg/client/rpc_client_test.go: `.SendTransaction(ctx, tx)`
$DIR/pkg/client/rpc_client_test.go: `.Run("NonceAt", func(t *testing.T) {
		// Call NonceAt with a test address
		_, err := rpc.NonceAt(ctx, testAddr, nil)

		// Verify it returns an error
		require.Error(t, err, "tron does not support eth_getTransactionCount")
	})`
$DIR/pkg/client/rpc_client_test.go: `.NonceAt(ctx, testAddr, nil)`
$DIR/pkg/client/rpc_client_test.go: `.PendingSequenceAt(ctx, testAddr)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(123456)`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
		switch method {
		case "chain_getFinalizedHead":
			resp.Result = `"0xf14c499253fd7bbcba142e5dd77dad8b5ad598c1dc414a66bacdd8dae14a6759"`
		case "chain_getHeader":
			if assert.True(t, params.IsArray()) && assert.Equal(t, "0xf14c499253fd7bbcba142e5dd77dad8b5ad598c1dc414a66bacdd8dae14a6759", params.Array()[0].String()) {
				resp.Result = `{"parentHash":"0x1311773bc6b4efc8f438ed1f094524b2a1233baf8a35396f641fcc42a378fc62","number":"0x4","stateRoot":"0x0e4920dc5516b587e1f74a0b65963134523a12cc11478bb314e52895758fbfa2","extrinsicsRoot":"0x5b02446dcab0659eb07d4a38f28f181c1b78a71b2aba207bb0ea1f0f3468e6bd","digest":{"logs":["0x066175726120ad678e0800000000","0x04525053529023158dc8e8fd0180bf26d88233a3d94eed2f4e43480395f0809f28791965e4d34e9b3905","0x0466726f6e88017441e97acf83f555e0deefef86db636bc8a37eb84747603412884e4df4d2280400","0x056175726101018a0a57edf70cc5474323114a47ee1e7f645b8beea5a1560a996416458e89f42bdf4955e24d32b5da54e1bf628aaa7ce4b8c0fa2b95c175a139d88786af12a88c"]}}`
			}
		case "eth_getBlockByNumber":
			assert.True(t, params.IsArray())
			switch params.Array()[0].String() {
			case "0x4":
				resp.Result = `{"author":"0x5accb3bf9194a5f81b2087d4bd6ac47c62775d49","baseFeePerGas":"0xb576270823","difficulty":"0x0","extraData":"0x","gasLimit":"0xe4e1c0","gasUsed":"0x0","hash":"0x7441e97acf83f555e0deefef86db636bc8a37eb84747603412884e4df4d22804","logsBloom":"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","miner":"0x5accb3bf9194a5f81b2087d4bd6ac47c62775d49","nonce":"0x0000000000000000","number":"0x4","parentHash":"0x6ba069c318b692bf2cc0bd7ea070a9382a20c2f52413c10554b57c2e381bf2bb","receiptsRoot":"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421","sha3Uncles":"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347","size":"0x201","stateRoot":"0x17c46d359b9af773312c747f1d20032c67658d9a2923799f00533b73789cf49b","timestamp":"0x66acdc22","totalDifficulty":"0x0","transactions":[],"transactionsRoot":"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421","uncles":[]}`
			case "finalized":
				resp.Result = `{"author":"0x1687736326c9fea17e25fc5287613693c912909c","baseFeePerGas":"0x3b9aca00","difficulty":"0x0","extraData":"0x","gasLimit":"0xe4e1c0","gasUsed":"0x0","hash":"0x62f03413681948b06882e7d9f91c4949bc39ded98d36336ab03faea038ec8e3d","logsBloom":"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","miner":"0x1687736326c9fea17e25fc5287613693c912909c","nonce":"0x0000000000000000","number":"0x8","parentHash":"0x43f504afdc639cbb8daf5fd5328a37762164b73f9c70ed54e1928c1fca6d8f23","receiptsRoot":"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421","sha3Uncles":"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347","size":"0x200","stateRoot":"0x0cb938d51ad83bdf401e3f5f7f989e60df64fdea620d394af41a3e72629f7495","timestamp":"0x61bd8d1a","totalDifficulty":"0x0","transactions":[],"transactionsRoot":"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421","uncles":[]}`
			default:
				assert.Fail(t, fmt.Sprintf("unexpected eth_getBlockByNumber param: %v", params.Array()))
			}
		default:
			assert.Fail(t, "unexpected method: "+method)
		}
		return
	})`
$DIR/pkg/client/rpc_client_test.go: `.Array()`
$DIR/pkg/client/rpc_client_test.go: `.String()`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL, ChainType: chaintype.ChainAstar})`
$DIR/pkg/client/rpc_client_test.go: `.Dial(tests.Context(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.LatestFinalizedBlock(ctx)`
$DIR/pkg/client/rpc_client_test.go: `.FinalizedBlockNumber.String()`
$DIR/pkg/client/rpc_client_test.go: `.BatchCallContext(ctx, []rpc.BatchElem{
					req,
				})`
$DIR/pkg/client/rpc_client_test.go: `.BatchCallContext(ctx, []rpc.BatchElem{req})`
$DIR/pkg/client/rpc_client_test.go: `.Run(testCase.Name, func(t *testing.T) {
			lf, err := testCase.GetLatestFinalized(tests.Context(t))
			require.NoError(t, err)
			require.NotNil(t, lf)
			assert.Equal(t, expectedFinalizedBlockHash, lf.Hash.String())
			assert.Equal(t, expectedFinalizedBlockNumber, lf.Number)
		})`
$DIR/pkg/client/rpc_client_test.go: `.GetLatestFinalized(tests.Context(t))`
$DIR/pkg/client/rpc_client_test.go: `.Context(t)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(1234567)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(10)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(20)`
$DIR/pkg/client/rpc_client_test.go: `.BigToAddress(big.NewInt(42))`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(42)`
$DIR/pkg/client/rpc_client_test.go: `.BigToHash(big.NewInt(128))`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(128)`
$DIR/pkg/client/rpc_client_test.go: `.CallContract(t.Context(), ethereum.CallMsg{Gas: 123}, big.NewInt(10))`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(10)`
$DIR/pkg/client/rpc_client_test.go: `.CallContractWithOpts(t.Context(), ethereum.CallMsg{Gas: 123}, big.NewInt(10), evmtypes.CallContractOpts{ConfidenceLevel: primitives.Finalized})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(10)`
$DIR/pkg/client/rpc_client_test.go: `.BalanceAt(t.Context(), common.BigToAddress(big.NewInt(42)), big.NewInt(10))`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.BigToAddress(big.NewInt(42))`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(42)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(10)`
$DIR/pkg/client/rpc_client_test.go: `.BalanceAtWithOpts(t.Context(), common.BigToAddress(big.NewInt(42)), big.NewInt(10), evmtypes.BalanceAtOpts{ConfidenceLevel: primitives.Finalized})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.BigToAddress(big.NewInt(42))`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(42)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(10)`
$DIR/pkg/client/rpc_client_test.go: `.FilterLogs(t.Context(), filterQuery)`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.FilterLogsWithOpts(t.Context(), filterQuery, evmtypes.FilterLogsOpts{ConfidenceLevel: primitives.Finalized})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.BlockByNumber(t.Context(), big.NewInt(10))`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(10)`
$DIR/pkg/client/rpc_client_test.go: `.HeaderByNumberWithOpts(t.Context(), big.NewInt(10), evmtypes.HeaderByNumberOpts{ConfidenceLevel: primitives.Finalized})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(10)`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, chainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			if method == "eth_getBlockByNumber" && params.IsArray() &&
				params.Array()[0].String() == rpc.FinalizedBlockNumber.String() {
				resp.Error.Message = stubErr
				resp.Error.Code = -32000
				return
			}

			if expectedMethod == "" {
				require.NotEmpty(t, params.String())
				require.NotEmpty(t, method)
				expectedMethod = method
				expectedParams = params.String()
			} else {
				require.Equal(t, expectedMethod, method)
				require.Equal(t, expectedParams, params.String())
			}
			resp.Error.Message = stubErr
			resp.Error.Code = -32000
			return
		})`
$DIR/pkg/client/rpc_client_test.go: `.IsArray()`
$DIR/pkg/client/rpc_client_test.go: `.Array()`
$DIR/pkg/client/rpc_client_test.go: `.String()`
$DIR/pkg/client/rpc_client_test.go: `.FinalizedBlockNumber.String()`
$DIR/pkg/client/rpc_client_test.go: `.String()`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewTestRPCClient(t, client.RPCClientOpts{WS: wsURL, FinalityTagsEnabled: true})`
$DIR/pkg/client/rpc_client_test.go: `.Cleanup(rpcClient.Close)`
$DIR/pkg/client/rpc_client_test.go: `.Dial(t.Context())`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.Run(tc.Name, func(t *testing.T) {
			rpcClient := newRPCClient(t)
			err := tc.OriginalCall(t, rpcClient)
			require.ErrorContains(t, err, stubErr)
			err = tc.WithOptsCall(t, rpcClient)
			require.ErrorContains(t, err, stubErr)
		})`
$DIR/pkg/client/rpc_client_test.go: `.OriginalCall(t, rpcClient)`
$DIR/pkg/client/rpc_client_test.go: `.WithOptsCall(t, rpcClient)`
$DIR/pkg/client/rpc_client_test.go: `.Run("Happy path", func(t *testing.T) {
		const expectedResult = "call contract happy path result"
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_call":
				resp.Result = fmt.Sprintf(`"%s"`, "0x"+hex.EncodeToString([]byte(expectedResult)))
			case "eth_getBlockByNumber":
				require.True(t, params.IsArray())
				require.Equal(t, "finalized", params.Array()[0].String())
				resp.Result = client.MakeHeadMsgForNumber(10)
			default:
				require.Fail(t, "unexpected method: "+method)
			}
			return
		}).WSURL()
		rpcClient := client.NewDialedTestRPCClient(t, client.RPCClientOpts{WS: wsURL, FinalityTagsEnabled: true})
		result, err := rpcClient.CallContractWithOpts(t.Context(), ethereum.CallMsg{}, big.NewInt(9), evmtypes.CallContractOpts{ConfidenceLevel: primitives.Finalized})
		require.NoError(t, err)
		require.Equal(t, expectedResult, string(result))
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_call":
				resp.Result = fmt.Sprintf(`"%s"`, "0x"+hex.EncodeToString([]byte(expectedResult)))
			case "eth_getBlockByNumber":
				require.True(t, params.IsArray())
				require.Equal(t, "finalized", params.Array()[0].String())
				resp.Result = client.MakeHeadMsgForNumber(10)
			default:
				require.Fail(t, "unexpected method: "+method)
			}
			return
		})`
$DIR/pkg/client/rpc_client_test.go: `.Sprintf(`"%s"`, "0x"+hex.EncodeToString([]byte(expectedResult)))`
$DIR/pkg/client/rpc_client_test.go: `.EncodeToString([]byte(expectedResult))`
$DIR/pkg/client/rpc_client_test.go: `.MakeHeadMsgForNumber(10)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewDialedTestRPCClient(t, client.RPCClientOpts{WS: wsURL, FinalityTagsEnabled: true})`
$DIR/pkg/client/rpc_client_test.go: `.CallContractWithOpts(t.Context(), ethereum.CallMsg{}, big.NewInt(9), evmtypes.CallContractOpts{ConfidenceLevel: primitives.Finalized})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(9)`
$DIR/pkg/client/rpc_client_test.go: `.NewHTTPServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_call":
				// Simulate a large response that exceeds the limit
				resp.Result = fmt.Sprintf(`"%s"`, "0x"+hex.EncodeToString(make([]byte, responseLimit+1))) // 10 MB
			default:
				require.Fail(t, "unexpected method: "+method)
			}
			return
		})`
$DIR/pkg/client/rpc_client_test.go: `.Sprintf(`"%s"`, "0x"+hex.EncodeToString(make([]byte, responseLimit+1)))`
$DIR/pkg/client/rpc_client_test.go: `.EncodeToString(make([]byte, responseLimit+1))`
$DIR/pkg/client/rpc_client_test.go: `.URL()`
$DIR/pkg/client/rpc_client_test.go: `.NewDialedTestRPCClient(t, client.RPCClientOpts{HTTP: httpURL, ExternalRequestMaxResponseSize: responseLimit})`
$DIR/pkg/client/rpc_client_test.go: `.CallContractWithOpts(t.Context(), ethereum.CallMsg{}, big.NewInt(9), evmtypes.CallContractOpts{IsExternalRequest: false})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(9)`
$DIR/pkg/client/rpc_client_test.go: `.CallContractWithOpts(t.Context(), ethereum.CallMsg{}, big.NewInt(9), evmtypes.CallContractOpts{IsExternalRequest: true})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(9)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(1234)`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_getBalance":
				resp.Result = fmt.Sprintf(`"%s"`, hexutil.EncodeBig(expectedResult))
			case "eth_getBlockByNumber":
				require.True(t, params.IsArray())
				require.Equal(t, "finalized", params.Array()[0].String())
				resp.Result = client.MakeHeadMsgForNumber(10)
			default:
				require.Fail(t, "unexpected method: "+method)
			}
			return
		})`
$DIR/pkg/client/rpc_client_test.go: `.Sprintf(`"%s"`, hexutil.EncodeBig(expectedResult))`
$DIR/pkg/client/rpc_client_test.go: `.EncodeBig(expectedResult)`
$DIR/pkg/client/rpc_client_test.go: `.MakeHeadMsgForNumber(10)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewDialedTestRPCClient(t, client.RPCClientOpts{WS: wsURL, FinalityTagsEnabled: true})`
$DIR/pkg/client/rpc_client_test.go: `.BalanceAtWithOpts(t.Context(), common.BigToAddress(big.NewInt(42)), big.NewInt(9), evmtypes.BalanceAtOpts{ConfidenceLevel: primitives.Finalized})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.BigToAddress(big.NewInt(42))`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(42)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(9)`
$DIR/pkg/client/rpc_client_test.go: `.BigToHash(big.NewInt(10))`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(10)`
$DIR/pkg/client/rpc_client_test.go: `.BigToAddress(big.NewInt(42))`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(42)`
$DIR/pkg/client/rpc_client_test.go: `.BigToAddress(big.NewInt(43))`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(43)`
$DIR/pkg/client/rpc_client_test.go: `.Run("Happy path", func(t *testing.T) {

		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_getLogs":
				logsAsJSON, err := json.Marshal(validLogs)
				require.NoError(t, err)
				resp.Result = string(logsAsJSON)
			case "eth_getBlockByNumber":
				require.True(t, params.IsArray())
				require.Equal(t, "finalized", params.Array()[0].String())
				resp.Result = client.MakeHeadMsgForNumber(10)
			default:
				require.Fail(t, "unexpected method: "+method)
			}
			return
		}).WSURL()
		rpcClient := client.NewDialedTestRPCClient(t, client.RPCClientOpts{WS: wsURL, FinalityTagsEnabled: true})
		filter := ethereum.FilterQuery{FromBlock: big.NewInt(0), ToBlock: big.NewInt(10), Topics: [][]common.Hash{topics}}
		result, err := rpcClient.FilterLogsWithOpts(t.Context(), filter, evmtypes.FilterLogsOpts{ConfidenceLevel: primitives.Finalized})
		require.NoError(t, err)
		require.Equal(t, validLogs, result)
	})`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_getLogs":
				logsAsJSON, err := json.Marshal(validLogs)
				require.NoError(t, err)
				resp.Result = string(logsAsJSON)
			case "eth_getBlockByNumber":
				require.True(t, params.IsArray())
				require.Equal(t, "finalized", params.Array()[0].String())
				resp.Result = client.MakeHeadMsgForNumber(10)
			default:
				require.Fail(t, "unexpected method: "+method)
			}
			return
		})`
$DIR/pkg/client/rpc_client_test.go: `.Marshal(validLogs)`
$DIR/pkg/client/rpc_client_test.go: `.MakeHeadMsgForNumber(10)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewDialedTestRPCClient(t, client.RPCClientOpts{WS: wsURL, FinalityTagsEnabled: true})`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(0)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(10)`
$DIR/pkg/client/rpc_client_test.go: `.FilterLogsWithOpts(t.Context(), filter, evmtypes.FilterLogsOpts{ConfidenceLevel: primitives.Finalized})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.Marshal(validLogs)`
$DIR/pkg/client/rpc_client_test.go: `.NewHTTPServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_getLogs":
				resp.Result = string(logsAsJSON)
			default:
				require.Fail(t, "unexpected method: "+method)
			}
			return
		})`
$DIR/pkg/client/rpc_client_test.go: `.URL()`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(0)`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(10)`
$DIR/pkg/client/rpc_client_test.go: `.NewDialedTestRPCClient(t, client.RPCClientOpts{HTTP: httpURL, ExternalRequestMaxResponseSize: responseSize - 1})`
$DIR/pkg/client/rpc_client_test.go: `.FilterLogsWithOpts(t.Context(), filter, evmtypes.FilterLogsOpts{IsExternalRequest: false})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.FilterLogsWithOpts(t.Context(), filter, evmtypes.FilterLogsOpts{IsExternalRequest: true})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.Unix(1000, 0)`
$DIR/pkg/client/rpc_client_test.go: `.UTC()`
$DIR/pkg/client/rpc_client_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			require.Equal(t, "eth_getBlockByNumber", method)
			require.True(t, params.IsArray())
			if params.Array()[0].String() == "finalized" {
				resp.Result = client.MakeHeadMsgForNumber(10)
				return
			}
			asJSON, err := json.Marshal(head)
			require.NoError(t, err)
			resp.Result = string(asJSON)
			return
		})`
$DIR/pkg/client/rpc_client_test.go: `.Array()`
$DIR/pkg/client/rpc_client_test.go: `.String()`
$DIR/pkg/client/rpc_client_test.go: `.MakeHeadMsgForNumber(10)`
$DIR/pkg/client/rpc_client_test.go: `.Marshal(head)`
$DIR/pkg/client/rpc_client_test.go: `.WSURL()`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(1234567)`
$DIR/pkg/client/rpc_client_test.go: `.NewDialedTestRPCClient(t, client.RPCClientOpts{WS: wsURL, FinalityTagsEnabled: true, ChainID: chainID})`
$DIR/pkg/client/rpc_client_test.go: `.HeaderByNumberWithOpts(t.Context(), big.NewInt(10), evmtypes.HeaderByNumberOpts{ConfidenceLevel: primitives.Finalized})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.NewInt(10)`
$DIR/pkg/client/rpc_client_test.go: `.New(chainID)`
$DIR/pkg/client/rpc_client_test.go: `.Marshal(&types.Receipt{
			Logs: []*types.Log{},
		})`
$DIR/pkg/client/rpc_client_test.go: `.NewHTTPServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_getTransactionReceipt":
				resp.Result = string(receiptsAsJSON)
			default:
				require.Fail(t, "unexpected method: "+method)
			}
			return
		})`
$DIR/pkg/client/rpc_client_test.go: `.URL()`
$DIR/pkg/client/rpc_client_test.go: `.NewDialedTestRPCClient(t, client.RPCClientOpts{HTTP: httpURL, ExternalRequestMaxResponseSize: responseSize - 1})`
$DIR/pkg/client/rpc_client_test.go: `.TransactionReceiptGethWithOpts(t.Context(), common.Hash{}, evmtypes.TransactionReceiptOpts{IsExternalRequest: false})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.TransactionReceiptGethWithOpts(t.Context(), common.Hash{}, evmtypes.TransactionReceiptOpts{IsExternalRequest: true})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.NewTx(&types.DynamicFeeTx{})`
$DIR/pkg/client/rpc_client_test.go: `.Marshal(tx)`
$DIR/pkg/client/rpc_client_test.go: `.NewHTTPServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_getTransactionByHash":
				resp.Result = string(txAsJSON)
			default:
				require.Fail(t, "unexpected method: "+method)
			}
			return
		})`
$DIR/pkg/client/rpc_client_test.go: `.URL()`
$DIR/pkg/client/rpc_client_test.go: `.NewDialedTestRPCClient(t, client.RPCClientOpts{HTTP: httpURL, ExternalRequestMaxResponseSize: responseSize - 1})`
$DIR/pkg/client/rpc_client_test.go: `.TransactionByHashWithOpts(t.Context(), common.Hash{}, evmtypes.TransactionByHashOpts{IsExternalRequest: false})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/rpc_client_test.go: `.TransactionByHashWithOpts(t.Context(), common.Hash{}, evmtypes.TransactionByHashOpts{IsExternalRequest: true})`
$DIR/pkg/client/rpc_client_test.go: `.Context()`
$DIR/pkg/client/sub_forwarder_test.go: `head.EVMChainID = ubig.New(chainID)`
$DIR/pkg/client/sub_forwarder_test.go: `t.Run("unsubscribe forwarder", func(t *testing.T) {
		t.Parallel()

		ch := make(chan *evmtypes.Head)
		forwarder := newChainIDSubForwarder(chainID, ch)
		sub := NewMockSubscription()
		err := forwarder.start(sub, nil)
		assert.NoError(t, err)
		forwarder.Unsubscribe()

		assert.True(t, sub.unsubscribed)
		_, ok := <-sub.Err()
		assert.False(t, ok)
		_, ok = <-forwarder.Err()
		assert.False(t, ok)
	})`
$DIR/pkg/client/sub_forwarder_test.go: `forwarder.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `_, ok = <-forwarder.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `t.Run("unsubscribe forwarder with error", func(t *testing.T) {
		t.Parallel()

		ch := make(chan *evmtypes.Head)
		forwarder := newChainIDSubForwarder(chainID, ch)
		sub := NewMockSubscription()
		err := forwarder.start(sub, nil)
		assert.NoError(t, err)
		expectedError := errors.New("boo")
		sub.Errors <- expectedError
		forwarder.Unsubscribe()

		assert.True(t, sub.unsubscribed)
		err, ok := <-forwarder.Err()
		assert.True(t, ok)
		require.ErrorIs(t, err, expectedError)
		_, ok = <-forwarder.Err()
		assert.False(t, ok)
	})`
$DIR/pkg/client/sub_forwarder_test.go: `sub.Errors <- expectedError`
$DIR/pkg/client/sub_forwarder_test.go: `forwarder.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `_, ok = <-forwarder.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `t.Run("unsubscribe forwarder with message", func(t *testing.T) {
		t.Parallel()

		ch := make(chan *evmtypes.Head)
		forwarder := newChainIDSubForwarder(chainID, ch)
		sub := NewMockSubscription()
		err := forwarder.start(sub, nil)
		assert.NoError(t, err)
		forwarder.srcCh <- &evmtypes.Head{}
		forwarder.Unsubscribe()

		assert.True(t, sub.unsubscribed)
		_, ok := <-sub.Err()
		assert.False(t, ok)
		_, ok = <-forwarder.Err()
		assert.False(t, ok)
	})`
$DIR/pkg/client/sub_forwarder_test.go: `forwarder.srcCh <- &evmtypes.Head{}`
$DIR/pkg/client/sub_forwarder_test.go: `forwarder.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `_, ok = <-forwarder.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `t.Run("non nil error parameter", func(t *testing.T) {
		t.Parallel()

		ch := make(chan *evmtypes.Head)
		forwarder := newChainIDSubForwarder(chainID, ch)
		sub := NewMockSubscription()
		errIn := errors.New("foo")
		errOut := forwarder.start(sub, errIn)
		assert.Equal(t, errIn, errOut)
	})`
$DIR/pkg/client/sub_forwarder_test.go: `forwarder.srcCh <- head`
$DIR/pkg/client/sub_forwarder_test.go: `sub.Errors <- expectedErr`
$DIR/pkg/client/sub_forwarder_test.go: `forwarder.srcCh <- head`
$DIR/pkg/client/sub_forwarder_test.go: `t.Run("Unsubscribe wrapper releases resources", func(t *testing.T) {
		t.Parallel()

		mockedSub := NewMockSubscription()
		const prefix = "RPC returned error"
		wrapper := newSubscriptionErrorWrapper(t, mockedSub, prefix)
		wrapper.Unsubscribe()

		// mock's resources were released
		assert.True(t, mockedSub.unsubscribed)
		_, ok := <-mockedSub.Err()
		assert.False(t, ok)
		// wrapper's channels are closed
		_, ok = <-wrapper.Err()
		assert.False(t, ok)
		//  subsequence unsubscribe does not causes panic
		wrapper.Unsubscribe()
	})`
$DIR/pkg/client/sub_forwarder_test.go: `wrapper.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `_, ok = <-wrapper.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `wrapper.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `t.Run("Successfully wraps error", func(t *testing.T) {
		t.Parallel()
		sub := NewMockSubscription()
		const prefix = "RPC returned error"
		wrapper := newSubscriptionErrorWrapper(t, sub, prefix)
		sub.Errors <- errors.New("root error")

		err, ok := <-wrapper.Err()
		assert.True(t, ok)
		assert.Equal(t, "RPC returned error: root error", err.Error())

		wrapper.Unsubscribe()
		_, ok = <-wrapper.Err()
		assert.False(t, ok)
	})`
$DIR/pkg/client/sub_forwarder_test.go: `sub.Errors <- errors.New("root error")`
$DIR/pkg/client/sub_forwarder_test.go: `wrapper.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `_, ok = <-wrapper.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `mockedSub.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `tests.AssertEventually(t, func() bool {
			_, ok = <-wrapper.Err()
			return !ok
		})`
$DIR/pkg/client/sub_forwarder_test.go: `_, ok = <-wrapper.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.New(chainID)`
$DIR/pkg/client/sub_forwarder_test.go: `.NewInt(123)`
$DIR/pkg/client/sub_forwarder_test.go: `.Run("unsubscribe forwarder", func(t *testing.T) {
		t.Parallel()

		ch := make(chan *evmtypes.Head)
		forwarder := newChainIDSubForwarder(chainID, ch)
		sub := NewMockSubscription()
		err := forwarder.start(sub, nil)
		assert.NoError(t, err)
		forwarder.Unsubscribe()

		assert.True(t, sub.unsubscribed)
		_, ok := <-sub.Err()
		assert.False(t, ok)
		_, ok = <-forwarder.Err()
		assert.False(t, ok)
	})`
$DIR/pkg/client/sub_forwarder_test.go: `.start(sub, nil)`
$DIR/pkg/client/sub_forwarder_test.go: `.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.Run("unsubscribe forwarder with error", func(t *testing.T) {
		t.Parallel()

		ch := make(chan *evmtypes.Head)
		forwarder := newChainIDSubForwarder(chainID, ch)
		sub := NewMockSubscription()
		err := forwarder.start(sub, nil)
		assert.NoError(t, err)
		expectedError := errors.New("boo")
		sub.Errors <- expectedError
		forwarder.Unsubscribe()

		assert.True(t, sub.unsubscribed)
		err, ok := <-forwarder.Err()
		assert.True(t, ok)
		require.ErrorIs(t, err, expectedError)
		_, ok = <-forwarder.Err()
		assert.False(t, ok)
	})`
$DIR/pkg/client/sub_forwarder_test.go: `.start(sub, nil)`
$DIR/pkg/client/sub_forwarder_test.go: `.New("boo")`
$DIR/pkg/client/sub_forwarder_test.go: `.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.Run("unsubscribe forwarder with message", func(t *testing.T) {
		t.Parallel()

		ch := make(chan *evmtypes.Head)
		forwarder := newChainIDSubForwarder(chainID, ch)
		sub := NewMockSubscription()
		err := forwarder.start(sub, nil)
		assert.NoError(t, err)
		forwarder.srcCh <- &evmtypes.Head{}
		forwarder.Unsubscribe()

		assert.True(t, sub.unsubscribed)
		_, ok := <-sub.Err()
		assert.False(t, ok)
		_, ok = <-forwarder.Err()
		assert.False(t, ok)
	})`
$DIR/pkg/client/sub_forwarder_test.go: `.start(sub, nil)`
$DIR/pkg/client/sub_forwarder_test.go: `.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.Run("non nil error parameter", func(t *testing.T) {
		t.Parallel()

		ch := make(chan *evmtypes.Head)
		forwarder := newChainIDSubForwarder(chainID, ch)
		sub := NewMockSubscription()
		errIn := errors.New("foo")
		errOut := forwarder.start(sub, errIn)
		assert.Equal(t, errIn, errOut)
	})`
$DIR/pkg/client/sub_forwarder_test.go: `.New("foo")`
$DIR/pkg/client/sub_forwarder_test.go: `.start(sub, errIn)`
$DIR/pkg/client/sub_forwarder_test.go: `.start(sub, nil)`
$DIR/pkg/client/sub_forwarder_test.go: `.New("error")`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.New("something went wrong during result interception")`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.Run("Unsubscribe wrapper releases resources", func(t *testing.T) {
		t.Parallel()

		mockedSub := NewMockSubscription()
		const prefix = "RPC returned error"
		wrapper := newSubscriptionErrorWrapper(t, mockedSub, prefix)
		wrapper.Unsubscribe()

		// mock's resources were released
		assert.True(t, mockedSub.unsubscribed)
		_, ok := <-mockedSub.Err()
		assert.False(t, ok)
		// wrapper's channels are closed
		_, ok = <-wrapper.Err()
		assert.False(t, ok)
		//  subsequence unsubscribe does not causes panic
		wrapper.Unsubscribe()
	})`
$DIR/pkg/client/sub_forwarder_test.go: `.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `.Run("Successfully wraps error", func(t *testing.T) {
		t.Parallel()
		sub := NewMockSubscription()
		const prefix = "RPC returned error"
		wrapper := newSubscriptionErrorWrapper(t, sub, prefix)
		sub.Errors <- errors.New("root error")

		err, ok := <-wrapper.Err()
		assert.True(t, ok)
		assert.Equal(t, "RPC returned error: root error", err.Error())

		wrapper.Unsubscribe()
		_, ok = <-wrapper.Err()
		assert.False(t, ok)
	})`
$DIR/pkg/client/sub_forwarder_test.go: `.New("root error")`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.Unsubscribe()`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/sub_forwarder_test.go: `.AssertEventually(t, func() bool {
			_, ok = <-wrapper.Err()
			return !ok
		})`
$DIR/pkg/client/sub_forwarder_test.go: `.Err()`
$DIR/pkg/client/tx_simulator_test.go: `t.Run("returns without error if simulation passes", func(t *testing.T) {
		ctx := tests.Context(t)
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_estimateGas":
				resp.Result = `"0x100"`
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		msg := ethereum.CallMsg{
			From: fromAddress,
			To:   &toAddress,
			Data: []byte("0x00"),
		}
		sendErr := client.SimulateTransaction(ctx, ethClient, logger.TestSugared(t), "", msg)
		require.Empty(t, sendErr)
	})`
$DIR/pkg/client/tx_simulator_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/tx_simulator_test.go: `resp.Notify = headResult`
$DIR/pkg/client/tx_simulator_test.go: `resp.Result = "true"`
$DIR/pkg/client/tx_simulator_test.go: `resp.Result = `"0x100"``
$DIR/pkg/client/tx_simulator_test.go: `t.Run("returns error if simulation returns zk out-of-counters error", func(t *testing.T) {
		ctx := tests.Context(t)
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_estimateGas":
				resp.Error.Code = -32000
				resp.Result = `"0x100"`
				resp.Error.Message = "not enough keccak counters to continue the execution"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		msg := ethereum.CallMsg{
			From: fromAddress,
			To:   &toAddress,
			Data: []byte("0x00"),
		}
		sendErr := client.SimulateTransaction(ctx, ethClient, logger.TestSugared(t), "", msg)
		require.True(t, sendErr.IsTerminallyStuckConfigError(nil))
	})`
$DIR/pkg/client/tx_simulator_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/tx_simulator_test.go: `resp.Notify = headResult`
$DIR/pkg/client/tx_simulator_test.go: `resp.Result = "true"`
$DIR/pkg/client/tx_simulator_test.go: `resp.Error.Code = -32000`
$DIR/pkg/client/tx_simulator_test.go: `resp.Result = `"0x100"``
$DIR/pkg/client/tx_simulator_test.go: `resp.Error.Message = "not enough keccak counters to continue the execution"`
$DIR/pkg/client/tx_simulator_test.go: `resp.Result = `"0x00"``
$DIR/pkg/client/tx_simulator_test.go: `resp.Notify = headResult`
$DIR/pkg/client/tx_simulator_test.go: `resp.Result = "true"`
$DIR/pkg/client/tx_simulator_test.go: `resp.Error.Code = -32000`
$DIR/pkg/client/tx_simulator_test.go: `resp.Error.Message = "something went wrong"`
$DIR/pkg/client/tx_simulator_test.go: `.NewAddress()`
$DIR/pkg/client/tx_simulator_test.go: `.NewAddress()`
$DIR/pkg/client/tx_simulator_test.go: `.Run("returns without error if simulation passes", func(t *testing.T) {
		ctx := tests.Context(t)
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_estimateGas":
				resp.Result = `"0x100"`
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		msg := ethereum.CallMsg{
			From: fromAddress,
			To:   &toAddress,
			Data: []byte("0x00"),
		}
		sendErr := client.SimulateTransaction(ctx, ethClient, logger.TestSugared(t), "", msg)
		require.Empty(t, sendErr)
	})`
$DIR/pkg/client/tx_simulator_test.go: `.Context(t)`
$DIR/pkg/client/tx_simulator_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_estimateGas":
				resp.Result = `"0x100"`
			}
			return
		})`
$DIR/pkg/client/tx_simulator_test.go: `.WSURL()`
$DIR/pkg/client/tx_simulator_test.go: `.String()`
$DIR/pkg/client/tx_simulator_test.go: `.SimulateTransaction(ctx, ethClient, logger.TestSugared(t), "", msg)`
$DIR/pkg/client/tx_simulator_test.go: `.TestSugared(t)`
$DIR/pkg/client/tx_simulator_test.go: `.Run("returns error if simulation returns zk out-of-counters error", func(t *testing.T) {
		ctx := tests.Context(t)
		wsURL := testutils.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_estimateGas":
				resp.Error.Code = -32000
				resp.Result = `"0x100"`
				resp.Error.Message = "not enough keccak counters to continue the execution"
			}
			return
		}).WSURL().String()

		ethClient := mustNewChainClient(t, wsURL)

		msg := ethereum.CallMsg{
			From: fromAddress,
			To:   &toAddress,
			Data: []byte("0x00"),
		}
		sendErr := client.SimulateTransaction(ctx, ethClient, logger.TestSugared(t), "", msg)
		require.True(t, sendErr.IsTerminallyStuckConfigError(nil))
	})`
$DIR/pkg/client/tx_simulator_test.go: `.Context(t)`
$DIR/pkg/client/tx_simulator_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_estimateGas":
				resp.Error.Code = -32000
				resp.Result = `"0x100"`
				resp.Error.Message = "not enough keccak counters to continue the execution"
			}
			return
		})`
$DIR/pkg/client/tx_simulator_test.go: `.WSURL()`
$DIR/pkg/client/tx_simulator_test.go: `.String()`
$DIR/pkg/client/tx_simulator_test.go: `.SimulateTransaction(ctx, ethClient, logger.TestSugared(t), "", msg)`
$DIR/pkg/client/tx_simulator_test.go: `.TestSugared(t)`
$DIR/pkg/client/tx_simulator_test.go: `.Context(t)`
$DIR/pkg/client/tx_simulator_test.go: `.NewWSServer(t, testutils.FixtureChainID, func(method string, params gjson.Result) (resp testutils.JSONRPCResponse) {
			switch method {
			case "eth_subscribe":
				resp.Result = `"0x00"`
				resp.Notify = headResult
				return
			case "eth_unsubscribe":
				resp.Result = "true"
				return
			case "eth_estimateGas":
				resp.Error.Code = -32000
				resp.Error.Message = "something went wrong"
			}
			return
		})`
$DIR/pkg/client/tx_simulator_test.go: `.WSURL()`
$DIR/pkg/client/tx_simulator_test.go: `.String()`
$DIR/pkg/client/tx_simulator_test.go: `.SimulateTransaction(ctx, ethClient, logger.TestSugared(t), "", msg)`
$DIR/pkg/client/tx_simulator_test.go: `.TestSugared(t)`
$DIR/pkg/config/chain_scoped_ocr2_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/config/chain_scoped_ocr2_test.go: `.EVM()`
$DIR/pkg/config/chain_scoped_ocr2_test.go: `.OCR2()`
$DIR/pkg/config/chain_scoped_ocr2_test.go: `.Automation()`
$DIR/pkg/config/chain_scoped_ocr2_test.go: `.GasLimit()`
$DIR/pkg/config/chain_scoped_ocr_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/config/chain_scoped_ocr_test.go: `.EVM()`
$DIR/pkg/config/chain_scoped_ocr_test.go: `.OCR()`
$DIR/pkg/config/chain_scoped_ocr_test.go: `.ObservationGracePeriod()`
$DIR/pkg/config/config_test.go: `c.GasEstimator.PriceMax = assets.NewWeiI(100000000000000)`
$DIR/pkg/config/config_test.go: `c.GasEstimator.PriceMax = assets.NewWeiI(100000000000000)`
$DIR/pkg/config/config_test.go: `c.GasEstimator.PriceDefault = assets.NewWeiI(42000000000)`
$DIR/pkg/config/config_test.go: `t.Run("EVM().GasEstimator().PriceDefault()", func(t *testing.T) {
		assert.Equal(t, assets.NewWeiI(20000000000), cfg.EVM().GasEstimator().PriceDefault())

		assert.Equal(t, assets.NewWeiI(42000000000), cfg2.EVM().GasEstimator().PriceDefault())
	})`
$DIR/pkg/config/config_test.go: `t.Run("EvmGasBumpTxDepthDefault", func(t *testing.T) {
		t.Run("uses MaxInFlightTransactions when not set", func(t *testing.T) {
			assert.Equal(t, cfg.EVM().Transactions().MaxInFlight(), cfg.EVM().GasEstimator().BumpTxDepth())
		})

		t.Run("uses customer configured value when set", func(t *testing.T) {
			var bumpTxDepth uint32 = 10
			cfg2 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.BumpTxDepth = &bumpTxDepth
			})
			assert.NotEqual(t, cfg2.EVM().Transactions().MaxInFlight(), cfg2.EVM().GasEstimator().BumpTxDepth())
			assert.Equal(t, bumpTxDepth, cfg2.EVM().GasEstimator().BumpTxDepth())
		})
	})`
$DIR/pkg/config/config_test.go: `t.Run("uses MaxInFlightTransactions when not set", func(t *testing.T) {
			assert.Equal(t, cfg.EVM().Transactions().MaxInFlight(), cfg.EVM().GasEstimator().BumpTxDepth())
		})`
$DIR/pkg/config/config_test.go: `t.Run("uses customer configured value when set", func(t *testing.T) {
			var bumpTxDepth uint32 = 10
			cfg2 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.BumpTxDepth = &bumpTxDepth
			})
			assert.NotEqual(t, cfg2.EVM().Transactions().MaxInFlight(), cfg2.EVM().GasEstimator().BumpTxDepth())
			assert.Equal(t, bumpTxDepth, cfg2.EVM().GasEstimator().BumpTxDepth())
		})`
$DIR/pkg/config/config_test.go: `c.GasEstimator.BumpTxDepth = &bumpTxDepth`
$DIR/pkg/config/config_test.go: `t.Run("PriceMaxKey", func(t *testing.T) {
		addr := utils.NewAddress()
		randomOtherAddr := utils.NewAddress()
		cfg2 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.KeySpecific = toml.KeySpecificConfig{
				{Key: ptr(types.EIP55AddressFromAddress(randomOtherAddr)),
					GasEstimator: toml.KeySpecificGasEstimator{
						PriceMax: assets.GWei(850),
					},
				},
			}
			c.GasEstimator.PriceMax = assets.NewWeiI(100000000000000)
			c.GasEstimator.PriceDefault = assets.NewWeiI(42000000000)
		})

		t.Run("uses chain-specific default value when nothing is set", func(t *testing.T) {
			assert.Equal(t, assets.NewWeiI(100000000000000), cfg2.EVM().GasEstimator().PriceMaxKey(addr))
		})

		t.Run("uses chain-specific override value when that is set", func(t *testing.T) {
			priceMax := assets.NewWeiI(rand.Int63())
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = priceMax
			})
			assert.Equal(t, priceMax.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})

		t.Run("uses key-specific override value when set", func(t *testing.T) {
			tests := []struct {
				name string
				val  *assets.Wei
			}{
				{"Test with 250 GWei", assets.GWei(250)},
				{"Test with 0 GWei", assets.GWei(0)},
			}

			for _, tt := range tests {
				t.Run(tt.name, func(t *testing.T) {
					cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
						c.KeySpecific = toml.KeySpecificConfig{
							{Key: ptr(types.EIP55AddressFromAddress(addr)),
								GasEstimator: toml.KeySpecificGasEstimator{
									PriceMax: tt.val,
								},
							},
						}
					})

					assert.Equal(t, tt.val.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
				})
			}
		})
		t.Run("uses key-specific override value when set and lower than chain specific config", func(t *testing.T) {
			keySpecificPrice := assets.GWei(900)
			chainSpecificPrice := assets.GWei(1200)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, keySpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})
		t.Run("uses chain-specific value when higher than key-specific value", func(t *testing.T) {
			keySpecificPrice := assets.GWei(1400)
			chainSpecificPrice := assets.GWei(1200)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, chainSpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})
		t.Run("uses key-specific override value when set and lower than global config", func(t *testing.T) {
			keySpecificPrice := assets.GWei(900)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, keySpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})
		t.Run("uses global value when higher than key-specific value", func(t *testing.T) {
			keySpecificPrice := assets.GWei(1400)
			chainSpecificPrice := assets.GWei(1200)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, chainSpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})
		t.Run("uses global value when there is no key-specific price", func(t *testing.T) {
			priceMax := assets.NewWeiI(rand.Int63())
			unsetAddr := utils.NewAddress()
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = priceMax
			})

			assert.Equal(t, priceMax.String(), cfg3.EVM().GasEstimator().PriceMaxKey(unsetAddr).String())
		})
	})`
$DIR/pkg/config/config_test.go: `c.KeySpecific = toml.KeySpecificConfig{
				{Key: ptr(types.EIP55AddressFromAddress(randomOtherAddr)),
					GasEstimator: toml.KeySpecificGasEstimator{
						PriceMax: assets.GWei(850),
					},
				},
			}`
$DIR/pkg/config/config_test.go: `c.GasEstimator.PriceMax = assets.NewWeiI(100000000000000)`
$DIR/pkg/config/config_test.go: `c.GasEstimator.PriceDefault = assets.NewWeiI(42000000000)`
$DIR/pkg/config/config_test.go: `t.Run("uses chain-specific default value when nothing is set", func(t *testing.T) {
			assert.Equal(t, assets.NewWeiI(100000000000000), cfg2.EVM().GasEstimator().PriceMaxKey(addr))
		})`
$DIR/pkg/config/config_test.go: `t.Run("uses chain-specific override value when that is set", func(t *testing.T) {
			priceMax := assets.NewWeiI(rand.Int63())
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = priceMax
			})
			assert.Equal(t, priceMax.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})`
$DIR/pkg/config/config_test.go: `c.GasEstimator.PriceMax = priceMax`
$DIR/pkg/config/config_test.go: `t.Run("uses key-specific override value when set", func(t *testing.T) {
			tests := []struct {
				name string
				val  *assets.Wei
			}{
				{"Test with 250 GWei", assets.GWei(250)},
				{"Test with 0 GWei", assets.GWei(0)},
			}

			for _, tt := range tests {
				t.Run(tt.name, func(t *testing.T) {
					cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
						c.KeySpecific = toml.KeySpecificConfig{
							{Key: ptr(types.EIP55AddressFromAddress(addr)),
								GasEstimator: toml.KeySpecificGasEstimator{
									PriceMax: tt.val,
								},
							},
						}
					})

					assert.Equal(t, tt.val.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
				})
			}
		})`
$DIR/pkg/config/config_test.go: `t.Run(tt.name, func(t *testing.T) {
					cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
						c.KeySpecific = toml.KeySpecificConfig{
							{Key: ptr(types.EIP55AddressFromAddress(addr)),
								GasEstimator: toml.KeySpecificGasEstimator{
									PriceMax: tt.val,
								},
							},
						}
					})

					assert.Equal(t, tt.val.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
				})`
$DIR/pkg/config/config_test.go: `c.KeySpecific = toml.KeySpecificConfig{
							{Key: ptr(types.EIP55AddressFromAddress(addr)),
								GasEstimator: toml.KeySpecificGasEstimator{
									PriceMax: tt.val,
								},
							},
						}`
$DIR/pkg/config/config_test.go: `t.Run("uses key-specific override value when set and lower than chain specific config", func(t *testing.T) {
			keySpecificPrice := assets.GWei(900)
			chainSpecificPrice := assets.GWei(1200)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, keySpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})`
$DIR/pkg/config/config_test.go: `c.GasEstimator.PriceMax = chainSpecificPrice`
$DIR/pkg/config/config_test.go: `c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}`
$DIR/pkg/config/config_test.go: `t.Run("uses chain-specific value when higher than key-specific value", func(t *testing.T) {
			keySpecificPrice := assets.GWei(1400)
			chainSpecificPrice := assets.GWei(1200)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, chainSpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})`
$DIR/pkg/config/config_test.go: `c.GasEstimator.PriceMax = chainSpecificPrice`
$DIR/pkg/config/config_test.go: `c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}`
$DIR/pkg/config/config_test.go: `t.Run("uses key-specific override value when set and lower than global config", func(t *testing.T) {
			keySpecificPrice := assets.GWei(900)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, keySpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})`
$DIR/pkg/config/config_test.go: `c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}`
$DIR/pkg/config/config_test.go: `t.Run("uses global value when higher than key-specific value", func(t *testing.T) {
			keySpecificPrice := assets.GWei(1400)
			chainSpecificPrice := assets.GWei(1200)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, chainSpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})`
$DIR/pkg/config/config_test.go: `c.GasEstimator.PriceMax = chainSpecificPrice`
$DIR/pkg/config/config_test.go: `c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}`
$DIR/pkg/config/config_test.go: `t.Run("uses global value when there is no key-specific price", func(t *testing.T) {
			priceMax := assets.NewWeiI(rand.Int63())
			unsetAddr := utils.NewAddress()
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = priceMax
			})

			assert.Equal(t, priceMax.String(), cfg3.EVM().GasEstimator().PriceMaxKey(unsetAddr).String())
		})`
$DIR/pkg/config/config_test.go: `c.GasEstimator.PriceMax = priceMax`
$DIR/pkg/config/config_test.go: `t.Run("LinkContractAddress", func(t *testing.T) {
		t.Run("uses chain-specific default value when nothing is set", func(t *testing.T) {
			assert.Equal(t, "", cfg.EVM().LinkContractAddress())
		})

		t.Run("uses chain-specific override value when that is set", func(t *testing.T) {
			addr := utils.NewAddress()

			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.LinkContractAddress = ptr(types.EIP55AddressFromAddress(addr))
			})

			assert.Equal(t, addr.String(), cfg3.EVM().LinkContractAddress())
		})
	})`
$DIR/pkg/config/config_test.go: `t.Run("uses chain-specific default value when nothing is set", func(t *testing.T) {
			assert.Equal(t, "", cfg.EVM().LinkContractAddress())
		})`
$DIR/pkg/config/config_test.go: `t.Run("uses chain-specific override value when that is set", func(t *testing.T) {
			addr := utils.NewAddress()

			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.LinkContractAddress = ptr(types.EIP55AddressFromAddress(addr))
			})

			assert.Equal(t, addr.String(), cfg3.EVM().LinkContractAddress())
		})`
$DIR/pkg/config/config_test.go: `c.LinkContractAddress = ptr(types.EIP55AddressFromAddress(addr))`
$DIR/pkg/config/config_test.go: `t.Run("OperatorFactoryAddress", func(t *testing.T) {
		t.Run("uses chain-specific default value when nothing is set", func(t *testing.T) {
			assert.Equal(t, "", cfg.EVM().OperatorFactoryAddress())
		})

		t.Run("uses chain-specific override value when that is set", func(t *testing.T) {
			val := utils.NewAddress()

			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.OperatorFactoryAddress = ptr(types.EIP55AddressFromAddress(val))
			})

			assert.Equal(t, val.String(), cfg3.EVM().OperatorFactoryAddress())
		})
	})`
$DIR/pkg/config/config_test.go: `t.Run("uses chain-specific default value when nothing is set", func(t *testing.T) {
			assert.Equal(t, "", cfg.EVM().OperatorFactoryAddress())
		})`
$DIR/pkg/config/config_test.go: `t.Run("uses chain-specific override value when that is set", func(t *testing.T) {
			val := utils.NewAddress()

			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.OperatorFactoryAddress = ptr(types.EIP55AddressFromAddress(val))
			})

			assert.Equal(t, val.String(), cfg3.EVM().OperatorFactoryAddress())
		})`
$DIR/pkg/config/config_test.go: `c.OperatorFactoryAddress = ptr(types.EIP55AddressFromAddress(val))`
$DIR/pkg/config/config_test.go: `t.Run("LogBroadcasterEnabled", func(t *testing.T) {
		t.Run("turn on LogBroadcasterEnabled by default", func(t *testing.T) {
			assert.True(t, cfg.EVM().LogBroadcasterEnabled())
		})

		t.Run("verify LogBroadcasterEnabled is set correctly", func(t *testing.T) {
			val := false
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.LogBroadcasterEnabled = ptr(val)
			})

			assert.False(t, cfg3.EVM().LogBroadcasterEnabled())
		})
	})`
$DIR/pkg/config/config_test.go: `t.Run("turn on LogBroadcasterEnabled by default", func(t *testing.T) {
			assert.True(t, cfg.EVM().LogBroadcasterEnabled())
		})`
$DIR/pkg/config/config_test.go: `t.Run("verify LogBroadcasterEnabled is set correctly", func(t *testing.T) {
			val := false
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.LogBroadcasterEnabled = ptr(val)
			})

			assert.False(t, cfg3.EVM().LogBroadcasterEnabled())
		})`
$DIR/pkg/config/config_test.go: `c.LogBroadcasterEnabled = ptr(val)`
$DIR/pkg/config/config_test.go: `t.Run("turn on EVM.Transactions.Enabled by default", func(t *testing.T) {
			assert.True(t, cfg.EVM().Transactions().Enabled())
		})`
$DIR/pkg/config/config_test.go: `t.Run("verify EVM.Transactions.Enabled is set correctly", func(t *testing.T) {
			val := false
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.Transactions.Enabled = ptr(val)
			})

			assert.False(t, cfg3.EVM().Transactions().Enabled())
		})`
$DIR/pkg/config/config_test.go: `c.Transactions.Enabled = ptr(val)`
$DIR/pkg/config/config_test.go: `c.GasEstimator.PriceMax = assets.GWei(500)`
$DIR/pkg/config/config_test.go: `c.ChainID = (*ubig.Big)(big.NewInt(56))`
$DIR/pkg/config/config_test.go: `timeout = cfg.EVM().OCR().ContractTransmitterTransmitTimeout()`
$DIR/pkg/config/config_test.go: `timeout = cfg.EVM().OCR().ObservationGracePeriod()`
$DIR/pkg/config/config_test.go: `t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			config := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.ChainID = ubig.NewI(tt.chainID)
			})

			assert.Equal(t, tt.expectedGasLimitDefault, config.EVM().GasEstimator().LimitDefault())
			assert.Nil(t, config.EVM().GasEstimator().LimitJobType().OCR())
			assert.Nil(t, config.EVM().GasEstimator().LimitJobType().DR())
			assert.Nil(t, config.EVM().GasEstimator().LimitJobType().VRF())
			assert.Nil(t, config.EVM().GasEstimator().LimitJobType().FM())
			assert.Nil(t, config.EVM().GasEstimator().LimitJobType().Keeper())
			assert.Equal(t, tt.expectedMinimumContractPayment, strings.TrimRight(config.EVM().MinContractPayment().Link(), "0"))
		})`
$DIR/pkg/config/config_test.go: `c.ChainID = ubig.NewI(tt.chainID)`
$DIR/pkg/config/config_test.go: `c.ChainID = id`
$DIR/pkg/config/config_test.go: `c.NodePool = toml.NodePool{
				Errors: toml.ClientErrors{
					NonceTooLow:                       ptr("client error nonce too low"),
					NonceTooHigh:                      ptr("client error nonce too high"),
					ReplacementTransactionUnderpriced: ptr("client error replacement underpriced"),
					LimitReached:                      ptr("client error limit reached"),
					TransactionAlreadyInMempool:       ptr("client error transaction already in mempool"),
					TerminallyUnderpriced:             ptr("client error terminally underpriced"),
					InsufficientEth:                   ptr("client error insufficient eth"),
					TxFeeExceedsCap:                   ptr("client error tx fee exceeds cap"),
					L2FeeTooLow:                       ptr("client error l2 fee too low"),
					L2FeeTooHigh:                      ptr("client error l2 fee too high"),
					L2Full:                            ptr("client error l2 full"),
					TransactionAlreadyMined:           ptr("client error transaction already mined"),
					Fatal:                             ptr("client error fatal"),
					ServiceUnavailable:                ptr("client error service unavailable"),
					TooManyResults:                    ptr("client error too many results"),
				},
			}`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.GasEstimator.PriceMax = assets.NewWeiI(100000000000000)
	})`
$DIR/pkg/config/config_test.go: `.NewWeiI(100000000000000)`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.GasEstimator.PriceMax = assets.NewWeiI(100000000000000)
		c.GasEstimator.PriceDefault = assets.NewWeiI(42000000000)
	})`
$DIR/pkg/config/config_test.go: `.NewWeiI(100000000000000)`
$DIR/pkg/config/config_test.go: `.NewWeiI(42000000000)`
$DIR/pkg/config/config_test.go: `.Run("EVM().GasEstimator().PriceDefault()", func(t *testing.T) {
		assert.Equal(t, assets.NewWeiI(20000000000), cfg.EVM().GasEstimator().PriceDefault())

		assert.Equal(t, assets.NewWeiI(42000000000), cfg2.EVM().GasEstimator().PriceDefault())
	})`
$DIR/pkg/config/config_test.go: `.Run("EvmGasBumpTxDepthDefault", func(t *testing.T) {
		t.Run("uses MaxInFlightTransactions when not set", func(t *testing.T) {
			assert.Equal(t, cfg.EVM().Transactions().MaxInFlight(), cfg.EVM().GasEstimator().BumpTxDepth())
		})

		t.Run("uses customer configured value when set", func(t *testing.T) {
			var bumpTxDepth uint32 = 10
			cfg2 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.BumpTxDepth = &bumpTxDepth
			})
			assert.NotEqual(t, cfg2.EVM().Transactions().MaxInFlight(), cfg2.EVM().GasEstimator().BumpTxDepth())
			assert.Equal(t, bumpTxDepth, cfg2.EVM().GasEstimator().BumpTxDepth())
		})
	})`
$DIR/pkg/config/config_test.go: `.Run("uses MaxInFlightTransactions when not set", func(t *testing.T) {
			assert.Equal(t, cfg.EVM().Transactions().MaxInFlight(), cfg.EVM().GasEstimator().BumpTxDepth())
		})`
$DIR/pkg/config/config_test.go: `.Run("uses customer configured value when set", func(t *testing.T) {
			var bumpTxDepth uint32 = 10
			cfg2 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.BumpTxDepth = &bumpTxDepth
			})
			assert.NotEqual(t, cfg2.EVM().Transactions().MaxInFlight(), cfg2.EVM().GasEstimator().BumpTxDepth())
			assert.Equal(t, bumpTxDepth, cfg2.EVM().GasEstimator().BumpTxDepth())
		})`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.BumpTxDepth = &bumpTxDepth
			})`
$DIR/pkg/config/config_test.go: `.Run("PriceMaxKey", func(t *testing.T) {
		addr := utils.NewAddress()
		randomOtherAddr := utils.NewAddress()
		cfg2 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.KeySpecific = toml.KeySpecificConfig{
				{Key: ptr(types.EIP55AddressFromAddress(randomOtherAddr)),
					GasEstimator: toml.KeySpecificGasEstimator{
						PriceMax: assets.GWei(850),
					},
				},
			}
			c.GasEstimator.PriceMax = assets.NewWeiI(100000000000000)
			c.GasEstimator.PriceDefault = assets.NewWeiI(42000000000)
		})

		t.Run("uses chain-specific default value when nothing is set", func(t *testing.T) {
			assert.Equal(t, assets.NewWeiI(100000000000000), cfg2.EVM().GasEstimator().PriceMaxKey(addr))
		})

		t.Run("uses chain-specific override value when that is set", func(t *testing.T) {
			priceMax := assets.NewWeiI(rand.Int63())
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = priceMax
			})
			assert.Equal(t, priceMax.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})

		t.Run("uses key-specific override value when set", func(t *testing.T) {
			tests := []struct {
				name string
				val  *assets.Wei
			}{
				{"Test with 250 GWei", assets.GWei(250)},
				{"Test with 0 GWei", assets.GWei(0)},
			}

			for _, tt := range tests {
				t.Run(tt.name, func(t *testing.T) {
					cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
						c.KeySpecific = toml.KeySpecificConfig{
							{Key: ptr(types.EIP55AddressFromAddress(addr)),
								GasEstimator: toml.KeySpecificGasEstimator{
									PriceMax: tt.val,
								},
							},
						}
					})

					assert.Equal(t, tt.val.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
				})
			}
		})
		t.Run("uses key-specific override value when set and lower than chain specific config", func(t *testing.T) {
			keySpecificPrice := assets.GWei(900)
			chainSpecificPrice := assets.GWei(1200)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, keySpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})
		t.Run("uses chain-specific value when higher than key-specific value", func(t *testing.T) {
			keySpecificPrice := assets.GWei(1400)
			chainSpecificPrice := assets.GWei(1200)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, chainSpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})
		t.Run("uses key-specific override value when set and lower than global config", func(t *testing.T) {
			keySpecificPrice := assets.GWei(900)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, keySpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})
		t.Run("uses global value when higher than key-specific value", func(t *testing.T) {
			keySpecificPrice := assets.GWei(1400)
			chainSpecificPrice := assets.GWei(1200)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, chainSpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})
		t.Run("uses global value when there is no key-specific price", func(t *testing.T) {
			priceMax := assets.NewWeiI(rand.Int63())
			unsetAddr := utils.NewAddress()
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = priceMax
			})

			assert.Equal(t, priceMax.String(), cfg3.EVM().GasEstimator().PriceMaxKey(unsetAddr).String())
		})
	})`
$DIR/pkg/config/config_test.go: `.NewAddress()`
$DIR/pkg/config/config_test.go: `.NewAddress()`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.KeySpecific = toml.KeySpecificConfig{
				{Key: ptr(types.EIP55AddressFromAddress(randomOtherAddr)),
					GasEstimator: toml.KeySpecificGasEstimator{
						PriceMax: assets.GWei(850),
					},
				},
			}
			c.GasEstimator.PriceMax = assets.NewWeiI(100000000000000)
			c.GasEstimator.PriceDefault = assets.NewWeiI(42000000000)
		})`
$DIR/pkg/config/config_test.go: `.EIP55AddressFromAddress(randomOtherAddr)`
$DIR/pkg/config/config_test.go: `.GWei(850)`
$DIR/pkg/config/config_test.go: `.NewWeiI(100000000000000)`
$DIR/pkg/config/config_test.go: `.NewWeiI(42000000000)`
$DIR/pkg/config/config_test.go: `.Run("uses chain-specific default value when nothing is set", func(t *testing.T) {
			assert.Equal(t, assets.NewWeiI(100000000000000), cfg2.EVM().GasEstimator().PriceMaxKey(addr))
		})`
$DIR/pkg/config/config_test.go: `.Run("uses chain-specific override value when that is set", func(t *testing.T) {
			priceMax := assets.NewWeiI(rand.Int63())
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = priceMax
			})
			assert.Equal(t, priceMax.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})`
$DIR/pkg/config/config_test.go: `.NewWeiI(rand.Int63())`
$DIR/pkg/config/config_test.go: `.Int63()`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = priceMax
			})`
$DIR/pkg/config/config_test.go: `.Run("uses key-specific override value when set", func(t *testing.T) {
			tests := []struct {
				name string
				val  *assets.Wei
			}{
				{"Test with 250 GWei", assets.GWei(250)},
				{"Test with 0 GWei", assets.GWei(0)},
			}

			for _, tt := range tests {
				t.Run(tt.name, func(t *testing.T) {
					cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
						c.KeySpecific = toml.KeySpecificConfig{
							{Key: ptr(types.EIP55AddressFromAddress(addr)),
								GasEstimator: toml.KeySpecificGasEstimator{
									PriceMax: tt.val,
								},
							},
						}
					})

					assert.Equal(t, tt.val.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
				})
			}
		})`
$DIR/pkg/config/config_test.go: `.GWei(250)`
$DIR/pkg/config/config_test.go: `.GWei(0)`
$DIR/pkg/config/config_test.go: `.Run(tt.name, func(t *testing.T) {
					cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
						c.KeySpecific = toml.KeySpecificConfig{
							{Key: ptr(types.EIP55AddressFromAddress(addr)),
								GasEstimator: toml.KeySpecificGasEstimator{
									PriceMax: tt.val,
								},
							},
						}
					})

					assert.Equal(t, tt.val.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
				})`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
						c.KeySpecific = toml.KeySpecificConfig{
							{Key: ptr(types.EIP55AddressFromAddress(addr)),
								GasEstimator: toml.KeySpecificGasEstimator{
									PriceMax: tt.val,
								},
							},
						}
					})`
$DIR/pkg/config/config_test.go: `.EIP55AddressFromAddress(addr)`
$DIR/pkg/config/config_test.go: `.Run("uses key-specific override value when set and lower than chain specific config", func(t *testing.T) {
			keySpecificPrice := assets.GWei(900)
			chainSpecificPrice := assets.GWei(1200)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, keySpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})`
$DIR/pkg/config/config_test.go: `.GWei(900)`
$DIR/pkg/config/config_test.go: `.GWei(1200)`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})`
$DIR/pkg/config/config_test.go: `.EIP55AddressFromAddress(addr)`
$DIR/pkg/config/config_test.go: `.Run("uses chain-specific value when higher than key-specific value", func(t *testing.T) {
			keySpecificPrice := assets.GWei(1400)
			chainSpecificPrice := assets.GWei(1200)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, chainSpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})`
$DIR/pkg/config/config_test.go: `.GWei(1400)`
$DIR/pkg/config/config_test.go: `.GWei(1200)`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})`
$DIR/pkg/config/config_test.go: `.EIP55AddressFromAddress(addr)`
$DIR/pkg/config/config_test.go: `.Run("uses key-specific override value when set and lower than global config", func(t *testing.T) {
			keySpecificPrice := assets.GWei(900)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, keySpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})`
$DIR/pkg/config/config_test.go: `.GWei(900)`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})`
$DIR/pkg/config/config_test.go: `.EIP55AddressFromAddress(addr)`
$DIR/pkg/config/config_test.go: `.Run("uses global value when higher than key-specific value", func(t *testing.T) {
			keySpecificPrice := assets.GWei(1400)
			chainSpecificPrice := assets.GWei(1200)
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})

			assert.Equal(t, chainSpecificPrice.String(), cfg3.EVM().GasEstimator().PriceMaxKey(addr).String())
		})`
$DIR/pkg/config/config_test.go: `.GWei(1400)`
$DIR/pkg/config/config_test.go: `.GWei(1200)`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = chainSpecificPrice
				c.KeySpecific = toml.KeySpecificConfig{
					{Key: ptr(types.EIP55AddressFromAddress(addr)),
						GasEstimator: toml.KeySpecificGasEstimator{
							PriceMax: keySpecificPrice,
						},
					},
				}
			})`
$DIR/pkg/config/config_test.go: `.EIP55AddressFromAddress(addr)`
$DIR/pkg/config/config_test.go: `.Run("uses global value when there is no key-specific price", func(t *testing.T) {
			priceMax := assets.NewWeiI(rand.Int63())
			unsetAddr := utils.NewAddress()
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = priceMax
			})

			assert.Equal(t, priceMax.String(), cfg3.EVM().GasEstimator().PriceMaxKey(unsetAddr).String())
		})`
$DIR/pkg/config/config_test.go: `.NewWeiI(rand.Int63())`
$DIR/pkg/config/config_test.go: `.Int63()`
$DIR/pkg/config/config_test.go: `.NewAddress()`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.GasEstimator.PriceMax = priceMax
			})`
$DIR/pkg/config/config_test.go: `.Run("LinkContractAddress", func(t *testing.T) {
		t.Run("uses chain-specific default value when nothing is set", func(t *testing.T) {
			assert.Equal(t, "", cfg.EVM().LinkContractAddress())
		})

		t.Run("uses chain-specific override value when that is set", func(t *testing.T) {
			addr := utils.NewAddress()

			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.LinkContractAddress = ptr(types.EIP55AddressFromAddress(addr))
			})

			assert.Equal(t, addr.String(), cfg3.EVM().LinkContractAddress())
		})
	})`
$DIR/pkg/config/config_test.go: `.Run("uses chain-specific default value when nothing is set", func(t *testing.T) {
			assert.Equal(t, "", cfg.EVM().LinkContractAddress())
		})`
$DIR/pkg/config/config_test.go: `.Run("uses chain-specific override value when that is set", func(t *testing.T) {
			addr := utils.NewAddress()

			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.LinkContractAddress = ptr(types.EIP55AddressFromAddress(addr))
			})

			assert.Equal(t, addr.String(), cfg3.EVM().LinkContractAddress())
		})`
$DIR/pkg/config/config_test.go: `.NewAddress()`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.LinkContractAddress = ptr(types.EIP55AddressFromAddress(addr))
			})`
$DIR/pkg/config/config_test.go: `.EIP55AddressFromAddress(addr)`
$DIR/pkg/config/config_test.go: `.Run("OperatorFactoryAddress", func(t *testing.T) {
		t.Run("uses chain-specific default value when nothing is set", func(t *testing.T) {
			assert.Equal(t, "", cfg.EVM().OperatorFactoryAddress())
		})

		t.Run("uses chain-specific override value when that is set", func(t *testing.T) {
			val := utils.NewAddress()

			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.OperatorFactoryAddress = ptr(types.EIP55AddressFromAddress(val))
			})

			assert.Equal(t, val.String(), cfg3.EVM().OperatorFactoryAddress())
		})
	})`
$DIR/pkg/config/config_test.go: `.Run("uses chain-specific default value when nothing is set", func(t *testing.T) {
			assert.Equal(t, "", cfg.EVM().OperatorFactoryAddress())
		})`
$DIR/pkg/config/config_test.go: `.Run("uses chain-specific override value when that is set", func(t *testing.T) {
			val := utils.NewAddress()

			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.OperatorFactoryAddress = ptr(types.EIP55AddressFromAddress(val))
			})

			assert.Equal(t, val.String(), cfg3.EVM().OperatorFactoryAddress())
		})`
$DIR/pkg/config/config_test.go: `.NewAddress()`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.OperatorFactoryAddress = ptr(types.EIP55AddressFromAddress(val))
			})`
$DIR/pkg/config/config_test.go: `.EIP55AddressFromAddress(val)`
$DIR/pkg/config/config_test.go: `.Run("LogBroadcasterEnabled", func(t *testing.T) {
		t.Run("turn on LogBroadcasterEnabled by default", func(t *testing.T) {
			assert.True(t, cfg.EVM().LogBroadcasterEnabled())
		})

		t.Run("verify LogBroadcasterEnabled is set correctly", func(t *testing.T) {
			val := false
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.LogBroadcasterEnabled = ptr(val)
			})

			assert.False(t, cfg3.EVM().LogBroadcasterEnabled())
		})
	})`
$DIR/pkg/config/config_test.go: `.Run("turn on LogBroadcasterEnabled by default", func(t *testing.T) {
			assert.True(t, cfg.EVM().LogBroadcasterEnabled())
		})`
$DIR/pkg/config/config_test.go: `.Run("verify LogBroadcasterEnabled is set correctly", func(t *testing.T) {
			val := false
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.LogBroadcasterEnabled = ptr(val)
			})

			assert.False(t, cfg3.EVM().LogBroadcasterEnabled())
		})`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.LogBroadcasterEnabled = ptr(val)
			})`
$DIR/pkg/config/config_test.go: `.Run("turn on EVM.Transactions.Enabled by default", func(t *testing.T) {
			assert.True(t, cfg.EVM().Transactions().Enabled())
		})`
$DIR/pkg/config/config_test.go: `.Run("verify EVM.Transactions.Enabled is set correctly", func(t *testing.T) {
			val := false
			cfg3 := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.Transactions.Enabled = ptr(val)
			})

			assert.False(t, cfg3.EVM().Transactions().Enabled())
		})`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.Transactions.Enabled = ptr(val)
			})`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/config/config_test.go: `.EVM()`
$DIR/pkg/config/config_test.go: `.GasEstimator()`
$DIR/pkg/config/config_test.go: `.BlockHistory()`
$DIR/pkg/config/config_test.go: `.EIP1559FeeCapBufferBlocks()`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/config/config_test.go: `.EVM()`
$DIR/pkg/config/config_test.go: `.GasEstimator()`
$DIR/pkg/config/config_test.go: `.FeeHistory()`
$DIR/pkg/config/config_test.go: `.CacheTimeout()`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.GasEstimator.PriceMax = assets.GWei(500)
	})`
$DIR/pkg/config/config_test.go: `.GWei(500)`
$DIR/pkg/config/config_test.go: `.EVM()`
$DIR/pkg/config/config_test.go: `.GasEstimator()`
$DIR/pkg/config/config_test.go: `.EstimateLimit()`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.ChainID = (*ubig.Big)(big.NewInt(56))
	})`
$DIR/pkg/config/config_test.go: `.NewInt(56)`
$DIR/pkg/config/config_test.go: `.EVM()`
$DIR/pkg/config/config_test.go: `.OCR()`
$DIR/pkg/config/config_test.go: `.DatabaseTimeout()`
$DIR/pkg/config/config_test.go: `.EVM()`
$DIR/pkg/config/config_test.go: `.OCR()`
$DIR/pkg/config/config_test.go: `.ContractTransmitterTransmitTimeout()`
$DIR/pkg/config/config_test.go: `.EVM()`
$DIR/pkg/config/config_test.go: `.OCR()`
$DIR/pkg/config/config_test.go: `.ObservationGracePeriod()`
$DIR/pkg/config/config_test.go: `.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			config := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.ChainID = ubig.NewI(tt.chainID)
			})

			assert.Equal(t, tt.expectedGasLimitDefault, config.EVM().GasEstimator().LimitDefault())
			assert.Nil(t, config.EVM().GasEstimator().LimitJobType().OCR())
			assert.Nil(t, config.EVM().GasEstimator().LimitJobType().DR())
			assert.Nil(t, config.EVM().GasEstimator().LimitJobType().VRF())
			assert.Nil(t, config.EVM().GasEstimator().LimitJobType().FM())
			assert.Nil(t, config.EVM().GasEstimator().LimitJobType().Keeper())
			assert.Equal(t, tt.expectedMinimumContractPayment, strings.TrimRight(config.EVM().MinContractPayment().Link(), "0"))
		})`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
				c.ChainID = ubig.NewI(tt.chainID)
			})`
$DIR/pkg/config/config_test.go: `.NewI(tt.chainID)`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/config/config_test.go: `.EVM()`
$DIR/pkg/config/config_test.go: `.HeadTracker()`
$DIR/pkg/config/config_test.go: `.PersistenceBatchSize()`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/config/config_test.go: `.EVM()`
$DIR/pkg/config/config_test.go: `.NodePool()`
$DIR/pkg/config/config_test.go: `.DeathDeclarationDelay()`
$DIR/pkg/config/config_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			id := ubig.New(big.NewInt(rand.Int63()))
			c.ChainID = id
			c.NodePool = toml.NodePool{
				Errors: toml.ClientErrors{
					NonceTooLow:                       ptr("client error nonce too low"),
					NonceTooHigh:                      ptr("client error nonce too high"),
					ReplacementTransactionUnderpriced: ptr("client error replacement underpriced"),
					LimitReached:                      ptr("client error limit reached"),
					TransactionAlreadyInMempool:       ptr("client error transaction already in mempool"),
					TerminallyUnderpriced:             ptr("client error terminally underpriced"),
					InsufficientEth:                   ptr("client error insufficient eth"),
					TxFeeExceedsCap:                   ptr("client error tx fee exceeds cap"),
					L2FeeTooLow:                       ptr("client error l2 fee too low"),
					L2FeeTooHigh:                      ptr("client error l2 fee too high"),
					L2Full:                            ptr("client error l2 full"),
					TransactionAlreadyMined:           ptr("client error transaction already mined"),
					Fatal:                             ptr("client error fatal"),
					ServiceUnavailable:                ptr("client error service unavailable"),
					TooManyResults:                    ptr("client error too many results"),
				},
			}
		})`
$DIR/pkg/config/config_test.go: `.New(big.NewInt(rand.Int63()))`
$DIR/pkg/config/config_test.go: `.NewInt(rand.Int63())`
$DIR/pkg/config/config_test.go: `.Int63()`
$DIR/pkg/config/config_test.go: `.EVM()`
$DIR/pkg/config/config_test.go: `.NodePool()`
$DIR/pkg/config/config_test.go: `.Errors()`
$DIR/pkg/config/toml/config_test.go: `t.Run(fmt.Sprintf("chainID-%s", id), func(t *testing.T) {
			evmCfg := &EVMConfig{
				ChainID: id,
				Chain:   Defaults(id),
				Nodes: EVMNodes{{
					Name:    &name,
					WSURL:   config.MustParseURL("wss://foo.test/ws"),
					HTTPURL: config.MustParseURL("http://foo.test"),
				}},
			}

			assert.NoError(t, config.Validate(evmCfg))
		})`
$DIR/pkg/config/toml/config_test.go: `unknown.ChainType = chaintype.NewConfig("arbitrum")`
$DIR/pkg/config/toml/config_test.go: `unknown.FlagsContractAddress = asEIP55Address(t, "0x1234567890abcdefaC8a1b4E58707D29258707D2")`
$DIR/pkg/config/toml/config_test.go: `unknown.LinkContractAddress = asEIP55Address(t, "0xabcdef1234567890aC8a1b4E58707D29258707D2")`
$DIR/pkg/config/toml/config_test.go: `unknown.OperatorFactoryAddress = asEIP55Address(t, "0xababab12341234aC8a1b4E58707D29258707D292")`
$DIR/pkg/config/toml/config_test.go: `unknown.Workflow.FromAddress = &addr`
$DIR/pkg/config/toml/config_test.go: `unknown.Workflow.ForwarderAddress = &addr`
$DIR/pkg/config/toml/config_test.go: `unknown.Workflow.GasLimitDefault = ptr(uint64(400000))`
$DIR/pkg/config/toml/config_test.go: `unknown.Transactions.TransactionManagerV2.BlockTime = new(config.Duration)`
$DIR/pkg/config/toml/config_test.go: `unknown.Transactions.TransactionManagerV2.CustomURL = new(config.URL)`
$DIR/pkg/config/toml/config_test.go: `unknown.Transactions.TransactionManagerV2.DualBroadcast = ptr(false)`
$DIR/pkg/config/toml/config_test.go: `unknown.Transactions.AutoPurge.Threshold = ptr(uint32(0))`
$DIR/pkg/config/toml/config_test.go: `unknown.Transactions.AutoPurge.MinAttempts = ptr(uint32(0))`
$DIR/pkg/config/toml/config_test.go: `unknown.Transactions.AutoPurge.DetectionApiUrl = new(config.URL)`
$DIR/pkg/config/toml/config_test.go: `unknown.GasEstimator.BlockHistory.EIP1559FeeCapBufferBlocks = ptr[uint16](10)`
$DIR/pkg/config/toml/config_test.go: `unknown.GasEstimator.SenderAddress = asEIP55Address(t, "0xae4E781a6218A8031764928E88d457937A954fC3")`
$DIR/pkg/config/toml/config_test.go: `unknown.GasEstimator.DAOracle.OracleType = &oracleType`
$DIR/pkg/config/toml/config_test.go: `unknown.GasEstimator.DAOracle.OracleAddress = new(types.EIP55Address)`
$DIR/pkg/config/toml/config_test.go: `unknown.GasEstimator.DAOracle.CustomGasPriceCalldata = new(string)`
$DIR/pkg/config/toml/config_test.go: `unknown.GasEstimator.LimitJobType = GasLimitJobType{
		OCR:    ptr[uint32](7),
		OCR2:   ptr[uint32](13),
		DR:     ptr[uint32](25),
		VRF:    ptr[uint32](37),
		FM:     ptr[uint32](42),
		Keeper: ptr[uint32](51),
	}`
$DIR/pkg/config/toml/config_test.go: `unknown.GasEstimator.BumpTxDepth = ptr[uint32](15)`
$DIR/pkg/config/toml/config_test.go: `unknown.NodePool.Errors = ClientErrors{
		NonceTooLow:                       ptr("too-low"),
		NonceTooHigh:                      ptr("too-high"),
		ReplacementTransactionUnderpriced: ptr("under"),
		LimitReached:                      ptr("limit"),
		TransactionAlreadyInMempool:       ptr("already"),
		TerminallyUnderpriced:             ptr("terminal"),
		InsufficientEth:                   ptr("insufficient"),
		TxFeeExceedsCap:                   ptr("exceeds"),
		L2FeeTooLow:                       ptr("low-fee"),
		L2FeeTooHigh:                      ptr("high-fee"),
		L2Full:                            ptr("full"),
		TransactionAlreadyMined:           ptr("mined"),
		Fatal:                             ptr("fatal"),
		ServiceUnavailable:                ptr("unavailable"),
		TooManyResults:                    ptr("too-many"),
		MissingBlocks:                     ptr("missing"),
	}`
$DIR/pkg/config/toml/config_test.go: `t.Run("complete", func(t *testing.T) {
		configtest.AssertDocsTOMLComplete[EVMConfig](t, docsTOML)
	})`
$DIR/pkg/config/toml/config_test.go: `configtest.AssertDocsTOMLComplete[EVMConfig](t, docsTOML)`
$DIR/pkg/config/toml/config_test.go: `docDefaults.ChainType = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.KeySpecific = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.GasEstimator.BumpTxDepth = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.GasEstimator.LimitJobType = GasLimitJobType{}`
$DIR/pkg/config/toml/config_test.go: `docDefaults.GasEstimator.BlockHistory.EIP1559FeeCapBufferBlocks = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.FlagsContractAddress = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.LinkContractAddress = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.OperatorFactoryAddress = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.Workflow.FromAddress = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.Workflow.ForwarderAddress = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.Workflow.GasLimitDefault = &gasLimitDefault`
$DIR/pkg/config/toml/config_test.go: `docDefaults.NodePool.Errors = ClientErrors{}`
$DIR/pkg/config/toml/config_test.go: `docDefaults.Transactions.AutoPurge.DetectionApiUrl = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.Transactions.AutoPurge.Threshold = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.Transactions.AutoPurge.MinAttempts = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.Transactions.TransactionManagerV2.BlockTime = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.Transactions.TransactionManagerV2.CustomURL = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.Transactions.TransactionManagerV2.DualBroadcast = nil`
$DIR/pkg/config/toml/config_test.go: `docDefaults.GasEstimator.DAOracle = DAOracle{}`
$DIR/pkg/config/toml/config_test.go: `docDefaults.GasEstimator.SenderAddress = nil`
$DIR/pkg/config/toml/config_test.go: `assertTOML(t, fallbackDefaults, docDefaults.Chain)`
$DIR/pkg/config/toml/config_test.go: `config.SetFrom(&fullConfig)`
$DIR/pkg/config/toml/config_test.go: `.Run(fmt.Sprintf("chainID-%s", id), func(t *testing.T) {
			evmCfg := &EVMConfig{
				ChainID: id,
				Chain:   Defaults(id),
				Nodes: EVMNodes{{
					Name:    &name,
					WSURL:   config.MustParseURL("wss://foo.test/ws"),
					HTTPURL: config.MustParseURL("http://foo.test"),
				}},
			}

			assert.NoError(t, config.Validate(evmCfg))
		})`
$DIR/pkg/config/toml/config_test.go: `.Sprintf("chainID-%s", id)`
$DIR/pkg/config/toml/config_test.go: `.MustParseURL("wss://foo.test/ws")`
$DIR/pkg/config/toml/config_test.go: `.MustParseURL("http://foo.test")`
$DIR/pkg/config/toml/config_test.go: `.NewConfig("arbitrum")`
$DIR/pkg/config/toml/config_test.go: `.NewEIP55Address("0x2a3e23c6f242F5345320814aC8a1b4E58707D292")`
$DIR/pkg/config/toml/config_test.go: `.Run("complete", func(t *testing.T) {
		configtest.AssertDocsTOMLComplete[EVMConfig](t, docsTOML)
	})`
$DIR/pkg/config/toml/config_test.go: `.SetFrom(&fullConfig)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `t.Cleanup(func() { b.Close() })`
$DIR/pkg/forwarders/forwarder_manager_test.go: `b.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `_, err = forwarder.SetAuthorizedSenders(owner, []common.Address{owner.From})`
$DIR/pkg/forwarders/forwarder_manager_test.go: `b.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `fwdMgr.ORM = forwarders.NewORM(db)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `err = fwdMgr.Close()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `cleanupCalled = true`
$DIR/pkg/forwarders/forwarder_manager_test.go: `err = fwdMgr.ORM.DeleteForwarder(ctx, fwd.ID, cleanup)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `t.Cleanup(func() { b.Close() })`
$DIR/pkg/forwarders/forwarder_manager_test.go: `b.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `fwdMgr.ORM = forwarders.NewORM(db)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `_, err = fwdMgr.ORM.CreateForwarder(ctx, forwarderAddr, ubig.Big(*testutils.FixtureChainID))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `err = fwdMgr.Start(testutils.Context(t))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `err = fwdMgr.Close()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `t.Cleanup(func() { ec.Close() })`
$DIR/pkg/forwarders/forwarder_manager_test.go: `ec.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `ec.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `fwdMgr.ORM = forwarders.NewORM(db)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `_, err = fwdMgr.ORM.CreateForwarder(ctx, forwarderAddr, ubig.Big(*testutils.FixtureChainID))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `fwdMgr = forwarders.NewFwdMgr(db, evmClient, lp, lggr, evmcfg.EVM())`
$DIR/pkg/forwarders/forwarder_manager_test.go: `_, err = forwarder.SetAuthorizedSenders(owner, []common.Address{owner.From})`
$DIR/pkg/forwarders/forwarder_manager_test.go: `ec.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `addr, err = fwdMgr.ForwarderForOCR2Feeds(ctx, owner.From, ocr2Address)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `_, err = ocr2.SetConfig(owner,
		[]common.Address{testutils.NewAddress(), testutils.NewAddress(), testutils.NewAddress(), testutils.NewAddress()},
		[]common.Address{forwarderAddr, testutils.NewAddress(), testutils.NewAddress(), testutils.NewAddress()},
		1,
		onchainConfig,
		0,
		[]byte{})`
$DIR/pkg/forwarders/forwarder_manager_test.go: `ec.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `fwdMgr = forwarders.NewFwdMgr(db, evmClient, lp, lggr, evmcfg.EVM())`
$DIR/pkg/forwarders/forwarder_manager_test.go: `addr, err = fwdMgr.ForwarderForOCR2Feeds(ctx, owner.From, ocr2Address)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Test(t)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewSqlxDB(t)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.MustNewSimTransactor(t)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Context(t)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewBackend(types.GenesisAlloc{
		owner.From: {
			Balance: big.NewInt(0).Mul(big.NewInt(10), big.NewInt(1e18)),
		},
	}, simulated.WithBlockGasLimit(10e6))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewInt(0)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Mul(big.NewInt(10), big.NewInt(1e18))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewInt(10)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewInt(1e18)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.WithBlockGasLimit(10e6)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Cleanup(func() { b.Close() })`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.HexToAddress("0x01BE23585060835E02B77ef475b0Cc51aA1e0709")`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.DeployOperator(owner, b.Client(), linkAddr, owner.From)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Client()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.DeployAuthorizedForwarder(owner, b.Client(), linkAddr, owner.From, operatorAddr, []byte{})`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Client()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.SetAuthorizedSenders(owner, []common.Address{owner.From})`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.GetAuthorizedSenders(nil)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewSimulatedBackendClient(t, b, testutils.FixtureChainID)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewSimulatedHeadTracker(evmClient, lpOpts.UseFinalityTag, lpOpts.FinalityDepth)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewLogPoller(logpoller.NewORM(testutils.FixtureChainID, db, lggr), evmClient, lggr, ht, lpOpts)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewORM(testutils.FixtureChainID, db, lggr)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewFwdMgr(db, evmClient, lp, lggr, evmcfg.EVM())`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.EVM()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewORM(db)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.ORM.CreateForwarder(ctx, forwarderAddr, ubig.Big(*testutils.FixtureChainID))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Big(*testutils.FixtureChainID)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.ORM.FindForwardersByChain(ctx, ubig.Big(*testutils.FixtureChainID))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Big(*testutils.FixtureChainID)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.ForwarderFor(ctx, owner.From)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.ORM.DeleteForwarder(ctx, fwd.ID, cleanup)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Test(t)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewSqlxDB(t)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Context(t)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.MustNewSimTransactor(t)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewBackend(types.GenesisAlloc{
		owner.From: {
			Balance: big.NewInt(0).Mul(big.NewInt(10), big.NewInt(1e18)),
		},
	}, simulated.WithBlockGasLimit(10e6))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewInt(0)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Mul(big.NewInt(10), big.NewInt(1e18))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewInt(10)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewInt(1e18)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.WithBlockGasLimit(10e6)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Cleanup(func() { b.Close() })`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.HexToAddress("0x01BE23585060835E02B77ef475b0Cc51aA1e0709")`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.DeployOperator(owner, b.Client(), linkAddr, owner.From)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Client()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.DeployAuthorizedForwarder(owner, b.Client(), linkAddr, owner.From, operatorAddr, []byte{})`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Client()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewSimulatedBackendClient(t, b, testutils.FixtureChainID)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewSimulatedHeadTracker(evmClient, lpOpts.UseFinalityTag, lpOpts.FinalityDepth)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewLogPoller(logpoller.NewORM(testutils.FixtureChainID, db, lggr), evmClient, lggr, ht, lpOpts)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewORM(testutils.FixtureChainID, db, lggr)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewFwdMgr(db, evmClient, lp, lggr, evmcfg.EVM())`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.EVM()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewORM(db)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.ORM.CreateForwarder(ctx, forwarderAddr, ubig.Big(*testutils.FixtureChainID))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Big(*testutils.FixtureChainID)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.ORM.FindForwardersByChain(ctx, ubig.Big(*testutils.FixtureChainID))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Big(*testutils.FixtureChainID)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Start(testutils.Context(t))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Context(t)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.ForwarderFor(ctx, owner.From)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Test(t)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewSqlxDB(t)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Context(t)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.MustNewSimTransactor(t)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewBackend(types.GenesisAlloc{
		owner.From: {
			Balance: big.NewInt(0).Mul(big.NewInt(10), big.NewInt(1e18)),
		},
	}, simulated.WithBlockGasLimit(10e6))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewInt(0)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Mul(big.NewInt(10), big.NewInt(1e18))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewInt(10)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewInt(1e18)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.WithBlockGasLimit(10e6)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Cleanup(func() { ec.Close() })`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.HexToAddress("0x01BE23585060835E02B77ef475b0Cc51aA1e0709")`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.DeployOperator(owner, ec.Client(), linkAddr, owner.From)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Client()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.DeployAuthorizedForwarder(owner, ec.Client(), linkAddr, owner.From, operatorAddr, []byte{})`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Client()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.DeploySimpleWriteAccessController(owner, ec.Client())`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Client()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.DeployOCR2Aggregator(
		owner,
		ec.Client(),
		linkAddr,
		big.NewInt(0),
		big.NewInt(10),
		accessAddress,
		accessAddress,
		9,
		"TEST",
	)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Client()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewInt(0)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewInt(10)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewSimulatedBackendClient(t, ec, testutils.FixtureChainID)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewSimulatedHeadTracker(evmClient, lpOpts.UseFinalityTag, lpOpts.FinalityDepth)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewLogPoller(logpoller.NewORM(testutils.FixtureChainID, db, lggr), evmClient, lggr, ht, lpOpts)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewORM(testutils.FixtureChainID, db, lggr)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewFwdMgr(db, evmClient, lp, lggr, evmcfg.EVM())`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.EVM()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewORM(db)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.ORM.CreateForwarder(ctx, forwarderAddr, ubig.Big(*testutils.FixtureChainID))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Big(*testutils.FixtureChainID)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.ORM.FindForwardersByChain(ctx, ubig.Big(*testutils.FixtureChainID))`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Big(*testutils.FixtureChainID)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewFwdMgr(db, evmClient, lp, lggr, evmcfg.EVM())`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.EVM()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.ForwarderForOCR2Feeds(ctx, owner.From, ocr2Address)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.SetAuthorizedSenders(owner, []common.Address{owner.From})`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.GetAuthorizedSenders(&bind.CallOpts{Context: ctx})`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.ForwarderForOCR2Feeds(ctx, owner.From, ocr2Address)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Encode(ctx, median.OnchainConfig{Min: big.NewInt(0), Max: big.NewInt(10)})`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewInt(0)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewInt(10)`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.SetConfig(owner,
		[]common.Address{testutils.NewAddress(), testutils.NewAddress(), testutils.NewAddress(), testutils.NewAddress()},
		[]common.Address{forwarderAddr, testutils.NewAddress(), testutils.NewAddress(), testutils.NewAddress()},
		1,
		onchainConfig,
		0,
		[]byte{})`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewAddress()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewAddress()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewAddress()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewAddress()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewAddress()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewAddress()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewAddress()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.Commit()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.GetTransmitters(&bind.CallOpts{Context: ctx})`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.NewFwdMgr(db, evmClient, lp, lggr, evmcfg.EVM())`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.EVM()`
$DIR/pkg/forwarders/forwarder_manager_test.go: `.ForwarderForOCR2Feeds(ctx, owner.From, ocr2Address)`
$DIR/pkg/forwarders/orm_test.go: `cleanupCalled++`
$DIR/pkg/forwarders/orm_test.go: `err = orm.DeleteForwarder(ctx, fwd.ID, testCleanupFn)`
$DIR/pkg/forwarders/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/forwarders/orm_test.go: `.NewAddress()`
$DIR/pkg/forwarders/orm_test.go: `.Context(t)`
$DIR/pkg/forwarders/orm_test.go: `.CreateForwarder(ctx, addr, *big.New(chainID))`
$DIR/pkg/forwarders/orm_test.go: `.New(chainID)`
$DIR/pkg/forwarders/orm_test.go: `.New("error during cleanup")`
$DIR/pkg/forwarders/orm_test.go: `.DeleteForwarder(ctx, fwd.ID, testCleanupFn)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `t.Run("calling GetLegacyGas on unstarted estimator returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)
		_, _, err = o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		assert.EqualError(t, err, "estimator is not started")
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `_, _, err = o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `zeros.Write(common.BigToHash(big.NewInt(0)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `zeros.Write(common.BigToHash(big.NewInt(0)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `zeros.Write(common.BigToHash(big.NewInt(123455)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `t.Run("calling GetLegacyGas on started estimator returns estimates", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})
		feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(zeros.Bytes(), nil)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{v: maxGasLimit, bumpPercent: bumpPercent, bumpMin: bumpMin}, feeEstimatorClient, l1Oracle)
		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		require.NoError(t, err)
		// Expected price for a standard l2_suggested_estimator would be 42, but we add a fixed gasPriceBufferPercentage.
		assert.Equal(t, assets.NewWeiI(42).AddPercentage(gasPriceBufferPercentage), gasPrice)
		assert.Equal(t, gasLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `(*big.Int)(res).SetInt64(42)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(zeros.Bytes(), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `t.Run("gas price is lower than user specified max gas price", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})
		feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(zeros.Bytes(), nil)

		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, assets.NewWeiI(40))
		require.Error(t, err)
		assert.EqualError(t, err, "estimated gas price: 42 wei is greater than the maximum gas price configured: 40 wei")
		assert.Nil(t, gasPrice)
		assert.Equal(t, uint64(0), chainSpecificGasLimit)
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `(*big.Int)(res).SetInt64(42)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(zeros.Bytes(), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `t.Run("gas price is lower than global max gas price", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(120)
		})
		feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(zeros.Bytes(), nil)

		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, assets.NewWeiI(110))
		assert.EqualError(t, err, "estimated gas price: 120 wei is greater than the maximum gas price configured: 110 wei")
		assert.Nil(t, gasPrice)
		assert.Equal(t, uint64(0), chainSpecificGasLimit)
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(120)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `(*big.Int)(res).SetInt64(120)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(zeros.Bytes(), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `t.Run("calling BumpLegacyGas on unstarted arbitrum estimator returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)
		_, _, err = o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), gasLimit, assets.NewWeiI(10), nil)
		assert.EqualError(t, err, "estimator is not started")
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `_, _, err = o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), gasLimit, assets.NewWeiI(10), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `t.Run("calling GetLegacyGas on started estimator if initial call failed returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(pkgerrors.New("kaboom"))
		feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(zeros.Bytes(), nil)

		servicetest.RunHealthy(t, o)

		_, _, err = o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		assert.EqualError(t, err, "failed to estimate gas; gas price not set")
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(pkgerrors.New("kaboom"))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(zeros.Bytes(), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `_, _, err = o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `t.Run("calling GetDynamicFee always returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)
		_, err = o.GetDynamicFee(tests.Context(t), maxGasPrice)
		assert.EqualError(t, err, "dynamic fees are not implemented for this estimator")
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `_, err = o.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `t.Run("calling BumpDynamicFee always returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)
		fee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(42),
			GasTipCap: assets.NewWeiI(5),
		}
		_, err = o.BumpDynamicFee(tests.Context(t), fee, maxGasPrice, nil)
		assert.EqualError(t, err, "dynamic fees are not implemented for this estimator")
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `_, err = o.BumpDynamicFee(tests.Context(t), fee, maxGasPrice, nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `t.Run("limit computes", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})
		const (
			perL2Tx       = 50_000
			perL1Calldata = 10_000
		)
		var expLimit = gasLimit + perL2Tx + perL1Calldata*uint64(len(calldata))

		var b bytes.Buffer
		b.Write(common.BigToHash(big.NewInt(perL2Tx)).Bytes())
		b.Write(common.BigToHash(big.NewInt(perL1Calldata)).Bytes())
		b.Write(common.BigToHash(big.NewInt(123455)).Bytes())
		feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(b.Bytes(), nil)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{v: maxGasLimit, bumpPercent: bumpPercent, bumpMin: bumpMin}, feeEstimatorClient, l1Oracle)
		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		require.NoError(t, err)
		require.NotNil(t, gasPrice)
		// Again, a normal l2_suggested_estimator would return 42, but arbitrum_estimator adds a buffer.
		assert.Equal(t, "63 wei", gasPrice.String())
		assert.Equal(t, expLimit, chainSpecificGasLimit, "expected %d but got %d", expLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `(*big.Int)(res).SetInt64(42)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `b.Write(common.BigToHash(big.NewInt(perL2Tx)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `b.Write(common.BigToHash(big.NewInt(perL1Calldata)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `b.Write(common.BigToHash(big.NewInt(123455)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(b.Bytes(), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `(*big.Int)(res).SetInt64(42)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `b.Write(common.BigToHash(big.NewInt(perL2Tx)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `b.Write(common.BigToHash(big.NewInt(perL1Calldata)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `b.Write(common.BigToHash(big.NewInt(123455)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(b.Bytes(), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewWei(big.NewInt(1))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run("calling GetLegacyGas on unstarted estimator returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)
		_, _, err = o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		assert.EqualError(t, err, "estimator is not started")
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Write(common.BigToHash(big.NewInt(0)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.BigToHash(big.NewInt(0))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewInt(0)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Write(common.BigToHash(big.NewInt(0)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.BigToHash(big.NewInt(0))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewInt(0)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Write(common.BigToHash(big.NewInt(123455)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.BigToHash(big.NewInt(123455))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewInt(123455)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run("calling GetLegacyGas on started estimator returns estimates", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})
		feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(zeros.Bytes(), nil)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{v: maxGasLimit, bumpPercent: bumpPercent, bumpMin: bumpMin}, feeEstimatorClient, l1Oracle)
		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		require.NoError(t, err)
		// Expected price for a standard l2_suggested_estimator would be 42, but we add a fixed gasPriceBufferPercentage.
		assert.Equal(t, assets.NewWeiI(42).AddPercentage(gasPriceBufferPercentage), gasPrice)
		assert.Equal(t, gasLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.SetInt64(42)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(2)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Return(zeros.Bytes(), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumEstimator(logger.Test(t), &arbConfig{v: maxGasLimit, bumpPercent: bumpPercent, bumpMin: bumpMin}, feeEstimatorClient, l1Oracle)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run("gas price is lower than user specified max gas price", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})
		feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(zeros.Bytes(), nil)

		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, assets.NewWeiI(40))
		require.Error(t, err)
		assert.EqualError(t, err, "estimated gas price: 42 wei is greater than the maximum gas price configured: 40 wei")
		assert.Nil(t, gasPrice)
		assert.Equal(t, uint64(0), chainSpecificGasLimit)
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.SetInt64(42)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(2)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Return(zeros.Bytes(), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.GetLegacyGas(tests.Context(t), calldata, gasLimit, assets.NewWeiI(40))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewWeiI(40)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run("gas price is lower than global max gas price", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(120)
		})
		feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(zeros.Bytes(), nil)

		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, assets.NewWeiI(110))
		assert.EqualError(t, err, "estimated gas price: 120 wei is greater than the maximum gas price configured: 110 wei")
		assert.Nil(t, gasPrice)
		assert.Equal(t, uint64(0), chainSpecificGasLimit)
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(120)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.SetInt64(120)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(2)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Return(zeros.Bytes(), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.GetLegacyGas(tests.Context(t), calldata, gasLimit, assets.NewWeiI(110))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewWeiI(110)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run("calling BumpLegacyGas on unstarted arbitrum estimator returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)
		_, _, err = o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), gasLimit, assets.NewWeiI(10), nil)
		assert.EqualError(t, err, "estimator is not started")
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), gasLimit, assets.NewWeiI(10), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run("calling GetLegacyGas on started estimator if initial call failed returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(pkgerrors.New("kaboom"))
		feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(zeros.Bytes(), nil)

		servicetest.RunHealthy(t, o)

		_, _, err = o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		assert.EqualError(t, err, "failed to estimate gas; gas price not set")
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Return(pkgerrors.New("kaboom"))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.New("kaboom")`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(2)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Return(zeros.Bytes(), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run("calling GetDynamicFee always returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)
		_, err = o.GetDynamicFee(tests.Context(t), maxGasPrice)
		assert.EqualError(t, err, "dynamic fees are not implemented for this estimator")
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run("calling BumpDynamicFee always returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)
		fee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(42),
			GasTipCap: assets.NewWeiI(5),
		}
		_, err = o.BumpDynamicFee(tests.Context(t), fee, maxGasPrice, nil)
		assert.EqualError(t, err, "dynamic fees are not implemented for this estimator")
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumEstimator(logger.Test(t), &arbConfig{}, feeEstimatorClient, l1Oracle)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewWeiI(5)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.BumpDynamicFee(tests.Context(t), fee, maxGasPrice, nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run("limit computes", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle, err := rollups.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)
		require.NoError(t, err)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})
		const (
			perL2Tx       = 50_000
			perL1Calldata = 10_000
		)
		var expLimit = gasLimit + perL2Tx + perL1Calldata*uint64(len(calldata))

		var b bytes.Buffer
		b.Write(common.BigToHash(big.NewInt(perL2Tx)).Bytes())
		b.Write(common.BigToHash(big.NewInt(perL1Calldata)).Bytes())
		b.Write(common.BigToHash(big.NewInt(123455)).Bytes())
		feeEstimatorClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		}).Return(b.Bytes(), nil)

		o := gas.NewArbitrumEstimator(logger.Test(t), &arbConfig{v: maxGasLimit, bumpPercent: bumpPercent, bumpMin: bumpMin}, feeEstimatorClient, l1Oracle)
		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		require.NoError(t, err)
		require.NotNil(t, gasPrice)
		// Again, a normal l2_suggested_estimator would return 42, but arbitrum_estimator adds a buffer.
		assert.Equal(t, "63 wei", gasPrice.String())
		assert.Equal(t, expLimit, chainSpecificGasLimit, "expected %d but got %d", expLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.SetInt64(42)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Write(common.BigToHash(big.NewInt(perL2Tx)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.BigToHash(big.NewInt(perL2Tx))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewInt(perL2Tx)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Write(common.BigToHash(big.NewInt(perL1Calldata)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.BigToHash(big.NewInt(perL1Calldata))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewInt(perL1Calldata)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Write(common.BigToHash(big.NewInt(123455)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.BigToHash(big.NewInt(123455))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewInt(123455)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(2)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Return(b.Bytes(), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumEstimator(logger.Test(t), &arbConfig{v: maxGasLimit, bumpPercent: bumpPercent, bumpMin: bumpMin}, feeEstimatorClient, l1Oracle)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumL1GasOracle(logger.Test(t), feeEstimatorClient)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.SetInt64(42)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Write(common.BigToHash(big.NewInt(perL2Tx)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.BigToHash(big.NewInt(perL2Tx))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewInt(perL2Tx)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Write(common.BigToHash(big.NewInt(perL1Calldata)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.BigToHash(big.NewInt(perL1Calldata))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewInt(perL1Calldata)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Write(common.BigToHash(big.NewInt(123455)).Bytes())`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.BigToHash(big.NewInt(123455))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewInt(123455)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			assert.Equal(t, rollups.ArbGasInfoAddress, callMsg.To.String())
			assert.Equal(t, rollups.ArbGasInfo_getPricesInArbGas, hex.EncodeToString(callMsg.Data))
			assert.Equal(t, big.NewInt(-1), blockNumber)
		})`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Get(2)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Return(b.Bytes(), nil)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Bytes()`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.NewArbitrumEstimator(logger.Test(t), &arbConfig{v: maxGasLimit, bumpPercent: bumpPercent, bumpMin: bumpMin}, feeEstimatorClient, l1Oracle)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)`
$DIR/pkg/gas/arbitrum_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = minGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BatchSizeF = batchSize`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = blockDelay`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = historySize`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = percentile`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("loads initial state", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		h := &evmtypes.Head{Hash: utils.NewHash(), Number: 42, BaseFeePerGas: assets.NewWeiI(420)}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == "0x2a" && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == "0x29" && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
			elems[1].Result = &evmtypes.Block{
				Number: 41,
				Hash:   utils.NewHash(),
			}
		}).Once()

		err := bhe.Start(tests.Context(t))
		require.NoError(t, err)

		assert.Len(t, gas.GetRollingBlockHistory(bhe), 2)
		assert.Equal(t, 41, int(gas.GetRollingBlockHistory(bhe)[0].Number))
		assert.Equal(t, 42, int(gas.GetRollingBlockHistory(bhe)[1].Number))

		assert.Equal(t, assets.NewWeiI(420), gas.GetLatestBaseFee(bhe))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == "0x2a" && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == "0x29" && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
			elems[1].Result = &evmtypes.Block{
				Number: 41,
				Hash:   utils.NewHash(),
			}
		}).Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[1].Result = &evmtypes.Block{
				Number: 41,
				Hash:   utils.NewHash(),
			}`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("starts and loads partial history if fetch context times out", func(t *testing.T) {
		geCfg2 := &gas.MockGasEstimatorConfig{}
		geCfg2.EIP1559DynamicFeesF = true
		geCfg2.PriceMinF = minGasPrice

		bhCfg2 := newBlockHistoryConfig()
		bhCfg2.BatchSizeF = uint32(1)
		bhCfg2.BlockDelayF = blockDelay
		bhCfg2.BlockHistorySizeF = historySize
		bhCfg2.TransactionPercentileF = percentile

		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg2, bhCfg2, l1Oracle)

		h := &evmtypes.Head{Hash: utils.NewHash(), Number: 42, BaseFeePerGas: assets.NewWeiI(420)}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)
		// First succeeds (42)
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(42) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
		}).Once()
		// Second fails (41)
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(41) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Return(pkgerrors.Wrap(context.DeadlineExceeded, "some error message")).Once()

		err := bhe.Start(tests.Context(t))
		require.NoError(t, err)

		require.Len(t, gas.GetRollingBlockHistory(bhe), 1)
		assert.Equal(t, 42, int(gas.GetRollingBlockHistory(bhe)[0].Number))

		assert.Equal(t, assets.NewWeiI(420), gas.GetLatestBaseFee(bhe))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg2.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg2.PriceMinF = minGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg2.BatchSizeF = uint32(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg2.BlockDelayF = blockDelay`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg2.BlockHistorySizeF = historySize`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg2.TransactionPercentileF = percentile`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(42) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
		}).Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(41) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Return(pkgerrors.Wrap(context.DeadlineExceeded, "some error message")).Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("boots even if initial batch call returns nothing", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		h := &evmtypes.Head{Hash: utils.NewHash(), Number: 42}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == int(historySize)
		})).Return(nil)

		err := bhe.Start(tests.Context(t))
		require.NoError(t, err)

		// non-eip1559 block
		assert.Nil(t, gas.GetLatestBaseFee(bhe))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == int(historySize)
		})).Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("starts anyway if fetching latest head fails", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, pkgerrors.New("something exploded"))

		err := bhe.Start(tests.Context(t))
		require.NoError(t, err)

		assert.Nil(t, gas.GetLatestBaseFee(bhe))

		_, _, err = bhe.GetLegacyGas(tests.Context(t), make([]byte, 0), 100, maxGasPrice)
		require.Error(t, err)
		require.Contains(t, err.Error(), "has not finished the first gas estimation yet, likely because a failure on start")

		_, err = bhe.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.Error(t, err)
		require.Contains(t, err.Error(), "has not finished the first gas estimation yet, likely because a failure on start")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, pkgerrors.New("something exploded"))`
$DIR/pkg/gas/block_history_estimator_test.go: `_, _, err = bhe.GetLegacyGas(tests.Context(t), make([]byte, 0), 100, maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `_, err = bhe.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("starts anyway if fetching first fetch fails, but errors on estimation", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		h := &evmtypes.Head{Hash: utils.NewHash(), Number: 42, BaseFeePerGas: assets.NewWeiI(420)}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)
		ethClient.On("BatchCallContext", mock.Anything, mock.Anything).Return(pkgerrors.New("something went wrong"))

		err := bhe.Start(tests.Context(t))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWeiI(420), gas.GetLatestBaseFee(bhe))

		_, _, err = bhe.GetLegacyGas(tests.Context(t), make([]byte, 0), 100, maxGasPrice)
		require.Error(t, err)
		require.Contains(t, err.Error(), "has not finished the first gas estimation yet, likely because a failure on start")

		_, err = bhe.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.Error(t, err)
		require.Contains(t, err.Error(), "has not finished the first gas estimation yet, likely because a failure on start")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.Anything).Return(pkgerrors.New("something went wrong"))`
$DIR/pkg/gas/block_history_estimator_test.go: `_, _, err = bhe.GetLegacyGas(tests.Context(t), make([]byte, 0), 100, maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `_, err = bhe.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("returns error if main context is cancelled", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		h := &evmtypes.Head{Hash: utils.NewHash(), Number: 42, BaseFeePerGas: assets.NewWeiI(420)}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)
		ethClient.On("BatchCallContext", mock.Anything, mock.Anything).Return(pkgerrors.New("this error doesn't matter"))

		ctx, cancel := context.WithCancel(tests.Context(t))
		cancel()
		err := bhe.Start(ctx)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "context canceled")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.Anything).Return(pkgerrors.New("this error doesn't matter"))`
$DIR/pkg/gas/block_history_estimator_test.go: `cancel()`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.Anything).Return(pkgerrors.New("this error doesn't matter")).Run(func(_ mock.Arguments) {
			time.Sleep(gas.MaxStartTime + 1*time.Second)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `time.Sleep(gas.MaxStartTime + 1*time.Second)`
$DIR/pkg/gas/block_history_estimator_test.go: `_, _, err = bhe.GetLegacyGas(tests.Context(t), make([]byte, 0), 100, maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `_, err = bhe.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.OnNewLongestChain(tests.Context(t), h)`
$DIR/pkg/gas/block_history_estimator_test.go: `h = testutils.Head(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `h.BaseFeePerGas = assets.NewWeiI(500)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.OnNewLongestChain(tests.Context(t), h)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("with history size of 0, errors", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		var blockDelay uint16 = 3
		var historySize uint16
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		head := testutils.Head(42)
		err := bhe.FetchBlocks(tests.Context(t), head)
		require.Error(t, err)
		require.EqualError(t, err, "BlockHistoryEstimator: history size must be > 0, got: 0")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = blockDelay`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = historySize`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("with current block height less than block delay does nothing", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		var blockDelay uint16 = 3
		var historySize uint16 = 1
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		for i := -1; i < 3; i++ {
			head := testutils.Head(i)
			err := bhe.FetchBlocks(tests.Context(t), head)
			require.Error(t, err)
			require.EqualError(t, err, fmt.Sprintf("BlockHistoryEstimator: cannot fetch, current block height %v is lower than EVM.RPCBlockQueryDelay=3", i))
		}
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = blockDelay`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = historySize`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("with error retrieving blocks returns error", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		var blockDelay uint16 = 3
		var historySize uint16 = 3
		var batchSize uint32
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize
		bhCfg.BatchSizeF = batchSize
		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		ethClient.On("BatchCallContext", mock.Anything, mock.Anything).Return(pkgerrors.New("something exploded"))

		err := bhe.FetchBlocks(tests.Context(t), testutils.Head(42))
		require.Error(t, err)
		assert.EqualError(t, err, "BlockHistoryEstimator#fetchBlocks error fetching blocks with BatchCallContext: something exploded")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = blockDelay`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = historySize`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BatchSizeF = batchSize`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.Anything).Return(pkgerrors.New("something exploded"))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("batch fetches heads and transactions and sets them on the block history estimator instance", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		var blockDelay uint16
		var historySize uint16 = 3
		var batchSize uint32 = 2
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize
		// Test batching
		bhCfg.BatchSizeF = batchSize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b41 := evmtypes.Block{
			Number:       41,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}
		b42 := evmtypes.Block{
			Number:       42,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(3),
		}
		b43 := evmtypes.Block{
			Number:       43,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(),
		}

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(43) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(42) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b43
			// This errored block (42) will be ignored
			elems[1].Error = pkgerrors.New("something went wrong")
		})
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(41) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b41
		})

		err := bhe.FetchBlocks(tests.Context(t), testutils.Head(43))
		require.NoError(t, err)

		require.Len(t, gas.GetRollingBlockHistory(bhe), 2)
		assert.Equal(t, 41, int(gas.GetRollingBlockHistory(bhe)[0].Number))
		// 42 is missing because the fetch errored
		assert.Equal(t, 43, int(gas.GetRollingBlockHistory(bhe)[1].Number))
		assert.Len(t, gas.GetRollingBlockHistory(bhe)[0].Transactions, 2)
		assert.Empty(t, gas.GetRollingBlockHistory(bhe)[1].Transactions)

		// On new fetch, rolls over the history and drops the old heads

		b44 := evmtypes.Block{
			Number:       44,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(4),
		}

		// We are gonna refetch blocks 42 and 44
		// 43 is skipped because it was already in the history
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(44) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(42) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b44
			elems[1].Result = &b42
		})

		head := evmtypes.NewHead(big.NewInt(44), b44.Hash, b43.Hash, ubig.New(testutils.FixtureChainID))
		err = bhe.FetchBlocks(tests.Context(t), &head)
		require.NoError(t, err)

		require.Len(t, gas.GetRollingBlockHistory(bhe), 3)
		assert.Equal(t, 42, int(gas.GetRollingBlockHistory(bhe)[0].Number))
		assert.Equal(t, 43, int(gas.GetRollingBlockHistory(bhe)[1].Number))
		assert.Equal(t, 44, int(gas.GetRollingBlockHistory(bhe)[2].Number))
		assert.Len(t, gas.GetRollingBlockHistory(bhe)[0].Transactions, 1)
		assert.Empty(t, gas.GetRollingBlockHistory(bhe)[1].Transactions)
		assert.Len(t, gas.GetRollingBlockHistory(bhe)[2].Transactions, 1)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = blockDelay`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = historySize`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BatchSizeF = batchSize`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(43) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(42) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b43
			// This errored block (42) will be ignored
			elems[1].Error = pkgerrors.New("something went wrong")
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &b43`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[1].Error = pkgerrors.New("something went wrong")`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(41) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b41
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &b41`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(44) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(42) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b44
			elems[1].Result = &b42
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &b44`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[1].Result = &b42`
$DIR/pkg/gas/block_history_estimator_test.go: `err = bhe.FetchBlocks(tests.Context(t), &head)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("does not refetch blocks below EVM.FinalityDepth", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		var blockDelay uint16
		var historySize uint16 = 3
		var batchSize uint32 = 2
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize
		bhCfg.BatchSizeF = batchSize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b0 := evmtypes.Block{
			Number:       0,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(9001),
		}
		b1 := evmtypes.Block{
			Number:       1,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(9002),
		}
		blocks := []evmtypes.Block{b0, b1}

		gas.SetRollingBlockHistory(bhe, blocks)

		b2 := evmtypes.Block{
			Number:       2,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}
		b3 := evmtypes.Block{
			Number:       3,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(3) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(2) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b3
			elems[1].Result = &b2
		})

		head2 := evmtypes.NewHead(big.NewInt(2), b2.Hash, b1.Hash, ubig.New(testutils.FixtureChainID))
		head3 := evmtypes.NewHead(big.NewInt(3), b3.Hash, b2.Hash, ubig.New(testutils.FixtureChainID))
		head3.Parent.Store(&head2)
		err := bhe.FetchBlocks(tests.Context(t), &head3)
		require.NoError(t, err)

		require.Len(t, gas.GetRollingBlockHistory(bhe), 3)
		assert.Equal(t, 1, int(gas.GetRollingBlockHistory(bhe)[0].Number))
		assert.Equal(t, 2, int(gas.GetRollingBlockHistory(bhe)[1].Number))
		assert.Equal(t, 3, int(gas.GetRollingBlockHistory(bhe)[2].Number))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = blockDelay`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = historySize`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BatchSizeF = batchSize`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(3) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(2) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b3
			elems[1].Result = &b2
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &b3`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[1].Result = &b2`
$DIR/pkg/gas/block_history_estimator_test.go: `head3.Parent.Store(&head2)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("replaces blocks on re-org within EVM.FinalityDepth", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		var blockDelay uint16
		var historySize uint16 = 3
		var batchSize uint32 = 2
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize
		bhCfg.BatchSizeF = batchSize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b0 := evmtypes.Block{
			Number:       0,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(9001),
		}
		b1 := evmtypes.Block{
			Number:       1,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(9002),
		}
		b2 := evmtypes.Block{
			Number:       2,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}
		b3 := evmtypes.Block{
			Number:       3,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}
		blocks := []evmtypes.Block{b0, b1, b2, b3}

		gas.SetRollingBlockHistory(bhe, blocks)

		// RE-ORG, head2 and head3 have different hash than saved b2 and b3
		head2 := evmtypes.NewHead(big.NewInt(2), utils.NewHash(), b1.Hash, ubig.New(testutils.FixtureChainID))
		head3 := evmtypes.NewHead(big.NewInt(3), utils.NewHash(), head2.Hash, ubig.New(testutils.FixtureChainID))
		head3.Parent.Store(&head2)

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(3) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(2) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			b2New := b2
			b2New.Hash = head2.Hash
			elems[1].Result = &b2New
			b3New := b3
			b3New.Hash = head3.Hash
			elems[0].Result = &b3New
		})

		err := bhe.FetchBlocks(tests.Context(t), &head3)
		require.NoError(t, err)

		require.Len(t, gas.GetRollingBlockHistory(bhe), 3)
		assert.Equal(t, 1, int(gas.GetRollingBlockHistory(bhe)[0].Number))
		assert.Equal(t, 2, int(gas.GetRollingBlockHistory(bhe)[1].Number))
		assert.Equal(t, 3, int(gas.GetRollingBlockHistory(bhe)[2].Number))
		assert.Equal(t, b1.Hash.Hex(), gas.GetRollingBlockHistory(bhe)[0].Hash.Hex())
		assert.Equal(t, head2.Hash.Hex(), gas.GetRollingBlockHistory(bhe)[1].Hash.Hex())
		assert.Equal(t, head3.Hash.Hex(), gas.GetRollingBlockHistory(bhe)[2].Hash.Hex())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = blockDelay`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = historySize`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BatchSizeF = batchSize`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `head3.Parent.Store(&head2)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(3) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(2) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			b2New := b2
			b2New.Hash = head2.Hash
			elems[1].Result = &b2New
			b3New := b3
			b3New.Hash = head3.Hash
			elems[0].Result = &b3New
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `b2New.Hash = head2.Hash`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[1].Result = &b2New`
$DIR/pkg/gas/block_history_estimator_test.go: `b3New.Hash = head3.Hash`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &b3New`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("uses locally cached blocks if they are in the chain", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		var blockDelay uint16
		var historySize uint16 = 3
		var batchSize uint32 = 2
		bhCfg := newBlockHistoryConfig()
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize
		bhCfg.BatchSizeF = batchSize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b0 := evmtypes.Block{
			Number:       0,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(9001),
		}
		b1 := evmtypes.Block{
			Number:       1,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(9002),
		}
		b2 := evmtypes.Block{
			Number:       2,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}
		b3 := evmtypes.Block{
			Number:       3,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}
		blocks := []evmtypes.Block{b0, b1, b2, b3}

		gas.SetRollingBlockHistory(bhe, blocks)

		// head2 and head3 have identical hash to saved blocks
		head2 := evmtypes.NewHead(big.NewInt(2), b2.Hash, b1.Hash, ubig.New(testutils.FixtureChainID))
		head3 := evmtypes.NewHead(big.NewInt(3), b3.Hash, head2.Hash, ubig.New(testutils.FixtureChainID))
		head3.Parent.Store(&head2)

		err := bhe.FetchBlocks(tests.Context(t), &head3)
		require.NoError(t, err)

		require.Len(t, gas.GetRollingBlockHistory(bhe), 3)
		assert.Equal(t, 1, int(gas.GetRollingBlockHistory(bhe)[0].Number))
		assert.Equal(t, 2, int(gas.GetRollingBlockHistory(bhe)[1].Number))
		assert.Equal(t, 3, int(gas.GetRollingBlockHistory(bhe)[2].Number))
		assert.Equal(t, b1.Hash.Hex(), gas.GetRollingBlockHistory(bhe)[0].Hash.Hex())
		assert.Equal(t, head2.Hash.Hex(), gas.GetRollingBlockHistory(bhe)[1].Hash.Hex())
		assert.Equal(t, head3.Hash.Hex(), gas.GetRollingBlockHistory(bhe)[2].Hash.Hex())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = blockDelay`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = historySize`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BatchSizeF = batchSize`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `head3.Parent.Store(&head2)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = blockDelay`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = historySize`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BatchSizeF = batchSize`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = checkInclusionBlocks`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(43) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(42) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b43
			elems[1].Result = &b42
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &b43`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[1].Result = &b42`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = uint16(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = uint16(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BatchSizeF = uint32(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = uint16(5)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = assets.NewWeiI(1000)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
		return len(b) == 5 &&
			b[0].Args[0] == "0x4" &&
			b[1].Args[0] == "0x3" &&
			b[2].Args[0] == "0x2" &&
			b[3].Args[0] == "0x1" &&
			b[4].Args[0] == "0x0"
	})).Return(nil).Run(func(args mock.Arguments) {
		elems := args.Get(1).([]rpc.BatchElem)
		elems[0].Result = &b4
		elems[1].Result = &b3
		elems[2].Result = &b2
		elems[3].Result = &b1
		elems[4].Result = &b0
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &b4`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[1].Result = &b3`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[2].Result = &b2`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[3].Result = &b1`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[4].Result = &b0`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.FetchBlocksAndRecalculate(tests.Context(t), testutils.Head(4))`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = uint16(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(50)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = uint16(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BatchSizeF = uint32(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = uint16(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = assets.NewWeiI(1000)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.TipCapMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
		return len(b) == 3 &&
			b[0].Args[0] == "0x2" &&
			b[1].Args[0] == "0x1" &&
			b[2].Args[0] == "0x0"
	})).Return(nil).Run(func(args mock.Arguments) {
		elems := args.Get(1).([]rpc.BatchElem)
		elems[0].Result = &b2
		elems[1].Result = &b1
		elems[2].Result = &b0
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &b2`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[1].Result = &b1`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[2].Result = &b0`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.FetchBlocksAndRecalculate(tests.Context(t), testutils.Head(2))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("does not crash or set gas price to zero if there are no transactions", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		blocks := []evmtypes.Block{}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))

		blocks = []evmtypes.Block{{}}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))

		blocks = []evmtypes.Block{{Transactions: []evmtypes.Transaction{}}}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `blocks = []evmtypes.Block{{}}`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `blocks = []evmtypes.Block{{Transactions: []evmtypes.Transaction{}}}`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("sets gas price to EVM.GasEstimator.PriceMax if the calculation would otherwise exceed it", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = minGasPrice

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		blocks := []evmtypes.Block{
			{
				Number:       0,
				Hash:         utils.NewHash(),
				Transactions: legacyTransactionsFromGasPrices(9001),
			},
			{
				Number:       1,
				Hash:         utils.NewHash(),
				Transactions: legacyTransactionsFromGasPrices(9002),
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(1))

		price := gas.GetGasPrice(bhe)
		require.Equal(t, maxGasPrice, price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = minGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("sets gas price to EVM.GasEstimator.PriceMin if the calculation would otherwise fall below it", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = minGasPrice

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		blocks := []evmtypes.Block{
			{
				Number:       0,
				Hash:         utils.NewHash(),
				Transactions: legacyTransactionsFromGasPrices(5),
			},
			{
				Number:       1,
				Hash:         utils.NewHash(),
				Transactions: legacyTransactionsFromGasPrices(7),
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(1))

		price := gas.GetGasPrice(bhe)
		require.Equal(t, minGasPrice, price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = minGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("ignores any transaction with a zero gas limit", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(100)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = minGasPrice

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b1Hash := utils.NewHash()
		b2Hash := utils.NewHash()

		blocks := []evmtypes.Block{
			{
				Number:       0,
				Hash:         b1Hash,
				ParentHash:   common.Hash{},
				Transactions: legacyTransactionsFromGasPrices(50),
			},
			{
				Number:       1,
				Hash:         b2Hash,
				ParentHash:   b1Hash,
				Transactions: []evmtypes.Transaction{{GasPrice: assets.NewWeiI(70), GasLimit: 42}},
			},
			{
				Number:       2,
				Hash:         utils.NewHash(),
				ParentHash:   b2Hash,
				Transactions: []evmtypes.Transaction{{GasPrice: assets.NewWeiI(90), GasLimit: 0}},
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(2))

		price := gas.GetGasPrice(bhe)
		require.Equal(t, assets.NewWeiI(70), price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = minGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(2))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("takes into account zero priced transactions if chain is not Gnosis", func(t *testing.T) {
		// Because everyone loves free gas!
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		bhCfg.TransactionPercentileF = uint16(50)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b1Hash := utils.NewHash()

		blocks := []evmtypes.Block{
			{
				Number:       0,
				Hash:         b1Hash,
				ParentHash:   common.Hash{},
				Transactions: legacyTransactionsFromGasPrices(0, 0, 25, 50, 100),
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(0))

		price := gas.GetGasPrice(bhe)
		require.Equal(t, assets.NewWeiI(25), price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(50)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("ignores zero priced transactions only on Gnosis", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		bhCfg.TransactionPercentileF = uint16(50)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(11) // Has to be set as Gnosis will only ignore transactions below this price

		ibhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)
		bhe := gas.BlockHistoryEstimatorFromInterface(ibhe)

		b1Hash := utils.NewHash()

		blocks := []evmtypes.Block{
			{
				Number:       0,
				Hash:         b1Hash,
				ParentHash:   common.Hash{},
				Transactions: legacyTransactionsFromGasPrices(0, 0, 0, 0, 80),
			},
		}
		gas.SetRollingBlockHistory(bhe, blocks)

		// chainType is not set - GasEstimator should not ignore zero priced transactions and instead default to PriceMin==11
		bhe.Recalculate(testutils.Head(0))
		require.Equal(t, assets.NewWeiI(11), gas.GetGasPrice(bhe))

		// Set chainType to Gnosis - GasEstimator should now ignore zero priced transactions
		ibhe = newBlockHistoryEstimator(t, ethClient, chaintype.ChainGnosis, geCfg, bhCfg, l1Oracle)
		bhe = gas.BlockHistoryEstimatorFromInterface(ibhe)
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(0))
		require.Equal(t, assets.NewWeiI(80), gas.GetGasPrice(bhe))

		// And for X Layer
		ibhe = newBlockHistoryEstimator(t, ethClient, chaintype.ChainXLayer, geCfg, bhCfg, l1Oracle)
		bhe = gas.BlockHistoryEstimatorFromInterface(ibhe)
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(0))
		require.Equal(t, assets.NewWeiI(80), gas.GetGasPrice(bhe))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(50)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(11)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `ibhe = newBlockHistoryEstimator(t, ethClient, chaintype.ChainGnosis, geCfg, bhCfg, l1Oracle)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe = gas.BlockHistoryEstimatorFromInterface(ibhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `ibhe = newBlockHistoryEstimator(t, ethClient, chaintype.ChainXLayer, geCfg, bhCfg, l1Oracle)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe = gas.BlockHistoryEstimatorFromInterface(ibhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("handles unreasonably large gas prices (larger than a 64 bit int can hold)", func(t *testing.T) {
		// Seems unlikely we will ever experience gas prices > 9 Petawei on mainnet (praying to the eth Gods )
		// But other chains could easily use a different base of account
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		reasonablyHugeGasPrice := assets.NewWeiI(1000).Mul(big.NewInt(math.MaxInt64))

		bhCfg.TransactionPercentileF = uint16(50)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = reasonablyHugeGasPrice
		geCfg.PriceMinF = assets.NewWeiI(10)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		unreasonablyHugeGasPrice := assets.NewWeiI(1000000).Mul(big.NewInt(math.MaxInt64))

		b1Hash := utils.NewHash()

		blocks := []evmtypes.Block{
			{
				Number:     0,
				Hash:       b1Hash,
				ParentHash: common.Hash{},
				Transactions: []evmtypes.Transaction{
					{GasPrice: assets.NewWeiI(50), GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
				},
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(0))

		price := gas.GetGasPrice(bhe)
		require.Equal(t, reasonablyHugeGasPrice, price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(50)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = reasonablyHugeGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(50)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("does not crash or set gas price to zero if there are no transactions", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		blocks := []evmtypes.Block{}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))

		blocks = []evmtypes.Block{{}} // No base fee (doesn't crash)
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))

		blocks = []evmtypes.Block{newBlockWithBaseFee()}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))

		empty := newBlockWithBaseFee()
		empty.Transactions = []evmtypes.Transaction{}
		blocks = []evmtypes.Block{empty}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))

		withOnlyLegacyTransactions := newBlockWithBaseFee()
		withOnlyLegacyTransactions.Transactions = legacyTransactionsFromGasPrices(9001)
		blocks = []evmtypes.Block{withOnlyLegacyTransactions}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `blocks = []evmtypes.Block{{}}`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `blocks = []evmtypes.Block{newBlockWithBaseFee()}`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `empty.Transactions = []evmtypes.Transaction{}`
$DIR/pkg/gas/block_history_estimator_test.go: `blocks = []evmtypes.Block{empty}`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `withOnlyLegacyTransactions.Transactions = legacyTransactionsFromGasPrices(9001)`
$DIR/pkg/gas/block_history_estimator_test.go: `blocks = []evmtypes.Block{withOnlyLegacyTransactions}`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("does not set tip higher than EVM.GasEstimator.PriceMax", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)
		geCfg.TipCapMinF = assets.NewWeiI(0)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		blocks := []evmtypes.Block{
			{
				BaseFeePerGas: assets.NewWeiI(1),
				Number:        0,
				Hash:          utils.NewHash(),
				Transactions:  dynamicFeeTransactionsFromTipCaps(9001),
			},
			{
				BaseFeePerGas: assets.NewWeiI(1),
				Number:        1,
				Hash:          utils.NewHash(),
				Transactions:  dynamicFeeTransactionsFromTipCaps(9002),
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(1))

		tipCap := gas.GetTipCap(bhe)
		require.Equal(t, tipCap.Int64(), maxGasPrice.Int64())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.TipCapMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("sets tip cap to EVM.GasEstimator.TipCapMin if the calculation would otherwise fall below it", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)
		geCfg.TipCapMinF = assets.NewWeiI(10)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		blocks := []evmtypes.Block{
			{
				BaseFeePerGas: assets.NewWeiI(1),
				Number:        0,
				Hash:          utils.NewHash(),
				Transactions:  dynamicFeeTransactionsFromTipCaps(5),
			},
			{
				BaseFeePerGas: assets.NewWeiI(1),
				Number:        1,
				Hash:          utils.NewHash(),
				Transactions:  dynamicFeeTransactionsFromTipCaps(7),
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(1))

		price := gas.GetTipCap(bhe)
		require.Equal(t, assets.NewWeiI(10), price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.TipCapMinF = assets.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("ignores any transaction with a zero gas limit", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(95)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)
		geCfg.TipCapMinF = assets.NewWeiI(10)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b1Hash := utils.NewHash()
		b2Hash := utils.NewHash()

		blocks := []evmtypes.Block{
			{
				Number:       0,
				Hash:         b1Hash,
				ParentHash:   common.Hash{},
				Transactions: legacyTransactionsFromGasPrices(50),
			},
			{
				BaseFeePerGas: assets.NewWeiI(10),
				Number:        1,
				Hash:          b2Hash,
				ParentHash:    b1Hash,
				Transactions:  []evmtypes.Transaction{{Type: 0x2, MaxFeePerGas: assets.NewWeiI(1000), MaxPriorityFeePerGas: assets.NewWeiI(60), GasLimit: 42}},
			},
			{
				Number:       2,
				Hash:         utils.NewHash(),
				ParentHash:   b2Hash,
				Transactions: []evmtypes.Transaction{{Type: 0x2, MaxFeePerGas: assets.NewWeiI(1000), MaxPriorityFeePerGas: assets.NewWeiI(80), GasLimit: 0}},
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(2))

		price := gas.GetTipCap(bhe)
		require.Equal(t, assets.NewWeiI(60), price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(95)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.TipCapMinF = assets.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(2))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("respects minimum gas tip cap", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)
		geCfg.TipCapMinF = assets.NewWeiI(1)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b1Hash := utils.NewHash()

		blocks := []evmtypes.Block{
			{
				BaseFeePerGas: assets.NewWeiI(10),
				Number:        0,
				Hash:          b1Hash,
				ParentHash:    common.Hash{},
				Transactions:  dynamicFeeTransactionsFromTipCaps(0, 0, 0, 0, 100),
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(0))

		price := gas.GetTipCap(bhe)
		assert.Equal(t, assets.NewWeiI(1), price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.TipCapMinF = assets.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.TipCapMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("returns false if transaction has 0 gas limit", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x0, GasPrice: assets.NewWeiI(10), GasLimit: 0, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("returns false if transaction gas limit is nil and tx type is 0x0", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x0, GasPrice: nil, GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("returns false if transaction is of type 0x7e only on Optimism", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x7e, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainOptimismBedrock, geCfg.PriceMin(), logger.Test(t)))

		assert.True(t, bhe.IsUsable(tx, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("returns false if transaction is of type 0x7c, 0x7b, or 0x7e only on Celo", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x7c, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainCelo, geCfg.PriceMin(), logger.Test(t)))

		tx2 := evmtypes.Transaction{Type: 0x7b, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx2, block, chaintype.ChainCelo, geCfg.PriceMin(), logger.Test(t)))

		tx3 := evmtypes.Transaction{Type: 0x7e, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx2, block, chaintype.ChainCelo, geCfg.PriceMin(), logger.Test(t)))

		assert.True(t, bhe.IsUsable(tx, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
		assert.True(t, bhe.IsUsable(tx2, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
		assert.True(t, bhe.IsUsable(tx3, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("returns false if transaction is of type 0x16 only on WeMix", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x16, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainWeMix, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("returns false if transaction has base fee higher than the gas price only on Celo", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x0, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainCelo, geCfg.PriceMin(), logger.Test(t)))

		tx2 := evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(250),
			GasPrice: assets.NewWeiI(50), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainCelo, geCfg.PriceMin(), logger.Test(t)))

		assert.True(t, bhe.IsUsable(tx, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
		assert.True(t, bhe.IsUsable(tx2, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("returns false if transaction is of type 0x71 or 0xff only on zkSync", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x71, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainZkSync, geCfg.PriceMin(), logger.Test(t)))

		tx.Type = 0x02
		assert.True(t, bhe.IsUsable(tx, block, chaintype.ChainZkSync, geCfg.PriceMin(), logger.Test(t)))

		tx.Type = 0xff
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainZkSync, geCfg.PriceMin(), logger.Test(t)))

		assert.True(t, bhe.IsUsable(tx, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `tx.Type = 0x02`
$DIR/pkg/gas/block_history_estimator_test.go: `tx.Type = 0xff`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `eipblock.BaseFeePerGas = assets.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("returns nil if block is missing base fee", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x0, GasPrice: assets.NewWeiI(42), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveTipCap(block, tx)
		assert.Nil(t, res)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("legacy transaction type infers tip cap from tx.gas_price - block.base_fee_per_gas", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x0, GasPrice: assets.NewWeiI(142), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "42 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("tx type 2, 3, and 4 should calculate gas price", func(t *testing.T) {
		// 0x2 transaction (should use MaxPriorityFeePerGas)
		tx := evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "200 wei", res.String())
		// 0x2 transaction (should use MaxPriorityFeePerGas, ignoring gas price)
		tx = evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(400), MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "200 wei", res.String())

		// 0x3 transaction (should use MaxPriorityFeePerGas)
		tx = evmtypes.Transaction{Type: 0x3, MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "100 wei", res.String())
		// 0x3 transaction (should use MaxPriorityFeePerGas, ignoring gas price)
		tx = evmtypes.Transaction{Type: 0x3, GasPrice: assets.NewWeiI(400), MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "100 wei", res.String())

		// 0x4 transaction (should use MaxPriorityFeePerGas)
		tx = evmtypes.Transaction{Type: 0x4, MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "100 wei", res.String())
		// 0x4 transaction (should use MaxPriorityFeePerGas, ignoring gas price)
		tx = evmtypes.Transaction{Type: 0x4, GasPrice: assets.NewWeiI(400), MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "100 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(400), MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x3, MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x3, GasPrice: assets.NewWeiI(400), MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x4, MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x4, GasPrice: assets.NewWeiI(400), MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("missing field returns nil", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(132), MaxFeePerGas: assets.NewWeiI(200), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveTipCap(eipblock, tx)
		assert.Nil(t, res)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `eipblock.BaseFeePerGas = assets.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("legacy transaction type should use GasPrice", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x0, GasPrice: assets.NewWeiI(42), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "42 wei", res.String())
		tx = evmtypes.Transaction{Type: 0x0, GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Nil(t, res)
		tx = evmtypes.Transaction{Type: 0x1, GasPrice: assets.NewWeiI(42), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "42 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x0, GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x1, GasPrice: assets.NewWeiI(42), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("tx type 2 should calculate gas price", func(t *testing.T) {
		// 0x2 transaction (should calculate to 250)
		tx := evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "250 wei", res.String())
		// 0x2 transaction (should calculate to 300)
		tx = evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "300 wei", res.String())
		// 0x2 transaction (should calculate to 300, ignoring gas price)
		tx = evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "300 wei", res.String())
		// 0x2 transaction (should fall back to gas price since MaxFeePerGas is missing)
		tx = evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(32), MaxPriorityFeePerGas: assets.NewWeiI(200), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "32 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(32), MaxPriorityFeePerGas: assets.NewWeiI(200), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("tx type 3 should calculate gas price", func(t *testing.T) {
		// 0x3 transaction (should calculate to 250)
		tx := evmtypes.Transaction{Type: 0x3, MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(110), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "110 wei", res.String())
		// 0x3 transaction (should calculate to 300)
		tx = evmtypes.Transaction{Type: 0x3, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "300 wei", res.String())
		// 0x3 transaction (should calculate to 300, ignoring gas price)
		tx = evmtypes.Transaction{Type: 0x3, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "300 wei", res.String())
		// 0x3 transaction (should fall back to gas price since MaxFeePerGas is missing)
		tx = evmtypes.Transaction{Type: 0x3, GasPrice: assets.NewWeiI(5), MaxPriorityFeePerGas: assets.NewWeiI(200), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "5 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x3, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x3, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x3, GasPrice: assets.NewWeiI(5), MaxPriorityFeePerGas: assets.NewWeiI(200), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("tx type 4 should calculate gas price", func(t *testing.T) {
		// 0x4 transaction (should calculate to 250)
		tx := evmtypes.Transaction{Type: 0x4, MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(110), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "110 wei", res.String())
		// 0x4 transaction (should calculate to 300)
		tx = evmtypes.Transaction{Type: 0x4, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "300 wei", res.String())
		// 0x4 transaction (should calculate to 300, ignoring gas price)
		tx = evmtypes.Transaction{Type: 0x4, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "300 wei", res.String())
		// 0x4 transaction (should fall back to gas price since MaxFeePerGas is missing)
		tx = evmtypes.Transaction{Type: 0x4, GasPrice: assets.NewWeiI(5), MaxPriorityFeePerGas: assets.NewWeiI(200), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "5 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x4, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x4, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `tx = evmtypes.Transaction{Type: 0x4, GasPrice: assets.NewWeiI(5), MaxPriorityFeePerGas: assets.NewWeiI(200), GasLimit: 42, Hash: utils.NewHash()}`
$DIR/pkg/gas/block_history_estimator_test.go: `res = bhe.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("tx type 2 has block missing base fee (should never happen but must handle gracefully)", func(t *testing.T) {
		// 0x2 transaction (should calculate to 250)
		tx := evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(55555), MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(block, tx)
		assert.Equal(t, "55.555 kwei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("unknown type returns nil", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x5, GasPrice: assets.NewWeiI(55555), MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(block, tx)
		assert.Nil(t, res)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("Assumption violation of MaxFeePerGas >= BaseFeePerGas returns gas price if specified", func(t *testing.T) {
		// Max: 1, Base: 100
		tx := evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(42), MaxPriorityFeePerGas: assets.NewWeiI(1), MaxFeePerGas: assets.NewWeiI(1), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "42 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("Assumption violation of MaxFeePerGas >= MaxPriorityFeePerGas returns gas price if specified", func(t *testing.T) {
		// Max Priority: 201, Max: 200, Base: 100
		tx := evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(42), MaxPriorityFeePerGas: assets.NewWeiI(201), MaxFeePerGas: assets.NewWeiI(200), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "42 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("Assumption violation of MaxFeePerGas >= BaseFeePerGas returns nil if no gas price is specified", func(t *testing.T) {
		// Max: 1, Base: 100
		tx := evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(1), MaxFeePerGas: assets.NewWeiI(1), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Nil(t, res)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = uint16(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = uint16(8)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SimulateStart(t, bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("if gas price is lower than global max and user specified max gas price", func(t *testing.T) {
		fee, limit, err := bhe.GetLegacyGas(tests.Context(t), make([]byte, 0), 10000, maxGasPrice)
		require.NoError(t, err)

		assert.Equal(t, assets.NewWeiI(1000), fee)
		assert.Equal(t, 10000, int(limit))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("if gas price is higher than user-specified max", func(t *testing.T) {
		fee, limit, err := bhe.GetLegacyGas(tests.Context(t), make([]byte, 0), 10000, assets.NewWeiI(800))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWeiI(800), fee)
		assert.Equal(t, 10000, int(limit))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = assets.NewWeiI(700)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe = newBlockHistoryEstimator(t, nil, defaultChainType, geCfg, bhCfg, l1Oracle)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SimulateStart(t, bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("fallbacks to EvmGasPriceDefault if there aren't any valid transactions to estimate from.", func(t *testing.T) {
		bhCfg := newBlockHistoryConfig()

		bhCfg.BatchSizeF = batchSize
		bhCfg.TransactionPercentileF = uint16(35)
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = assets.NewWeiI(1000000)
		geCfg.PriceDefaultF = assets.NewWeiI(100)

		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		h := &evmtypes.Head{Hash: utils.NewHash(), Number: 42, BaseFeePerGas: nil}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(42) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(41) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[2].Method == "eth_getBlockByNumber" && b[2].Args[0] == gas.Int64ToHex(40) && b[1].Args[1].(bool) && reflect.TypeOf(b[2].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
			elems[1].Result = &evmtypes.Block{
				Number: 41,
				Hash:   utils.NewHash(),
			}
			elems[2].Result = &evmtypes.Block{
				Number:       40,
				Hash:         utils.NewHash(),
				Transactions: legacyTransactionsFromGasPricesTxType(specialTxTypeCode, 1),
			}
		}).Once()

		err := bhe.Start(tests.Context(t))
		require.NoError(t, err)

		fee, limit, err := bhe.GetLegacyGas(tests.Context(t), make([]byte, 0), 10000, assets.NewWeiI(800))
		require.NoError(t, err)
		require.Equal(t, geCfg.PriceDefault(), fee)
		assert.Equal(t, 10000, int(limit))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BatchSizeF = batchSize`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = blockDelay`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = historySize`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = assets.NewWeiI(1000000)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceDefaultF = assets.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(42) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(41) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[2].Method == "eth_getBlockByNumber" && b[2].Args[0] == gas.Int64ToHex(40) && b[1].Args[1].(bool) && reflect.TypeOf(b[2].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
			elems[1].Result = &evmtypes.Block{
				Number: 41,
				Hash:   utils.NewHash(),
			}
			elems[2].Result = &evmtypes.Block{
				Number:       40,
				Hash:         utils.NewHash(),
				Transactions: legacyTransactionsFromGasPricesTxType(specialTxTypeCode, 1),
			}
		}).Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[1].Result = &evmtypes.Block{
				Number: 41,
				Hash:   utils.NewHash(),
			}`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[2].Result = &evmtypes.Block{
				Number:       40,
				Hash:         utils.NewHash(),
				Transactions: legacyTransactionsFromGasPricesTxType(specialTxTypeCode, 1),
			}`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BatchSizeF = batchSize`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = blockDelay`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = historySize`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.EIP1559FeeCapBufferBlocksF = uint16(4)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = assets.NewWeiI(1000000)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceDefaultF = assets.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.TipCapDefaultF = assets.NewWeiI(50)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpThresholdF = uint64(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(42) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(41) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[2].Method == "eth_getBlockByNumber" && b[2].Args[0] == gas.Int64ToHex(40) && b[1].Args[1].(bool) && reflect.TypeOf(b[2].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
			elems[1].Result = &evmtypes.Block{
				Number: 41,
				Hash:   utils.NewHash(),
			}
			elems[2].Result = &evmtypes.Block{
				Number:       40,
				Hash:         utils.NewHash(),
				Transactions: dynamicFeeTransactionsFromTipCapsTxType(specialTxTypeCode, 1),
			}
		}).Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[1].Result = &evmtypes.Block{
				Number: 41,
				Hash:   utils.NewHash(),
			}`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[2].Result = &evmtypes.Block{
				Number:       40,
				Hash:         utils.NewHash(),
				Transactions: dynamicFeeTransactionsFromTipCapsTxType(specialTxTypeCode, 1),
			}`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.EIP1559FeeCapBufferBlocksF = uint16(4)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = uint16(35)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.TipCapMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SimulateStart(t, bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("if estimator is missing base fee and gas bumping is enabled", func(t *testing.T) {
		geCfg.BumpThresholdF = uint64(1)

		_, err := bhe.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "BlockHistoryEstimator: no value for latest block base fee; cannot estimate EIP-1559 base fee. Are you trying to run with EIP1559 enabled on a non-EIP1559 chain?")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpThresholdF = uint64(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("if estimator is missing base fee and gas bumping is disabled", func(t *testing.T) {
		geCfg.BumpThresholdF = uint64(0)

		fee, err := bhe.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.NoError(t, err)
		assert.Equal(t, gas.DynamicFee{GasFeeCap: maxGasPrice, GasTipCap: assets.NewWeiI(6000)}, fee)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpThresholdF = uint64(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `h.BaseFeePerGas = assets.NewWeiI(112500)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.OnNewLongestChain(tests.Context(t), h)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("if gas bumping is enabled", func(t *testing.T) {
		geCfg.BumpThresholdF = uint64(1)

		fee, err := bhe.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.NoError(t, err)

		assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(186203), GasTipCap: assets.NewWeiI(6000)}, fee)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpThresholdF = uint64(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("if gas bumping is disabled", func(t *testing.T) {
		geCfg.BumpThresholdF = uint64(0)

		fee, err := bhe.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.NoError(t, err)

		assert.Equal(t, gas.DynamicFee{GasFeeCap: maxGasPrice, GasTipCap: assets.NewWeiI(6000)}, fee)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpThresholdF = uint64(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("if gas bumping is enabled and local max gas price set", func(t *testing.T) {
		geCfg.BumpThresholdF = uint64(1)

		fee, err := bhe.GetDynamicFee(tests.Context(t), assets.NewWeiI(180000))
		require.NoError(t, err)

		assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(180000), GasTipCap: assets.NewWeiI(6000)}, fee)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpThresholdF = uint64(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("if bump threshold is 0 and local max gas price set", func(t *testing.T) {
		geCfg.BumpThresholdF = uint64(0)

		fee, err := bhe.GetDynamicFee(tests.Context(t), assets.NewWeiI(100))
		require.NoError(t, err)

		assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(100)}, fee)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpThresholdF = uint64(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `h = testutils.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `h.BaseFeePerGas = assets.NewWeiI(900000)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.OnNewLongestChain(tests.Context(t), h)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpThresholdF = uint64(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = uint16(4)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = uint16(90)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = assets.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("fails halt bumping check if estimator is not started", func(t *testing.T) {
		err := bhe.HaltBumping(attempts)
		require.Error(t, err, "BlockHistoryEstimator is not started; do not have max gas to allow bumping")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
		return len(b) == 1
	})).Return(nil).Run(func(args mock.Arguments) {
		elems := args.Get(1).([]rpc.BatchElem)
		elems[0].Result = &b0
	}).Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &b0`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("allows bumping check if CheckInclusionPercentile price failed to set due to no suitable transactions", func(t *testing.T) {
		err := bhe.HaltBumping(attempts)
		require.Error(t, err, "90 percentile price is not set. This is likely because there aren't any valid transactions to estimate from. Preventing bumping until valid price is available to compare")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, []evmtypes.Block{b0, b1, b2, b3})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("skips halt bumping check if attempts is nil or empty", func(t *testing.T) {
		err := bhe.HaltBumping(nil)
		require.NoError(t, err)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("returns error if one of the supplied attempts is missing BroadcastBeforeBlockNum", func(t *testing.T) {
		err := bhe.HaltBumping(attempts)
		require.Error(t, err)
		assert.Contains(t, err.Error(), fmt.Sprintf("BroadcastBeforeBlockNum was unexpectedly nil for attempt %s", attempts[0].TxHash))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `attempts = []gas.EvmPriorAttempt{
		{TxType: 0x3, BroadcastBeforeBlockNum: &num, TxHash: hash},
	}`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("returns error if one of the supplied attempts has an unknown transaction type", func(t *testing.T) {
		err := bhe.HaltBumping(attempts)
		require.Error(t, err)
		assert.Contains(t, err.Error(), fmt.Sprintf("attempt %s has unknown transaction type 0x3", hash))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `attempts = []gas.EvmPriorAttempt{
		{TxType: 0x0, BroadcastBeforeBlockNum: &num, TxHash: hash},
	}`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("in legacy mode", func(t *testing.T) {
		b0 = evmtypes.Block{
			Number:       0,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1000),
		}
		b1 = evmtypes.Block{
			Number:       1,
			Hash:         utils.NewHash(),
			ParentHash:   b0.Hash,
			Transactions: legacyTransactionsFromGasPrices(2, 3, 4, 5, 6),
		}
		b2 = evmtypes.Block{
			Number:       2,
			Hash:         utils.NewHash(),
			ParentHash:   b1.Hash,
			Transactions: legacyTransactionsFromGasPrices(4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9),
		}
		b3 = evmtypes.Block{
			Number:       3,
			Hash:         utils.NewHash(),
			ParentHash:   b2.Hash,
			Transactions: legacyTransactionsFromGasPrices(3, 4, 5, 6, 7),
		}
		gas.SetRollingBlockHistory(bhe, []evmtypes.Block{b0, b1, b2, b3})

		attempts = []gas.EvmPriorAttempt{
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(3), BroadcastBeforeBlockNum: ptr(int64(0))},
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(5), BroadcastBeforeBlockNum: ptr(int64(1))},
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(7), BroadcastBeforeBlockNum: ptr(int64(1))},
		}

		t.Run("passes check if all attempt gas prices are lower than or equal to percentile price", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 80 // percentile price is 7 wei
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.NoError(t, err)
		})
		t.Run("fails check if any attempt price is higher than percentile price", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 40 // percentile price is 5 wei
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has gas price of 7 wei, which is above percentile=40%% (percentile price: 5 wei)", attempts[2].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `b0 = evmtypes.Block{
			Number:       0,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1000),
		}`
$DIR/pkg/gas/block_history_estimator_test.go: `b1 = evmtypes.Block{
			Number:       1,
			Hash:         utils.NewHash(),
			ParentHash:   b0.Hash,
			Transactions: legacyTransactionsFromGasPrices(2, 3, 4, 5, 6),
		}`
$DIR/pkg/gas/block_history_estimator_test.go: `b2 = evmtypes.Block{
			Number:       2,
			Hash:         utils.NewHash(),
			ParentHash:   b1.Hash,
			Transactions: legacyTransactionsFromGasPrices(4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9),
		}`
$DIR/pkg/gas/block_history_estimator_test.go: `b3 = evmtypes.Block{
			Number:       3,
			Hash:         utils.NewHash(),
			ParentHash:   b2.Hash,
			Transactions: legacyTransactionsFromGasPrices(3, 4, 5, 6, 7),
		}`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, []evmtypes.Block{b0, b1, b2, b3})`
$DIR/pkg/gas/block_history_estimator_test.go: `attempts = []gas.EvmPriorAttempt{
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(3), BroadcastBeforeBlockNum: ptr(int64(0))},
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(5), BroadcastBeforeBlockNum: ptr(int64(1))},
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(7), BroadcastBeforeBlockNum: ptr(int64(1))},
		}`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("passes check if all attempt gas prices are lower than or equal to percentile price", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 80 // percentile price is 7 wei
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.NoError(t, err)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 3`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = 80`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("fails check if any attempt price is higher than percentile price", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 40 // percentile price is 5 wei
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has gas price of 7 wei, which is above percentile=40%% (percentile price: 5 wei)", attempts[2].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 3`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = 40`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("handles mixed legacy and EIP-1559 transactions", func(t *testing.T) {
		b0 = evmtypes.Block{
			BaseFeePerGas: assets.NewWeiI(1),
			Number:        3,
			Hash:          utils.NewHash(),
			Transactions:  append(legacyTransactionsFromGasPrices(1, 2, 3, 4, 5), dynamicFeeTransactionsFromTipCaps(6, 7, 8, 9, 10)...),
		}
		gas.SetRollingBlockHistory(bhe, []evmtypes.Block{b0})

		attempts = []gas.EvmPriorAttempt{
			{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(1), GasTipCap: assets.NewWeiI(3)}, BroadcastBeforeBlockNum: ptr(int64(0))},
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(10), BroadcastBeforeBlockNum: ptr(int64(0))},
		}

		t.Run("passes check if both transactions are ok", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 1
			bhCfg.CheckInclusionPercentileF = 90 // percentile price is 5 wei
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.NoError(t, err)
		})
		t.Run("fails check if legacy transaction fails", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 1
			bhCfg.CheckInclusionPercentileF = 60
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has gas price of 10 wei, which is above percentile=60%% (percentile price: 7 wei)", attempts[1].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})

		attempts = []gas.EvmPriorAttempt{
			{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(11), GasTipCap: assets.NewWeiI(10)}, BroadcastBeforeBlockNum: ptr(int64(0))},
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(3), BroadcastBeforeBlockNum: ptr(int64(0))},
		}

		t.Run("fails check if dynamic fee transaction fails", func(t *testing.T) {
			geCfg.EIP1559DynamicFeesF = true
			geCfg.TipCapMinF = assets.NewWeiI(1)
			bhCfg.CheckInclusionBlocksF = 1
			bhCfg.CheckInclusionPercentileF = 60
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has tip cap of 10 wei, which is above percentile=60%% (percentile tip cap: 6 wei)", attempts[0].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `b0 = evmtypes.Block{
			BaseFeePerGas: assets.NewWeiI(1),
			Number:        3,
			Hash:          utils.NewHash(),
			Transactions:  append(legacyTransactionsFromGasPrices(1, 2, 3, 4, 5), dynamicFeeTransactionsFromTipCaps(6, 7, 8, 9, 10)...),
		}`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, []evmtypes.Block{b0})`
$DIR/pkg/gas/block_history_estimator_test.go: `attempts = []gas.EvmPriorAttempt{
			{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(1), GasTipCap: assets.NewWeiI(3)}, BroadcastBeforeBlockNum: ptr(int64(0))},
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(10), BroadcastBeforeBlockNum: ptr(int64(0))},
		}`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("passes check if both transactions are ok", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 1
			bhCfg.CheckInclusionPercentileF = 90 // percentile price is 5 wei
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.NoError(t, err)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 1`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = 90`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("fails check if legacy transaction fails", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 1
			bhCfg.CheckInclusionPercentileF = 60
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has gas price of 10 wei, which is above percentile=60%% (percentile price: 7 wei)", attempts[1].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 1`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = 60`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `attempts = []gas.EvmPriorAttempt{
			{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(11), GasTipCap: assets.NewWeiI(10)}, BroadcastBeforeBlockNum: ptr(int64(0))},
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(3), BroadcastBeforeBlockNum: ptr(int64(0))},
		}`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("fails check if dynamic fee transaction fails", func(t *testing.T) {
			geCfg.EIP1559DynamicFeesF = true
			geCfg.TipCapMinF = assets.NewWeiI(1)
			bhCfg.CheckInclusionBlocksF = 1
			bhCfg.CheckInclusionPercentileF = 60
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has tip cap of 10 wei, which is above percentile=60%% (percentile tip cap: 6 wei)", attempts[0].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.TipCapMinF = assets.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 1`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = 60`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `b0 = evmtypes.Block{
			BaseFeePerGas: assets.NewWeiI(5),
			Number:        0,
			Hash:          utils.NewHash(),
			Transactions:  dynamicFeeTransactionsFromTipCaps(1000),
		}`
$DIR/pkg/gas/block_history_estimator_test.go: `b1 = evmtypes.Block{
			BaseFeePerGas: assets.NewWeiI(8),
			Number:        1,
			Hash:          utils.NewHash(),
			ParentHash:    b0.Hash,
			Transactions:  dynamicFeeTransactionsFromTipCaps(2, 3, 4, 5, 6),
		}`
$DIR/pkg/gas/block_history_estimator_test.go: `b2 = evmtypes.Block{
			BaseFeePerGas: assets.NewWeiI(13),
			Number:        2,
			Hash:          utils.NewHash(),
			ParentHash:    b1.Hash,
			Transactions:  dynamicFeeTransactionsFromTipCaps(4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9),
		}`
$DIR/pkg/gas/block_history_estimator_test.go: `b3 = evmtypes.Block{
			BaseFeePerGas: assets.NewWeiI(21),
			Number:        3,
			Hash:          utils.NewHash(),
			ParentHash:    b2.Hash,
			Transactions:  dynamicFeeTransactionsFromTipCaps(3, 4, 5, 6, 7),
		}`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `attempts = []gas.EvmPriorAttempt{
			{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(30), GasTipCap: assets.NewWeiI(3)}, BroadcastBeforeBlockNum: ptr(int64(0))},
			{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(30), GasTipCap: assets.NewWeiI(5)}, BroadcastBeforeBlockNum: ptr(int64(1))},
			{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(30), GasTipCap: assets.NewWeiI(7)}, BroadcastBeforeBlockNum: ptr(int64(1))},
		}`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("passes check if 90th percentile price higher than highest transaction tip cap", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 80
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.NoError(t, err)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 3`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = 80`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("fails check if percentile tip cap higher than any transaction tip cap, and base fee higher than the block base fee", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 20
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has tip cap of 5 wei, which is above percentile=20%% (percentile tip cap: 4 wei)", attempts[1].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)

			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 2
			bhe.Recalculate(testutils.Head(3))

			err = bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has tip cap of 3 wei, which is above percentile=2%% (percentile tip cap: 2 wei)", attempts[0].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 3`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = 20`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 3`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = 2`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `err = bhe.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("passes check if, for at least one block, feecap < tipcap+basefee, even if percentile is not reached", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 5
			bhe.Recalculate(testutils.Head(3))

			attempts = []gas.EvmPriorAttempt{
				{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(4), GasTipCap: assets.NewWeiI(7)}, BroadcastBeforeBlockNum: ptr(int64(1))},
			}

			err := bhe.HaltBumping(attempts)
			require.NoError(t, err)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 3`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = 5`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `attempts = []gas.EvmPriorAttempt{
				{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(4), GasTipCap: assets.NewWeiI(7)}, BroadcastBeforeBlockNum: ptr(int64(1))},
			}`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("BumpLegacyGas halts bumping", func(t *testing.T) {
		bhCfg.BlockDelayF = 0
		bhCfg.CheckInclusionBlocksF = 1
		bhCfg.CheckInclusionPercentileF = 10
		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.BumpPercentF = 10
		geCfg.BumpMinF = assets.NewWeiI(150)
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)
		l1Oracle := rollupMocks.NewL1Oracle(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ctx := tests.Context(t)

		bhe := gas.BlockHistoryEstimatorFromInterface(
			gas.NewBlockHistoryEstimator(logger.Test(t), ethClient, defaultChainType, geCfg, bhCfg, testutils.NewRandomEVMChainID(), l1Oracle),
		)

		b0 := evmtypes.Block{
			Number:       0,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1),
		}
		h := testutils.Head(0)
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil).Once()
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b0
		}).Once()
		err := bhe.Start(ctx)
		require.NoError(t, err)

		attempts := []gas.EvmPriorAttempt{
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(1000), BroadcastBeforeBlockNum: ptr(int64(0))},
		}
		_, _, err = bhe.BumpLegacyGas(ctx, assets.NewWeiI(42), 100000, maxGasPrice, attempts)
		require.Error(t, err)
		assert.True(t, pkgerrors.Is(err, fees.ErrConnectivity))
		assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has gas price of 1 kwei, which is above percentile=10%% (percentile price: 1 wei)", attempts[0].TxHash))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = 0`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 1`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = 10`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpPercentF = 10`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpMinF = assets.NewWeiI(150)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil).Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b0
		}).Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &b0`
$DIR/pkg/gas/block_history_estimator_test.go: `_, _, err = bhe.BumpLegacyGas(ctx, assets.NewWeiI(42), 100000, maxGasPrice, attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("BumpLegacyGas calls BumpLegacyGasPriceOnly with proper current gas price", func(t *testing.T) {
		bhCfg := newBlockHistoryConfig()
		bhCfg.CheckInclusionBlocksF = 0
		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.BumpPercentF = 10
		geCfg.BumpMinF = assets.NewWeiI(150)
		geCfg.PriceMaxF = maxGasPrice
		l1Oracle := rollupMocks.NewL1Oracle(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ctx := tests.Context(t)

		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, nil).Once()
		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)
		err := bhe.Start(ctx)
		require.NoError(t, err)

		t.Run("ignores nil current gas price", func(t *testing.T) {
			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			expectedGasPrice, err := gas.BumpLegacyGasPriceOnly(geCfg, logger.TestSugared(t), nil, assets.NewWeiI(42), maxGasPrice)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, expectedGasPrice, gasPrice)
		})

		t.Run("ignores current gas price > max gas price", func(t *testing.T) {
			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			massive := assets.NewWeiI(100000000000000)
			gas.SetGasPrice(bhe, massive)

			expectedGasPrice, err := gas.BumpLegacyGasPriceOnly(geCfg, logger.TestSugared(t), massive, assets.NewWeiI(42), maxGasPrice)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, expectedGasPrice, gasPrice)
		})

		t.Run("ignores current gas price < bumped gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(191))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, assets.NewWeiI(192), gasPrice)
		})

		t.Run("uses current gas price > bumped gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(193))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, assets.NewWeiI(193), gasPrice)
		})

		t.Run("bumped gas price > max gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(191))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, assets.NewWeiI(100), nil)
			require.Error(t, err)

			assert.Nil(t, gasPrice)
			assert.Equal(t, 0, int(gasLimit))
			assert.Contains(t, err.Error(), "bumped gas price of 192 wei would exceed configured max gas price of 100 wei (original price was 42 wei).")
		})

		t.Run("current gas price > max gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(193))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, assets.NewWeiI(100), nil)
			require.Error(t, err)

			assert.Nil(t, gasPrice)
			assert.Equal(t, 0, int(gasLimit))
			assert.Contains(t, err.Error(), "bumped gas price of 192 wei would exceed configured max gas price of 100 wei (original price was 42 wei).")
		})
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 0`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpPercentF = 10`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpMinF = assets.NewWeiI(150)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, nil).Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("ignores nil current gas price", func(t *testing.T) {
			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			expectedGasPrice, err := gas.BumpLegacyGasPriceOnly(geCfg, logger.TestSugared(t), nil, assets.NewWeiI(42), maxGasPrice)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, expectedGasPrice, gasPrice)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("ignores current gas price > max gas price", func(t *testing.T) {
			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			massive := assets.NewWeiI(100000000000000)
			gas.SetGasPrice(bhe, massive)

			expectedGasPrice, err := gas.BumpLegacyGasPriceOnly(geCfg, logger.TestSugared(t), massive, assets.NewWeiI(42), maxGasPrice)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, expectedGasPrice, gasPrice)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetGasPrice(bhe, massive)`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("ignores current gas price < bumped gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(191))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, assets.NewWeiI(192), gasPrice)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetGasPrice(bhe, assets.NewWeiI(191))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("uses current gas price > bumped gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(193))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, assets.NewWeiI(193), gasPrice)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetGasPrice(bhe, assets.NewWeiI(193))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("bumped gas price > max gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(191))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, assets.NewWeiI(100), nil)
			require.Error(t, err)

			assert.Nil(t, gasPrice)
			assert.Equal(t, 0, int(gasLimit))
			assert.Contains(t, err.Error(), "bumped gas price of 192 wei would exceed configured max gas price of 100 wei (original price was 42 wei).")
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetGasPrice(bhe, assets.NewWeiI(191))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("current gas price > max gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(193))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, assets.NewWeiI(100), nil)
			require.Error(t, err)

			assert.Nil(t, gasPrice)
			assert.Equal(t, 0, int(gasLimit))
			assert.Contains(t, err.Error(), "bumped gas price of 192 wei would exceed configured max gas price of 100 wei (original price was 42 wei).")
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetGasPrice(bhe, assets.NewWeiI(193))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("BumpDynamicFee checks connectivity", func(t *testing.T) {
		bhCfg := newBlockHistoryConfig()
		bhCfg.CheckInclusionBlocksF = 1
		bhCfg.CheckInclusionPercentileF = 10
		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true
		geCfg.BumpPercentF = 10
		geCfg.BumpMinF = assets.NewWeiI(150)
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)
		geCfg.TipCapMinF = assets.NewWeiI(0)
		l1Oracle := rollupMocks.NewL1Oracle(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ctx := tests.Context(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b0 := evmtypes.Block{
			BaseFeePerGas: assets.NewWeiI(1),
			Number:        0,
			Hash:          utils.NewHash(),
			Transactions:  dynamicFeeTransactionsFromTipCaps(1),
		}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(testutils.Head(0), nil).Once()
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b0
		}).Once()
		err := bhe.Start(ctx)
		require.NoError(t, err)

		originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(25)}
		attempts := []gas.EvmPriorAttempt{
			{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasTipCap: originalFee.GasTipCap, GasFeeCap: originalFee.GasFeeCap}, BroadcastBeforeBlockNum: ptr(int64(0))}}

		_, err = bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, attempts)
		require.Error(t, err)
		assert.True(t, pkgerrors.Is(err, fees.ErrConnectivity))
		assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has tip cap of 25 wei, which is above percentile=10%% (percentile tip cap: 1 wei)", attempts[0].TxHash))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 1`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = 10`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpPercentF = 10`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpMinF = assets.NewWeiI(150)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.TipCapMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(testutils.Head(0), nil).Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b0
		}).Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &b0`
$DIR/pkg/gas/block_history_estimator_test.go: `_, err = bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpPercentF = 10`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.BumpMinF = assets.NewWeiI(150)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.TipCapDefaultF = assets.NewWeiI(52)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, nil).Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("when current tip cap is nil", func(t *testing.T) {
			originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(25)}
			fee, err := bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(250), GasTipCap: assets.NewWeiI(202)}, fee)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("ignores current tip cap that is smaller than original fee with bump applied", func(t *testing.T) {
			gas.SetTipCap(bhe, assets.NewWeiI(201))

			originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(25)}
			fee, err := bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(250), GasTipCap: assets.NewWeiI(202)}, fee)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetTipCap(bhe, assets.NewWeiI(201))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("uses current tip cap that is larger than original fee with bump applied", func(t *testing.T) {
			gas.SetTipCap(bhe, assets.NewWeiI(203))

			originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(25)}
			fee, err := bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(250), GasTipCap: assets.NewWeiI(203)}, fee)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetTipCap(bhe, assets.NewWeiI(203))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("ignores absurdly large current tip cap", func(t *testing.T) {
			gas.SetTipCap(bhe, assets.NewWeiI(1000000000000000))

			originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(25)}
			fee, err := bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(250), GasTipCap: assets.NewWeiI(202)}, fee)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetTipCap(bhe, assets.NewWeiI(1000000000000000))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("bumped tip cap price > max gas price", func(t *testing.T) {
			gas.SetTipCap(bhe, assets.NewWeiI(203))

			originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(990000)}
			fee, err := bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)
			require.Error(t, err)

			assert.Equal(t, gas.DynamicFee{}, fee)
			assert.Contains(t, err.Error(), "bumped tip cap of 1.089 mwei would exceed configured max gas price of 1 mwei (original fee: tip cap 990 kwei, fee cap 100 wei)")
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetTipCap(bhe, assets.NewWeiI(203))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("bumped fee cap price > max gas price", func(t *testing.T) {
			gas.SetTipCap(bhe, assets.NewWeiI(203))

			originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(990000), GasTipCap: assets.NewWeiI(25)}
			fee, err := bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)
			require.Error(t, err)

			assert.Equal(t, gas.DynamicFee{}, fee)
			assert.Contains(t, err.Error(), "bumped fee cap of 1.089 mwei would exceed configured max gas price of 1 mwei (original fee: tip cap 25 wei, fee cap 990 kwei)")
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `gas.SetTipCap(bhe, assets.NewWeiI(203))`
$DIR/pkg/gas/block_history_estimator_test.go: `t.Run("sets CheckInclusionPercentile price using the latest blocks, eip-1559 disabled", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		bhCfg.BlockDelayF = 0
		bhCfg.TransactionPercentileF = 35
		// Set BlockHistorySize larger than CheckInclusionBlocks to cache more blocks than needed for calculation
		// Helps test whether the latest block is being used or not
		bhCfg.BlockHistorySizeF = 3
		bhCfg.BatchSizeF = 0
		bhCfg.CheckInclusionBlocksF = 1
		bhCfg.CheckInclusionPercentileF = 100

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = assets.NewWeiI(1000)
		geCfg.PriceMinF = assets.NewWeiI(0)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b0 := evmtypes.Block{
			Number:       0,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2, 3),
		}
		b1 := evmtypes.Block{
			Number:       1,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(4, 5, 6),
		}
		b2 := evmtypes.Block{
			Number:       2,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(7, 8, 9),
		}

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Args[0] == "0x2" &&
				b[1].Args[0] == "0x1" &&
				b[2].Args[0] == "0x0"
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b2
			elems[1].Result = &b1
			elems[2].Result = &b0
		})

		bhe.FetchBlocksAndRecalculate(tests.Context(t), testutils.Head(2))

		price := gas.GetMaxPercentileGasPrice(bhe)
		require.Equal(t, assets.NewWeiI(9), price)

		assert.Len(t, gas.GetRollingBlockHistory(bhe), 3)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = 0`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = 35`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = 3`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BatchSizeF = 0`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 1`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = 100`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = false`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = assets.NewWeiI(1000)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Args[0] == "0x2" &&
				b[1].Args[0] == "0x1" &&
				b[2].Args[0] == "0x0"
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b2
			elems[1].Result = &b1
			elems[2].Result = &b0
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &b2`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[1].Result = &b1`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[2].Result = &b0`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.FetchBlocksAndRecalculate(tests.Context(t), testutils.Head(2))`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockDelayF = 0`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.TransactionPercentileF = 35`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BlockHistorySizeF = 3`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.BatchSizeF = 0`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionBlocksF = 1`
$DIR/pkg/gas/block_history_estimator_test.go: `bhCfg.CheckInclusionPercentileF = 100`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.EIP1559DynamicFeesF = true`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMaxF = assets.NewWeiI(1000)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.PriceMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `geCfg.TipCapMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Args[0] == "0x2" &&
				b[1].Args[0] == "0x1" &&
				b[2].Args[0] == "0x0"
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b2
			elems[1].Result = &b1
			elems[2].Result = &b0
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[0].Result = &b2`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[1].Result = &b1`
$DIR/pkg/gas/block_history_estimator_test.go: `elems[2].Result = &b0`
$DIR/pkg/gas/block_history_estimator_test.go: `bhe.FetchBlocksAndRecalculate(tests.Context(t), testutils.Head(2))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("loads initial state", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		h := &evmtypes.Head{Hash: utils.NewHash(), Number: 42, BaseFeePerGas: assets.NewWeiI(420)}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == "0x2a" && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == "0x29" && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
			elems[1].Result = &evmtypes.Block{
				Number: 41,
				Hash:   utils.NewHash(),
			}
		}).Once()

		err := bhe.Start(tests.Context(t))
		require.NoError(t, err)

		assert.Len(t, gas.GetRollingBlockHistory(bhe), 2)
		assert.Equal(t, 41, int(gas.GetRollingBlockHistory(bhe)[0].Number))
		assert.Equal(t, 42, int(gas.GetRollingBlockHistory(bhe)[1].Number))

		assert.Equal(t, assets.NewWeiI(420), gas.GetLatestBaseFee(bhe))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(420)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == "0x2a" && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == "0x29" && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == "0x2a" && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == "0x29" && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[0].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[1].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
			elems[1].Result = &evmtypes.Block{
				Number: 41,
				Hash:   utils.NewHash(),
			}
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(tests.Context(t))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("starts and loads partial history if fetch context times out", func(t *testing.T) {
		geCfg2 := &gas.MockGasEstimatorConfig{}
		geCfg2.EIP1559DynamicFeesF = true
		geCfg2.PriceMinF = minGasPrice

		bhCfg2 := newBlockHistoryConfig()
		bhCfg2.BatchSizeF = uint32(1)
		bhCfg2.BlockDelayF = blockDelay
		bhCfg2.BlockHistorySizeF = historySize
		bhCfg2.TransactionPercentileF = percentile

		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg2, bhCfg2, l1Oracle)

		h := &evmtypes.Head{Hash: utils.NewHash(), Number: 42, BaseFeePerGas: assets.NewWeiI(420)}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)
		// First succeeds (42)
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(42) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
		}).Once()
		// Second fails (41)
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(41) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Return(pkgerrors.Wrap(context.DeadlineExceeded, "some error message")).Once()

		err := bhe.Start(tests.Context(t))
		require.NoError(t, err)

		require.Len(t, gas.GetRollingBlockHistory(bhe), 1)
		assert.Equal(t, 42, int(gas.GetRollingBlockHistory(bhe)[0].Number))

		assert.Equal(t, assets.NewWeiI(420), gas.GetLatestBaseFee(bhe))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(420)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(42) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(42) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[0].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(41) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(41) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(41)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[0].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(pkgerrors.Wrap(context.DeadlineExceeded, "some error message"))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Wrap(context.DeadlineExceeded, "some error message")`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(tests.Context(t))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("boots even if initial batch call returns nothing", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		h := &evmtypes.Head{Hash: utils.NewHash(), Number: 42}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == int(historySize)
		})).Return(nil)

		err := bhe.Start(tests.Context(t))
		require.NoError(t, err)

		// non-eip1559 block
		assert.Nil(t, gas.GetLatestBaseFee(bhe))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == int(historySize)
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == int(historySize)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(tests.Context(t))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("starts anyway if fetching latest head fails", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, pkgerrors.New("something exploded"))

		err := bhe.Start(tests.Context(t))
		require.NoError(t, err)

		assert.Nil(t, gas.GetLatestBaseFee(bhe))

		_, _, err = bhe.GetLegacyGas(tests.Context(t), make([]byte, 0), 100, maxGasPrice)
		require.Error(t, err)
		require.Contains(t, err.Error(), "has not finished the first gas estimation yet, likely because a failure on start")

		_, err = bhe.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.Error(t, err)
		require.Contains(t, err.Error(), "has not finished the first gas estimation yet, likely because a failure on start")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil, pkgerrors.New("something exploded"))`
$DIR/pkg/gas/block_history_estimator_test.go: `.New("something exploded")`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(tests.Context(t))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetLegacyGas(tests.Context(t), make([]byte, 0), 100, maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("starts anyway if fetching first fetch fails, but errors on estimation", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		h := &evmtypes.Head{Hash: utils.NewHash(), Number: 42, BaseFeePerGas: assets.NewWeiI(420)}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)
		ethClient.On("BatchCallContext", mock.Anything, mock.Anything).Return(pkgerrors.New("something went wrong"))

		err := bhe.Start(tests.Context(t))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWeiI(420), gas.GetLatestBaseFee(bhe))

		_, _, err = bhe.GetLegacyGas(tests.Context(t), make([]byte, 0), 100, maxGasPrice)
		require.Error(t, err)
		require.Contains(t, err.Error(), "has not finished the first gas estimation yet, likely because a failure on start")

		_, err = bhe.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.Error(t, err)
		require.Contains(t, err.Error(), "has not finished the first gas estimation yet, likely because a failure on start")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(420)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.Anything)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(pkgerrors.New("something went wrong"))`
$DIR/pkg/gas/block_history_estimator_test.go: `.New("something went wrong")`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(tests.Context(t))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetLegacyGas(tests.Context(t), make([]byte, 0), 100, maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("returns error if main context is cancelled", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		h := &evmtypes.Head{Hash: utils.NewHash(), Number: 42, BaseFeePerGas: assets.NewWeiI(420)}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)
		ethClient.On("BatchCallContext", mock.Anything, mock.Anything).Return(pkgerrors.New("this error doesn't matter"))

		ctx, cancel := context.WithCancel(tests.Context(t))
		cancel()
		err := bhe.Start(ctx)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "context canceled")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(420)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.Anything)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(pkgerrors.New("this error doesn't matter"))`
$DIR/pkg/gas/block_history_estimator_test.go: `.New("this error doesn't matter")`
$DIR/pkg/gas/block_history_estimator_test.go: `.WithCancel(tests.Context(t))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(ctx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(420)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.Anything)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(pkgerrors.New("this error doesn't matter"))`
$DIR/pkg/gas/block_history_estimator_test.go: `.New("this error doesn't matter")`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(_ mock.Arguments) {
			time.Sleep(gas.MaxStartTime + 1*time.Second)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Sleep(gas.MaxStartTime + 1*time.Second)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(tests.Context(t))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetLegacyGas(tests.Context(t), make([]byte, 0), 100, maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.OnNewLongestChain(tests.Context(t), h)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(500)`
$DIR/pkg/gas/block_history_estimator_test.go: `.OnNewLongestChain(tests.Context(t), h)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(500)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetLatestBaseFee(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("with history size of 0, errors", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		var blockDelay uint16 = 3
		var historySize uint16
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		head := testutils.Head(42)
		err := bhe.FetchBlocks(tests.Context(t), head)
		require.Error(t, err)
		require.EqualError(t, err, "BlockHistoryEstimator: history size must be > 0, got: 0")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.FetchBlocks(tests.Context(t), head)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("with current block height less than block delay does nothing", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		var blockDelay uint16 = 3
		var historySize uint16 = 1
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		for i := -1; i < 3; i++ {
			head := testutils.Head(i)
			err := bhe.FetchBlocks(tests.Context(t), head)
			require.Error(t, err)
			require.EqualError(t, err, fmt.Sprintf("BlockHistoryEstimator: cannot fetch, current block height %v is lower than EVM.RPCBlockQueryDelay=3", i))
		}
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(i)`
$DIR/pkg/gas/block_history_estimator_test.go: `.FetchBlocks(tests.Context(t), head)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("with error retrieving blocks returns error", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		var blockDelay uint16 = 3
		var historySize uint16 = 3
		var batchSize uint32
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize
		bhCfg.BatchSizeF = batchSize
		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		ethClient.On("BatchCallContext", mock.Anything, mock.Anything).Return(pkgerrors.New("something exploded"))

		err := bhe.FetchBlocks(tests.Context(t), testutils.Head(42))
		require.Error(t, err)
		assert.EqualError(t, err, "BlockHistoryEstimator#fetchBlocks error fetching blocks with BatchCallContext: something exploded")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.Anything)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(pkgerrors.New("something exploded"))`
$DIR/pkg/gas/block_history_estimator_test.go: `.New("something exploded")`
$DIR/pkg/gas/block_history_estimator_test.go: `.FetchBlocks(tests.Context(t), testutils.Head(42))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("batch fetches heads and transactions and sets them on the block history estimator instance", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		var blockDelay uint16
		var historySize uint16 = 3
		var batchSize uint32 = 2
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize
		// Test batching
		bhCfg.BatchSizeF = batchSize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b41 := evmtypes.Block{
			Number:       41,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}
		b42 := evmtypes.Block{
			Number:       42,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(3),
		}
		b43 := evmtypes.Block{
			Number:       43,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(),
		}

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(43) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(42) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b43
			// This errored block (42) will be ignored
			elems[1].Error = pkgerrors.New("something went wrong")
		})
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(41) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b41
		})

		err := bhe.FetchBlocks(tests.Context(t), testutils.Head(43))
		require.NoError(t, err)

		require.Len(t, gas.GetRollingBlockHistory(bhe), 2)
		assert.Equal(t, 41, int(gas.GetRollingBlockHistory(bhe)[0].Number))
		// 42 is missing because the fetch errored
		assert.Equal(t, 43, int(gas.GetRollingBlockHistory(bhe)[1].Number))
		assert.Len(t, gas.GetRollingBlockHistory(bhe)[0].Transactions, 2)
		assert.Empty(t, gas.GetRollingBlockHistory(bhe)[1].Transactions)

		// On new fetch, rolls over the history and drops the old heads

		b44 := evmtypes.Block{
			Number:       44,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(4),
		}

		// We are gonna refetch blocks 42 and 44
		// 43 is skipped because it was already in the history
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(44) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(42) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b44
			elems[1].Result = &b42
		})

		head := evmtypes.NewHead(big.NewInt(44), b44.Hash, b43.Hash, ubig.New(testutils.FixtureChainID))
		err = bhe.FetchBlocks(tests.Context(t), &head)
		require.NoError(t, err)

		require.Len(t, gas.GetRollingBlockHistory(bhe), 3)
		assert.Equal(t, 42, int(gas.GetRollingBlockHistory(bhe)[0].Number))
		assert.Equal(t, 43, int(gas.GetRollingBlockHistory(bhe)[1].Number))
		assert.Equal(t, 44, int(gas.GetRollingBlockHistory(bhe)[2].Number))
		assert.Len(t, gas.GetRollingBlockHistory(bhe)[0].Transactions, 1)
		assert.Empty(t, gas.GetRollingBlockHistory(bhe)[1].Transactions)
		assert.Len(t, gas.GetRollingBlockHistory(bhe)[2].Transactions, 1)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(43) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(42) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(43) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(42) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(43)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[0].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[1].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b43
			// This errored block (42) will be ignored
			elems[1].Error = pkgerrors.New("something went wrong")
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.New("something went wrong")`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(41) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(41) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{})
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(41)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[0].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b41
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.FetchBlocks(tests.Context(t), testutils.Head(43))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(43)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(44) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(42) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(44) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(42) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(44)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[0].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[1].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b44
			elems[1].Result = &b42
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHead(big.NewInt(44), b44.Hash, b43.Hash, ubig.New(testutils.FixtureChainID))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewInt(44)`
$DIR/pkg/gas/block_history_estimator_test.go: `.New(testutils.FixtureChainID)`
$DIR/pkg/gas/block_history_estimator_test.go: `.FetchBlocks(tests.Context(t), &head)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("does not refetch blocks below EVM.FinalityDepth", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		var blockDelay uint16
		var historySize uint16 = 3
		var batchSize uint32 = 2
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize
		bhCfg.BatchSizeF = batchSize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b0 := evmtypes.Block{
			Number:       0,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(9001),
		}
		b1 := evmtypes.Block{
			Number:       1,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(9002),
		}
		blocks := []evmtypes.Block{b0, b1}

		gas.SetRollingBlockHistory(bhe, blocks)

		b2 := evmtypes.Block{
			Number:       2,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}
		b3 := evmtypes.Block{
			Number:       3,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(3) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(2) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b3
			elems[1].Result = &b2
		})

		head2 := evmtypes.NewHead(big.NewInt(2), b2.Hash, b1.Hash, ubig.New(testutils.FixtureChainID))
		head3 := evmtypes.NewHead(big.NewInt(3), b3.Hash, b2.Hash, ubig.New(testutils.FixtureChainID))
		head3.Parent.Store(&head2)
		err := bhe.FetchBlocks(tests.Context(t), &head3)
		require.NoError(t, err)

		require.Len(t, gas.GetRollingBlockHistory(bhe), 3)
		assert.Equal(t, 1, int(gas.GetRollingBlockHistory(bhe)[0].Number))
		assert.Equal(t, 2, int(gas.GetRollingBlockHistory(bhe)[1].Number))
		assert.Equal(t, 3, int(gas.GetRollingBlockHistory(bhe)[2].Number))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(3) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(2) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(3) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(2) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[0].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[1].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b3
			elems[1].Result = &b2
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHead(big.NewInt(2), b2.Hash, b1.Hash, ubig.New(testutils.FixtureChainID))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewInt(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.New(testutils.FixtureChainID)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHead(big.NewInt(3), b3.Hash, b2.Hash, ubig.New(testutils.FixtureChainID))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewInt(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.New(testutils.FixtureChainID)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Parent.Store(&head2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.FetchBlocks(tests.Context(t), &head3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("replaces blocks on re-org within EVM.FinalityDepth", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		var blockDelay uint16
		var historySize uint16 = 3
		var batchSize uint32 = 2
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize
		bhCfg.BatchSizeF = batchSize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b0 := evmtypes.Block{
			Number:       0,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(9001),
		}
		b1 := evmtypes.Block{
			Number:       1,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(9002),
		}
		b2 := evmtypes.Block{
			Number:       2,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}
		b3 := evmtypes.Block{
			Number:       3,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}
		blocks := []evmtypes.Block{b0, b1, b2, b3}

		gas.SetRollingBlockHistory(bhe, blocks)

		// RE-ORG, head2 and head3 have different hash than saved b2 and b3
		head2 := evmtypes.NewHead(big.NewInt(2), utils.NewHash(), b1.Hash, ubig.New(testutils.FixtureChainID))
		head3 := evmtypes.NewHead(big.NewInt(3), utils.NewHash(), head2.Hash, ubig.New(testutils.FixtureChainID))
		head3.Parent.Store(&head2)

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(3) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(2) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Once().Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			b2New := b2
			b2New.Hash = head2.Hash
			elems[1].Result = &b2New
			b3New := b3
			b3New.Hash = head3.Hash
			elems[0].Result = &b3New
		})

		err := bhe.FetchBlocks(tests.Context(t), &head3)
		require.NoError(t, err)

		require.Len(t, gas.GetRollingBlockHistory(bhe), 3)
		assert.Equal(t, 1, int(gas.GetRollingBlockHistory(bhe)[0].Number))
		assert.Equal(t, 2, int(gas.GetRollingBlockHistory(bhe)[1].Number))
		assert.Equal(t, 3, int(gas.GetRollingBlockHistory(bhe)[2].Number))
		assert.Equal(t, b1.Hash.Hex(), gas.GetRollingBlockHistory(bhe)[0].Hash.Hex())
		assert.Equal(t, head2.Hash.Hex(), gas.GetRollingBlockHistory(bhe)[1].Hash.Hex())
		assert.Equal(t, head3.Hash.Hex(), gas.GetRollingBlockHistory(bhe)[2].Hash.Hex())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHead(big.NewInt(2), utils.NewHash(), b1.Hash, ubig.New(testutils.FixtureChainID))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewInt(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.New(testutils.FixtureChainID)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHead(big.NewInt(3), utils.NewHash(), head2.Hash, ubig.New(testutils.FixtureChainID))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewInt(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.New(testutils.FixtureChainID)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Parent.Store(&head2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(3) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(2) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(3) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(2) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[0].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[1].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			b2New := b2
			b2New.Hash = head2.Hash
			elems[1].Result = &b2New
			b3New := b3
			b3New.Hash = head3.Hash
			elems[0].Result = &b3New
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.FetchBlocks(tests.Context(t), &head3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("uses locally cached blocks if they are in the chain", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		var blockDelay uint16
		var historySize uint16 = 3
		var batchSize uint32 = 2
		bhCfg := newBlockHistoryConfig()
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize
		bhCfg.BatchSizeF = batchSize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b0 := evmtypes.Block{
			Number:       0,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(9001),
		}
		b1 := evmtypes.Block{
			Number:       1,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(9002),
		}
		b2 := evmtypes.Block{
			Number:       2,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}
		b3 := evmtypes.Block{
			Number:       3,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2),
		}
		blocks := []evmtypes.Block{b0, b1, b2, b3}

		gas.SetRollingBlockHistory(bhe, blocks)

		// head2 and head3 have identical hash to saved blocks
		head2 := evmtypes.NewHead(big.NewInt(2), b2.Hash, b1.Hash, ubig.New(testutils.FixtureChainID))
		head3 := evmtypes.NewHead(big.NewInt(3), b3.Hash, head2.Hash, ubig.New(testutils.FixtureChainID))
		head3.Parent.Store(&head2)

		err := bhe.FetchBlocks(tests.Context(t), &head3)
		require.NoError(t, err)

		require.Len(t, gas.GetRollingBlockHistory(bhe), 3)
		assert.Equal(t, 1, int(gas.GetRollingBlockHistory(bhe)[0].Number))
		assert.Equal(t, 2, int(gas.GetRollingBlockHistory(bhe)[1].Number))
		assert.Equal(t, 3, int(gas.GetRollingBlockHistory(bhe)[2].Number))
		assert.Equal(t, b1.Hash.Hex(), gas.GetRollingBlockHistory(bhe)[0].Hash.Hex())
		assert.Equal(t, head2.Hash.Hex(), gas.GetRollingBlockHistory(bhe)[1].Hash.Hex())
		assert.Equal(t, head3.Hash.Hex(), gas.GetRollingBlockHistory(bhe)[2].Hash.Hex())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHead(big.NewInt(2), b2.Hash, b1.Hash, ubig.New(testutils.FixtureChainID))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewInt(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.New(testutils.FixtureChainID)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHead(big.NewInt(3), b3.Hash, head2.Hash, ubig.New(testutils.FixtureChainID))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewInt(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.New(testutils.FixtureChainID)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Parent.Store(&head2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.FetchBlocks(tests.Context(t), &head3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(43) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(42) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(43) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(42) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{})
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(43)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[0].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[1].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b43
			elems[1].Result = &b42
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.FetchBlocks(tests.Context(t), testutils.Head(43))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(43)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
		return len(b) == 5 &&
			b[0].Args[0] == "0x4" &&
			b[1].Args[0] == "0x3" &&
			b[2].Args[0] == "0x2" &&
			b[3].Args[0] == "0x1" &&
			b[4].Args[0] == "0x0"
	}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
		return len(b) == 5 &&
			b[0].Args[0] == "0x4" &&
			b[1].Args[0] == "0x3" &&
			b[2].Args[0] == "0x2" &&
			b[3].Args[0] == "0x1" &&
			b[4].Args[0] == "0x0"
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
		elems := args.Get(1).([]rpc.BatchElem)
		elems[0].Result = &b4
		elems[1].Result = &b3
		elems[2].Result = &b2
		elems[3].Result = &b1
		elems[4].Result = &b0
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.FetchBlocksAndRecalculate(tests.Context(t), testutils.Head(4))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(4)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetGasPrice(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetRollingBlockHistory(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
		return len(b) == 3 &&
			b[0].Args[0] == "0x2" &&
			b[1].Args[0] == "0x1" &&
			b[2].Args[0] == "0x0"
	}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
		return len(b) == 3 &&
			b[0].Args[0] == "0x2" &&
			b[1].Args[0] == "0x1" &&
			b[2].Args[0] == "0x0"
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
		elems := args.Get(1).([]rpc.BatchElem)
		elems[0].Result = &b2
		elems[1].Result = &b1
		elems[2].Result = &b0
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.FetchBlocksAndRecalculate(tests.Context(t), testutils.Head(2))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetTipCap(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetRollingBlockHistory(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("does not crash or set gas price to zero if there are no transactions", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		blocks := []evmtypes.Block{}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))

		blocks = []evmtypes.Block{{}}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))

		blocks = []evmtypes.Block{{Transactions: []evmtypes.Transaction{}}}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("sets gas price to EVM.GasEstimator.PriceMax if the calculation would otherwise exceed it", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = minGasPrice

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		blocks := []evmtypes.Block{
			{
				Number:       0,
				Hash:         utils.NewHash(),
				Transactions: legacyTransactionsFromGasPrices(9001),
			},
			{
				Number:       1,
				Hash:         utils.NewHash(),
				Transactions: legacyTransactionsFromGasPrices(9002),
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(1))

		price := gas.GetGasPrice(bhe)
		require.Equal(t, maxGasPrice, price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetGasPrice(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("sets gas price to EVM.GasEstimator.PriceMin if the calculation would otherwise fall below it", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = minGasPrice

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		blocks := []evmtypes.Block{
			{
				Number:       0,
				Hash:         utils.NewHash(),
				Transactions: legacyTransactionsFromGasPrices(5),
			},
			{
				Number:       1,
				Hash:         utils.NewHash(),
				Transactions: legacyTransactionsFromGasPrices(7),
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(1))

		price := gas.GetGasPrice(bhe)
		require.Equal(t, minGasPrice, price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetGasPrice(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("ignores any transaction with a zero gas limit", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(100)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = minGasPrice

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b1Hash := utils.NewHash()
		b2Hash := utils.NewHash()

		blocks := []evmtypes.Block{
			{
				Number:       0,
				Hash:         b1Hash,
				ParentHash:   common.Hash{},
				Transactions: legacyTransactionsFromGasPrices(50),
			},
			{
				Number:       1,
				Hash:         b2Hash,
				ParentHash:   b1Hash,
				Transactions: []evmtypes.Transaction{{GasPrice: assets.NewWeiI(70), GasLimit: 42}},
			},
			{
				Number:       2,
				Hash:         utils.NewHash(),
				ParentHash:   b2Hash,
				Transactions: []evmtypes.Transaction{{GasPrice: assets.NewWeiI(90), GasLimit: 0}},
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(2))

		price := gas.GetGasPrice(bhe)
		require.Equal(t, assets.NewWeiI(70), price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(70)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(90)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(2))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetGasPrice(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("takes into account zero priced transactions if chain is not Gnosis", func(t *testing.T) {
		// Because everyone loves free gas!
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		bhCfg.TransactionPercentileF = uint16(50)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b1Hash := utils.NewHash()

		blocks := []evmtypes.Block{
			{
				Number:       0,
				Hash:         b1Hash,
				ParentHash:   common.Hash{},
				Transactions: legacyTransactionsFromGasPrices(0, 0, 25, 50, 100),
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(0))

		price := gas.GetGasPrice(bhe)
		require.Equal(t, assets.NewWeiI(25), price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetGasPrice(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("ignores zero priced transactions only on Gnosis", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		bhCfg.TransactionPercentileF = uint16(50)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(11) // Has to be set as Gnosis will only ignore transactions below this price

		ibhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)
		bhe := gas.BlockHistoryEstimatorFromInterface(ibhe)

		b1Hash := utils.NewHash()

		blocks := []evmtypes.Block{
			{
				Number:       0,
				Hash:         b1Hash,
				ParentHash:   common.Hash{},
				Transactions: legacyTransactionsFromGasPrices(0, 0, 0, 0, 80),
			},
		}
		gas.SetRollingBlockHistory(bhe, blocks)

		// chainType is not set - GasEstimator should not ignore zero priced transactions and instead default to PriceMin==11
		bhe.Recalculate(testutils.Head(0))
		require.Equal(t, assets.NewWeiI(11), gas.GetGasPrice(bhe))

		// Set chainType to Gnosis - GasEstimator should now ignore zero priced transactions
		ibhe = newBlockHistoryEstimator(t, ethClient, chaintype.ChainGnosis, geCfg, bhCfg, l1Oracle)
		bhe = gas.BlockHistoryEstimatorFromInterface(ibhe)
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(0))
		require.Equal(t, assets.NewWeiI(80), gas.GetGasPrice(bhe))

		// And for X Layer
		ibhe = newBlockHistoryEstimator(t, ethClient, chaintype.ChainXLayer, geCfg, bhCfg, l1Oracle)
		bhe = gas.BlockHistoryEstimatorFromInterface(ibhe)
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(0))
		require.Equal(t, assets.NewWeiI(80), gas.GetGasPrice(bhe))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(11)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BlockHistoryEstimatorFromInterface(ibhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BlockHistoryEstimatorFromInterface(ibhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BlockHistoryEstimatorFromInterface(ibhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("handles unreasonably large gas prices (larger than a 64 bit int can hold)", func(t *testing.T) {
		// Seems unlikely we will ever experience gas prices > 9 Petawei on mainnet (praying to the eth Gods )
		// But other chains could easily use a different base of account
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		reasonablyHugeGasPrice := assets.NewWeiI(1000).Mul(big.NewInt(math.MaxInt64))

		bhCfg.TransactionPercentileF = uint16(50)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = reasonablyHugeGasPrice
		geCfg.PriceMinF = assets.NewWeiI(10)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		unreasonablyHugeGasPrice := assets.NewWeiI(1000000).Mul(big.NewInt(math.MaxInt64))

		b1Hash := utils.NewHash()

		blocks := []evmtypes.Block{
			{
				Number:     0,
				Hash:       b1Hash,
				ParentHash: common.Hash{},
				Transactions: []evmtypes.Transaction{
					{GasPrice: assets.NewWeiI(50), GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
					{GasPrice: unreasonablyHugeGasPrice, GasLimit: 42},
				},
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(0))

		price := gas.GetGasPrice(bhe)
		require.Equal(t, reasonablyHugeGasPrice, price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Mul(big.NewInt(math.MaxInt64))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewInt(math.MaxInt64)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Mul(big.NewInt(math.MaxInt64))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewInt(math.MaxInt64)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(50)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetGasPrice(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetGasPrice(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("does not crash or set gas price to zero if there are no transactions", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		blocks := []evmtypes.Block{}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))

		blocks = []evmtypes.Block{{}} // No base fee (doesn't crash)
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))

		blocks = []evmtypes.Block{newBlockWithBaseFee()}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))

		empty := newBlockWithBaseFee()
		empty.Transactions = []evmtypes.Transaction{}
		blocks = []evmtypes.Block{empty}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))

		withOnlyLegacyTransactions := newBlockWithBaseFee()
		withOnlyLegacyTransactions.Transactions = legacyTransactionsFromGasPrices(9001)
		blocks = []evmtypes.Block{withOnlyLegacyTransactions}
		gas.SetRollingBlockHistory(bhe, blocks)
		bhe.Recalculate(testutils.Head(1))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("does not set tip higher than EVM.GasEstimator.PriceMax", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)
		geCfg.TipCapMinF = assets.NewWeiI(0)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		blocks := []evmtypes.Block{
			{
				BaseFeePerGas: assets.NewWeiI(1),
				Number:        0,
				Hash:          utils.NewHash(),
				Transactions:  dynamicFeeTransactionsFromTipCaps(9001),
			},
			{
				BaseFeePerGas: assets.NewWeiI(1),
				Number:        1,
				Hash:          utils.NewHash(),
				Transactions:  dynamicFeeTransactionsFromTipCaps(9002),
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(1))

		tipCap := gas.GetTipCap(bhe)
		require.Equal(t, tipCap.Int64(), maxGasPrice.Int64())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetTipCap(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("sets tip cap to EVM.GasEstimator.TipCapMin if the calculation would otherwise fall below it", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)
		geCfg.TipCapMinF = assets.NewWeiI(10)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		blocks := []evmtypes.Block{
			{
				BaseFeePerGas: assets.NewWeiI(1),
				Number:        0,
				Hash:          utils.NewHash(),
				Transactions:  dynamicFeeTransactionsFromTipCaps(5),
			},
			{
				BaseFeePerGas: assets.NewWeiI(1),
				Number:        1,
				Hash:          utils.NewHash(),
				Transactions:  dynamicFeeTransactionsFromTipCaps(7),
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(1))

		price := gas.GetTipCap(bhe)
		require.Equal(t, assets.NewWeiI(10), price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetTipCap(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("ignores any transaction with a zero gas limit", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(95)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)
		geCfg.TipCapMinF = assets.NewWeiI(10)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b1Hash := utils.NewHash()
		b2Hash := utils.NewHash()

		blocks := []evmtypes.Block{
			{
				Number:       0,
				Hash:         b1Hash,
				ParentHash:   common.Hash{},
				Transactions: legacyTransactionsFromGasPrices(50),
			},
			{
				BaseFeePerGas: assets.NewWeiI(10),
				Number:        1,
				Hash:          b2Hash,
				ParentHash:    b1Hash,
				Transactions:  []evmtypes.Transaction{{Type: 0x2, MaxFeePerGas: assets.NewWeiI(1000), MaxPriorityFeePerGas: assets.NewWeiI(60), GasLimit: 42}},
			},
			{
				Number:       2,
				Hash:         utils.NewHash(),
				ParentHash:   b2Hash,
				Transactions: []evmtypes.Transaction{{Type: 0x2, MaxFeePerGas: assets.NewWeiI(1000), MaxPriorityFeePerGas: assets.NewWeiI(80), GasLimit: 0}},
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(2))

		price := gas.GetTipCap(bhe)
		require.Equal(t, assets.NewWeiI(60), price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(60)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(80)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(2))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetTipCap(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("respects minimum gas tip cap", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()

		bhCfg.TransactionPercentileF = uint16(35)

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)
		geCfg.TipCapMinF = assets.NewWeiI(1)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b1Hash := utils.NewHash()

		blocks := []evmtypes.Block{
			{
				BaseFeePerGas: assets.NewWeiI(10),
				Number:        0,
				Hash:          b1Hash,
				ParentHash:    common.Hash{},
				Transactions:  dynamicFeeTransactionsFromTipCaps(0, 0, 0, 0, 100),
			},
		}

		gas.SetRollingBlockHistory(bhe, blocks)

		bhe.Recalculate(testutils.Head(0))

		price := gas.GetTipCap(bhe)
		assert.Equal(t, assets.NewWeiI(1), price)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetTipCap(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(0))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetTipCap(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("returns false if transaction has 0 gas limit", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x0, GasPrice: assets.NewWeiI(10), GasLimit: 0, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("returns false if transaction gas limit is nil and tx type is 0x0", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x0, GasPrice: nil, GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("returns false if transaction is of type 0x7e only on Optimism", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x7e, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainOptimismBedrock, geCfg.PriceMin(), logger.Test(t)))

		assert.True(t, bhe.IsUsable(tx, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("returns false if transaction is of type 0x7c, 0x7b, or 0x7e only on Celo", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x7c, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainCelo, geCfg.PriceMin(), logger.Test(t)))

		tx2 := evmtypes.Transaction{Type: 0x7b, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx2, block, chaintype.ChainCelo, geCfg.PriceMin(), logger.Test(t)))

		tx3 := evmtypes.Transaction{Type: 0x7e, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx2, block, chaintype.ChainCelo, geCfg.PriceMin(), logger.Test(t)))

		assert.True(t, bhe.IsUsable(tx, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
		assert.True(t, bhe.IsUsable(tx2, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
		assert.True(t, bhe.IsUsable(tx3, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("returns false if transaction is of type 0x16 only on WeMix", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x16, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainWeMix, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("returns false if transaction has base fee higher than the gas price only on Celo", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x0, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainCelo, geCfg.PriceMin(), logger.Test(t)))

		tx2 := evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(250),
			GasPrice: assets.NewWeiI(50), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainCelo, geCfg.PriceMin(), logger.Test(t)))

		assert.True(t, bhe.IsUsable(tx, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
		assert.True(t, bhe.IsUsable(tx2, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(250)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(50)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("returns false if transaction is of type 0x71 or 0xff only on zkSync", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x71, GasPrice: assets.NewWeiI(10), GasLimit: 42, Hash: utils.NewHash()}
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainZkSync, geCfg.PriceMin(), logger.Test(t)))

		tx.Type = 0x02
		assert.True(t, bhe.IsUsable(tx, block, chaintype.ChainZkSync, geCfg.PriceMin(), logger.Test(t)))

		tx.Type = 0xff
		assert.False(t, bhe.IsUsable(tx, block, chaintype.ChainZkSync, geCfg.PriceMin(), logger.Test(t)))

		assert.True(t, bhe.IsUsable(tx, block, defaultChainType, geCfg.PriceMin(), logger.Test(t)))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("returns nil if block is missing base fee", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x0, GasPrice: assets.NewWeiI(42), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveTipCap(block, tx)
		assert.Nil(t, res)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveTipCap(block, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("legacy transaction type infers tip cap from tx.gas_price - block.base_fee_per_gas", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x0, GasPrice: assets.NewWeiI(142), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "42 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(142)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("tx type 2, 3, and 4 should calculate gas price", func(t *testing.T) {
		// 0x2 transaction (should use MaxPriorityFeePerGas)
		tx := evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "200 wei", res.String())
		// 0x2 transaction (should use MaxPriorityFeePerGas, ignoring gas price)
		tx = evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(400), MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "200 wei", res.String())

		// 0x3 transaction (should use MaxPriorityFeePerGas)
		tx = evmtypes.Transaction{Type: 0x3, MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "100 wei", res.String())
		// 0x3 transaction (should use MaxPriorityFeePerGas, ignoring gas price)
		tx = evmtypes.Transaction{Type: 0x3, GasPrice: assets.NewWeiI(400), MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "100 wei", res.String())

		// 0x4 transaction (should use MaxPriorityFeePerGas)
		tx = evmtypes.Transaction{Type: 0x4, MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "100 wei", res.String())
		// 0x4 transaction (should use MaxPriorityFeePerGas, ignoring gas price)
		tx = evmtypes.Transaction{Type: 0x4, GasPrice: assets.NewWeiI(400), MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveTipCap(eipblock, tx)
		assert.Equal(t, "100 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(250)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(400)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(350)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(250)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(400)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(350)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(250)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(400)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(350)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("missing field returns nil", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(132), MaxFeePerGas: assets.NewWeiI(200), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveTipCap(eipblock, tx)
		assert.Nil(t, res)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(132)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(55555)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(250)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveTipCap(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("legacy transaction type should use GasPrice", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x0, GasPrice: assets.NewWeiI(42), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "42 wei", res.String())
		tx = evmtypes.Transaction{Type: 0x0, GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Nil(t, res)
		tx = evmtypes.Transaction{Type: 0x1, GasPrice: assets.NewWeiI(42), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "42 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("tx type 2 should calculate gas price", func(t *testing.T) {
		// 0x2 transaction (should calculate to 250)
		tx := evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "250 wei", res.String())
		// 0x2 transaction (should calculate to 300)
		tx = evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "300 wei", res.String())
		// 0x2 transaction (should calculate to 300, ignoring gas price)
		tx = evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "300 wei", res.String())
		// 0x2 transaction (should fall back to gas price since MaxFeePerGas is missing)
		tx = evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(32), MaxPriorityFeePerGas: assets.NewWeiI(200), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "32 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(250)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(350)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(350)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(32)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("tx type 3 should calculate gas price", func(t *testing.T) {
		// 0x3 transaction (should calculate to 250)
		tx := evmtypes.Transaction{Type: 0x3, MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(110), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "110 wei", res.String())
		// 0x3 transaction (should calculate to 300)
		tx = evmtypes.Transaction{Type: 0x3, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "300 wei", res.String())
		// 0x3 transaction (should calculate to 300, ignoring gas price)
		tx = evmtypes.Transaction{Type: 0x3, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "300 wei", res.String())
		// 0x3 transaction (should fall back to gas price since MaxFeePerGas is missing)
		tx = evmtypes.Transaction{Type: 0x3, GasPrice: assets.NewWeiI(5), MaxPriorityFeePerGas: assets.NewWeiI(200), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "5 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(110)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(350)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(350)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(5)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("tx type 4 should calculate gas price", func(t *testing.T) {
		// 0x4 transaction (should calculate to 250)
		tx := evmtypes.Transaction{Type: 0x4, MaxPriorityFeePerGas: assets.NewWeiI(100), MaxFeePerGas: assets.NewWeiI(110), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "110 wei", res.String())
		// 0x4 transaction (should calculate to 300)
		tx = evmtypes.Transaction{Type: 0x4, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "300 wei", res.String())
		// 0x4 transaction (should calculate to 300, ignoring gas price)
		tx = evmtypes.Transaction{Type: 0x4, MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(350), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "300 wei", res.String())
		// 0x4 transaction (should fall back to gas price since MaxFeePerGas is missing)
		tx = evmtypes.Transaction{Type: 0x4, GasPrice: assets.NewWeiI(5), MaxPriorityFeePerGas: assets.NewWeiI(200), GasLimit: 42, Hash: utils.NewHash()}
		res = bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "5 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(110)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(350)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(350)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(5)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("tx type 2 has block missing base fee (should never happen but must handle gracefully)", func(t *testing.T) {
		// 0x2 transaction (should calculate to 250)
		tx := evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(55555), MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(block, tx)
		assert.Equal(t, "55.555 kwei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(55555)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(250)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(block, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("unknown type returns nil", func(t *testing.T) {
		tx := evmtypes.Transaction{Type: 0x5, GasPrice: assets.NewWeiI(55555), MaxPriorityFeePerGas: assets.NewWeiI(200), MaxFeePerGas: assets.NewWeiI(250), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(block, tx)
		assert.Nil(t, res)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(55555)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(250)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(block, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("Assumption violation of MaxFeePerGas >= BaseFeePerGas returns gas price if specified", func(t *testing.T) {
		// Max: 1, Base: 100
		tx := evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(42), MaxPriorityFeePerGas: assets.NewWeiI(1), MaxFeePerGas: assets.NewWeiI(1), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "42 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("Assumption violation of MaxFeePerGas >= MaxPriorityFeePerGas returns gas price if specified", func(t *testing.T) {
		// Max Priority: 201, Max: 200, Base: 100
		tx := evmtypes.Transaction{Type: 0x2, GasPrice: assets.NewWeiI(42), MaxPriorityFeePerGas: assets.NewWeiI(201), MaxFeePerGas: assets.NewWeiI(200), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Equal(t, "42 wei", res.String())
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(201)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("Assumption violation of MaxFeePerGas >= BaseFeePerGas returns nil if no gas price is specified", func(t *testing.T) {
		// Max: 1, Base: 100
		tx := evmtypes.Transaction{Type: 0x2, MaxPriorityFeePerGas: assets.NewWeiI(1), MaxFeePerGas: assets.NewWeiI(1), GasLimit: 42, Hash: utils.NewHash()}
		res := bhe.EffectiveGasPrice(eipblock, tx)
		assert.Nil(t, res)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(201)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.EffectiveGasPrice(eipblock, tx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Unmarshal([]byte(blockJSON), &block)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Unmarshal([]byte(blockJSON), &block)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Hash.String()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SimulateStart(t, bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("if gas price is lower than global max and user specified max gas price", func(t *testing.T) {
		fee, limit, err := bhe.GetLegacyGas(tests.Context(t), make([]byte, 0), 10000, maxGasPrice)
		require.NoError(t, err)

		assert.Equal(t, assets.NewWeiI(1000), fee)
		assert.Equal(t, 10000, int(limit))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetLegacyGas(tests.Context(t), make([]byte, 0), 10000, maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("if gas price is higher than user-specified max", func(t *testing.T) {
		fee, limit, err := bhe.GetLegacyGas(tests.Context(t), make([]byte, 0), 10000, assets.NewWeiI(800))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWeiI(800), fee)
		assert.Equal(t, 10000, int(limit))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetLegacyGas(tests.Context(t), make([]byte, 0), 10000, assets.NewWeiI(800))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(800)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(700)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SimulateStart(t, bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetLegacyGas(tests.Context(t), make([]byte, 0), 10000, maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("fallbacks to EvmGasPriceDefault if there aren't any valid transactions to estimate from.", func(t *testing.T) {
		bhCfg := newBlockHistoryConfig()

		bhCfg.BatchSizeF = batchSize
		bhCfg.TransactionPercentileF = uint16(35)
		bhCfg.BlockDelayF = blockDelay
		bhCfg.BlockHistorySizeF = historySize

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = assets.NewWeiI(1000000)
		geCfg.PriceDefaultF = assets.NewWeiI(100)

		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		h := &evmtypes.Head{Hash: utils.NewHash(), Number: 42, BaseFeePerGas: nil}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil)
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(42) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(41) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[2].Method == "eth_getBlockByNumber" && b[2].Args[0] == gas.Int64ToHex(40) && b[1].Args[1].(bool) && reflect.TypeOf(b[2].Result) == reflect.TypeOf(&evmtypes.Block{})
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
			elems[1].Result = &evmtypes.Block{
				Number: 41,
				Hash:   utils.NewHash(),
			}
			elems[2].Result = &evmtypes.Block{
				Number:       40,
				Hash:         utils.NewHash(),
				Transactions: legacyTransactionsFromGasPricesTxType(specialTxTypeCode, 1),
			}
		}).Once()

		err := bhe.Start(tests.Context(t))
		require.NoError(t, err)

		fee, limit, err := bhe.GetLegacyGas(tests.Context(t), make([]byte, 0), 10000, assets.NewWeiI(800))
		require.NoError(t, err)
		require.Equal(t, geCfg.PriceDefault(), fee)
		assert.Equal(t, 10000, int(limit))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(42) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(41) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[2].Method == "eth_getBlockByNumber" && b[2].Args[0] == gas.Int64ToHex(40) && b[1].Args[1].(bool) && reflect.TypeOf(b[2].Result) == reflect.TypeOf(&evmtypes.Block{})
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(42) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(41) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[2].Method == "eth_getBlockByNumber" && b[2].Args[0] == gas.Int64ToHex(40) && b[1].Args[1].(bool) && reflect.TypeOf(b[2].Result) == reflect.TypeOf(&evmtypes.Block{})
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[0].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(41)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[1].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(40)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[2].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
			elems[1].Result = &evmtypes.Block{
				Number: 41,
				Hash:   utils.NewHash(),
			}
			elems[2].Result = &evmtypes.Block{
				Number:       40,
				Hash:         utils.NewHash(),
				Transactions: legacyTransactionsFromGasPricesTxType(specialTxTypeCode, 1),
			}
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(tests.Context(t))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetLegacyGas(tests.Context(t), make([]byte, 0), 10000, assets.NewWeiI(800))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(800)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(50)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(40)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(42) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(41) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[2].Method == "eth_getBlockByNumber" && b[2].Args[0] == gas.Int64ToHex(40) && b[1].Args[1].(bool) && reflect.TypeOf(b[2].Result) == reflect.TypeOf(&evmtypes.Block{})
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Method == "eth_getBlockByNumber" && b[0].Args[0] == gas.Int64ToHex(42) && b[0].Args[1].(bool) && reflect.TypeOf(b[0].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[1].Method == "eth_getBlockByNumber" && b[1].Args[0] == gas.Int64ToHex(41) && b[1].Args[1].(bool) && reflect.TypeOf(b[1].Result) == reflect.TypeOf(&evmtypes.Block{}) &&
				b[2].Method == "eth_getBlockByNumber" && b[2].Args[0] == gas.Int64ToHex(40) && b[1].Args[1].(bool) && reflect.TypeOf(b[2].Result) == reflect.TypeOf(&evmtypes.Block{})
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[0].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(41)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[1].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Int64ToHex(40)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(b[2].Result)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TypeOf(&evmtypes.Block{})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &evmtypes.Block{
				Number: 42,
				Hash:   utils.NewHash(),
			}
			elems[1].Result = &evmtypes.Block{
				Number: 41,
				Hash:   utils.NewHash(),
			}
			elems[2].Result = &evmtypes.Block{
				Number:       40,
				Hash:         utils.NewHash(),
				Transactions: dynamicFeeTransactionsFromTipCapsTxType(specialTxTypeCode, 1),
			}
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(tests.Context(t))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), assets.NewWeiI(200))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(200)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(88889)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(1))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SimulateStart(t, bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("if estimator is missing base fee and gas bumping is enabled", func(t *testing.T) {
		geCfg.BumpThresholdF = uint64(1)

		_, err := bhe.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "BlockHistoryEstimator: no value for latest block base fee; cannot estimate EIP-1559 base fee. Are you trying to run with EIP1559 enabled on a non-EIP1559 chain?")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("if estimator is missing base fee and gas bumping is disabled", func(t *testing.T) {
		geCfg.BumpThresholdF = uint64(0)

		fee, err := bhe.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.NoError(t, err)
		assert.Equal(t, gas.DynamicFee{GasFeeCap: maxGasPrice, GasTipCap: assets.NewWeiI(6000)}, fee)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(112500)`
$DIR/pkg/gas/block_history_estimator_test.go: `.OnNewLongestChain(tests.Context(t), h)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("if gas bumping is enabled", func(t *testing.T) {
		geCfg.BumpThresholdF = uint64(1)

		fee, err := bhe.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.NoError(t, err)

		assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(186203), GasTipCap: assets.NewWeiI(6000)}, fee)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("if gas bumping is disabled", func(t *testing.T) {
		geCfg.BumpThresholdF = uint64(0)

		fee, err := bhe.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.NoError(t, err)

		assert.Equal(t, gas.DynamicFee{GasFeeCap: maxGasPrice, GasTipCap: assets.NewWeiI(6000)}, fee)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("if gas bumping is enabled and local max gas price set", func(t *testing.T) {
		geCfg.BumpThresholdF = uint64(1)

		fee, err := bhe.GetDynamicFee(tests.Context(t), assets.NewWeiI(180000))
		require.NoError(t, err)

		assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(180000), GasTipCap: assets.NewWeiI(6000)}, fee)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), assets.NewWeiI(180000))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(180000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("if bump threshold is 0 and local max gas price set", func(t *testing.T) {
		geCfg.BumpThresholdF = uint64(0)

		fee, err := bhe.GetDynamicFee(tests.Context(t), assets.NewWeiI(100))
		require.NoError(t, err)

		assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(100)}, fee)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), assets.NewWeiI(100))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(900000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.OnNewLongestChain(tests.Context(t), h)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), assets.NewWeiI(1200000))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1200000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BlockHistoryEstimatorFromInterface(
		gas.NewBlockHistoryEstimator(lggr, ethClient, defaultChainType, geCfg, bhCfg, testutils.NewRandomEVMChainID(), l1Oracle),
	)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewBlockHistoryEstimator(lggr, ethClient, defaultChainType, geCfg, bhCfg, testutils.NewRandomEVMChainID(), l1Oracle)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("fails halt bumping check if estimator is not started", func(t *testing.T) {
		err := bhe.HaltBumping(attempts)
		require.Error(t, err, "BlockHistoryEstimator is not started; do not have max gas to allow bumping")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
		return len(b) == 1
	}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
		return len(b) == 1
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
		elems := args.Get(1).([]rpc.BatchElem)
		elems[0].Result = &b0
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(ctx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("allows bumping check if CheckInclusionPercentile price failed to set due to no suitable transactions", func(t *testing.T) {
		err := bhe.HaltBumping(attempts)
		require.Error(t, err, "90 percentile price is not set. This is likely because there aren't any valid transactions to estimate from. Preventing bumping until valid price is available to compare")
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, []evmtypes.Block{b0, b1, b2, b3})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("skips halt bumping check if attempts is nil or empty", func(t *testing.T) {
		err := bhe.HaltBumping(nil)
		require.NoError(t, err)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("returns error if one of the supplied attempts is missing BroadcastBeforeBlockNum", func(t *testing.T) {
		err := bhe.HaltBumping(attempts)
		require.Error(t, err)
		assert.Contains(t, err.Error(), fmt.Sprintf("BroadcastBeforeBlockNum was unexpectedly nil for attempt %s", attempts[0].TxHash))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("returns error if one of the supplied attempts has an unknown transaction type", func(t *testing.T) {
		err := bhe.HaltBumping(attempts)
		require.Error(t, err)
		assert.Contains(t, err.Error(), fmt.Sprintf("attempt %s has unknown transaction type 0x3", hash))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("in legacy mode", func(t *testing.T) {
		b0 = evmtypes.Block{
			Number:       0,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1000),
		}
		b1 = evmtypes.Block{
			Number:       1,
			Hash:         utils.NewHash(),
			ParentHash:   b0.Hash,
			Transactions: legacyTransactionsFromGasPrices(2, 3, 4, 5, 6),
		}
		b2 = evmtypes.Block{
			Number:       2,
			Hash:         utils.NewHash(),
			ParentHash:   b1.Hash,
			Transactions: legacyTransactionsFromGasPrices(4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9),
		}
		b3 = evmtypes.Block{
			Number:       3,
			Hash:         utils.NewHash(),
			ParentHash:   b2.Hash,
			Transactions: legacyTransactionsFromGasPrices(3, 4, 5, 6, 7),
		}
		gas.SetRollingBlockHistory(bhe, []evmtypes.Block{b0, b1, b2, b3})

		attempts = []gas.EvmPriorAttempt{
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(3), BroadcastBeforeBlockNum: ptr(int64(0))},
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(5), BroadcastBeforeBlockNum: ptr(int64(1))},
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(7), BroadcastBeforeBlockNum: ptr(int64(1))},
		}

		t.Run("passes check if all attempt gas prices are lower than or equal to percentile price", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 80 // percentile price is 7 wei
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.NoError(t, err)
		})
		t.Run("fails check if any attempt price is higher than percentile price", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 40 // percentile price is 5 wei
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has gas price of 7 wei, which is above percentile=40%% (percentile price: 5 wei)", attempts[2].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, []evmtypes.Block{b0, b1, b2, b3})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(5)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(7)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("passes check if all attempt gas prices are lower than or equal to percentile price", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 80 // percentile price is 7 wei
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.NoError(t, err)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("fails check if any attempt price is higher than percentile price", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 40 // percentile price is 5 wei
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has gas price of 7 wei, which is above percentile=40%% (percentile price: 5 wei)", attempts[2].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("handles mixed legacy and EIP-1559 transactions", func(t *testing.T) {
		b0 = evmtypes.Block{
			BaseFeePerGas: assets.NewWeiI(1),
			Number:        3,
			Hash:          utils.NewHash(),
			Transactions:  append(legacyTransactionsFromGasPrices(1, 2, 3, 4, 5), dynamicFeeTransactionsFromTipCaps(6, 7, 8, 9, 10)...),
		}
		gas.SetRollingBlockHistory(bhe, []evmtypes.Block{b0})

		attempts = []gas.EvmPriorAttempt{
			{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(1), GasTipCap: assets.NewWeiI(3)}, BroadcastBeforeBlockNum: ptr(int64(0))},
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(10), BroadcastBeforeBlockNum: ptr(int64(0))},
		}

		t.Run("passes check if both transactions are ok", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 1
			bhCfg.CheckInclusionPercentileF = 90 // percentile price is 5 wei
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.NoError(t, err)
		})
		t.Run("fails check if legacy transaction fails", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 1
			bhCfg.CheckInclusionPercentileF = 60
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has gas price of 10 wei, which is above percentile=60%% (percentile price: 7 wei)", attempts[1].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})

		attempts = []gas.EvmPriorAttempt{
			{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(11), GasTipCap: assets.NewWeiI(10)}, BroadcastBeforeBlockNum: ptr(int64(0))},
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(3), BroadcastBeforeBlockNum: ptr(int64(0))},
		}

		t.Run("fails check if dynamic fee transaction fails", func(t *testing.T) {
			geCfg.EIP1559DynamicFeesF = true
			geCfg.TipCapMinF = assets.NewWeiI(1)
			bhCfg.CheckInclusionBlocksF = 1
			bhCfg.CheckInclusionPercentileF = 60
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has tip cap of 10 wei, which is above percentile=60%% (percentile tip cap: 6 wei)", attempts[0].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, []evmtypes.Block{b0})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("passes check if both transactions are ok", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 1
			bhCfg.CheckInclusionPercentileF = 90 // percentile price is 5 wei
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.NoError(t, err)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("fails check if legacy transaction fails", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 1
			bhCfg.CheckInclusionPercentileF = 60
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has gas price of 10 wei, which is above percentile=60%% (percentile price: 7 wei)", attempts[1].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(11)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("fails check if dynamic fee transaction fails", func(t *testing.T) {
			geCfg.EIP1559DynamicFeesF = true
			geCfg.TipCapMinF = assets.NewWeiI(1)
			bhCfg.CheckInclusionBlocksF = 1
			bhCfg.CheckInclusionPercentileF = 60
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has tip cap of 10 wei, which is above percentile=60%% (percentile tip cap: 6 wei)", attempts[0].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(5)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(8)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(13)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(21)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetRollingBlockHistory(bhe, blocks)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(30)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(30)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(5)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(30)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(7)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("passes check if 90th percentile price higher than highest transaction tip cap", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 80
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.NoError(t, err)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("fails check if percentile tip cap higher than any transaction tip cap, and base fee higher than the block base fee", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 20
			bhe.Recalculate(testutils.Head(3))

			err := bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has tip cap of 5 wei, which is above percentile=20%% (percentile tip cap: 4 wei)", attempts[1].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)

			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 2
			bhe.Recalculate(testutils.Head(3))

			err = bhe.HaltBumping(attempts)
			require.Error(t, err)
			assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has tip cap of 3 wei, which is above percentile=2%% (percentile tip cap: 2 wei)", attempts[0].TxHash))
			require.ErrorIs(t, err, fees.ErrConnectivity)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("passes check if, for at least one block, feecap < tipcap+basefee, even if percentile is not reached", func(t *testing.T) {
			bhCfg.CheckInclusionBlocksF = 3
			bhCfg.CheckInclusionPercentileF = 5
			bhe.Recalculate(testutils.Head(3))

			attempts = []gas.EvmPriorAttempt{
				{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(4), GasTipCap: assets.NewWeiI(7)}, BroadcastBeforeBlockNum: ptr(int64(1))},
			}

			err := bhe.HaltBumping(attempts)
			require.NoError(t, err)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Recalculate(testutils.Head(3))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(4)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(7)`
$DIR/pkg/gas/block_history_estimator_test.go: `.HaltBumping(attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("BumpLegacyGas halts bumping", func(t *testing.T) {
		bhCfg.BlockDelayF = 0
		bhCfg.CheckInclusionBlocksF = 1
		bhCfg.CheckInclusionPercentileF = 10
		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.BumpPercentF = 10
		geCfg.BumpMinF = assets.NewWeiI(150)
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)
		l1Oracle := rollupMocks.NewL1Oracle(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ctx := tests.Context(t)

		bhe := gas.BlockHistoryEstimatorFromInterface(
			gas.NewBlockHistoryEstimator(logger.Test(t), ethClient, defaultChainType, geCfg, bhCfg, testutils.NewRandomEVMChainID(), l1Oracle),
		)

		b0 := evmtypes.Block{
			Number:       0,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1),
		}
		h := testutils.Head(0)
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h, nil).Once()
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b0
		}).Once()
		err := bhe.Start(ctx)
		require.NoError(t, err)

		attempts := []gas.EvmPriorAttempt{
			{TxType: 0x0, TxHash: NewEvmHash(), GasPrice: assets.NewWeiI(1000), BroadcastBeforeBlockNum: ptr(int64(0))},
		}
		_, _, err = bhe.BumpLegacyGas(ctx, assets.NewWeiI(42), 100000, maxGasPrice, attempts)
		require.Error(t, err)
		assert.True(t, pkgerrors.Is(err, fees.ErrConnectivity))
		assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has gas price of 1 kwei, which is above percentile=10%% (percentile price: 1 wei)", attempts[0].TxHash))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(150)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BlockHistoryEstimatorFromInterface(
			gas.NewBlockHistoryEstimator(logger.Test(t), ethClient, defaultChainType, geCfg, bhCfg, testutils.NewRandomEVMChainID(), l1Oracle),
		)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewBlockHistoryEstimator(logger.Test(t), ethClient, defaultChainType, geCfg, bhCfg, testutils.NewRandomEVMChainID(), l1Oracle)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(h, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b0
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(ctx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpLegacyGas(ctx, assets.NewWeiI(42), 100000, maxGasPrice, attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("BumpLegacyGas calls BumpLegacyGasPriceOnly with proper current gas price", func(t *testing.T) {
		bhCfg := newBlockHistoryConfig()
		bhCfg.CheckInclusionBlocksF = 0
		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.BumpPercentF = 10
		geCfg.BumpMinF = assets.NewWeiI(150)
		geCfg.PriceMaxF = maxGasPrice
		l1Oracle := rollupMocks.NewL1Oracle(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ctx := tests.Context(t)

		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, nil).Once()
		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)
		err := bhe.Start(ctx)
		require.NoError(t, err)

		t.Run("ignores nil current gas price", func(t *testing.T) {
			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			expectedGasPrice, err := gas.BumpLegacyGasPriceOnly(geCfg, logger.TestSugared(t), nil, assets.NewWeiI(42), maxGasPrice)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, expectedGasPrice, gasPrice)
		})

		t.Run("ignores current gas price > max gas price", func(t *testing.T) {
			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			massive := assets.NewWeiI(100000000000000)
			gas.SetGasPrice(bhe, massive)

			expectedGasPrice, err := gas.BumpLegacyGasPriceOnly(geCfg, logger.TestSugared(t), massive, assets.NewWeiI(42), maxGasPrice)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, expectedGasPrice, gasPrice)
		})

		t.Run("ignores current gas price < bumped gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(191))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, assets.NewWeiI(192), gasPrice)
		})

		t.Run("uses current gas price > bumped gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(193))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, assets.NewWeiI(193), gasPrice)
		})

		t.Run("bumped gas price > max gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(191))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, assets.NewWeiI(100), nil)
			require.Error(t, err)

			assert.Nil(t, gasPrice)
			assert.Equal(t, 0, int(gasLimit))
			assert.Contains(t, err.Error(), "bumped gas price of 192 wei would exceed configured max gas price of 100 wei (original price was 42 wei).")
		})

		t.Run("current gas price > max gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(193))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, assets.NewWeiI(100), nil)
			require.Error(t, err)

			assert.Nil(t, gasPrice)
			assert.Equal(t, 0, int(gasLimit))
			assert.Contains(t, err.Error(), "bumped gas price of 192 wei would exceed configured max gas price of 100 wei (original price was 42 wei).")
		})
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(150)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(ctx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("ignores nil current gas price", func(t *testing.T) {
			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			expectedGasPrice, err := gas.BumpLegacyGasPriceOnly(geCfg, logger.TestSugared(t), nil, assets.NewWeiI(42), maxGasPrice)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, expectedGasPrice, gasPrice)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpLegacyGasPriceOnly(geCfg, logger.TestSugared(t), nil, assets.NewWeiI(42), maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TestSugared(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("ignores current gas price > max gas price", func(t *testing.T) {
			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			massive := assets.NewWeiI(100000000000000)
			gas.SetGasPrice(bhe, massive)

			expectedGasPrice, err := gas.BumpLegacyGasPriceOnly(geCfg, logger.TestSugared(t), massive, assets.NewWeiI(42), maxGasPrice)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, expectedGasPrice, gasPrice)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100000000000000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetGasPrice(bhe, massive)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpLegacyGasPriceOnly(geCfg, logger.TestSugared(t), massive, assets.NewWeiI(42), maxGasPrice)`
$DIR/pkg/gas/block_history_estimator_test.go: `.TestSugared(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("ignores current gas price < bumped gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(191))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, assets.NewWeiI(192), gasPrice)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetGasPrice(bhe, assets.NewWeiI(191))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(191)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("uses current gas price > bumped gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(193))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, 100000, int(gasLimit))
			assert.Equal(t, assets.NewWeiI(193), gasPrice)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetGasPrice(bhe, assets.NewWeiI(193))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(193)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("bumped gas price > max gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(191))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, assets.NewWeiI(100), nil)
			require.Error(t, err)

			assert.Nil(t, gasPrice)
			assert.Equal(t, 0, int(gasLimit))
			assert.Contains(t, err.Error(), "bumped gas price of 192 wei would exceed configured max gas price of 100 wei (original price was 42 wei).")
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetGasPrice(bhe, assets.NewWeiI(191))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(191)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, assets.NewWeiI(100), nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("current gas price > max gas price", func(t *testing.T) {
			gas.SetGasPrice(bhe, assets.NewWeiI(193))

			gasPrice, gasLimit, err := bhe.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, assets.NewWeiI(100), nil)
			require.Error(t, err)

			assert.Nil(t, gasPrice)
			assert.Equal(t, 0, int(gasLimit))
			assert.Contains(t, err.Error(), "bumped gas price of 192 wei would exceed configured max gas price of 100 wei (original price was 42 wei).")
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetGasPrice(bhe, assets.NewWeiI(193))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(193)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, assets.NewWeiI(100), nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("BumpDynamicFee checks connectivity", func(t *testing.T) {
		bhCfg := newBlockHistoryConfig()
		bhCfg.CheckInclusionBlocksF = 1
		bhCfg.CheckInclusionPercentileF = 10
		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = true
		geCfg.BumpPercentF = 10
		geCfg.BumpMinF = assets.NewWeiI(150)
		geCfg.PriceMaxF = maxGasPrice
		geCfg.PriceMinF = assets.NewWeiI(0)
		geCfg.TipCapMinF = assets.NewWeiI(0)
		l1Oracle := rollupMocks.NewL1Oracle(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ctx := tests.Context(t)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b0 := evmtypes.Block{
			BaseFeePerGas: assets.NewWeiI(1),
			Number:        0,
			Hash:          utils.NewHash(),
			Transactions:  dynamicFeeTransactionsFromTipCaps(1),
		}
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(testutils.Head(0), nil).Once()
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b0
		}).Once()
		err := bhe.Start(ctx)
		require.NoError(t, err)

		originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(25)}
		attempts := []gas.EvmPriorAttempt{
			{TxType: 0x2, TxHash: NewEvmHash(), DynamicFee: gas.DynamicFee{GasTipCap: originalFee.GasTipCap, GasFeeCap: originalFee.GasFeeCap}, BroadcastBeforeBlockNum: ptr(int64(0))}}

		_, err = bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, attempts)
		require.Error(t, err)
		assert.True(t, pkgerrors.Is(err, fees.ErrConnectivity))
		assert.Contains(t, err.Error(), fmt.Sprintf("transaction %s has tip cap of 25 wei, which is above percentile=10%% (percentile tip cap: 1 wei)", attempts[0].TxHash))
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(150)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(testutils.Head(0), nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b0
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(ctx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(25)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, attempts)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(150)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(52)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/block_history_estimator_test.go: `.Start(ctx)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("when current tip cap is nil", func(t *testing.T) {
			originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(25)}
			fee, err := bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(250), GasTipCap: assets.NewWeiI(202)}, fee)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(25)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("ignores current tip cap that is smaller than original fee with bump applied", func(t *testing.T) {
			gas.SetTipCap(bhe, assets.NewWeiI(201))

			originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(25)}
			fee, err := bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(250), GasTipCap: assets.NewWeiI(202)}, fee)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetTipCap(bhe, assets.NewWeiI(201))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(201)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(25)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("uses current tip cap that is larger than original fee with bump applied", func(t *testing.T) {
			gas.SetTipCap(bhe, assets.NewWeiI(203))

			originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(25)}
			fee, err := bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(250), GasTipCap: assets.NewWeiI(203)}, fee)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetTipCap(bhe, assets.NewWeiI(203))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(203)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(25)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("ignores absurdly large current tip cap", func(t *testing.T) {
			gas.SetTipCap(bhe, assets.NewWeiI(1000000000000000))

			originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(25)}
			fee, err := bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)
			require.NoError(t, err)

			assert.Equal(t, gas.DynamicFee{GasFeeCap: assets.NewWeiI(250), GasTipCap: assets.NewWeiI(202)}, fee)
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetTipCap(bhe, assets.NewWeiI(1000000000000000))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000000000000000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(25)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("bumped tip cap price > max gas price", func(t *testing.T) {
			gas.SetTipCap(bhe, assets.NewWeiI(203))

			originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(100), GasTipCap: assets.NewWeiI(990000)}
			fee, err := bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)
			require.Error(t, err)

			assert.Equal(t, gas.DynamicFee{}, fee)
			assert.Contains(t, err.Error(), "bumped tip cap of 1.089 mwei would exceed configured max gas price of 1 mwei (original fee: tip cap 990 kwei, fee cap 100 wei)")
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetTipCap(bhe, assets.NewWeiI(203))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(203)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(990000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("bumped fee cap price > max gas price", func(t *testing.T) {
			gas.SetTipCap(bhe, assets.NewWeiI(203))

			originalFee := gas.DynamicFee{GasFeeCap: assets.NewWeiI(990000), GasTipCap: assets.NewWeiI(25)}
			fee, err := bhe.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)
			require.Error(t, err)

			assert.Equal(t, gas.DynamicFee{}, fee)
			assert.Contains(t, err.Error(), "bumped fee cap of 1.089 mwei would exceed configured max gas price of 1 mwei (original fee: tip cap 25 wei, fee cap 990 kwei)")
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.SetTipCap(bhe, assets.NewWeiI(203))`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(203)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(990000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(25)`
$DIR/pkg/gas/block_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run("sets CheckInclusionPercentile price using the latest blocks, eip-1559 disabled", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		bhCfg := newBlockHistoryConfig()
		bhCfg.BlockDelayF = 0
		bhCfg.TransactionPercentileF = 35
		// Set BlockHistorySize larger than CheckInclusionBlocks to cache more blocks than needed for calculation
		// Helps test whether the latest block is being used or not
		bhCfg.BlockHistorySizeF = 3
		bhCfg.BatchSizeF = 0
		bhCfg.CheckInclusionBlocksF = 1
		bhCfg.CheckInclusionPercentileF = 100

		geCfg := &gas.MockGasEstimatorConfig{}
		geCfg.EIP1559DynamicFeesF = false
		geCfg.PriceMaxF = assets.NewWeiI(1000)
		geCfg.PriceMinF = assets.NewWeiI(0)

		bhe := newBlockHistoryEstimator(t, ethClient, defaultChainType, geCfg, bhCfg, l1Oracle)

		b0 := evmtypes.Block{
			Number:       0,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(1, 2, 3),
		}
		b1 := evmtypes.Block{
			Number:       1,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(4, 5, 6),
		}
		b2 := evmtypes.Block{
			Number:       2,
			Hash:         utils.NewHash(),
			Transactions: legacyTransactionsFromGasPrices(7, 8, 9),
		}

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Args[0] == "0x2" &&
				b[1].Args[0] == "0x1" &&
				b[2].Args[0] == "0x0"
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b2
			elems[1].Result = &b1
			elems[2].Result = &b0
		})

		bhe.FetchBlocksAndRecalculate(tests.Context(t), testutils.Head(2))

		price := gas.GetMaxPercentileGasPrice(bhe)
		require.Equal(t, assets.NewWeiI(9), price)

		assert.Len(t, gas.GetRollingBlockHistory(bhe), 3)
	})`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Args[0] == "0x2" &&
				b[1].Args[0] == "0x1" &&
				b[2].Args[0] == "0x0"
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Args[0] == "0x2" &&
				b[1].Args[0] == "0x1" &&
				b[2].Args[0] == "0x0"
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b2
			elems[1].Result = &b1
			elems[2].Result = &b0
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.FetchBlocksAndRecalculate(tests.Context(t), testutils.Head(2))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetMaxPercentileGasPrice(bhe)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1000)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewWeiI(3)`
$DIR/pkg/gas/block_history_estimator_test.go: `.NewHash()`
$DIR/pkg/gas/block_history_estimator_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Args[0] == "0x2" &&
				b[1].Args[0] == "0x1" &&
				b[2].Args[0] == "0x0"
		}))`
$DIR/pkg/gas/block_history_estimator_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				b[0].Args[0] == "0x2" &&
				b[1].Args[0] == "0x1" &&
				b[2].Args[0] == "0x0"
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &b2
			elems[1].Result = &b1
			elems[2].Result = &b0
		})`
$DIR/pkg/gas/block_history_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/block_history_estimator_test.go: `.FetchBlocksAndRecalculate(tests.Context(t), testutils.Head(2))`
$DIR/pkg/gas/block_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/block_history_estimator_test.go: `.Head(2)`
$DIR/pkg/gas/block_history_estimator_test.go: `.GetMaxPercentileTipCap(bhe)`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("fails if you fetch gas price before the estimator starts", func(t *testing.T) {
		cfg := gas.FeeHistoryEstimatorConfig{
			BumpPercent:      20,
			RewardPercentile: 60,
			EIP1559:          false,
		}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), nil, cfg, chainID, nil)
		_, _, err := u.GetLegacyGas(tests.Context(t), nil, gasLimit, maxPrice)
		assert.ErrorContains(t, err, "gas price not set")
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("fails to start if BumpPercent is lower than the minimum cap", func(t *testing.T) {
		cfg := gas.FeeHistoryEstimatorConfig{BumpPercent: 9}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), nil, cfg, chainID, nil)
		assert.ErrorContains(t, u.Start(tests.Context(t)), "BumpPercent")
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("fails to start if RewardPercentile is higher than ConnectivityPercentile in EIP-1559", func(t *testing.T) {
		cfg := gas.FeeHistoryEstimatorConfig{
			BumpPercent:      20,
			RewardPercentile: 99,
			EIP1559:          true,
		}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), nil, cfg, chainID, nil)
		assert.ErrorContains(t, u.Start(tests.Context(t)), "RewardPercentile")
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(10), nil).Maybe()`
$DIR/pkg/gas/fee_history_estimator_test.go: `err = u.Close()`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("fetches a new gas price when first called", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(10), nil).Once()

		cfg := gas.FeeHistoryEstimatorConfig{}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		_, err := u.RefreshGasPrice()
		assert.NoError(t, err)
		gasPrice, _, err := u.GetLegacyGas(tests.Context(t), nil, gasLimit, maxPrice)
		assert.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(10), gasPrice)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(10), nil).Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("will return max price if estimation exceeds it", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(10), nil).Once()

		cfg := gas.FeeHistoryEstimatorConfig{}

		maxPrice := assets.NewWeiI(1)
		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		_, err := u.RefreshGasPrice()
		assert.NoError(t, err)
		gas1, _, err := u.GetLegacyGas(tests.Context(t), nil, gasLimit, maxPrice)
		assert.NoError(t, err)
		assert.Equal(t, maxPrice, gas1)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(10), nil).Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("bumps a previous attempt by BumpPercent", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		originalGasPrice := assets.NewWeiI(10)
		client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(10), nil)

		cfg := gas.FeeHistoryEstimatorConfig{BumpPercent: 50, CacheTimeout: 5 * time.Second}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		servicetest.RunHealthy(t, u)
		gasPrice, _, err := u.BumpLegacyGas(tests.Context(t), originalGasPrice, gasLimit, maxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(15), gasPrice)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(10), nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `servicetest.RunHealthy(t, u)`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("fails if the original attempt is nil, or equal or higher than the max price", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)

		cfg := gas.FeeHistoryEstimatorConfig{}
		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)

		var originalPrice *assets.Wei
		_, _, err := u.BumpLegacyGas(tests.Context(t), originalPrice, gasLimit, maxPrice, nil)
		assert.Error(t, err)

		originalPrice = assets.NewWeiI(100)
		_, _, err = u.BumpLegacyGas(tests.Context(t), originalPrice, gasLimit, maxPrice, nil)
		assert.Error(t, err)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `originalPrice = assets.NewWeiI(100)`
$DIR/pkg/gas/fee_history_estimator_test.go: `_, _, err = u.BumpLegacyGas(tests.Context(t), originalPrice, gasLimit, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("returns market gas price if bumped original fee is lower", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(80), nil).Once()
		originalGasPrice := assets.NewWeiI(10)

		cfg := gas.FeeHistoryEstimatorConfig{}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		gas, _, err := u.BumpLegacyGas(tests.Context(t), originalGasPrice, gasLimit, maxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(80), gas)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(80), nil).Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("returns max gas price if bumped original fee is higher", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(1), nil).Once()
		originalGasPrice := assets.NewWeiI(10)

		cfg := gas.FeeHistoryEstimatorConfig{BumpPercent: 50}

		maxPrice := assets.NewWeiI(14)
		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		gas, _, err := u.BumpLegacyGas(tests.Context(t), originalGasPrice, gasLimit, maxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, maxPrice, gas)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(1), nil).Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("returns max gas price if the aggregation of max and original bumped fee is higher", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(1), nil).Once()
		originalGasPrice := assets.NewWeiI(10)

		cfg := gas.FeeHistoryEstimatorConfig{BumpPercent: 50}

		maxPrice := assets.NewWeiI(14)
		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		gas, _, err := u.BumpLegacyGas(tests.Context(t), originalGasPrice, gasLimit, maxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, maxPrice, gas)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(1), nil).Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(100), nil).Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("fetches a new dynamic fee when first called", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		baseFee := big.NewInt(5)
		maxPriorityFeePerGas1 := big.NewInt(33)
		maxPriorityFeePerGas2 := big.NewInt(20)

		feeHistoryResult := &ethereum.FeeHistory{
			OldestBlock:  big.NewInt(1),
			Reward:       [][]*big.Int{{maxPriorityFeePerGas1, big.NewInt(5)}, {maxPriorityFeePerGas2, big.NewInt(5)}, {}}, // first one represents market price and second one connectivity price
			BaseFee:      []*big.Int{baseFee, baseFee},
			GasUsedRatio: nil,
		}
		client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()

		blockHistoryLength := 2
		cfg := gas.FeeHistoryEstimatorConfig{BlockHistorySize: uint64(blockHistoryLength)}
		avrgPriorityFee := big.NewInt(0)
		avrgPriorityFee.Add(maxPriorityFeePerGas1, maxPriorityFeePerGas2).Div(avrgPriorityFee, big.NewInt(int64(blockHistoryLength)))
		maxFee := (*assets.Wei)(baseFee).AddPercentage(gas.BaseFeeBufferPercentage).Add((*assets.Wei)(avrgPriorityFee))

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		err := u.RefreshDynamicPrice()
		assert.NoError(t, err)
		dynamicFee, err := u.GetDynamicFee(tests.Context(t), maxPrice)
		assert.NoError(t, err)
		assert.Equal(t, maxFee, dynamicFee.GasFeeCap)
		assert.Equal(t, (*assets.Wei)(avrgPriorityFee), dynamicFee.GasTipCap)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `avrgPriorityFee.Add(maxPriorityFeePerGas1, maxPriorityFeePerGas2).Div(avrgPriorityFee, big.NewInt(int64(blockHistoryLength)))`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("fails if dynamic prices have not been set yet", func(t *testing.T) {
		cfg := gas.FeeHistoryEstimatorConfig{}

		maxPrice := assets.NewWeiI(1)
		u := gas.NewFeeHistoryEstimator(logger.Test(t), nil, cfg, chainID, nil)
		_, err := u.GetDynamicFee(tests.Context(t), maxPrice)
		assert.Error(t, err)
		assert.ErrorContains(t, err, "dynamic price not set")
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("bumps a previous attempt by BumpPercent", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		originalFee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(20),
			GasTipCap: assets.NewWeiI(10),
		}

		// These values will be ignored because they are lower prices than the originalFee
		feeHistoryResult := &ethereum.FeeHistory{
			OldestBlock:  big.NewInt(1),
			Reward:       [][]*big.Int{{big.NewInt(5), big.NewInt(50)}}, // first one represents market price and second one connectivity price
			BaseFee:      []*big.Int{big.NewInt(5)},
			GasUsedRatio: nil,
		}
		client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()

		cfg := gas.FeeHistoryEstimatorConfig{
			BlockHistorySize: 2,
			BumpPercent:      50,
		}

		expectedFeeCap := originalFee.GasFeeCap.AddPercentage(cfg.BumpPercent)
		expectedTipCap := originalFee.GasTipCap.AddPercentage(cfg.BumpPercent)

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		err := u.RefreshDynamicPrice()
		assert.NoError(t, err)
		dynamicFee, err := u.BumpDynamicFee(tests.Context(t), originalFee, globalMaxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, expectedFeeCap, dynamicFee.GasFeeCap)
		assert.Equal(t, expectedTipCap, dynamicFee.GasTipCap)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("fails if the original attempt is invalid", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		maxPrice := assets.NewWeiI(20)
		cfg := gas.FeeHistoryEstimatorConfig{BlockHistorySize: 1}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		// nil original fee
		var originalFee gas.DynamicFee
		_, err := u.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)
		assert.Error(t, err)

		// tip cap is higher than fee cap
		originalFee = gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(10),
			GasTipCap: assets.NewWeiI(11),
		}
		_, err = u.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)
		assert.Error(t, err)

		// fee cap is equal or higher to max price
		originalFee = gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(20),
			GasTipCap: assets.NewWeiI(10),
		}
		_, err = u.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)
		assert.Error(t, err)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `originalFee = gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(10),
			GasTipCap: assets.NewWeiI(11),
		}`
$DIR/pkg/gas/fee_history_estimator_test.go: `_, err = u.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `originalFee = gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(20),
			GasTipCap: assets.NewWeiI(10),
		}`
$DIR/pkg/gas/fee_history_estimator_test.go: `_, err = u.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("returns market prices if bumped original fee is lower", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		originalFee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(20),
			GasTipCap: assets.NewWeiI(10),
		}

		// Market fees
		baseFee := big.NewInt(5)
		maxPriorityFeePerGas := big.NewInt(33)
		feeHistoryResult := &ethereum.FeeHistory{
			OldestBlock:  big.NewInt(1),
			Reward:       [][]*big.Int{{maxPriorityFeePerGas, big.NewInt(100)}}, // first one represents market price and second one connectivity price
			BaseFee:      []*big.Int{baseFee},
			GasUsedRatio: nil,
		}
		client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()

		maxFee := (*assets.Wei)(baseFee).AddPercentage(gas.BaseFeeBufferPercentage).Add((*assets.Wei)(maxPriorityFeePerGas))

		cfg := gas.FeeHistoryEstimatorConfig{
			BlockHistorySize: 1,
			BumpPercent:      50,
		}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		err := u.RefreshDynamicPrice()
		assert.NoError(t, err)
		bumpedFee, err := u.BumpDynamicFee(tests.Context(t), originalFee, globalMaxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, (*assets.Wei)(maxPriorityFeePerGas), bumpedFee.GasTipCap)
		assert.Equal(t, maxFee, bumpedFee.GasFeeCap)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("fails if connectivity percentile value is reached", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		originalFee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(20),
			GasTipCap: assets.NewWeiI(10),
		}

		// Market fees
		baseFee := big.NewInt(5)
		maxPriorityFeePerGas := big.NewInt(33)
		feeHistoryResult := &ethereum.FeeHistory{
			OldestBlock:  big.NewInt(1),
			Reward:       [][]*big.Int{{maxPriorityFeePerGas, big.NewInt(30)}}, // first one represents market price and second one connectivity price
			BaseFee:      []*big.Int{baseFee},
			GasUsedRatio: nil,
		}
		client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()

		cfg := gas.FeeHistoryEstimatorConfig{
			BlockHistorySize: 1,
			BumpPercent:      50,
		}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		err := u.RefreshDynamicPrice()
		assert.NoError(t, err)
		_, err = u.BumpDynamicFee(tests.Context(t), originalFee, globalMaxPrice, nil)
		assert.Error(t, err)
		assert.True(t, fees.IsBumpErr(err))
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `_, err = u.BumpDynamicFee(tests.Context(t), originalFee, globalMaxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("returns max price if the aggregation of max and original bumped fee is higher", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		originalFee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(20),
			GasTipCap: assets.NewWeiI(18),
		}

		maxPrice := assets.NewWeiI(25)
		// Market fees
		baseFee := big.NewInt(1)
		maxPriorityFeePerGas := big.NewInt(1)
		feeHistoryResult := &ethereum.FeeHistory{
			OldestBlock:  big.NewInt(1),
			Reward:       [][]*big.Int{{maxPriorityFeePerGas, big.NewInt(30)}}, // first one represents market price and second one connectivity price
			BaseFee:      []*big.Int{baseFee},
			GasUsedRatio: nil,
		}
		client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()

		cfg := gas.FeeHistoryEstimatorConfig{
			BlockHistorySize: 1,
			BumpPercent:      50,
		}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		err := u.RefreshDynamicPrice()
		assert.NoError(t, err)
		bumpedFee, err := u.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, maxPrice, bumpedFee.GasTipCap)
		assert.Equal(t, maxPrice, bumpedFee.GasFeeCap)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `t.Run("fails if the bumped gas price is lower than the minimum bump percentage", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		originalFee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(20),
			GasTipCap: assets.NewWeiI(18),
		}

		maxPrice := assets.NewWeiI(21)
		// Market fees
		baseFee := big.NewInt(1)
		maxPriorityFeePerGas := big.NewInt(1)
		feeHistoryResult := &ethereum.FeeHistory{
			OldestBlock:  big.NewInt(1),
			Reward:       [][]*big.Int{{maxPriorityFeePerGas, big.NewInt(30)}}, // first one represents market price and second one connectivity price
			BaseFee:      []*big.Int{baseFee},
			GasUsedRatio: nil,
		}
		client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()

		cfg := gas.FeeHistoryEstimatorConfig{
			BlockHistorySize: 1,
			BumpPercent:      50,
		}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		err := u.RefreshDynamicPrice()
		assert.NoError(t, err)
		_, err = u.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)
		assert.Error(t, err)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `_, err = u.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `servicetest.RunHealthy(t, u)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(0)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("fails if you fetch gas price before the estimator starts", func(t *testing.T) {
		cfg := gas.FeeHistoryEstimatorConfig{
			BumpPercent:      20,
			RewardPercentile: 60,
			EIP1559:          false,
		}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), nil, cfg, chainID, nil)
		_, _, err := u.GetLegacyGas(tests.Context(t), nil, gasLimit, maxPrice)
		assert.ErrorContains(t, err, "gas price not set")
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), nil, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.GetLegacyGas(tests.Context(t), nil, gasLimit, maxPrice)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("fails to start if BumpPercent is lower than the minimum cap", func(t *testing.T) {
		cfg := gas.FeeHistoryEstimatorConfig{BumpPercent: 9}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), nil, cfg, chainID, nil)
		assert.ErrorContains(t, u.Start(tests.Context(t)), "BumpPercent")
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), nil, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("fails to start if RewardPercentile is higher than ConnectivityPercentile in EIP-1559", func(t *testing.T) {
		cfg := gas.FeeHistoryEstimatorConfig{
			BumpPercent:      20,
			RewardPercentile: 99,
			EIP1559:          true,
		}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), nil, cfg, chainID, nil)
		assert.ErrorContains(t, u.Start(tests.Context(t)), "RewardPercentile")
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), nil, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("SuggestGasPrice", mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(big.NewInt(10), nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Maybe()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Start(tests.Context(t))`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(0)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("fetches a new gas price when first called", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(10), nil).Once()

		cfg := gas.FeeHistoryEstimatorConfig{}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		_, err := u.RefreshGasPrice()
		assert.NoError(t, err)
		gasPrice, _, err := u.GetLegacyGas(tests.Context(t), nil, gasLimit, maxPrice)
		assert.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(10), gasPrice)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("SuggestGasPrice", mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(big.NewInt(10), nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.RefreshGasPrice()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.GetLegacyGas(tests.Context(t), nil, gasLimit, maxPrice)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("will return max price if estimation exceeds it", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(10), nil).Once()

		cfg := gas.FeeHistoryEstimatorConfig{}

		maxPrice := assets.NewWeiI(1)
		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		_, err := u.RefreshGasPrice()
		assert.NoError(t, err)
		gas1, _, err := u.GetLegacyGas(tests.Context(t), nil, gasLimit, maxPrice)
		assert.NoError(t, err)
		assert.Equal(t, maxPrice, gas1)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("SuggestGasPrice", mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(big.NewInt(10), nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.RefreshGasPrice()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.GetLegacyGas(tests.Context(t), nil, gasLimit, maxPrice)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), nil, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.GetLegacyGas(tests.Context(t), nil, gasLimit, maxPrice)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(0)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("bumps a previous attempt by BumpPercent", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		originalGasPrice := assets.NewWeiI(10)
		client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(10), nil)

		cfg := gas.FeeHistoryEstimatorConfig{BumpPercent: 50, CacheTimeout: 5 * time.Second}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		servicetest.RunHealthy(t, u)
		gasPrice, _, err := u.BumpLegacyGas(tests.Context(t), originalGasPrice, gasLimit, maxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(15), gasPrice)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("SuggestGasPrice", mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(big.NewInt(10), nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.RunHealthy(t, u)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpLegacyGas(tests.Context(t), originalGasPrice, gasLimit, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("fails if the original attempt is nil, or equal or higher than the max price", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)

		cfg := gas.FeeHistoryEstimatorConfig{}
		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)

		var originalPrice *assets.Wei
		_, _, err := u.BumpLegacyGas(tests.Context(t), originalPrice, gasLimit, maxPrice, nil)
		assert.Error(t, err)

		originalPrice = assets.NewWeiI(100)
		_, _, err = u.BumpLegacyGas(tests.Context(t), originalPrice, gasLimit, maxPrice, nil)
		assert.Error(t, err)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpLegacyGas(tests.Context(t), originalPrice, gasLimit, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpLegacyGas(tests.Context(t), originalPrice, gasLimit, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("returns market gas price if bumped original fee is lower", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(80), nil).Once()
		originalGasPrice := assets.NewWeiI(10)

		cfg := gas.FeeHistoryEstimatorConfig{}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		gas, _, err := u.BumpLegacyGas(tests.Context(t), originalGasPrice, gasLimit, maxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(80), gas)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("SuggestGasPrice", mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(big.NewInt(80), nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(80)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpLegacyGas(tests.Context(t), originalGasPrice, gasLimit, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("returns max gas price if bumped original fee is higher", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(1), nil).Once()
		originalGasPrice := assets.NewWeiI(10)

		cfg := gas.FeeHistoryEstimatorConfig{BumpPercent: 50}

		maxPrice := assets.NewWeiI(14)
		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		gas, _, err := u.BumpLegacyGas(tests.Context(t), originalGasPrice, gasLimit, maxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, maxPrice, gas)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("SuggestGasPrice", mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(big.NewInt(1), nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(14)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpLegacyGas(tests.Context(t), originalGasPrice, gasLimit, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("returns max gas price if the aggregation of max and original bumped fee is higher", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		client.On("SuggestGasPrice", mock.Anything).Return(big.NewInt(1), nil).Once()
		originalGasPrice := assets.NewWeiI(10)

		cfg := gas.FeeHistoryEstimatorConfig{BumpPercent: 50}

		maxPrice := assets.NewWeiI(14)
		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		gas, _, err := u.BumpLegacyGas(tests.Context(t), originalGasPrice, gasLimit, maxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, maxPrice, gas)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("SuggestGasPrice", mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(big.NewInt(1), nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(14)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpLegacyGas(tests.Context(t), originalGasPrice, gasLimit, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("SuggestGasPrice", mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(big.NewInt(100), nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(100)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(101)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpLegacyGas(tests.Context(t), originalGasPrice, gasLimit, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(0)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("fetches a new dynamic fee when first called", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		baseFee := big.NewInt(5)
		maxPriorityFeePerGas1 := big.NewInt(33)
		maxPriorityFeePerGas2 := big.NewInt(20)

		feeHistoryResult := &ethereum.FeeHistory{
			OldestBlock:  big.NewInt(1),
			Reward:       [][]*big.Int{{maxPriorityFeePerGas1, big.NewInt(5)}, {maxPriorityFeePerGas2, big.NewInt(5)}, {}}, // first one represents market price and second one connectivity price
			BaseFee:      []*big.Int{baseFee, baseFee},
			GasUsedRatio: nil,
		}
		client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()

		blockHistoryLength := 2
		cfg := gas.FeeHistoryEstimatorConfig{BlockHistorySize: uint64(blockHistoryLength)}
		avrgPriorityFee := big.NewInt(0)
		avrgPriorityFee.Add(maxPriorityFeePerGas1, maxPriorityFeePerGas2).Div(avrgPriorityFee, big.NewInt(int64(blockHistoryLength)))
		maxFee := (*assets.Wei)(baseFee).AddPercentage(gas.BaseFeeBufferPercentage).Add((*assets.Wei)(avrgPriorityFee))

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		err := u.RefreshDynamicPrice()
		assert.NoError(t, err)
		dynamicFee, err := u.GetDynamicFee(tests.Context(t), maxPrice)
		assert.NoError(t, err)
		assert.Equal(t, maxFee, dynamicFee.GasFeeCap)
		assert.Equal(t, (*assets.Wei)(avrgPriorityFee), dynamicFee.GasTipCap)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(5)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(33)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(20)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(5)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(5)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(feeHistoryResult, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(0)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Add(maxPriorityFeePerGas1, maxPriorityFeePerGas2)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Div(avrgPriorityFee, big.NewInt(int64(blockHistoryLength)))`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(int64(blockHistoryLength))`
$DIR/pkg/gas/fee_history_estimator_test.go: `.AddPercentage(gas.BaseFeeBufferPercentage)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Add((*assets.Wei)(avrgPriorityFee))`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.RefreshDynamicPrice()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxPrice)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("fails if dynamic prices have not been set yet", func(t *testing.T) {
		cfg := gas.FeeHistoryEstimatorConfig{}

		maxPrice := assets.NewWeiI(1)
		u := gas.NewFeeHistoryEstimator(logger.Test(t), nil, cfg, chainID, nil)
		_, err := u.GetDynamicFee(tests.Context(t), maxPrice)
		assert.Error(t, err)
		assert.ErrorContains(t, err, "dynamic price not set")
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), nil, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxPrice)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(3)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(2)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(5)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(feeHistoryResult, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.RefreshDynamicPrice()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxPrice)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(0)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("bumps a previous attempt by BumpPercent", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		originalFee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(20),
			GasTipCap: assets.NewWeiI(10),
		}

		// These values will be ignored because they are lower prices than the originalFee
		feeHistoryResult := &ethereum.FeeHistory{
			OldestBlock:  big.NewInt(1),
			Reward:       [][]*big.Int{{big.NewInt(5), big.NewInt(50)}}, // first one represents market price and second one connectivity price
			BaseFee:      []*big.Int{big.NewInt(5)},
			GasUsedRatio: nil,
		}
		client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()

		cfg := gas.FeeHistoryEstimatorConfig{
			BlockHistorySize: 2,
			BumpPercent:      50,
		}

		expectedFeeCap := originalFee.GasFeeCap.AddPercentage(cfg.BumpPercent)
		expectedTipCap := originalFee.GasTipCap.AddPercentage(cfg.BumpPercent)

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		err := u.RefreshDynamicPrice()
		assert.NoError(t, err)
		dynamicFee, err := u.BumpDynamicFee(tests.Context(t), originalFee, globalMaxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, expectedFeeCap, dynamicFee.GasFeeCap)
		assert.Equal(t, expectedTipCap, dynamicFee.GasTipCap)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(20)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(5)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(50)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(5)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(feeHistoryResult, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.GasFeeCap.AddPercentage(cfg.BumpPercent)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.GasTipCap.AddPercentage(cfg.BumpPercent)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.RefreshDynamicPrice()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, globalMaxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("fails if the original attempt is invalid", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		maxPrice := assets.NewWeiI(20)
		cfg := gas.FeeHistoryEstimatorConfig{BlockHistorySize: 1}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		// nil original fee
		var originalFee gas.DynamicFee
		_, err := u.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)
		assert.Error(t, err)

		// tip cap is higher than fee cap
		originalFee = gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(10),
			GasTipCap: assets.NewWeiI(11),
		}
		_, err = u.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)
		assert.Error(t, err)

		// fee cap is equal or higher to max price
		originalFee = gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(20),
			GasTipCap: assets.NewWeiI(10),
		}
		_, err = u.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)
		assert.Error(t, err)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(20)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(11)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(20)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("returns market prices if bumped original fee is lower", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		originalFee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(20),
			GasTipCap: assets.NewWeiI(10),
		}

		// Market fees
		baseFee := big.NewInt(5)
		maxPriorityFeePerGas := big.NewInt(33)
		feeHistoryResult := &ethereum.FeeHistory{
			OldestBlock:  big.NewInt(1),
			Reward:       [][]*big.Int{{maxPriorityFeePerGas, big.NewInt(100)}}, // first one represents market price and second one connectivity price
			BaseFee:      []*big.Int{baseFee},
			GasUsedRatio: nil,
		}
		client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()

		maxFee := (*assets.Wei)(baseFee).AddPercentage(gas.BaseFeeBufferPercentage).Add((*assets.Wei)(maxPriorityFeePerGas))

		cfg := gas.FeeHistoryEstimatorConfig{
			BlockHistorySize: 1,
			BumpPercent:      50,
		}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		err := u.RefreshDynamicPrice()
		assert.NoError(t, err)
		bumpedFee, err := u.BumpDynamicFee(tests.Context(t), originalFee, globalMaxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, (*assets.Wei)(maxPriorityFeePerGas), bumpedFee.GasTipCap)
		assert.Equal(t, maxFee, bumpedFee.GasFeeCap)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(20)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(5)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(33)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(100)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(feeHistoryResult, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.AddPercentage(gas.BaseFeeBufferPercentage)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Add((*assets.Wei)(maxPriorityFeePerGas))`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.RefreshDynamicPrice()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, globalMaxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("fails if connectivity percentile value is reached", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		originalFee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(20),
			GasTipCap: assets.NewWeiI(10),
		}

		// Market fees
		baseFee := big.NewInt(5)
		maxPriorityFeePerGas := big.NewInt(33)
		feeHistoryResult := &ethereum.FeeHistory{
			OldestBlock:  big.NewInt(1),
			Reward:       [][]*big.Int{{maxPriorityFeePerGas, big.NewInt(30)}}, // first one represents market price and second one connectivity price
			BaseFee:      []*big.Int{baseFee},
			GasUsedRatio: nil,
		}
		client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()

		cfg := gas.FeeHistoryEstimatorConfig{
			BlockHistorySize: 1,
			BumpPercent:      50,
		}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		err := u.RefreshDynamicPrice()
		assert.NoError(t, err)
		_, err = u.BumpDynamicFee(tests.Context(t), originalFee, globalMaxPrice, nil)
		assert.Error(t, err)
		assert.True(t, fees.IsBumpErr(err))
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(20)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(5)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(33)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(30)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(feeHistoryResult, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.RefreshDynamicPrice()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, globalMaxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("returns max price if the aggregation of max and original bumped fee is higher", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		originalFee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(20),
			GasTipCap: assets.NewWeiI(18),
		}

		maxPrice := assets.NewWeiI(25)
		// Market fees
		baseFee := big.NewInt(1)
		maxPriorityFeePerGas := big.NewInt(1)
		feeHistoryResult := &ethereum.FeeHistory{
			OldestBlock:  big.NewInt(1),
			Reward:       [][]*big.Int{{maxPriorityFeePerGas, big.NewInt(30)}}, // first one represents market price and second one connectivity price
			BaseFee:      []*big.Int{baseFee},
			GasUsedRatio: nil,
		}
		client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()

		cfg := gas.FeeHistoryEstimatorConfig{
			BlockHistorySize: 1,
			BumpPercent:      50,
		}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		err := u.RefreshDynamicPrice()
		assert.NoError(t, err)
		bumpedFee, err := u.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)
		assert.NoError(t, err)
		assert.Equal(t, maxPrice, bumpedFee.GasTipCap)
		assert.Equal(t, maxPrice, bumpedFee.GasFeeCap)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(20)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(18)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(25)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(30)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(feeHistoryResult, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.RefreshDynamicPrice()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Run("fails if the bumped gas price is lower than the minimum bump percentage", func(t *testing.T) {
		client := mocks.NewFeeHistoryEstimatorClient(t)
		originalFee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(20),
			GasTipCap: assets.NewWeiI(18),
		}

		maxPrice := assets.NewWeiI(21)
		// Market fees
		baseFee := big.NewInt(1)
		maxPriorityFeePerGas := big.NewInt(1)
		feeHistoryResult := &ethereum.FeeHistory{
			OldestBlock:  big.NewInt(1),
			Reward:       [][]*big.Int{{maxPriorityFeePerGas, big.NewInt(30)}}, // first one represents market price and second one connectivity price
			BaseFee:      []*big.Int{baseFee},
			GasUsedRatio: nil,
		}
		client.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(feeHistoryResult, nil).Once()

		cfg := gas.FeeHistoryEstimatorConfig{
			BlockHistorySize: 1,
			BumpPercent:      50,
		}

		u := gas.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)
		err := u.RefreshDynamicPrice()
		assert.NoError(t, err)
		_, err = u.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)
		assert.Error(t, err)
	})`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(20)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(18)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(21)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(30)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(feeHistoryResult, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Once()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.RefreshDynamicPrice()`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, maxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimatorClient(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(40)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(10)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(0)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewInt(0)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.On("FeeHistory", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Return(feeHistoryResult, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewWei(baseFee)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.AddPercentage(gas.BaseFeeBufferPercentage)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.NewFeeHistoryEstimator(logger.Test(t), client, cfg, chainID, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.RunHealthy(t, u)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, globalMaxPrice, nil)`
$DIR/pkg/gas/fee_history_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `t.Run("GetLegacyGas returns EvmGasPriceDefault from config", func(t *testing.T) {
		config := &gas.MockGasEstimatorConfig{}
		l1Oracle := rollupMocks.NewL1Oracle(t)

		f := gas.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, logger.Test(t), l1Oracle)

		config.PriceDefaultF = assets.NewWeiI(42)
		config.PriceMaxF = maxGasPrice

		gasPrice, gasLimit, err := f.GetLegacyGas(tests.Context(t), nil, 100000, maxGasPrice)
		require.NoError(t, err)
		assert.Equal(t, 100000, int(gasLimit))
		assert.Equal(t, assets.NewWeiI(42), gasPrice)
	})`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.PriceDefaultF = assets.NewWeiI(42)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/fixed_price_estimator_test.go: `t.Run("GetLegacyGas returns user specified maximum gas price", func(t *testing.T) {
		config := &gas.MockGasEstimatorConfig{}
		config.PriceDefaultF = assets.NewWeiI(42)
		config.PriceMaxF = assets.NewWeiI(35)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		f := gas.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, logger.Test(t), l1Oracle)

		gasPrice, gasLimit, err := f.GetLegacyGas(tests.Context(t), nil, 100000, assets.NewWeiI(30))
		require.NoError(t, err)
		assert.Equal(t, 100000, int(gasLimit))
		assert.Equal(t, assets.NewWeiI(30), gasPrice)
	})`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.PriceDefaultF = assets.NewWeiI(42)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.PriceMaxF = assets.NewWeiI(35)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `t.Run("GetLegacyGas returns global maximum gas price", func(t *testing.T) {
		config := &gas.MockGasEstimatorConfig{}
		config.PriceDefaultF = assets.NewWeiI(42)
		config.PriceMaxF = assets.NewWeiI(20)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		f := gas.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, logger.Test(t), l1Oracle)
		gasPrice, gasLimit, err := f.GetLegacyGas(tests.Context(t), nil, 100000, assets.NewWeiI(30))
		require.NoError(t, err)
		assert.Equal(t, 100000, int(gasLimit))
		assert.Equal(t, assets.NewWeiI(20), gasPrice)
	})`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.PriceDefaultF = assets.NewWeiI(42)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.PriceMaxF = assets.NewWeiI(20)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `t.Run("BumpLegacyGas calls BumpLegacyGasPriceOnly", func(t *testing.T) {
		config := &gas.MockGasEstimatorConfig{}
		config.PriceDefaultF = assets.NewWeiI(42)
		config.PriceMaxF = maxGasPrice
		config.BumpPercentF = uint16(10)
		config.BumpMinF = assets.NewWeiI(150)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		lggr := logger.TestSugared(t)
		f := gas.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, lggr, l1Oracle)

		gasPrice, gasLimit, err := f.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
		require.NoError(t, err)

		expectedGasPrice, err := gas.BumpLegacyGasPriceOnly(config, lggr, nil, assets.NewWeiI(42), maxGasPrice)
		require.NoError(t, err)

		assert.Equal(t, 100000, int(gasLimit))
		assert.Equal(t, expectedGasPrice, gasPrice)
	})`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.PriceDefaultF = assets.NewWeiI(42)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.BumpPercentF = uint16(10)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.BumpMinF = assets.NewWeiI(150)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `t.Run("GetDynamicFee returns defaults from config", func(t *testing.T) {
		config := &gas.MockGasEstimatorConfig{}
		config.PriceMaxF = maxGasPrice
		config.TipCapDefaultF = assets.NewWeiI(52)
		config.FeeCapDefaultF = assets.NewWeiI(100)
		config.BumpThresholdF = uint64(3)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		lggr := logger.Test(t)
		f := gas.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, lggr, l1Oracle)

		fee, err := f.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.NoError(t, err)

		assert.Equal(t, assets.NewWeiI(52), fee.GasTipCap)
		assert.Equal(t, assets.NewWeiI(100), fee.GasFeeCap)

		// Gas bumping disabled
		config.BumpThresholdF = uint64(0)

		fee, err = f.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.NoError(t, err)

		assert.Equal(t, assets.NewWeiI(52), fee.GasTipCap)
		assert.Equal(t, maxGasPrice, fee.GasFeeCap)

		// override max gas price
		fee, err = f.GetDynamicFee(tests.Context(t), assets.NewWeiI(10))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWeiI(52), fee.GasTipCap)
		assert.Equal(t, assets.NewWeiI(10), fee.GasFeeCap)
	})`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.TipCapDefaultF = assets.NewWeiI(52)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.FeeCapDefaultF = assets.NewWeiI(100)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.BumpThresholdF = uint64(3)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.BumpThresholdF = uint64(0)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `fee, err = f.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `fee, err = f.GetDynamicFee(tests.Context(t), assets.NewWeiI(10))`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.PriceMaxF = maxGasPrice`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.TipCapDefaultF = assets.NewWeiI(52)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.BumpMinF = assets.NewWeiI(150)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `config.BumpPercentF = uint16(10)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(1000000)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Run("GetLegacyGas returns EvmGasPriceDefault from config", func(t *testing.T) {
		config := &gas.MockGasEstimatorConfig{}
		l1Oracle := rollupMocks.NewL1Oracle(t)

		f := gas.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, logger.Test(t), l1Oracle)

		config.PriceDefaultF = assets.NewWeiI(42)
		config.PriceMaxF = maxGasPrice

		gasPrice, gasLimit, err := f.GetLegacyGas(tests.Context(t), nil, 100000, maxGasPrice)
		require.NoError(t, err)
		assert.Equal(t, 100000, int(gasLimit))
		assert.Equal(t, assets.NewWeiI(42), gasPrice)
	})`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, logger.Test(t), l1Oracle)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.GetLegacyGas(tests.Context(t), nil, 100000, maxGasPrice)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Run("GetLegacyGas returns user specified maximum gas price", func(t *testing.T) {
		config := &gas.MockGasEstimatorConfig{}
		config.PriceDefaultF = assets.NewWeiI(42)
		config.PriceMaxF = assets.NewWeiI(35)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		f := gas.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, logger.Test(t), l1Oracle)

		gasPrice, gasLimit, err := f.GetLegacyGas(tests.Context(t), nil, 100000, assets.NewWeiI(30))
		require.NoError(t, err)
		assert.Equal(t, 100000, int(gasLimit))
		assert.Equal(t, assets.NewWeiI(30), gasPrice)
	})`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(35)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, logger.Test(t), l1Oracle)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.GetLegacyGas(tests.Context(t), nil, 100000, assets.NewWeiI(30))`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(30)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Run("GetLegacyGas returns global maximum gas price", func(t *testing.T) {
		config := &gas.MockGasEstimatorConfig{}
		config.PriceDefaultF = assets.NewWeiI(42)
		config.PriceMaxF = assets.NewWeiI(20)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		f := gas.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, logger.Test(t), l1Oracle)
		gasPrice, gasLimit, err := f.GetLegacyGas(tests.Context(t), nil, 100000, assets.NewWeiI(30))
		require.NoError(t, err)
		assert.Equal(t, 100000, int(gasLimit))
		assert.Equal(t, assets.NewWeiI(20), gasPrice)
	})`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(20)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, logger.Test(t), l1Oracle)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.GetLegacyGas(tests.Context(t), nil, 100000, assets.NewWeiI(30))`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(30)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Run("BumpLegacyGas calls BumpLegacyGasPriceOnly", func(t *testing.T) {
		config := &gas.MockGasEstimatorConfig{}
		config.PriceDefaultF = assets.NewWeiI(42)
		config.PriceMaxF = maxGasPrice
		config.BumpPercentF = uint16(10)
		config.BumpMinF = assets.NewWeiI(150)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		lggr := logger.TestSugared(t)
		f := gas.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, lggr, l1Oracle)

		gasPrice, gasLimit, err := f.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)
		require.NoError(t, err)

		expectedGasPrice, err := gas.BumpLegacyGasPriceOnly(config, lggr, nil, assets.NewWeiI(42), maxGasPrice)
		require.NoError(t, err)

		assert.Equal(t, 100000, int(gasLimit))
		assert.Equal(t, expectedGasPrice, gasPrice)
	})`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(150)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.TestSugared(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, lggr, l1Oracle)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), 100000, maxGasPrice, nil)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.BumpLegacyGasPriceOnly(config, lggr, nil, assets.NewWeiI(42), maxGasPrice)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Run("GetDynamicFee returns defaults from config", func(t *testing.T) {
		config := &gas.MockGasEstimatorConfig{}
		config.PriceMaxF = maxGasPrice
		config.TipCapDefaultF = assets.NewWeiI(52)
		config.FeeCapDefaultF = assets.NewWeiI(100)
		config.BumpThresholdF = uint64(3)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		lggr := logger.Test(t)
		f := gas.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, lggr, l1Oracle)

		fee, err := f.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.NoError(t, err)

		assert.Equal(t, assets.NewWeiI(52), fee.GasTipCap)
		assert.Equal(t, assets.NewWeiI(100), fee.GasFeeCap)

		// Gas bumping disabled
		config.BumpThresholdF = uint64(0)

		fee, err = f.GetDynamicFee(tests.Context(t), maxGasPrice)
		require.NoError(t, err)

		assert.Equal(t, assets.NewWeiI(52), fee.GasTipCap)
		assert.Equal(t, maxGasPrice, fee.GasFeeCap)

		// override max gas price
		fee, err = f.GetDynamicFee(tests.Context(t), assets.NewWeiI(10))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWeiI(52), fee.GasTipCap)
		assert.Equal(t, assets.NewWeiI(10), fee.GasFeeCap)
	})`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(52)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, lggr, l1Oracle)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.GetDynamicFee(tests.Context(t), assets.NewWeiI(10))`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(52)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(150)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.TestSugared(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewFixedPriceEstimator(config, nil, &blockHistoryConfig{}, lggr, l1Oracle)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.NewWeiI(25)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.BumpDynamicFee(tests.Context(t), originalFee, maxGasPrice, nil)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/fixed_price_estimator_test.go: `.BumpDynamicFeeOnly(config, 0, lggr, nil, nil, originalFee, maxGasPrice)`
$DIR/pkg/gas/gas_test.go: `t.Run(test.name, func(t *testing.T) {
			cfg := &gas.MockGasEstimatorConfig{}
			cfg.BumpPercentF = test.bumpPercent
			cfg.BumpMinF = test.bumpMin
			cfg.PriceMaxF = test.priceMax
			cfg.LimitMultiplierF = test.limitMultiplierPercent
			actual, err := gas.BumpLegacyGasPriceOnly(cfg, logger.TestSugared(t), test.currentGasPrice, test.originalGasPrice, test.priceMax)
			require.NoError(t, err)
			if actual.Cmp(test.expectedGasPrice) != 0 {
				t.Fatalf("Expected %s but got %s", test.expectedGasPrice.String(), actual.String())
			}
		})`
$DIR/pkg/gas/gas_test.go: `cfg.BumpPercentF = test.bumpPercent`
$DIR/pkg/gas/gas_test.go: `cfg.BumpMinF = test.bumpMin`
$DIR/pkg/gas/gas_test.go: `cfg.PriceMaxF = test.priceMax`
$DIR/pkg/gas/gas_test.go: `cfg.LimitMultiplierF = test.limitMultiplierPercent`
$DIR/pkg/gas/gas_test.go: `cfg.BumpPercentF = uint16(50)`
$DIR/pkg/gas/gas_test.go: `cfg.BumpMinF = assets.NewWeiI(5000000000)`
$DIR/pkg/gas/gas_test.go: `cfg.PriceMaxF = priceMax`
$DIR/pkg/gas/gas_test.go: `cfg.BumpPercentF = uint16(0)`
$DIR/pkg/gas/gas_test.go: `cfg.BumpMinF = assets.NewWeiI(0)`
$DIR/pkg/gas/gas_test.go: `cfg.PriceMaxF = priceMax`
$DIR/pkg/gas/gas_test.go: `originalGasPrice = toWei("4e10")`
$DIR/pkg/gas/gas_test.go: `_, err = gas.BumpLegacyGasPriceOnly(cfg, lggr, nil, originalGasPrice, priceMax)`
$DIR/pkg/gas/gas_test.go: `t.Run(test.name, func(t *testing.T) {
			cfg := &gas.MockGasEstimatorConfig{}
			cfg.BumpPercentF = test.bumpPercent
			cfg.TipCapDefaultF = test.tipCapDefault
			cfg.BumpMinF = test.bumpMin
			cfg.PriceMaxF = test.priceMax
			cfg.LimitMultiplierF = test.limitMultiplierPercent

			bufferBlocks := uint16(4)
			actual, err := gas.BumpDynamicFeeOnly(cfg, bufferBlocks, logger.TestSugared(t), test.currentGasTipCap, test.currentBaseFee, test.originalFee, test.priceMax)
			require.NoError(t, err)
			if actual.GasTipCap.Cmp(test.expectedFee.GasTipCap) != 0 {
				t.Fatalf("TipCap not equal, expected %s but got %s", test.expectedFee.GasTipCap.String(), actual.GasTipCap.String())
			}
			if actual.GasFeeCap.Cmp(test.expectedFee.GasFeeCap) != 0 {
				t.Fatalf("FeeCap not equal, expected %s but got %s", test.expectedFee.GasFeeCap.String(), actual.GasFeeCap.String())
			}
		})`
$DIR/pkg/gas/gas_test.go: `cfg.BumpPercentF = test.bumpPercent`
$DIR/pkg/gas/gas_test.go: `cfg.TipCapDefaultF = test.tipCapDefault`
$DIR/pkg/gas/gas_test.go: `cfg.BumpMinF = test.bumpMin`
$DIR/pkg/gas/gas_test.go: `cfg.PriceMaxF = test.priceMax`
$DIR/pkg/gas/gas_test.go: `cfg.LimitMultiplierF = test.limitMultiplierPercent`
$DIR/pkg/gas/gas_test.go: `cfg.BumpPercentF = uint16(50)`
$DIR/pkg/gas/gas_test.go: `cfg.TipCapDefaultF = assets.GWei(0)`
$DIR/pkg/gas/gas_test.go: `cfg.BumpMinF = assets.NewWeiI(5000000000)`
$DIR/pkg/gas/gas_test.go: `cfg.PriceMaxF = priceMax`
$DIR/pkg/gas/gas_test.go: `t.Run("tip cap hits max", func(t *testing.T) {
		originalFee := gas.DynamicFee{GasTipCap: assets.GWei(30), GasFeeCap: assets.GWei(100)}
		_, err := gas.BumpDynamicFeeOnly(cfg, 0, logger.TestSugared(t), nil, nil, originalFee, priceMax)
		require.Error(t, err)
		require.Contains(t, err.Error(), "bumped tip cap of 45 gwei would exceed configured max gas price of 40 gwei (original fee: tip cap 30 gwei, fee cap 100 gwei)")
	})`
$DIR/pkg/gas/gas_test.go: `.Run(test.name, func(t *testing.T) {
			cfg := &gas.MockGasEstimatorConfig{}
			cfg.BumpPercentF = test.bumpPercent
			cfg.BumpMinF = test.bumpMin
			cfg.PriceMaxF = test.priceMax
			cfg.LimitMultiplierF = test.limitMultiplierPercent
			actual, err := gas.BumpLegacyGasPriceOnly(cfg, logger.TestSugared(t), test.currentGasPrice, test.originalGasPrice, test.priceMax)
			require.NoError(t, err)
			if actual.Cmp(test.expectedGasPrice) != 0 {
				t.Fatalf("Expected %s but got %s", test.expectedGasPrice.String(), actual.String())
			}
		})`
$DIR/pkg/gas/gas_test.go: `.BumpLegacyGasPriceOnly(cfg, logger.TestSugared(t), test.currentGasPrice, test.originalGasPrice, test.priceMax)`
$DIR/pkg/gas/gas_test.go: `.TestSugared(t)`
$DIR/pkg/gas/gas_test.go: `.Cmp(test.expectedGasPrice)`
$DIR/pkg/gas/gas_test.go: `.GWei(40)`
$DIR/pkg/gas/gas_test.go: `.NewWeiI(5000000000)`
$DIR/pkg/gas/gas_test.go: `.BumpLegacyGasPriceOnly(cfg, logger.TestSugared(t), nil, originalGasPrice, priceMax)`
$DIR/pkg/gas/gas_test.go: `.TestSugared(t)`
$DIR/pkg/gas/gas_test.go: `.GWei(40)`
$DIR/pkg/gas/gas_test.go: `.TestSugared(t)`
$DIR/pkg/gas/gas_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/gas_test.go: `.BumpLegacyGasPriceOnly(cfg, lggr, nil, originalGasPrice, priceMax)`
$DIR/pkg/gas/gas_test.go: `.BumpLegacyGasPriceOnly(cfg, lggr, nil, originalGasPrice, priceMax)`
$DIR/pkg/gas/gas_test.go: `.GWei(30)`
$DIR/pkg/gas/gas_test.go: `.GWei(4000)`
$DIR/pkg/gas/gas_test.go: `.GWei(20)`
$DIR/pkg/gas/gas_test.go: `.GWei(5000)`
$DIR/pkg/gas/gas_test.go: `.GWei(36)`
$DIR/pkg/gas/gas_test.go: `.GWei(4800)`
$DIR/pkg/gas/gas_test.go: `.GWei(30)`
$DIR/pkg/gas/gas_test.go: `.GWei(100)`
$DIR/pkg/gas/gas_test.go: `.GWei(20)`
$DIR/pkg/gas/gas_test.go: `.GWei(39)`
$DIR/pkg/gas/gas_test.go: `.GWei(130)`
$DIR/pkg/gas/gas_test.go: `.GWei(30)`
$DIR/pkg/gas/gas_test.go: `.GWei(400)`
$DIR/pkg/gas/gas_test.go: `.GWei(20)`
$DIR/pkg/gas/gas_test.go: `.GWei(38)`
$DIR/pkg/gas/gas_test.go: `.GWei(480)`
$DIR/pkg/gas/gas_test.go: `.GWei(30)`
$DIR/pkg/gas/gas_test.go: `.GWei(400)`
$DIR/pkg/gas/gas_test.go: `.GWei(40)`
$DIR/pkg/gas/gas_test.go: `.GWei(48)`
$DIR/pkg/gas/gas_test.go: `.GWei(480)`
$DIR/pkg/gas/gas_test.go: `.GWei(48)`
$DIR/pkg/gas/gas_test.go: `.GWei(30)`
$DIR/pkg/gas/gas_test.go: `.GWei(400)`
$DIR/pkg/gas/gas_test.go: `.GWei(40)`
$DIR/pkg/gas/gas_test.go: `.GWei(49)`
$DIR/pkg/gas/gas_test.go: `.GWei(480)`
$DIR/pkg/gas/gas_test.go: `.GWei(50)`
$DIR/pkg/gas/gas_test.go: `.GWei(30)`
$DIR/pkg/gas/gas_test.go: `.GWei(400)`
$DIR/pkg/gas/gas_test.go: `.GWei(40)`
$DIR/pkg/gas/gas_test.go: `.GWei(50)`
$DIR/pkg/gas/gas_test.go: `.GWei(480)`
$DIR/pkg/gas/gas_test.go: `.GWei(10)`
$DIR/pkg/gas/gas_test.go: `.GWei(20)`
$DIR/pkg/gas/gas_test.go: `.GWei(5)`
$DIR/pkg/gas/gas_test.go: `.GWei(50)`
$DIR/pkg/gas/gas_test.go: `.GWei(60)`
$DIR/pkg/gas/gas_test.go: `.GWei(70)`
$DIR/pkg/gas/gas_test.go: `.GWei(20)`
$DIR/pkg/gas/gas_test.go: `.GWei(100)`
$DIR/pkg/gas/gas_test.go: `.GWei(30)`
$DIR/pkg/gas/gas_test.go: `.GWei(400)`
$DIR/pkg/gas/gas_test.go: `.GWei(20)`
$DIR/pkg/gas/gas_test.go: `.GWei(5000)`
$DIR/pkg/gas/gas_test.go: `.GWei(36)`
$DIR/pkg/gas/gas_test.go: `.GWei(480)`
$DIR/pkg/gas/gas_test.go: `.GWei(20)`
$DIR/pkg/gas/gas_test.go: `.GWei(1000)`
$DIR/pkg/gas/gas_test.go: `.GWei(30)`
$DIR/pkg/gas/gas_test.go: `.GWei(400)`
$DIR/pkg/gas/gas_test.go: `.GWei(20)`
$DIR/pkg/gas/gas_test.go: `.GWei(5000)`
$DIR/pkg/gas/gas_test.go: `.GWei(36)`
$DIR/pkg/gas/gas_test.go: `.NewWeiI(1637806640625)`
$DIR/pkg/gas/gas_test.go: `.Run(test.name, func(t *testing.T) {
			cfg := &gas.MockGasEstimatorConfig{}
			cfg.BumpPercentF = test.bumpPercent
			cfg.TipCapDefaultF = test.tipCapDefault
			cfg.BumpMinF = test.bumpMin
			cfg.PriceMaxF = test.priceMax
			cfg.LimitMultiplierF = test.limitMultiplierPercent

			bufferBlocks := uint16(4)
			actual, err := gas.BumpDynamicFeeOnly(cfg, bufferBlocks, logger.TestSugared(t), test.currentGasTipCap, test.currentBaseFee, test.originalFee, test.priceMax)
			require.NoError(t, err)
			if actual.GasTipCap.Cmp(test.expectedFee.GasTipCap) != 0 {
				t.Fatalf("TipCap not equal, expected %s but got %s", test.expectedFee.GasTipCap.String(), actual.GasTipCap.String())
			}
			if actual.GasFeeCap.Cmp(test.expectedFee.GasFeeCap) != 0 {
				t.Fatalf("FeeCap not equal, expected %s but got %s", test.expectedFee.GasFeeCap.String(), actual.GasFeeCap.String())
			}
		})`
$DIR/pkg/gas/gas_test.go: `.BumpDynamicFeeOnly(cfg, bufferBlocks, logger.TestSugared(t), test.currentGasTipCap, test.currentBaseFee, test.originalFee, test.priceMax)`
$DIR/pkg/gas/gas_test.go: `.TestSugared(t)`
$DIR/pkg/gas/gas_test.go: `.GasTipCap.Cmp(test.expectedFee.GasTipCap)`
$DIR/pkg/gas/gas_test.go: `.GasFeeCap.Cmp(test.expectedFee.GasFeeCap)`
$DIR/pkg/gas/gas_test.go: `.GWei(40)`
$DIR/pkg/gas/gas_test.go: `.GWei(0)`
$DIR/pkg/gas/gas_test.go: `.NewWeiI(5000000000)`
$DIR/pkg/gas/gas_test.go: `.Run("tip cap hits max", func(t *testing.T) {
		originalFee := gas.DynamicFee{GasTipCap: assets.GWei(30), GasFeeCap: assets.GWei(100)}
		_, err := gas.BumpDynamicFeeOnly(cfg, 0, logger.TestSugared(t), nil, nil, originalFee, priceMax)
		require.Error(t, err)
		require.Contains(t, err.Error(), "bumped tip cap of 45 gwei would exceed configured max gas price of 40 gwei (original fee: tip cap 30 gwei, fee cap 100 gwei)")
	})`
$DIR/pkg/gas/gas_test.go: `.GWei(30)`
$DIR/pkg/gas/gas_test.go: `.GWei(100)`
$DIR/pkg/gas/gas_test.go: `.BumpDynamicFeeOnly(cfg, 0, logger.TestSugared(t), nil, nil, originalFee, priceMax)`
$DIR/pkg/gas/gas_test.go: `.TestSugared(t)`
$DIR/pkg/gas/gas_test.go: `.GWei(10)`
$DIR/pkg/gas/gas_test.go: `.GWei(100)`
$DIR/pkg/gas/gas_test.go: `.BumpDynamicFeeOnly(cfg, 0, logger.TestSugared(t), nil, nil, originalFee, priceMax)`
$DIR/pkg/gas/gas_test.go: `.TestSugared(t)`
$DIR/pkg/gas/models_test.go: `est.On("GetDynamicFee", mock.Anything, mock.Anything).
		Return(dynamicFee, nil).Times(6)`
$DIR/pkg/gas/models_test.go: `est.On("GetLegacyGas", mock.Anything, mock.Anything, mock.Anything, mock.Anything).
		Return(legacyFee, gasLimit, nil).Times(6)`
$DIR/pkg/gas/models_test.go: `est.On("BumpDynamicFee", mock.Anything, mock.Anything, mock.Anything, mock.Anything).
		Return(dynamicFee, nil).Once()`
$DIR/pkg/gas/models_test.go: `est.On("BumpLegacyGas", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).
		Return(legacyFee, gasLimit, nil).Once()`
$DIR/pkg/gas/models_test.go: `geCfg.LimitMultiplierF = limitMultiplier`
$DIR/pkg/gas/models_test.go: `t.Run("L1Oracle", func(t *testing.T) {
		lggr := logger.Test(t)

		evmEstimator := mocks.NewEvmEstimator(t)
		evmEstimator.On("L1Oracle").Return(nil).Once()

		getEst := func(logger.Logger) gas.EvmEstimator { return evmEstimator }

		// expect nil
		estimator := gas.NewEvmFeeEstimator(lggr, getEst, false, nil, nil)
		l1Oracle := estimator.L1Oracle()

		assert.Nil(t, l1Oracle)

		// expect l1Oracle

		daOracle := rollups.CreateTestDAOracle(t, toml.DAOracleOPStack, "0x420000000000000000000000000000000000000F", "")
		oracle, err := rollups.NewL1GasOracle(lggr, nil, chaintype.ChainOptimismBedrock, daOracle, nil)
		require.NoError(t, err)
		// cast oracle to L1Oracle interface
		estimator = gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)

		evmEstimator.On("L1Oracle").Return(oracle).Once()
		l1Oracle = estimator.L1Oracle()
		assert.Equal(t, oracle, l1Oracle)
	})`
$DIR/pkg/gas/models_test.go: `evmEstimator.On("L1Oracle").Return(nil).Once()`
$DIR/pkg/gas/models_test.go: `estimator = gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `evmEstimator.On("L1Oracle").Return(oracle).Once()`
$DIR/pkg/gas/models_test.go: `l1Oracle = estimator.L1Oracle()`
$DIR/pkg/gas/models_test.go: `t.Run("GetFee", func(t *testing.T) {
		lggr := logger.Test(t)
		// expect legacy fee data
		dynamicFees := false
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)
		fee, max, err := estimator.GetFee(ctx, nil, 0, nil, nil, nil)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), max)
		assert.True(t, legacyFee.Equal(fee.GasPrice))
		assert.Nil(t, fee.GasTipCap)
		assert.Nil(t, fee.GasFeeCap)

		// expect dynamic fee data
		dynamicFees = true
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)
		fee, max, err = estimator.GetFee(ctx, nil, gasLimit, nil, nil, nil)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), max)
		assert.True(t, dynamicFee.GasFeeCap.Equal(fee.GasFeeCap))
		assert.True(t, dynamicFee.GasTipCap.Equal(fee.GasTipCap))
		assert.Nil(t, fee.GasPrice)
	})`
$DIR/pkg/gas/models_test.go: `dynamicFees = true`
$DIR/pkg/gas/models_test.go: `estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `fee, max, err = estimator.GetFee(ctx, nil, gasLimit, nil, nil, nil)`
$DIR/pkg/gas/models_test.go: `t.Run("BumpFee", func(t *testing.T) {
		lggr := logger.Test(t)
		dynamicFees := false
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)

		// expect legacy fee data
		fee, max, err := estimator.BumpFee(ctx, gas.EvmFee{GasPrice: assets.NewWeiI(0)}, 0, nil, nil)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), max)
		assert.True(t, legacyFee.Equal(fee.GasPrice))
		assert.Nil(t, fee.GasTipCap)
		assert.Nil(t, fee.GasFeeCap)

		// expect dynamic fee data
		fee, max, err = estimator.BumpFee(ctx, gas.EvmFee{
			DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(0), GasTipCap: assets.NewWeiI(0)},
		}, gasLimit, nil, nil)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), max)
		assert.True(t, dynamicFee.GasFeeCap.Equal(fee.GasFeeCap))
		assert.True(t, dynamicFee.GasTipCap.Equal(fee.GasTipCap))
		assert.Nil(t, fee.GasPrice)

		// expect error
		_, _, err = estimator.BumpFee(ctx, gas.EvmFee{}, 0, nil, nil)
		assert.Error(t, err)
		_, _, err = estimator.BumpFee(ctx, gas.EvmFee{
			GasPrice:   legacyFee,
			DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(0), GasTipCap: assets.NewWeiI(0)},
		}, 0, nil, nil)
		assert.Error(t, err)
	})`
$DIR/pkg/gas/models_test.go: `fee, max, err = estimator.BumpFee(ctx, gas.EvmFee{
			DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(0), GasTipCap: assets.NewWeiI(0)},
		}, gasLimit, nil, nil)`
$DIR/pkg/gas/models_test.go: `_, _, err = estimator.BumpFee(ctx, gas.EvmFee{}, 0, nil, nil)`
$DIR/pkg/gas/models_test.go: `_, _, err = estimator.BumpFee(ctx, gas.EvmFee{
			GasPrice:   legacyFee,
			DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(0), GasTipCap: assets.NewWeiI(0)},
		}, 0, nil, nil)`
$DIR/pkg/gas/models_test.go: `t.Run("GetMaxCost", func(t *testing.T) {
		lggr := logger.Test(t)
		val := assets.NewEthValue(1)

		// expect legacy fee data
		dynamicFees := false
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)
		total, err := estimator.GetMaxCost(ctx, val, nil, gasLimit, nil, nil, nil)
		require.NoError(t, err)
		fee := new(big.Int).Mul(legacyFee.ToInt(), big.NewInt(int64(gasLimit)))
		fee, _ = new(big.Float).Mul(new(big.Float).SetInt(fee), big.NewFloat(float64(limitMultiplier))).Int(nil)
		assert.Equal(t, new(big.Int).Add(val.ToInt(), fee), total)

		// expect dynamic fee data
		dynamicFees = true
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)
		total, err = estimator.GetMaxCost(ctx, val, nil, gasLimit, nil, nil, nil)
		require.NoError(t, err)
		fee = new(big.Int).Mul(dynamicFee.GasFeeCap.ToInt(), big.NewInt(10))
		fee, _ = new(big.Float).Mul(new(big.Float).SetInt(fee), big.NewFloat(float64(limitMultiplier))).Int(nil)
		assert.Equal(t, new(big.Int).Add(val.ToInt(), fee), total)
	})`
$DIR/pkg/gas/models_test.go: `fee, _ = new(big.Float).Mul(new(big.Float).SetInt(fee), big.NewFloat(float64(limitMultiplier))).Int(nil)`
$DIR/pkg/gas/models_test.go: `dynamicFees = true`
$DIR/pkg/gas/models_test.go: `estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `total, err = estimator.GetMaxCost(ctx, val, nil, gasLimit, nil, nil, nil)`
$DIR/pkg/gas/models_test.go: `fee = new(big.Int).Mul(dynamicFee.GasFeeCap.ToInt(), big.NewInt(10))`
$DIR/pkg/gas/models_test.go: `fee, _ = new(big.Float).Mul(new(big.Float).SetInt(fee), big.NewFloat(float64(limitMultiplier))).Int(nil)`
$DIR/pkg/gas/models_test.go: `t.Run("Name", func(t *testing.T) {
		lggr := logger.Test(t)

		evmEstimator := mocks.NewEvmEstimator(t)
		evmEstimator.On("Name").Return(mockEvmEstimatorName, nil).Once()

		estimator := gas.NewEvmFeeEstimator(lggr, func(logger.Logger) gas.EvmEstimator {
			return evmEstimator
		}, false, geCfg, nil)

		require.Equal(t, mockEstimatorName, estimator.Name())
		require.Equal(t, mockEvmEstimatorName, evmEstimator.Name())
	})`
$DIR/pkg/gas/models_test.go: `evmEstimator.On("Name").Return(mockEvmEstimatorName, nil).Once()`
$DIR/pkg/gas/models_test.go: `t.Run("Start and stop calls both EVM estimator and L1Oracle", func(t *testing.T) {
		lggr := logger.Test(t)
		oracle := rollupMocks.NewL1Oracle(t)
		evmEstimator := mocks.NewEvmEstimator(t)

		evmEstimator.On("Start", mock.Anything).Return(nil).Twice()
		evmEstimator.On("Close").Return(nil).Twice()
		oracle.On("Start", mock.Anything).Return(nil).Once()
		oracle.On("Close").Return(nil).Once()
		getEst := func(logger.Logger) gas.EvmEstimator { return evmEstimator }

		evmEstimator.On("L1Oracle", mock.Anything).Return(nil).Twice()

		estimator := gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)
		err := estimator.Start(ctx)
		require.NoError(t, err)
		err = estimator.Close()
		require.NoError(t, err)

		evmEstimator.On("L1Oracle", mock.Anything).Return(oracle).Twice()

		estimator = gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)
		err = estimator.Start(ctx)
		require.NoError(t, err)
		err = estimator.Close()
		require.NoError(t, err)
	})`
$DIR/pkg/gas/models_test.go: `evmEstimator.On("Start", mock.Anything).Return(nil).Twice()`
$DIR/pkg/gas/models_test.go: `evmEstimator.On("Close").Return(nil).Twice()`
$DIR/pkg/gas/models_test.go: `oracle.On("Start", mock.Anything).Return(nil).Once()`
$DIR/pkg/gas/models_test.go: `oracle.On("Close").Return(nil).Once()`
$DIR/pkg/gas/models_test.go: `evmEstimator.On("L1Oracle", mock.Anything).Return(nil).Twice()`
$DIR/pkg/gas/models_test.go: `err = estimator.Close()`
$DIR/pkg/gas/models_test.go: `evmEstimator.On("L1Oracle", mock.Anything).Return(oracle).Twice()`
$DIR/pkg/gas/models_test.go: `estimator = gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `err = estimator.Start(ctx)`
$DIR/pkg/gas/models_test.go: `err = estimator.Close()`
$DIR/pkg/gas/models_test.go: `t.Run("Read calls both EVM estimator and L1Oracle", func(t *testing.T) {
		lggr := logger.Test(t)
		evmEstimator := mocks.NewEvmEstimator(t)
		oracle := rollupMocks.NewL1Oracle(t)

		evmEstimator.On("L1Oracle").Return(oracle).Twice()
		evmEstimator.On("Ready").Return(nil).Twice()
		oracle.On("Ready").Return(nil).Twice()
		getEst := func(logger.Logger) gas.EvmEstimator { return evmEstimator }

		estimator := gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)
		err := estimator.Ready()
		require.NoError(t, err)

		estimator = gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)
		err = estimator.Ready()
		require.NoError(t, err)
	})`
$DIR/pkg/gas/models_test.go: `evmEstimator.On("L1Oracle").Return(oracle).Twice()`
$DIR/pkg/gas/models_test.go: `evmEstimator.On("Ready").Return(nil).Twice()`
$DIR/pkg/gas/models_test.go: `oracle.On("Ready").Return(nil).Twice()`
$DIR/pkg/gas/models_test.go: `estimator = gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `err = estimator.Ready()`
$DIR/pkg/gas/models_test.go: `t.Run("HealthReport merges report from EVM estimator and L1Oracle", func(t *testing.T) {
		lggr := logger.Test(t)
		evmEstimator := mocks.NewEvmEstimator(t)
		oracle := rollupMocks.NewL1Oracle(t)

		evmEstimatorKey := "evm"
		evmEstimatorError := pkgerrors.New("evm error")
		oracleKey := "oracle"
		oracleError := pkgerrors.New("oracle error")

		evmEstimator.On("L1Oracle").Return(nil).Once()
		evmEstimator.On("HealthReport").Return(map[string]error{evmEstimatorKey: evmEstimatorError}).Twice()

		oracle.On("HealthReport").Return(map[string]error{oracleKey: oracleError}).Once()
		getEst := func(logger.Logger) gas.EvmEstimator { return evmEstimator }

		estimator := gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)
		report := estimator.HealthReport()
		require.True(t, pkgerrors.Is(report[evmEstimatorKey], evmEstimatorError))
		require.NoError(t, report[oracleKey])
		require.Error(t, report[mockEstimatorName])

		evmEstimator.On("L1Oracle").Return(oracle).Once()

		estimator = gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)
		report = estimator.HealthReport()
		require.True(t, pkgerrors.Is(report[evmEstimatorKey], evmEstimatorError))
		require.True(t, pkgerrors.Is(report[oracleKey], oracleError))
		require.Error(t, report[mockEstimatorName])
	})`
$DIR/pkg/gas/models_test.go: `evmEstimator.On("L1Oracle").Return(nil).Once()`
$DIR/pkg/gas/models_test.go: `evmEstimator.On("HealthReport").Return(map[string]error{evmEstimatorKey: evmEstimatorError}).Twice()`
$DIR/pkg/gas/models_test.go: `oracle.On("HealthReport").Return(map[string]error{oracleKey: oracleError}).Once()`
$DIR/pkg/gas/models_test.go: `evmEstimator.On("L1Oracle").Return(oracle).Once()`
$DIR/pkg/gas/models_test.go: `estimator = gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `report = estimator.HealthReport()`
$DIR/pkg/gas/models_test.go: `t.Run("GetFee, estimate gas limit enabled, succeeds", func(t *testing.T) {
		estimatedGasLimit := uint64(5)
		lggr := logger.Test(t)
		// expect legacy fee data
		dynamicFees := false
		geCfg.EstimateLimitF = true
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Twice()
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err := estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(estimatedGasLimit)*gas.EstimateGasBuffer), limit)
		assert.True(t, legacyFee.Equal(fee.GasPrice))
		assert.Nil(t, fee.GasTipCap)
		assert.Nil(t, fee.GasFeeCap)

		// expect dynamic fee data
		dynamicFees = true
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err = estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(estimatedGasLimit)*gas.EstimateGasBuffer), limit)
		assert.True(t, dynamicFee.GasFeeCap.Equal(fee.GasFeeCap))
		assert.True(t, dynamicFee.GasTipCap.Equal(fee.GasTipCap))
		assert.Nil(t, fee.GasPrice)
	})`
$DIR/pkg/gas/models_test.go: `geCfg.EstimateLimitF = true`
$DIR/pkg/gas/models_test.go: `ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Twice()`
$DIR/pkg/gas/models_test.go: `dynamicFees = true`
$DIR/pkg/gas/models_test.go: `estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `fee, limit, err = estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `t.Run("GetFee, estimate gas limit enabled, estimate exceeds provided limit, returns error", func(t *testing.T) {
		estimatedGasLimit := uint64(100)
		lggr := logger.Test(t)
		// expect legacy fee data
		dynamicFees := false
		geCfg.EstimateLimitF = true
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Twice()
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		_, _, err := estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.ErrorIs(t, err, fees.ErrFeeLimitTooLow)

		// expect dynamic fee data
		dynamicFees = true
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		_, _, err = estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.ErrorIs(t, err, fees.ErrFeeLimitTooLow)
	})`
$DIR/pkg/gas/models_test.go: `geCfg.EstimateLimitF = true`
$DIR/pkg/gas/models_test.go: `ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Twice()`
$DIR/pkg/gas/models_test.go: `dynamicFees = true`
$DIR/pkg/gas/models_test.go: `estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `_, _, err = estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `t.Run("GetFee, estimate gas limit enabled, buffer exceeds provided limit, fallsback to provided limit", func(t *testing.T) {
		estimatedGasLimit := uint64(15) // same as provided limit
		lggr := logger.Test(t)
		dynamicFees := false // expect legacy fee data
		geCfg.EstimateLimitF = true
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Twice()
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err := estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), limit)
		assert.True(t, legacyFee.Equal(fee.GasPrice))
		assert.Nil(t, fee.GasTipCap)
		assert.Nil(t, fee.GasFeeCap)

		dynamicFees = true // expect dynamic fee data
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err = estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), limit)
		assert.True(t, dynamicFee.GasFeeCap.Equal(fee.GasFeeCap))
		assert.True(t, dynamicFee.GasTipCap.Equal(fee.GasTipCap))
		assert.Nil(t, fee.GasPrice)
	})`
$DIR/pkg/gas/models_test.go: `geCfg.EstimateLimitF = true`
$DIR/pkg/gas/models_test.go: `ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Twice()`
$DIR/pkg/gas/models_test.go: `dynamicFees = true`
$DIR/pkg/gas/models_test.go: `estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `fee, limit, err = estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `t.Run("GetFee, estimate gas limit enabled, RPC fails and fallsback to provided gas limit", func(t *testing.T) {
		lggr := logger.Test(t)
		// expect legacy fee data
		dynamicFees := false
		geCfg.EstimateLimitF = true
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(uint64(0), errors.New("something broke")).Twice()
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err := estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), limit)
		assert.True(t, legacyFee.Equal(fee.GasPrice))
		assert.Nil(t, fee.GasTipCap)
		assert.Nil(t, fee.GasFeeCap)

		// expect dynamic fee data
		dynamicFees = true
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err = estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), limit)
		assert.True(t, dynamicFee.GasFeeCap.Equal(fee.GasFeeCap))
		assert.True(t, dynamicFee.GasTipCap.Equal(fee.GasTipCap))
		assert.Nil(t, fee.GasPrice)
	})`
$DIR/pkg/gas/models_test.go: `geCfg.EstimateLimitF = true`
$DIR/pkg/gas/models_test.go: `ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(uint64(0), errors.New("something broke")).Twice()`
$DIR/pkg/gas/models_test.go: `dynamicFees = true`
$DIR/pkg/gas/models_test.go: `estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `fee, limit, err = estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `t.Run("GetFee, estimate gas limit enabled, provided fee limit 0, returns uncapped estimation", func(t *testing.T) {
		est.On("GetDynamicFee", mock.Anything, mock.Anything).
			Return(dynamicFee, nil).Once()
		est.On("GetLegacyGas", mock.Anything, mock.Anything, uint64(0), mock.Anything).
			Return(legacyFee, uint64(0), nil).Once()
		estimatedGasLimit := uint64(100) // same as provided limit
		lggr := logger.Test(t)
		// expect legacy fee data
		dynamicFees := false
		geCfg.EstimateLimitF = true
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Twice()
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err := estimator.GetFee(ctx, []byte{}, uint64(0), nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(estimatedGasLimit)*gas.EstimateGasBuffer), limit)
		assert.True(t, legacyFee.Equal(fee.GasPrice))
		assert.Nil(t, fee.GasTipCap)
		assert.Nil(t, fee.GasFeeCap)

		// expect dynamic fee data
		dynamicFees = true
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err = estimator.GetFee(ctx, []byte{}, 0, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(estimatedGasLimit)*gas.EstimateGasBuffer), limit)
		assert.True(t, dynamicFee.GasFeeCap.Equal(fee.GasFeeCap))
		assert.True(t, dynamicFee.GasTipCap.Equal(fee.GasTipCap))
		assert.Nil(t, fee.GasPrice)
	})`
$DIR/pkg/gas/models_test.go: `est.On("GetDynamicFee", mock.Anything, mock.Anything).
			Return(dynamicFee, nil).Once()`
$DIR/pkg/gas/models_test.go: `est.On("GetLegacyGas", mock.Anything, mock.Anything, uint64(0), mock.Anything).
			Return(legacyFee, uint64(0), nil).Once()`
$DIR/pkg/gas/models_test.go: `geCfg.EstimateLimitF = true`
$DIR/pkg/gas/models_test.go: `ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Twice()`
$DIR/pkg/gas/models_test.go: `dynamicFees = true`
$DIR/pkg/gas/models_test.go: `estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `fee, limit, err = estimator.GetFee(ctx, []byte{}, 0, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `est.On("GetDynamicFee", mock.Anything, mock.Anything).
			Return(dynamicFee, nil).Once()`
$DIR/pkg/gas/models_test.go: `est.On("GetLegacyGas", mock.Anything, mock.Anything, uint64(0), mock.Anything).
			Return(legacyFee, uint64(0), nil).Once()`
$DIR/pkg/gas/models_test.go: `geCfg.EstimateLimitF = true`
$DIR/pkg/gas/models_test.go: `ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(uint64(0), errors.New("something broke")).Twice()`
$DIR/pkg/gas/models_test.go: `dynamicFees = true`
$DIR/pkg/gas/models_test.go: `estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `_, _, err = estimator.GetFee(ctx, []byte{}, 0, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `.Context(t)`
$DIR/pkg/gas/models_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/models_test.go: `.NewWeiI(20)`
$DIR/pkg/gas/models_test.go: `.NewWeiI(1)`
$DIR/pkg/gas/models_test.go: `.NewEvmEstimator(t)`
$DIR/pkg/gas/models_test.go: `.On("GetDynamicFee", mock.Anything, mock.Anything)`
$DIR/pkg/gas/models_test.go: `.
		Return(dynamicFee, nil)`
$DIR/pkg/gas/models_test.go: `.Times(6)`
$DIR/pkg/gas/models_test.go: `.On("GetLegacyGas", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/gas/models_test.go: `.
		Return(legacyFee, gasLimit, nil)`
$DIR/pkg/gas/models_test.go: `.Times(6)`
$DIR/pkg/gas/models_test.go: `.On("BumpDynamicFee", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/gas/models_test.go: `.
		Return(dynamicFee, nil)`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.On("BumpLegacyGas", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/gas/models_test.go: `.
		Return(legacyFee, gasLimit, nil)`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.NewMockGasConfig()`
$DIR/pkg/gas/models_test.go: `.NewAddress()`
$DIR/pkg/gas/models_test.go: `.NewAddress()`
$DIR/pkg/gas/models_test.go: `.Run("L1Oracle", func(t *testing.T) {
		lggr := logger.Test(t)

		evmEstimator := mocks.NewEvmEstimator(t)
		evmEstimator.On("L1Oracle").Return(nil).Once()

		getEst := func(logger.Logger) gas.EvmEstimator { return evmEstimator }

		// expect nil
		estimator := gas.NewEvmFeeEstimator(lggr, getEst, false, nil, nil)
		l1Oracle := estimator.L1Oracle()

		assert.Nil(t, l1Oracle)

		// expect l1Oracle

		daOracle := rollups.CreateTestDAOracle(t, toml.DAOracleOPStack, "0x420000000000000000000000000000000000000F", "")
		oracle, err := rollups.NewL1GasOracle(lggr, nil, chaintype.ChainOptimismBedrock, daOracle, nil)
		require.NoError(t, err)
		// cast oracle to L1Oracle interface
		estimator = gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)

		evmEstimator.On("L1Oracle").Return(oracle).Once()
		l1Oracle = estimator.L1Oracle()
		assert.Equal(t, oracle, l1Oracle)
	})`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewEvmEstimator(t)`
$DIR/pkg/gas/models_test.go: `.On("L1Oracle")`
$DIR/pkg/gas/models_test.go: `.Return(nil)`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getEst, false, nil, nil)`
$DIR/pkg/gas/models_test.go: `.L1Oracle()`
$DIR/pkg/gas/models_test.go: `.CreateTestDAOracle(t, toml.DAOracleOPStack, "0x420000000000000000000000000000000000000F", "")`
$DIR/pkg/gas/models_test.go: `.NewL1GasOracle(lggr, nil, chaintype.ChainOptimismBedrock, daOracle, nil)`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `.On("L1Oracle")`
$DIR/pkg/gas/models_test.go: `.Return(oracle)`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.L1Oracle()`
$DIR/pkg/gas/models_test.go: `.Run("GetFee", func(t *testing.T) {
		lggr := logger.Test(t)
		// expect legacy fee data
		dynamicFees := false
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)
		fee, max, err := estimator.GetFee(ctx, nil, 0, nil, nil, nil)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), max)
		assert.True(t, legacyFee.Equal(fee.GasPrice))
		assert.Nil(t, fee.GasTipCap)
		assert.Nil(t, fee.GasFeeCap)

		// expect dynamic fee data
		dynamicFees = true
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)
		fee, max, err = estimator.GetFee(ctx, nil, gasLimit, nil, nil, nil)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), max)
		assert.True(t, dynamicFee.GasFeeCap.Equal(fee.GasFeeCap))
		assert.True(t, dynamicFee.GasTipCap.Equal(fee.GasTipCap))
		assert.Nil(t, fee.GasPrice)
	})`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, nil, 0, nil, nil, nil)`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, nil, gasLimit, nil, nil, nil)`
$DIR/pkg/gas/models_test.go: `.Run("BumpFee", func(t *testing.T) {
		lggr := logger.Test(t)
		dynamicFees := false
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)

		// expect legacy fee data
		fee, max, err := estimator.BumpFee(ctx, gas.EvmFee{GasPrice: assets.NewWeiI(0)}, 0, nil, nil)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), max)
		assert.True(t, legacyFee.Equal(fee.GasPrice))
		assert.Nil(t, fee.GasTipCap)
		assert.Nil(t, fee.GasFeeCap)

		// expect dynamic fee data
		fee, max, err = estimator.BumpFee(ctx, gas.EvmFee{
			DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(0), GasTipCap: assets.NewWeiI(0)},
		}, gasLimit, nil, nil)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), max)
		assert.True(t, dynamicFee.GasFeeCap.Equal(fee.GasFeeCap))
		assert.True(t, dynamicFee.GasTipCap.Equal(fee.GasTipCap))
		assert.Nil(t, fee.GasPrice)

		// expect error
		_, _, err = estimator.BumpFee(ctx, gas.EvmFee{}, 0, nil, nil)
		assert.Error(t, err)
		_, _, err = estimator.BumpFee(ctx, gas.EvmFee{
			GasPrice:   legacyFee,
			DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(0), GasTipCap: assets.NewWeiI(0)},
		}, 0, nil, nil)
		assert.Error(t, err)
	})`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `.BumpFee(ctx, gas.EvmFee{GasPrice: assets.NewWeiI(0)}, 0, nil, nil)`
$DIR/pkg/gas/models_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/models_test.go: `.BumpFee(ctx, gas.EvmFee{
			DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(0), GasTipCap: assets.NewWeiI(0)},
		}, gasLimit, nil, nil)`
$DIR/pkg/gas/models_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/models_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/models_test.go: `.BumpFee(ctx, gas.EvmFee{}, 0, nil, nil)`
$DIR/pkg/gas/models_test.go: `.BumpFee(ctx, gas.EvmFee{
			GasPrice:   legacyFee,
			DynamicFee: gas.DynamicFee{GasFeeCap: assets.NewWeiI(0), GasTipCap: assets.NewWeiI(0)},
		}, 0, nil, nil)`
$DIR/pkg/gas/models_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/models_test.go: `.NewWeiI(0)`
$DIR/pkg/gas/models_test.go: `.Run("GetMaxCost", func(t *testing.T) {
		lggr := logger.Test(t)
		val := assets.NewEthValue(1)

		// expect legacy fee data
		dynamicFees := false
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)
		total, err := estimator.GetMaxCost(ctx, val, nil, gasLimit, nil, nil, nil)
		require.NoError(t, err)
		fee := new(big.Int).Mul(legacyFee.ToInt(), big.NewInt(int64(gasLimit)))
		fee, _ = new(big.Float).Mul(new(big.Float).SetInt(fee), big.NewFloat(float64(limitMultiplier))).Int(nil)
		assert.Equal(t, new(big.Int).Add(val.ToInt(), fee), total)

		// expect dynamic fee data
		dynamicFees = true
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)
		total, err = estimator.GetMaxCost(ctx, val, nil, gasLimit, nil, nil, nil)
		require.NoError(t, err)
		fee = new(big.Int).Mul(dynamicFee.GasFeeCap.ToInt(), big.NewInt(10))
		fee, _ = new(big.Float).Mul(new(big.Float).SetInt(fee), big.NewFloat(float64(limitMultiplier))).Int(nil)
		assert.Equal(t, new(big.Int).Add(val.ToInt(), fee), total)
	})`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewEthValue(1)`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `.GetMaxCost(ctx, val, nil, gasLimit, nil, nil, nil)`
$DIR/pkg/gas/models_test.go: `.Mul(legacyFee.ToInt(), big.NewInt(int64(gasLimit)))`
$DIR/pkg/gas/models_test.go: `.ToInt()`
$DIR/pkg/gas/models_test.go: `.NewInt(int64(gasLimit))`
$DIR/pkg/gas/models_test.go: `.Mul(new(big.Float).SetInt(fee), big.NewFloat(float64(limitMultiplier)))`
$DIR/pkg/gas/models_test.go: `.SetInt(fee)`
$DIR/pkg/gas/models_test.go: `.NewFloat(float64(limitMultiplier))`
$DIR/pkg/gas/models_test.go: `.Int(nil)`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `.GetMaxCost(ctx, val, nil, gasLimit, nil, nil, nil)`
$DIR/pkg/gas/models_test.go: `.Mul(dynamicFee.GasFeeCap.ToInt(), big.NewInt(10))`
$DIR/pkg/gas/models_test.go: `.GasFeeCap.ToInt()`
$DIR/pkg/gas/models_test.go: `.NewInt(10)`
$DIR/pkg/gas/models_test.go: `.Mul(new(big.Float).SetInt(fee), big.NewFloat(float64(limitMultiplier)))`
$DIR/pkg/gas/models_test.go: `.SetInt(fee)`
$DIR/pkg/gas/models_test.go: `.NewFloat(float64(limitMultiplier))`
$DIR/pkg/gas/models_test.go: `.Int(nil)`
$DIR/pkg/gas/models_test.go: `.Run("Name", func(t *testing.T) {
		lggr := logger.Test(t)

		evmEstimator := mocks.NewEvmEstimator(t)
		evmEstimator.On("Name").Return(mockEvmEstimatorName, nil).Once()

		estimator := gas.NewEvmFeeEstimator(lggr, func(logger.Logger) gas.EvmEstimator {
			return evmEstimator
		}, false, geCfg, nil)

		require.Equal(t, mockEstimatorName, estimator.Name())
		require.Equal(t, mockEvmEstimatorName, evmEstimator.Name())
	})`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewEvmEstimator(t)`
$DIR/pkg/gas/models_test.go: `.On("Name")`
$DIR/pkg/gas/models_test.go: `.Return(mockEvmEstimatorName, nil)`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, func(logger.Logger) gas.EvmEstimator {
			return evmEstimator
		}, false, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `.Run("Start and stop calls both EVM estimator and L1Oracle", func(t *testing.T) {
		lggr := logger.Test(t)
		oracle := rollupMocks.NewL1Oracle(t)
		evmEstimator := mocks.NewEvmEstimator(t)

		evmEstimator.On("Start", mock.Anything).Return(nil).Twice()
		evmEstimator.On("Close").Return(nil).Twice()
		oracle.On("Start", mock.Anything).Return(nil).Once()
		oracle.On("Close").Return(nil).Once()
		getEst := func(logger.Logger) gas.EvmEstimator { return evmEstimator }

		evmEstimator.On("L1Oracle", mock.Anything).Return(nil).Twice()

		estimator := gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)
		err := estimator.Start(ctx)
		require.NoError(t, err)
		err = estimator.Close()
		require.NoError(t, err)

		evmEstimator.On("L1Oracle", mock.Anything).Return(oracle).Twice()

		estimator = gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)
		err = estimator.Start(ctx)
		require.NoError(t, err)
		err = estimator.Close()
		require.NoError(t, err)
	})`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/models_test.go: `.NewEvmEstimator(t)`
$DIR/pkg/gas/models_test.go: `.On("Start", mock.Anything)`
$DIR/pkg/gas/models_test.go: `.Return(nil)`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.On("Close")`
$DIR/pkg/gas/models_test.go: `.Return(nil)`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.On("Start", mock.Anything)`
$DIR/pkg/gas/models_test.go: `.Return(nil)`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.On("Close")`
$DIR/pkg/gas/models_test.go: `.Return(nil)`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.On("L1Oracle", mock.Anything)`
$DIR/pkg/gas/models_test.go: `.Return(nil)`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `.Start(ctx)`
$DIR/pkg/gas/models_test.go: `.On("L1Oracle", mock.Anything)`
$DIR/pkg/gas/models_test.go: `.Return(oracle)`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `.Start(ctx)`
$DIR/pkg/gas/models_test.go: `.Run("Read calls both EVM estimator and L1Oracle", func(t *testing.T) {
		lggr := logger.Test(t)
		evmEstimator := mocks.NewEvmEstimator(t)
		oracle := rollupMocks.NewL1Oracle(t)

		evmEstimator.On("L1Oracle").Return(oracle).Twice()
		evmEstimator.On("Ready").Return(nil).Twice()
		oracle.On("Ready").Return(nil).Twice()
		getEst := func(logger.Logger) gas.EvmEstimator { return evmEstimator }

		estimator := gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)
		err := estimator.Ready()
		require.NoError(t, err)

		estimator = gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)
		err = estimator.Ready()
		require.NoError(t, err)
	})`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewEvmEstimator(t)`
$DIR/pkg/gas/models_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/models_test.go: `.On("L1Oracle")`
$DIR/pkg/gas/models_test.go: `.Return(oracle)`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.On("Ready")`
$DIR/pkg/gas/models_test.go: `.Return(nil)`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.On("Ready")`
$DIR/pkg/gas/models_test.go: `.Return(nil)`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `.Ready()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `.Ready()`
$DIR/pkg/gas/models_test.go: `.Run("HealthReport merges report from EVM estimator and L1Oracle", func(t *testing.T) {
		lggr := logger.Test(t)
		evmEstimator := mocks.NewEvmEstimator(t)
		oracle := rollupMocks.NewL1Oracle(t)

		evmEstimatorKey := "evm"
		evmEstimatorError := pkgerrors.New("evm error")
		oracleKey := "oracle"
		oracleError := pkgerrors.New("oracle error")

		evmEstimator.On("L1Oracle").Return(nil).Once()
		evmEstimator.On("HealthReport").Return(map[string]error{evmEstimatorKey: evmEstimatorError}).Twice()

		oracle.On("HealthReport").Return(map[string]error{oracleKey: oracleError}).Once()
		getEst := func(logger.Logger) gas.EvmEstimator { return evmEstimator }

		estimator := gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)
		report := estimator.HealthReport()
		require.True(t, pkgerrors.Is(report[evmEstimatorKey], evmEstimatorError))
		require.NoError(t, report[oracleKey])
		require.Error(t, report[mockEstimatorName])

		evmEstimator.On("L1Oracle").Return(oracle).Once()

		estimator = gas.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)
		report = estimator.HealthReport()
		require.True(t, pkgerrors.Is(report[evmEstimatorKey], evmEstimatorError))
		require.True(t, pkgerrors.Is(report[oracleKey], oracleError))
		require.Error(t, report[mockEstimatorName])
	})`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewEvmEstimator(t)`
$DIR/pkg/gas/models_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/models_test.go: `.New("evm error")`
$DIR/pkg/gas/models_test.go: `.New("oracle error")`
$DIR/pkg/gas/models_test.go: `.On("L1Oracle")`
$DIR/pkg/gas/models_test.go: `.Return(nil)`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.On("HealthReport")`
$DIR/pkg/gas/models_test.go: `.Return(map[string]error{evmEstimatorKey: evmEstimatorError})`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.On("HealthReport")`
$DIR/pkg/gas/models_test.go: `.Return(map[string]error{oracleKey: oracleError})`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `.HealthReport()`
$DIR/pkg/gas/models_test.go: `.On("L1Oracle")`
$DIR/pkg/gas/models_test.go: `.Return(oracle)`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getEst, false, geCfg, nil)`
$DIR/pkg/gas/models_test.go: `.HealthReport()`
$DIR/pkg/gas/models_test.go: `.Run("GetFee, estimate gas limit enabled, succeeds", func(t *testing.T) {
		estimatedGasLimit := uint64(5)
		lggr := logger.Test(t)
		// expect legacy fee data
		dynamicFees := false
		geCfg.EstimateLimitF = true
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Twice()
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err := estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(estimatedGasLimit)*gas.EstimateGasBuffer), limit)
		assert.True(t, legacyFee.Equal(fee.GasPrice))
		assert.Nil(t, fee.GasTipCap)
		assert.Nil(t, fee.GasFeeCap)

		// expect dynamic fee data
		dynamicFees = true
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err = estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(estimatedGasLimit)*gas.EstimateGasBuffer), limit)
		assert.True(t, dynamicFee.GasFeeCap.Equal(fee.GasFeeCap))
		assert.True(t, dynamicFee.GasTipCap.Equal(fee.GasTipCap))
		assert.Nil(t, fee.GasPrice)
	})`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/models_test.go: `.On("EstimateGas", mock.Anything, mock.Anything)`
$DIR/pkg/gas/models_test.go: `.Return(estimatedGasLimit, nil)`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `.Run("GetFee, estimate gas limit enabled, estimate exceeds provided limit, returns error", func(t *testing.T) {
		estimatedGasLimit := uint64(100)
		lggr := logger.Test(t)
		// expect legacy fee data
		dynamicFees := false
		geCfg.EstimateLimitF = true
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Twice()
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		_, _, err := estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.ErrorIs(t, err, fees.ErrFeeLimitTooLow)

		// expect dynamic fee data
		dynamicFees = true
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		_, _, err = estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.ErrorIs(t, err, fees.ErrFeeLimitTooLow)
	})`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/models_test.go: `.On("EstimateGas", mock.Anything, mock.Anything)`
$DIR/pkg/gas/models_test.go: `.Return(estimatedGasLimit, nil)`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `.Run("GetFee, estimate gas limit enabled, buffer exceeds provided limit, fallsback to provided limit", func(t *testing.T) {
		estimatedGasLimit := uint64(15) // same as provided limit
		lggr := logger.Test(t)
		dynamicFees := false // expect legacy fee data
		geCfg.EstimateLimitF = true
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Twice()
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err := estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), limit)
		assert.True(t, legacyFee.Equal(fee.GasPrice))
		assert.Nil(t, fee.GasTipCap)
		assert.Nil(t, fee.GasFeeCap)

		dynamicFees = true // expect dynamic fee data
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err = estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), limit)
		assert.True(t, dynamicFee.GasFeeCap.Equal(fee.GasFeeCap))
		assert.True(t, dynamicFee.GasTipCap.Equal(fee.GasTipCap))
		assert.Nil(t, fee.GasPrice)
	})`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/models_test.go: `.On("EstimateGas", mock.Anything, mock.Anything)`
$DIR/pkg/gas/models_test.go: `.Return(estimatedGasLimit, nil)`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `.Run("GetFee, estimate gas limit enabled, RPC fails and fallsback to provided gas limit", func(t *testing.T) {
		lggr := logger.Test(t)
		// expect legacy fee data
		dynamicFees := false
		geCfg.EstimateLimitF = true
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(uint64(0), errors.New("something broke")).Twice()
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err := estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), limit)
		assert.True(t, legacyFee.Equal(fee.GasPrice))
		assert.Nil(t, fee.GasTipCap)
		assert.Nil(t, fee.GasFeeCap)

		// expect dynamic fee data
		dynamicFees = true
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err = estimator.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(gasLimit)*limitMultiplier), limit)
		assert.True(t, dynamicFee.GasFeeCap.Equal(fee.GasFeeCap))
		assert.True(t, dynamicFee.GasTipCap.Equal(fee.GasTipCap))
		assert.Nil(t, fee.GasPrice)
	})`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/models_test.go: `.On("EstimateGas", mock.Anything, mock.Anything)`
$DIR/pkg/gas/models_test.go: `.Return(uint64(0), errors.New("something broke"))`
$DIR/pkg/gas/models_test.go: `.New("something broke")`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, []byte{}, gasLimit, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `.Run("GetFee, estimate gas limit enabled, provided fee limit 0, returns uncapped estimation", func(t *testing.T) {
		est.On("GetDynamicFee", mock.Anything, mock.Anything).
			Return(dynamicFee, nil).Once()
		est.On("GetLegacyGas", mock.Anything, mock.Anything, uint64(0), mock.Anything).
			Return(legacyFee, uint64(0), nil).Once()
		estimatedGasLimit := uint64(100) // same as provided limit
		lggr := logger.Test(t)
		// expect legacy fee data
		dynamicFees := false
		geCfg.EstimateLimitF = true
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Twice()
		estimator := gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err := estimator.GetFee(ctx, []byte{}, uint64(0), nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(estimatedGasLimit)*gas.EstimateGasBuffer), limit)
		assert.True(t, legacyFee.Equal(fee.GasPrice))
		assert.Nil(t, fee.GasTipCap)
		assert.Nil(t, fee.GasFeeCap)

		// expect dynamic fee data
		dynamicFees = true
		estimator = gas.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)
		fee, limit, err = estimator.GetFee(ctx, []byte{}, 0, nil, &fromAddress, &toAddress)
		require.NoError(t, err)
		assert.Equal(t, uint64(float32(estimatedGasLimit)*gas.EstimateGasBuffer), limit)
		assert.True(t, dynamicFee.GasFeeCap.Equal(fee.GasFeeCap))
		assert.True(t, dynamicFee.GasTipCap.Equal(fee.GasTipCap))
		assert.Nil(t, fee.GasPrice)
	})`
$DIR/pkg/gas/models_test.go: `.On("GetDynamicFee", mock.Anything, mock.Anything)`
$DIR/pkg/gas/models_test.go: `.
			Return(dynamicFee, nil)`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.On("GetLegacyGas", mock.Anything, mock.Anything, uint64(0), mock.Anything)`
$DIR/pkg/gas/models_test.go: `.
			Return(legacyFee, uint64(0), nil)`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/models_test.go: `.On("EstimateGas", mock.Anything, mock.Anything)`
$DIR/pkg/gas/models_test.go: `.Return(estimatedGasLimit, nil)`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, []byte{}, uint64(0), nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, []byte{}, 0, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `.On("GetDynamicFee", mock.Anything, mock.Anything)`
$DIR/pkg/gas/models_test.go: `.
			Return(dynamicFee, nil)`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.On("GetLegacyGas", mock.Anything, mock.Anything, uint64(0), mock.Anything)`
$DIR/pkg/gas/models_test.go: `.
			Return(legacyFee, uint64(0), nil)`
$DIR/pkg/gas/models_test.go: `.Once()`
$DIR/pkg/gas/models_test.go: `.Test(t)`
$DIR/pkg/gas/models_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/gas/models_test.go: `.On("EstimateGas", mock.Anything, mock.Anything)`
$DIR/pkg/gas/models_test.go: `.Return(uint64(0), errors.New("something broke"))`
$DIR/pkg/gas/models_test.go: `.New("something broke")`
$DIR/pkg/gas/models_test.go: `.Twice()`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, []byte{}, 0, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/models_test.go: `.NewEvmFeeEstimator(lggr, getRootEst, dynamicFees, geCfg, ethClient)`
$DIR/pkg/gas/models_test.go: `.GetFee(ctx, []byte{}, 0, nil, &fromAddress, &toAddress)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `t.Run("throws error if oracle type is not custom_calldata", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)
		daOracleConfig := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		_, err := NewCustomCalldataDAOracle(logger.Test(t), ethClient, chaintype.ChainArbitrum, daOracleConfig)
		require.Error(t, err)
	})`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `t.Run("throws error if CustomGasPriceCalldata is empty", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)

		daOracleConfig := CreateTestDAOracle(t, toml.DAOracleCustomCalldata, oracleAddress, "")
		_, err := NewCustomCalldataDAOracle(logger.Test(t), ethClient, chaintype.ChainCelo, daOracleConfig)
		require.Error(t, err)
	})`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `t.Run("correctly fetches gas price if DA oracle config has custom calldata", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)
		expectedPriceHex := "0x32" // 50

		daOracleConfig := CreateTestDAOracle(t, toml.DAOracleCustomCalldata, oracleAddress, "0x0000000000000000000000000000000000001234")
		oracle, err := NewCustomCalldataDAOracle(logger.Test(t), ethClient, chaintype.ChainZkSync, daOracleConfig)
		require.NoError(t, err)

		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			require.NotNil(t, callMsg.To)
			require.Equal(t, oracleAddress, callMsg.To.String())
			require.Nil(t, blockNumber)
		}).Return(hexutil.MustDecode(expectedPriceHex), nil).Once()

		price, err := oracle.getCustomCalldataGasPrice(tests.Context(t))
		require.NoError(t, err)
		require.Equal(t, big.NewInt(50), price)
	})`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			require.NotNil(t, callMsg.To)
			require.Equal(t, oracleAddress, callMsg.To.String())
			require.Nil(t, blockNumber)
		}).Return(hexutil.MustDecode(expectedPriceHex), nil).Once()`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `t.Run("throws error if custom calldata fails to decode", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)

		daOracleConfig := CreateTestDAOracle(t, toml.DAOracleCustomCalldata, oracleAddress, "0xblahblahblah")
		oracle, err := NewCustomCalldataDAOracle(logger.Test(t), ethClient, chaintype.ChainCelo, daOracleConfig)
		require.NoError(t, err)

		_, err = oracle.getCustomCalldataGasPrice(tests.Context(t))
		require.Error(t, err)
	})`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `_, err = oracle.getCustomCalldataGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `ethClient.On("CallContract", mock.Anything, mock.Anything, mock.Anything).Return(nil, errors.New("RPC failure")).Once()`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `_, err = oracle.getCustomCalldataGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.RandomAddress()`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Run("throws error if oracle type is not custom_calldata", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)
		daOracleConfig := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		_, err := NewCustomCalldataDAOracle(logger.Test(t), ethClient, chaintype.ChainArbitrum, daOracleConfig)
		require.Error(t, err)
	})`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Run("throws error if CustomGasPriceCalldata is empty", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)

		daOracleConfig := CreateTestDAOracle(t, toml.DAOracleCustomCalldata, oracleAddress, "")
		_, err := NewCustomCalldataDAOracle(logger.Test(t), ethClient, chaintype.ChainCelo, daOracleConfig)
		require.Error(t, err)
	})`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.RandomAddress()`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Run("correctly fetches gas price if DA oracle config has custom calldata", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)
		expectedPriceHex := "0x32" // 50

		daOracleConfig := CreateTestDAOracle(t, toml.DAOracleCustomCalldata, oracleAddress, "0x0000000000000000000000000000000000001234")
		oracle, err := NewCustomCalldataDAOracle(logger.Test(t), ethClient, chaintype.ChainZkSync, daOracleConfig)
		require.NoError(t, err)

		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			require.NotNil(t, callMsg.To)
			require.Equal(t, oracleAddress, callMsg.To.String())
			require.Nil(t, blockNumber)
		}).Return(hexutil.MustDecode(expectedPriceHex), nil).Once()

		price, err := oracle.getCustomCalldataGasPrice(tests.Context(t))
		require.NoError(t, err)
		require.Equal(t, big.NewInt(50), price)
	})`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			require.NotNil(t, callMsg.To)
			require.Equal(t, oracleAddress, callMsg.To.String())
			require.Nil(t, blockNumber)
		})`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Get(2)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Return(hexutil.MustDecode(expectedPriceHex), nil)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.MustDecode(expectedPriceHex)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Once()`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.getCustomCalldataGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Run("throws error if custom calldata fails to decode", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)

		daOracleConfig := CreateTestDAOracle(t, toml.DAOracleCustomCalldata, oracleAddress, "0xblahblahblah")
		oracle, err := NewCustomCalldataDAOracle(logger.Test(t), ethClient, chaintype.ChainCelo, daOracleConfig)
		require.NoError(t, err)

		_, err = oracle.getCustomCalldataGasPrice(tests.Context(t))
		require.Error(t, err)
	})`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.getCustomCalldataGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.On("CallContract", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Return(nil, errors.New("RPC failure"))`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.New("RPC failure")`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Once()`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.getCustomCalldataGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/custom_calldata_da_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `t.Run("Unsupported ChainType returns nil", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, utils.RandomAddress().String(), "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainCelo, daOracle, nil)
		require.NoError(t, err)
		assert.Nil(t, oracle)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `t.Run("DAOracle config is nil, falls back to using chainType", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)

		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainArbitrum, nil, nil)
		require.NoError(t, err)
		assert.NotNil(t, oracle)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `t.Run("DAOracle config is not nil, but OracleType is empty, falls back to using chainType arbitrum", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)

		daOracle := CreateTestDAOracle(t, "", utils.RandomAddress().String(), "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainArbitrum, daOracle, nil)
		require.NoError(t, err)
		assert.NotNil(t, oracle)
		assert.Equal(t, "L1GasOracle(arbitrum)", oracle.Name())
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `t.Run("Calling GasPrice on unstarted L1Oracle returns error", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, utils.RandomAddress().String(), "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle, nil)
		require.NoError(t, err)

		_, err = oracle.GasPrice(tests.Context(t))
		assert.EqualError(t, err, "L1GasOracle is not started; cannot estimate gas")
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `_, err = oracle.GasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `t.Run("Calling GasPrice on started Arbitrum L1Oracle returns Arbitrum l1GasPrice", func(t *testing.T) {
		l1BaseFee := big.NewInt(100)
		l1GasPriceMethodAbi, err := abi.JSON(strings.NewReader(GetL1BaseFeeEstimateAbiString))
		require.NoError(t, err)

		ethClient := mocks.NewL1OracleClient(t)
		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("getL1BaseFeeEstimate")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(l1BaseFee).Bytes(), nil)

		daOracle := CreateTestDAOracle(t, toml.DAOracleArbitrum, "0x0000000000000000000000000000000000000000", "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainArbitrum, daOracle, nil)
		require.NoError(t, err)
		servicetest.RunHealthy(t, oracle)

		gasPrice, err := oracle.GasPrice(tests.Context(t))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWei(l1BaseFee), gasPrice)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("getL1BaseFeeEstimate")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(l1BaseFee).Bytes(), nil)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `payload, err = l1GasPriceMethodAbi.Pack("getL1BaseFeeEstimate")`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `servicetest.RunHealthy(t, oracle)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `t.Run("Calling GasPrice on started Kroma L1Oracle returns Kroma l1GasPrice", func(t *testing.T) {
		l1BaseFee := big.NewInt(100)

		l1GasPriceMethodAbi, err := abi.JSON(strings.NewReader(L1BaseFeeAbiString))
		require.NoError(t, err)

		oracleAddress := utils.RandomAddress().String()
		ethClient := setupUpgradeCheck(t, oracleAddress, false, false) // Ecotone, Fjord disabled

		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(l1BaseFee).Bytes(), nil)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainKroma, daOracle, nil)
		require.NoError(t, err)
		servicetest.RunHealthy(t, oracle)

		gasPrice, err := oracle.GasPrice(tests.Context(t))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWei(l1BaseFee), gasPrice)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(l1BaseFee).Bytes(), nil)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `servicetest.RunHealthy(t, oracle)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `t.Run("Calling GasPrice on started OPStack L1Oracle returns OPStack l1GasPrice", func(t *testing.T) {
		l1BaseFee := big.NewInt(100)

		l1GasPriceMethodAbi, err := abi.JSON(strings.NewReader(L1BaseFeeAbiString))
		require.NoError(t, err)

		oracleAddress := utils.RandomAddress().String()
		ethClient := setupUpgradeCheck(t, oracleAddress, false, false) // Ecotone, Fjord disabled

		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(l1BaseFee).Bytes(), nil)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle, nil)
		require.NoError(t, err)
		servicetest.RunHealthy(t, oracle)

		gasPrice, err := oracle.GasPrice(tests.Context(t))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWei(l1BaseFee), gasPrice)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(l1BaseFee).Bytes(), nil)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `servicetest.RunHealthy(t, oracle)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `t.Run("Calling GasPrice on started Scroll L1Oracle returns Scroll l1GasPrice", func(t *testing.T) {
		l1BaseFee := big.NewInt(200)
		l1GasPriceMethodAbi, err := abi.JSON(strings.NewReader(L1BaseFeeAbiString))
		require.NoError(t, err)

		oracleAddress := utils.RandomAddress().String()
		ethClient := setupUpgradeCheck(t, oracleAddress, false, false) // Ecotone, Fjord disabled

		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(l1BaseFee).Bytes(), nil)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainScroll, daOracle, nil)
		require.NoError(t, err)
		servicetest.RunHealthy(t, oracle)

		gasPrice, err := oracle.GasPrice(tests.Context(t))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWei(l1BaseFee), gasPrice)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(l1BaseFee).Bytes(), nil)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `servicetest.RunHealthy(t, oracle)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `t.Run("Calling GasPrice on started zkSync L1Oracle returns ZkSync l1GasPrice", func(t *testing.T) {
		gasPerPubByteL2 := big.NewInt(1100)
		gasPriceL2 := big.NewInt(25000000)
		ZksyncGasInfo_getGasPriceL2 := "0xfe173b97"
		ZksyncGasInfo_getGasPerPubdataByteL2 := "0x7cb9357e"
		ethClient := mocks.NewL1OracleClient(t)

		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err := hex.DecodeString(ZksyncGasInfo_getGasPriceL2[2:])
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(gasPriceL2).Bytes(), nil).Once()

		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err := hex.DecodeString(ZksyncGasInfo_getGasPerPubdataByteL2[2:])
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(gasPerPubByteL2).Bytes(), nil)

		daOracle := CreateTestDAOracle(t, toml.DAOracleZKSync, utils.RandomAddress().String(), "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainZkSync, daOracle, nil)
		require.NoError(t, err)
		servicetest.RunHealthy(t, oracle)

		gasPrice, err := oracle.GasPrice(tests.Context(t))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWei(new(big.Int).Mul(gasPriceL2, gasPerPubByteL2)), gasPrice)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err := hex.DecodeString(ZksyncGasInfo_getGasPriceL2[2:])
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(gasPriceL2).Bytes(), nil).Once()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err := hex.DecodeString(ZksyncGasInfo_getGasPerPubdataByteL2[2:])
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(gasPerPubByteL2).Bytes(), nil)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `servicetest.RunHealthy(t, oracle)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			require.NotNil(t, callMsg.To)
			require.Equal(t, oracleAddress, callMsg.To.String())
			require.Nil(t, blockNumber)
		}).Return(common.BigToHash(mockedPrice).Bytes(), nil).Once()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `servicetest.RunHealthy(t, oracle)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run("Unsupported ChainType returns nil", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, utils.RandomAddress().String(), "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainCelo, daOracle, nil)
		require.NoError(t, err)
		assert.Nil(t, oracle)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RandomAddress()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run("DAOracle config is nil, falls back to using chainType", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)

		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainArbitrum, nil, nil)
		require.NoError(t, err)
		assert.NotNil(t, oracle)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run("DAOracle config is not nil, but OracleType is empty, falls back to using chainType arbitrum", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)

		daOracle := CreateTestDAOracle(t, "", utils.RandomAddress().String(), "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainArbitrum, daOracle, nil)
		require.NoError(t, err)
		assert.NotNil(t, oracle)
		assert.Equal(t, "L1GasOracle(arbitrum)", oracle.Name())
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RandomAddress()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RandomAddress()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run("Calling GasPrice on unstarted L1Oracle returns error", func(t *testing.T) {
		ethClient := mocks.NewL1OracleClient(t)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, utils.RandomAddress().String(), "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle, nil)
		require.NoError(t, err)

		_, err = oracle.GasPrice(tests.Context(t))
		assert.EqualError(t, err, "L1GasOracle is not started; cannot estimate gas")
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RandomAddress()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.GasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run("Calling GasPrice on started Arbitrum L1Oracle returns Arbitrum l1GasPrice", func(t *testing.T) {
		l1BaseFee := big.NewInt(100)
		l1GasPriceMethodAbi, err := abi.JSON(strings.NewReader(GetL1BaseFeeEstimateAbiString))
		require.NoError(t, err)

		ethClient := mocks.NewL1OracleClient(t)
		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("getL1BaseFeeEstimate")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(l1BaseFee).Bytes(), nil)

		daOracle := CreateTestDAOracle(t, toml.DAOracleArbitrum, "0x0000000000000000000000000000000000000000", "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainArbitrum, daOracle, nil)
		require.NoError(t, err)
		servicetest.RunHealthy(t, oracle)

		gasPrice, err := oracle.GasPrice(tests.Context(t))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWei(l1BaseFee), gasPrice)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewInt(100)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.JSON(strings.NewReader(GetL1BaseFeeEstimateAbiString))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewReader(GetL1BaseFeeEstimateAbiString)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("getL1BaseFeeEstimate")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(2)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Pack("getL1BaseFeeEstimate")`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Return(common.BigToHash(l1BaseFee).Bytes(), nil)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.BigToHash(l1BaseFee)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Bytes()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RunHealthy(t, oracle)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.GasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run("Calling GasPrice on started Kroma L1Oracle returns Kroma l1GasPrice", func(t *testing.T) {
		l1BaseFee := big.NewInt(100)

		l1GasPriceMethodAbi, err := abi.JSON(strings.NewReader(L1BaseFeeAbiString))
		require.NoError(t, err)

		oracleAddress := utils.RandomAddress().String()
		ethClient := setupUpgradeCheck(t, oracleAddress, false, false) // Ecotone, Fjord disabled

		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(l1BaseFee).Bytes(), nil)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainKroma, daOracle, nil)
		require.NoError(t, err)
		servicetest.RunHealthy(t, oracle)

		gasPrice, err := oracle.GasPrice(tests.Context(t))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWei(l1BaseFee), gasPrice)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewInt(100)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.JSON(strings.NewReader(L1BaseFeeAbiString))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewReader(L1BaseFeeAbiString)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RandomAddress()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(2)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Pack("l1BaseFee")`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Return(common.BigToHash(l1BaseFee).Bytes(), nil)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.BigToHash(l1BaseFee)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Bytes()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RunHealthy(t, oracle)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.GasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run("Calling GasPrice on started OPStack L1Oracle returns OPStack l1GasPrice", func(t *testing.T) {
		l1BaseFee := big.NewInt(100)

		l1GasPriceMethodAbi, err := abi.JSON(strings.NewReader(L1BaseFeeAbiString))
		require.NoError(t, err)

		oracleAddress := utils.RandomAddress().String()
		ethClient := setupUpgradeCheck(t, oracleAddress, false, false) // Ecotone, Fjord disabled

		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(l1BaseFee).Bytes(), nil)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle, nil)
		require.NoError(t, err)
		servicetest.RunHealthy(t, oracle)

		gasPrice, err := oracle.GasPrice(tests.Context(t))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWei(l1BaseFee), gasPrice)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewInt(100)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.JSON(strings.NewReader(L1BaseFeeAbiString))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewReader(L1BaseFeeAbiString)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RandomAddress()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(2)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Pack("l1BaseFee")`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Return(common.BigToHash(l1BaseFee).Bytes(), nil)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.BigToHash(l1BaseFee)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Bytes()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RunHealthy(t, oracle)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.GasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run("Calling GasPrice on started Scroll L1Oracle returns Scroll l1GasPrice", func(t *testing.T) {
		l1BaseFee := big.NewInt(200)
		l1GasPriceMethodAbi, err := abi.JSON(strings.NewReader(L1BaseFeeAbiString))
		require.NoError(t, err)

		oracleAddress := utils.RandomAddress().String()
		ethClient := setupUpgradeCheck(t, oracleAddress, false, false) // Ecotone, Fjord disabled

		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(l1BaseFee).Bytes(), nil)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainScroll, daOracle, nil)
		require.NoError(t, err)
		servicetest.RunHealthy(t, oracle)

		gasPrice, err := oracle.GasPrice(tests.Context(t))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWei(l1BaseFee), gasPrice)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewInt(200)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.JSON(strings.NewReader(L1BaseFeeAbiString))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewReader(L1BaseFeeAbiString)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RandomAddress()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err = l1GasPriceMethodAbi.Pack("l1BaseFee")
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(2)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Pack("l1BaseFee")`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Return(common.BigToHash(l1BaseFee).Bytes(), nil)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.BigToHash(l1BaseFee)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Bytes()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RunHealthy(t, oracle)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.GasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run("Calling GasPrice on started zkSync L1Oracle returns ZkSync l1GasPrice", func(t *testing.T) {
		gasPerPubByteL2 := big.NewInt(1100)
		gasPriceL2 := big.NewInt(25000000)
		ZksyncGasInfo_getGasPriceL2 := "0xfe173b97"
		ZksyncGasInfo_getGasPerPubdataByteL2 := "0x7cb9357e"
		ethClient := mocks.NewL1OracleClient(t)

		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err := hex.DecodeString(ZksyncGasInfo_getGasPriceL2[2:])
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(gasPriceL2).Bytes(), nil).Once()

		ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err := hex.DecodeString(ZksyncGasInfo_getGasPerPubdataByteL2[2:])
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		}).Return(common.BigToHash(gasPerPubByteL2).Bytes(), nil)

		daOracle := CreateTestDAOracle(t, toml.DAOracleZKSync, utils.RandomAddress().String(), "")
		oracle, err := NewL1GasOracle(logger.Test(t), ethClient, chaintype.ChainZkSync, daOracle, nil)
		require.NoError(t, err)
		servicetest.RunHealthy(t, oracle)

		gasPrice, err := oracle.GasPrice(tests.Context(t))
		require.NoError(t, err)

		assert.Equal(t, assets.NewWei(new(big.Int).Mul(gasPriceL2, gasPerPubByteL2)), gasPrice)
	})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewInt(1100)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewInt(25000000)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err := hex.DecodeString(ZksyncGasInfo_getGasPriceL2[2:])
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(2)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.DecodeString(ZksyncGasInfo_getGasPriceL2[2:])`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Return(common.BigToHash(gasPriceL2).Bytes(), nil)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.BigToHash(gasPriceL2)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Bytes()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Once()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			var payload []byte
			payload, err := hex.DecodeString(ZksyncGasInfo_getGasPerPubdataByteL2[2:])
			require.NoError(t, err)
			require.Equal(t, payload, callMsg.Data)
			assert.Nil(t, blockNumber)
		})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(2)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.DecodeString(ZksyncGasInfo_getGasPerPubdataByteL2[2:])`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Return(common.BigToHash(gasPerPubByteL2).Bytes(), nil)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.BigToHash(gasPerPubByteL2)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Bytes()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RandomAddress()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RunHealthy(t, oracle)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.GasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.NewInt(30)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RandomAddress()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Run(func(args mock.Arguments) {
			callMsg := args.Get(1).(ethereum.CallMsg)
			blockNumber := args.Get(2).(*big.Int)
			require.NotNil(t, callMsg.To)
			require.Equal(t, oracleAddress, callMsg.To.String())
			require.Nil(t, blockNumber)
		})`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Get(2)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Return(common.BigToHash(mockedPrice).Bytes(), nil)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.BigToHash(mockedPrice)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Bytes()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Once()`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.RunHealthy(t, oracle)`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.GasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `t.Run(tc.name, func(t *testing.T) {
			l1BaseFee := big.NewInt(100)
			oracleAddress := common.HexToAddress("0x1234").String()

			l1BaseFeeMethodAbi, err := abi.JSON(strings.NewReader(L1BaseFeeAbiString))
			require.NoError(t, err)
			l1BaseFeeCalldata, err := l1BaseFeeMethodAbi.Pack(l1BaseFeeMethod)
			require.NoError(t, err)

			// IsFjord calldata
			isFjordMethodAbi, err := abi.JSON(strings.NewReader(OPIsFjordAbiString))
			require.NoError(t, err)
			isFjordCalldata, err := isFjordMethodAbi.Pack(isFjordMethod)
			require.NoError(t, err)

			// IsEcotone calldata
			isEcotoneMethodAbi, err := abi.JSON(strings.NewReader(OPIsEcotoneAbiString))
			require.NoError(t, err)
			isEcotoneCalldata, err := isEcotoneMethodAbi.Pack(isEcotoneMethod)
			require.NoError(t, err)

			ethClient := mocks.NewL1OracleClient(t)
			ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
				rpcElements := args.Get(1).([]rpc.BatchElem)
				require.Len(t, rpcElements, 2)
				for _, rE := range rpcElements {
					require.Equal(t, "eth_call", rE.Method)
					require.Equal(t, oracleAddress, rE.Args[0].(map[string]interface{})["to"])
					require.Equal(t, "latest", rE.Args[1])
				}
				require.Equal(t, hexutil.Bytes(isFjordCalldata), rpcElements[0].Args[0].(map[string]interface{})["data"])
				require.Equal(t, hexutil.Bytes(isEcotoneCalldata), rpcElements[1].Args[0].(map[string]interface{})["data"])
				isUpgraded := "0x0000000000000000000000000000000000000000000000000000000000000000"
				if tc.isFjordError {
					rpcElements[0].Error = errors.New("test error")
				} else {
					rpcElements[0].Result = &isUpgraded
				}
				if tc.isEcotoneError {
					rpcElements[1].Error = errors.New("test error")
				} else {
					rpcElements[1].Result = &isUpgraded
				}
			}).Return(nil).Once()

			ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
				callMsg := args.Get(1).(ethereum.CallMsg)
				blockNumber := args.Get(2).(*big.Int)
				require.Equal(t, l1BaseFeeCalldata, callMsg.Data)
				require.Equal(t, oracleAddress, callMsg.To.String())
				assert.Nil(t, blockNumber)
			}).Return(common.BigToHash(l1BaseFee).Bytes(), nil).Once()

			daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, "0x0000000000000000000000000000000000001234", "")
			oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
			require.NoError(t, err)
			gasPrice, err := oracle.GetDAGasPrice(tests.Context(t))

			require.NoError(t, err)
			assert.Equal(t, l1BaseFee, gasPrice)
		})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
				rpcElements := args.Get(1).([]rpc.BatchElem)
				require.Len(t, rpcElements, 2)
				for _, rE := range rpcElements {
					require.Equal(t, "eth_call", rE.Method)
					require.Equal(t, oracleAddress, rE.Args[0].(map[string]interface{})["to"])
					require.Equal(t, "latest", rE.Args[1])
				}
				require.Equal(t, hexutil.Bytes(isFjordCalldata), rpcElements[0].Args[0].(map[string]interface{})["data"])
				require.Equal(t, hexutil.Bytes(isEcotoneCalldata), rpcElements[1].Args[0].(map[string]interface{})["data"])
				isUpgraded := "0x0000000000000000000000000000000000000000000000000000000000000000"
				if tc.isFjordError {
					rpcElements[0].Error = errors.New("test error")
				} else {
					rpcElements[0].Result = &isUpgraded
				}
				if tc.isEcotoneError {
					rpcElements[1].Error = errors.New("test error")
				} else {
					rpcElements[1].Result = &isUpgraded
				}
			}).Return(nil).Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `rpcElements[0].Error = errors.New("test error")`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `rpcElements[0].Result = &isUpgraded`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `rpcElements[1].Error = errors.New("test error")`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `rpcElements[1].Result = &isUpgraded`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
				callMsg := args.Get(1).(ethereum.CallMsg)
				blockNumber := args.Get(2).(*big.Int)
				require.Equal(t, l1BaseFeeCalldata, callMsg.Data)
				require.Equal(t, oracleAddress, callMsg.To.String())
				assert.Nil(t, blockNumber)
			}).Return(common.BigToHash(l1BaseFee).Bytes(), nil).Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `t.Run("correctly fetches weighted gas price if chain has upgraded to Ecotone", func(t *testing.T) {
		ethClient := setupUpgradeCheck(t, oracleAddress, false, true)
		mockBatchContractCall(t, ethClient, oracleAddress, baseFee, baseFeeScalar, blobBaseFee, blobBaseFeeScalar, decimals)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
		require.NoError(t, err)
		gasPrice, err := oracle.GetDAGasPrice(tests.Context(t))
		require.NoError(t, err)
		scaledGasPrice := big.NewInt(16125000000) // baseFee * scalar * 16 + blobBaseFee * scalar
		scale := big.NewInt(16000000)             // Scaled by 16 * 10 ^ decimals
		expectedGasPrice := new(big.Int).Div(scaledGasPrice, scale)
		assert.Equal(t, expectedGasPrice, gasPrice)
	})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `mockBatchContractCall(t, ethClient, oracleAddress, baseFee, baseFeeScalar, blobBaseFee, blobBaseFeeScalar, decimals)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `t.Run("fetching Ecotone price but rpc returns bad data", func(t *testing.T) {
		ethClient := setupUpgradeCheck(t, oracleAddress, false, true)
		ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			var badData = "zzz"
			rpcElements[0].Result = &badData
			rpcElements[1].Result = &badData
		}).Return(nil).Once()

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
		require.NoError(t, err)
		_, err = oracle.GetDAGasPrice(tests.Context(t))
		assert.Error(t, err)
	})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			var badData = "zzz"
			rpcElements[0].Result = &badData
			rpcElements[1].Result = &badData
		}).Return(nil).Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `rpcElements[0].Result = &badData`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `rpcElements[1].Result = &badData`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `_, err = oracle.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `t.Run("fetching Ecotone price but rpc parent call errors", func(t *testing.T) {
		ethClient := setupUpgradeCheck(t, oracleAddress, false, true)
		ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Return(errors.New("revert")).Once()

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
		require.NoError(t, err)
		_, err = oracle.GetDAGasPrice(tests.Context(t))
		assert.Error(t, err)
	})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Return(errors.New("revert")).Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `_, err = oracle.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			res := common.BigToHash(baseFee).Hex()
			rpcElements[0].Result = &res
			rpcElements[1].Error = errors.New("revert")
		}).Return(nil).Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `rpcElements[0].Result = &res`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `rpcElements[1].Error = errors.New("revert")`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `_, err = oracle.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `t.Run("correctly fetches gas price if chain has upgraded to Fjord", func(t *testing.T) {
		ethClient := setupUpgradeCheck(t, oracleAddress, true, true)
		mockBatchContractCall(t, ethClient, oracleAddress, baseFee, baseFeeScalar, blobBaseFee, blobBaseFeeScalar, decimals)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
		require.NoError(t, err)
		gasPrice, err := oracle.GetDAGasPrice(tests.Context(t))
		require.NoError(t, err)
		scaledGasPrice := big.NewInt(16125000000) // baseFee * scalar * 16 + blobBaseFee * scalar
		scale := big.NewInt(16000000)             // Scaled by 16 * 10 ^ decimals
		expectedGasPrice := new(big.Int).Div(scaledGasPrice, scale)
		assert.Equal(t, expectedGasPrice, gasPrice)
	})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `mockBatchContractCall(t, ethClient, oracleAddress, baseFee, baseFeeScalar, blobBaseFee, blobBaseFeeScalar, decimals)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `t.Run("fetching Fjord price but rpc returns bad data", func(t *testing.T) {
		ethClient := setupUpgradeCheck(t, oracleAddress, true, true)
		ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			var badData = "zzz"
			rpcElements[0].Result = &badData
			rpcElements[1].Result = &badData
		}).Return(nil).Once()

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
		require.NoError(t, err)
		_, err = oracle.GetDAGasPrice(tests.Context(t))
		assert.Error(t, err)
	})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			var badData = "zzz"
			rpcElements[0].Result = &badData
			rpcElements[1].Result = &badData
		}).Return(nil).Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `rpcElements[0].Result = &badData`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `rpcElements[1].Result = &badData`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `_, err = oracle.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `t.Run("fetching Fjord price but rpc parent call errors", func(t *testing.T) {
		ethClient := setupUpgradeCheck(t, oracleAddress, true, true)
		ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Return(errors.New("revert")).Once()

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
		require.NoError(t, err)
		_, err = oracle.GetDAGasPrice(tests.Context(t))
		assert.Error(t, err)
	})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Return(errors.New("revert")).Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `_, err = oracle.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			res := common.BigToHash(baseFee).Hex()
			rpcElements[0].Result = &res
			rpcElements[1].Error = errors.New("revert")
		}).Return(nil).Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `rpcElements[0].Result = &res`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `rpcElements[1].Error = errors.New("revert")`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `_, err = oracle.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Run(tc.name, func(t *testing.T) {
			l1BaseFee := big.NewInt(100)
			oracleAddress := common.HexToAddress("0x1234").String()

			l1BaseFeeMethodAbi, err := abi.JSON(strings.NewReader(L1BaseFeeAbiString))
			require.NoError(t, err)
			l1BaseFeeCalldata, err := l1BaseFeeMethodAbi.Pack(l1BaseFeeMethod)
			require.NoError(t, err)

			// IsFjord calldata
			isFjordMethodAbi, err := abi.JSON(strings.NewReader(OPIsFjordAbiString))
			require.NoError(t, err)
			isFjordCalldata, err := isFjordMethodAbi.Pack(isFjordMethod)
			require.NoError(t, err)

			// IsEcotone calldata
			isEcotoneMethodAbi, err := abi.JSON(strings.NewReader(OPIsEcotoneAbiString))
			require.NoError(t, err)
			isEcotoneCalldata, err := isEcotoneMethodAbi.Pack(isEcotoneMethod)
			require.NoError(t, err)

			ethClient := mocks.NewL1OracleClient(t)
			ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
				rpcElements := args.Get(1).([]rpc.BatchElem)
				require.Len(t, rpcElements, 2)
				for _, rE := range rpcElements {
					require.Equal(t, "eth_call", rE.Method)
					require.Equal(t, oracleAddress, rE.Args[0].(map[string]interface{})["to"])
					require.Equal(t, "latest", rE.Args[1])
				}
				require.Equal(t, hexutil.Bytes(isFjordCalldata), rpcElements[0].Args[0].(map[string]interface{})["data"])
				require.Equal(t, hexutil.Bytes(isEcotoneCalldata), rpcElements[1].Args[0].(map[string]interface{})["data"])
				isUpgraded := "0x0000000000000000000000000000000000000000000000000000000000000000"
				if tc.isFjordError {
					rpcElements[0].Error = errors.New("test error")
				} else {
					rpcElements[0].Result = &isUpgraded
				}
				if tc.isEcotoneError {
					rpcElements[1].Error = errors.New("test error")
				} else {
					rpcElements[1].Result = &isUpgraded
				}
			}).Return(nil).Once()

			ethClient.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{})).Run(func(args mock.Arguments) {
				callMsg := args.Get(1).(ethereum.CallMsg)
				blockNumber := args.Get(2).(*big.Int)
				require.Equal(t, l1BaseFeeCalldata, callMsg.Data)
				require.Equal(t, oracleAddress, callMsg.To.String())
				assert.Nil(t, blockNumber)
			}).Return(common.BigToHash(l1BaseFee).Bytes(), nil).Once()

			daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, "0x0000000000000000000000000000000000001234", "")
			oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
			require.NoError(t, err)
			gasPrice, err := oracle.GetDAGasPrice(tests.Context(t))

			require.NoError(t, err)
			assert.Equal(t, l1BaseFee, gasPrice)
		})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(100)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.JSON(strings.NewReader(L1BaseFeeAbiString))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewReader(L1BaseFeeAbiString)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Pack(l1BaseFeeMethod)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.JSON(strings.NewReader(OPIsFjordAbiString))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewReader(OPIsFjordAbiString)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Pack(isFjordMethod)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.JSON(strings.NewReader(OPIsEcotoneAbiString))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewReader(OPIsEcotoneAbiString)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Pack(isEcotoneMethod)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewL1OracleClient(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{}))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.IsType([]rpc.BatchElem{})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Run(func(args mock.Arguments) {
				rpcElements := args.Get(1).([]rpc.BatchElem)
				require.Len(t, rpcElements, 2)
				for _, rE := range rpcElements {
					require.Equal(t, "eth_call", rE.Method)
					require.Equal(t, oracleAddress, rE.Args[0].(map[string]interface{})["to"])
					require.Equal(t, "latest", rE.Args[1])
				}
				require.Equal(t, hexutil.Bytes(isFjordCalldata), rpcElements[0].Args[0].(map[string]interface{})["data"])
				require.Equal(t, hexutil.Bytes(isEcotoneCalldata), rpcElements[1].Args[0].(map[string]interface{})["data"])
				isUpgraded := "0x0000000000000000000000000000000000000000000000000000000000000000"
				if tc.isFjordError {
					rpcElements[0].Error = errors.New("test error")
				} else {
					rpcElements[0].Result = &isUpgraded
				}
				if tc.isEcotoneError {
					rpcElements[1].Error = errors.New("test error")
				} else {
					rpcElements[1].Result = &isUpgraded
				}
			})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.New("test error")`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.New("test error")`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Return(nil)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.On("CallContract", mock.Anything, mock.IsType(ethereum.CallMsg{}), mock.IsType(&big.Int{}))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.IsType(ethereum.CallMsg{})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.IsType(&big.Int{})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Run(func(args mock.Arguments) {
				callMsg := args.Get(1).(ethereum.CallMsg)
				blockNumber := args.Get(2).(*big.Int)
				require.Equal(t, l1BaseFeeCalldata, callMsg.Data)
				require.Equal(t, oracleAddress, callMsg.To.String())
				assert.Nil(t, blockNumber)
			})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Get(2)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Return(common.BigToHash(l1BaseFee).Bytes(), nil)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.BigToHash(l1BaseFee)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Bytes()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(100000000)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(25000000)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(10)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(5)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(6)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.RandomAddress()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Run("correctly fetches weighted gas price if chain has upgraded to Ecotone", func(t *testing.T) {
		ethClient := setupUpgradeCheck(t, oracleAddress, false, true)
		mockBatchContractCall(t, ethClient, oracleAddress, baseFee, baseFeeScalar, blobBaseFee, blobBaseFeeScalar, decimals)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
		require.NoError(t, err)
		gasPrice, err := oracle.GetDAGasPrice(tests.Context(t))
		require.NoError(t, err)
		scaledGasPrice := big.NewInt(16125000000) // baseFee * scalar * 16 + blobBaseFee * scalar
		scale := big.NewInt(16000000)             // Scaled by 16 * 10 ^ decimals
		expectedGasPrice := new(big.Int).Div(scaledGasPrice, scale)
		assert.Equal(t, expectedGasPrice, gasPrice)
	})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(16125000000)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(16000000)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Div(scaledGasPrice, scale)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Run("fetching Ecotone price but rpc returns bad data", func(t *testing.T) {
		ethClient := setupUpgradeCheck(t, oracleAddress, false, true)
		ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			var badData = "zzz"
			rpcElements[0].Result = &badData
			rpcElements[1].Result = &badData
		}).Return(nil).Once()

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
		require.NoError(t, err)
		_, err = oracle.GetDAGasPrice(tests.Context(t))
		assert.Error(t, err)
	})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{}))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.IsType([]rpc.BatchElem{})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			var badData = "zzz"
			rpcElements[0].Result = &badData
			rpcElements[1].Result = &badData
		})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Return(nil)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Run("fetching Ecotone price but rpc parent call errors", func(t *testing.T) {
		ethClient := setupUpgradeCheck(t, oracleAddress, false, true)
		ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Return(errors.New("revert")).Once()

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
		require.NoError(t, err)
		_, err = oracle.GetDAGasPrice(tests.Context(t))
		assert.Error(t, err)
	})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{}))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.IsType([]rpc.BatchElem{})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Return(errors.New("revert"))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.New("revert")`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{}))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.IsType([]rpc.BatchElem{})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			res := common.BigToHash(baseFee).Hex()
			rpcElements[0].Result = &res
			rpcElements[1].Error = errors.New("revert")
		})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.BigToHash(baseFee)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Hex()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.New("revert")`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Return(nil)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(100000000)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(25000000)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(10)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(5)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(6)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.RandomAddress()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.String()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Run("correctly fetches gas price if chain has upgraded to Fjord", func(t *testing.T) {
		ethClient := setupUpgradeCheck(t, oracleAddress, true, true)
		mockBatchContractCall(t, ethClient, oracleAddress, baseFee, baseFeeScalar, blobBaseFee, blobBaseFeeScalar, decimals)

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
		require.NoError(t, err)
		gasPrice, err := oracle.GetDAGasPrice(tests.Context(t))
		require.NoError(t, err)
		scaledGasPrice := big.NewInt(16125000000) // baseFee * scalar * 16 + blobBaseFee * scalar
		scale := big.NewInt(16000000)             // Scaled by 16 * 10 ^ decimals
		expectedGasPrice := new(big.Int).Div(scaledGasPrice, scale)
		assert.Equal(t, expectedGasPrice, gasPrice)
	})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(16125000000)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.NewInt(16000000)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Div(scaledGasPrice, scale)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Run("fetching Fjord price but rpc returns bad data", func(t *testing.T) {
		ethClient := setupUpgradeCheck(t, oracleAddress, true, true)
		ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			var badData = "zzz"
			rpcElements[0].Result = &badData
			rpcElements[1].Result = &badData
		}).Return(nil).Once()

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
		require.NoError(t, err)
		_, err = oracle.GetDAGasPrice(tests.Context(t))
		assert.Error(t, err)
	})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{}))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.IsType([]rpc.BatchElem{})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			var badData = "zzz"
			rpcElements[0].Result = &badData
			rpcElements[1].Result = &badData
		})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Return(nil)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Run("fetching Fjord price but rpc parent call errors", func(t *testing.T) {
		ethClient := setupUpgradeCheck(t, oracleAddress, true, true)
		ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Return(errors.New("revert")).Once()

		daOracle := CreateTestDAOracle(t, toml.DAOracleOPStack, oracleAddress, "")
		oracle, err := NewOpStackL1GasOracle(logger.Test(t), ethClient, chaintype.ChainOptimismBedrock, daOracle)
		require.NoError(t, err)
		_, err = oracle.GetDAGasPrice(tests.Context(t))
		assert.Error(t, err)
	})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{}))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.IsType([]rpc.BatchElem{})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Return(errors.New("revert"))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.New("revert")`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{}))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.IsType([]rpc.BatchElem{})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			res := common.BigToHash(baseFee).Hex()
			rpcElements[0].Result = &res
			rpcElements[1].Error = errors.New("revert")
		})`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Get(1)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.BigToHash(baseFee)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Hex()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.New("revert")`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Return(nil)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Once()`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Test(t)`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.GetDAGasPrice(tests.Context(t))`
$DIR/pkg/gas/rollups/op_l1_oracle_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("calling GetLegacyGas on unstarted estimator returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		_, _, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		assert.EqualError(t, err, "estimator is not started")
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("calling GetLegacyGas on started estimator returns prices", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		require.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(42), gasPrice)
		assert.Equal(t, gasLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `(*big.Int)(res).SetInt64(42)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("gas price is lower than user specified max gas price", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})

		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, assets.NewWeiI(40))
		require.Error(t, err)
		assert.EqualError(t, err, "estimated gas price: 42 wei is greater than the maximum gas price configured: 40 wei")
		assert.Nil(t, gasPrice)
		assert.Equal(t, uint64(0), chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `(*big.Int)(res).SetInt64(42)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("gas price is lower than global max gas price", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(120)
		})

		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, assets.NewWeiI(110))
		assert.EqualError(t, err, "estimated gas price: 120 wei is greater than the maximum gas price configured: 110 wei")
		assert.Nil(t, gasPrice)
		assert.Equal(t, uint64(0), chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(120)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `(*big.Int)(res).SetInt64(120)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("calling GetLegacyGas on started estimator if initial call failed returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(pkgerrors.New("kaboom"))

		servicetest.RunHealthy(t, o)

		_, _, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		assert.EqualError(t, err, "failed to estimate gas; gas price not set")
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(pkgerrors.New("kaboom"))`
$DIR/pkg/gas/suggested_price_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("calling GetDynamicFee always returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		_, err := o.GetDynamicFee(tests.Context(t), maxGasPrice)
		assert.EqualError(t, err, "dynamic fees are not implemented for this estimator")
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("calling BumpLegacyGas on unstarted estimator returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		_, _, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), gasLimit, maxGasPrice, nil)
		assert.EqualError(t, err, "estimator is not started")
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("calling BumpDynamicFee always returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		fee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(42),
			GasTipCap: assets.NewWeiI(5),
		}
		_, err := o.BumpDynamicFee(tests.Context(t), fee, maxGasPrice, nil)
		assert.EqualError(t, err, "dynamic fees are not implemented for this estimator")
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("calling BumpLegacyGas on started estimator returns new price buffered with bumpPercent", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(40)
		})

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, maxGasPrice, nil)
		require.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(44), gasPrice)
		assert.Equal(t, gasLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(40)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `(*big.Int)(res).SetInt64(40)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("calling BumpLegacyGas on started estimator returns new price buffered with bumpMin", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(40)
		})

		testCfg := &gas.MockGasEstimatorConfig{BumpPercentF: 1, BumpMinF: assets.NewWei(big.NewInt(1)), BumpThresholdF: 1, LimitMultiplierF: 1}
		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, testCfg, l1Oracle)
		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, maxGasPrice, nil)
		require.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(41), gasPrice)
		assert.Equal(t, gasLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(40)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `(*big.Int)(res).SetInt64(40)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("calling BumpLegacyGas on started estimator returns original price when lower than previous", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(5)
		})

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, maxGasPrice, nil)
		require.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(10), gasPrice)
		assert.Equal(t, gasLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(5)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `(*big.Int)(res).SetInt64(5)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("calling BumpLegacyGas on started estimator returns error, suggested gas price is higher than max gas price", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})

		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, assets.NewWeiI(40), nil)
		require.Error(t, err)
		assert.EqualError(t, err, "estimated gas price: 42 wei is greater than the maximum gas price configured: 40 wei")
		assert.Nil(t, gasPrice)
		assert.Equal(t, uint64(0), chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `(*big.Int)(res).SetInt64(42)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("calling BumpLegacyGas on started estimator returns max gas price when suggested price under max but the buffer exceeds it", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(39)
		})

		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, assets.NewWeiI(40), nil)
		require.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(40), gasPrice)
		assert.Equal(t, gasLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(39)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `(*big.Int)(res).SetInt64(39)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `t.Run("calling BumpLegacyGas on started estimator if initial call failed returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(pkgerrors.New("kaboom"))

		servicetest.RunHealthy(t, o)

		_, _, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, maxGasPrice, nil)
		assert.EqualError(t, err, "failed to refresh and return gas; gas price not set")
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(pkgerrors.New("kaboom"))`
$DIR/pkg/gas/suggested_price_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(40)
		}).Once()`
$DIR/pkg/gas/suggested_price_estimator_test.go: `(*big.Int)(res).SetInt64(40)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(pkgerrors.New("kaboom"))`
$DIR/pkg/gas/suggested_price_estimator_test.go: `servicetest.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(100)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWei(big.NewInt(1))`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("calling GetLegacyGas on unstarted estimator returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		_, _, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		assert.EqualError(t, err, "estimator is not started")
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("calling GetLegacyGas on started estimator returns prices", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		require.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(42), gasPrice)
		assert.Equal(t, gasLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.SetInt64(42)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("gas price is lower than user specified max gas price", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})

		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, assets.NewWeiI(40))
		require.Error(t, err)
		assert.EqualError(t, err, "estimated gas price: 42 wei is greater than the maximum gas price configured: 40 wei")
		assert.Nil(t, gasPrice)
		assert.Equal(t, uint64(0), chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.SetInt64(42)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.GetLegacyGas(tests.Context(t), calldata, gasLimit, assets.NewWeiI(40))`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(40)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("gas price is lower than global max gas price", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(120)
		})

		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, assets.NewWeiI(110))
		assert.EqualError(t, err, "estimated gas price: 120 wei is greater than the maximum gas price configured: 110 wei")
		assert.Nil(t, gasPrice)
		assert.Equal(t, uint64(0), chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(120)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.SetInt64(120)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.GetLegacyGas(tests.Context(t), calldata, gasLimit, assets.NewWeiI(110))`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(110)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("calling GetLegacyGas on started estimator if initial call failed returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(pkgerrors.New("kaboom"))

		servicetest.RunHealthy(t, o)

		_, _, err := o.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)
		assert.EqualError(t, err, "failed to estimate gas; gas price not set")
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Return(pkgerrors.New("kaboom"))`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.New("kaboom")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.GetLegacyGas(tests.Context(t), calldata, gasLimit, maxGasPrice)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("calling GetDynamicFee always returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		_, err := o.GetDynamicFee(tests.Context(t), maxGasPrice)
		assert.EqualError(t, err, "dynamic fees are not implemented for this estimator")
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.GetDynamicFee(tests.Context(t), maxGasPrice)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("calling BumpLegacyGas on unstarted estimator returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		_, _, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), gasLimit, maxGasPrice, nil)
		assert.EqualError(t, err, "estimator is not started")
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(42), gasLimit, maxGasPrice, nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("calling BumpDynamicFee always returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		fee := gas.DynamicFee{
			GasFeeCap: assets.NewWeiI(42),
			GasTipCap: assets.NewWeiI(5),
		}
		_, err := o.BumpDynamicFee(tests.Context(t), fee, maxGasPrice, nil)
		assert.EqualError(t, err, "dynamic fees are not implemented for this estimator")
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(42)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(5)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.BumpDynamicFee(tests.Context(t), fee, maxGasPrice, nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("calling BumpLegacyGas on started estimator returns new price buffered with bumpPercent", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(40)
		})

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, maxGasPrice, nil)
		require.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(44), gasPrice)
		assert.Equal(t, gasLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(40)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.SetInt64(40)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, maxGasPrice, nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("calling BumpLegacyGas on started estimator returns new price buffered with bumpMin", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(40)
		})

		testCfg := &gas.MockGasEstimatorConfig{BumpPercentF: 1, BumpMinF: assets.NewWei(big.NewInt(1)), BumpThresholdF: 1, LimitMultiplierF: 1}
		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, testCfg, l1Oracle)
		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, maxGasPrice, nil)
		require.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(41), gasPrice)
		assert.Equal(t, gasLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(40)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.SetInt64(40)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWei(big.NewInt(1))`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewInt(1)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, testCfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, maxGasPrice, nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("calling BumpLegacyGas on started estimator returns original price when lower than previous", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(5)
		})

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)
		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, maxGasPrice, nil)
		require.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(10), gasPrice)
		assert.Equal(t, gasLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(5)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.SetInt64(5)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, maxGasPrice, nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("calling BumpLegacyGas on started estimator returns error, suggested gas price is higher than max gas price", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})

		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, assets.NewWeiI(40), nil)
		require.Error(t, err)
		assert.EqualError(t, err, "estimated gas price: 42 wei is greater than the maximum gas price configured: 40 wei")
		assert.Nil(t, gasPrice)
		assert.Equal(t, uint64(0), chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(42)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.SetInt64(42)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, assets.NewWeiI(40), nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(40)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("calling BumpLegacyGas on started estimator returns max gas price when suggested price under max but the buffer exceeds it", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(nil).Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(39)
		})

		servicetest.RunHealthy(t, o)
		gasPrice, chainSpecificGasLimit, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, assets.NewWeiI(40), nil)
		require.NoError(t, err)
		assert.Equal(t, assets.NewWeiI(40), gasPrice)
		assert.Equal(t, gasLimit, chainSpecificGasLimit)
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(39)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.SetInt64(39)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, assets.NewWeiI(40), nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(40)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run("calling BumpLegacyGas on started estimator if initial call failed returns error", func(t *testing.T) {
		feeEstimatorClient := mocks.NewFeeEstimatorClient(t)
		l1Oracle := rollupMocks.NewL1Oracle(t)

		o := gas.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)

		feeEstimatorClient.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice").Return(pkgerrors.New("kaboom"))

		servicetest.RunHealthy(t, o)

		_, _, err := o.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, maxGasPrice, nil)
		assert.EqualError(t, err, "failed to refresh and return gas; gas price not set")
	})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Return(pkgerrors.New("kaboom"))`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.New("kaboom")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, maxGasPrice, nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewFeeEstimatorClient(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewL1Oracle(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewSuggestedPriceEstimator(logger.Test(t), feeEstimatorClient, cfg, l1Oracle)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Test(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Return(nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Run(func(args mock.Arguments) {
			res := args.Get(1).(*hexutil.Big)
			(*big.Int)(res).SetInt64(40)
		})`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Get(1)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.SetInt64(40)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Once()`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.On("CallContext", mock.Anything, mock.Anything, "eth_gasPrice")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Return(pkgerrors.New("kaboom"))`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.New("kaboom")`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.RunHealthy(t, o)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.BumpLegacyGas(tests.Context(t), assets.NewWeiI(10), gasLimit, maxGasPrice, nil)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.Context(t)`
$DIR/pkg/gas/suggested_price_estimator_test.go: `.NewWeiI(10)`
$DIR/pkg/heads/broadcaster_test.go: `c.HeadTracker.SamplingInterval = &commonconfig.Duration{}`
$DIR/pkg/heads/broadcaster_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).
		Run(func(args mock.Arguments) {
			chchHeaders <- chHead
		}).
		Return((<-chan *evmtypes.Head)(chHead), sub, nil)`
$DIR/pkg/heads/broadcaster_test.go: `chchHeaders <- chHead`
$DIR/pkg/heads/broadcaster_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(h, nil)`
$DIR/pkg/heads/broadcaster_test.go: `sub.On("Unsubscribe").Return()`
$DIR/pkg/heads/broadcaster_test.go: `sub.On("Err").Return(nil)`
$DIR/pkg/heads/broadcaster_test.go: `servicetest.Run(t, mailMon)`
$DIR/pkg/heads/broadcaster_test.go: `servicetest.Run(t, hb)`
$DIR/pkg/heads/broadcaster_test.go: `servicetest.Run(t, ht)`
$DIR/pkg/heads/broadcaster_test.go: `headers <- h`
$DIR/pkg/heads/broadcaster_test.go: `g.Eventually(checker1.OnNewLongestChainCount).Should(gomega.Equal(int32(1)))`
$DIR/pkg/heads/broadcaster_test.go: `unsubscribe1()`
$DIR/pkg/heads/broadcaster_test.go: `h2.Parent.Store(h)`
$DIR/pkg/heads/broadcaster_test.go: `headers <- h2`
$DIR/pkg/heads/broadcaster_test.go: `waitHeadBroadcasterToStart(t, broadcaster)`
$DIR/pkg/heads/broadcaster_test.go: `broadcaster.BroadcastNewLongestChain(testutils.Head(1))`
$DIR/pkg/heads/broadcaster_test.go: `g.Eventually(subscriber1.OnNewLongestChainCount).Should(gomega.Equal(int32(1)))`
$DIR/pkg/heads/broadcaster_test.go: `unsubscribe1()`
$DIR/pkg/heads/broadcaster_test.go: `broadcaster.BroadcastNewLongestChain(testutils.Head(2))`
$DIR/pkg/heads/broadcaster_test.go: `g.Eventually(subscriber2.OnNewLongestChainCount).Should(gomega.Equal(int32(2)))`
$DIR/pkg/heads/broadcaster_test.go: `unsubscribe2()`
$DIR/pkg/heads/broadcaster_test.go: `broadcaster.BroadcastNewLongestChain(testutils.Head(1))`
$DIR/pkg/heads/broadcaster_test.go: `g.Eventually(subscriber3.OnNewLongestChainCount).Should(gomega.Equal(int32(1)))`
$DIR/pkg/heads/broadcaster_test.go: `unsubscribe3()`
$DIR/pkg/heads/broadcaster_test.go: `broadcaster.BroadcastNewLongestChain(testutils.Head(0))`
$DIR/pkg/heads/broadcaster_test.go: `err = broadcaster.Close()`
$DIR/pkg/heads/broadcaster_test.go: `waitHeadBroadcasterToStart(t, broadcaster)`
$DIR/pkg/heads/broadcaster_test.go: `broadcaster.BroadcastNewLongestChain(testutils.Head(1))`
$DIR/pkg/heads/broadcaster_test.go: `slowAwaiter.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/broadcaster_test.go: `fastAwaiter.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/broadcaster_test.go: `unsubscribe1()`
$DIR/pkg/heads/broadcaster_test.go: `unsubscribe2()`
$DIR/pkg/heads/broadcaster_test.go: `err = broadcaster.Close()`
$DIR/pkg/heads/broadcaster_test.go: `.NewWithT(t)`
$DIR/pkg/heads/broadcaster_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.HeadTracker.SamplingInterval = &commonconfig.Duration{}
	})`
$DIR/pkg/heads/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/broadcaster_test.go: `.Test(t)`
$DIR/pkg/heads/broadcaster_test.go: `.NewSubscription(t)`
$DIR/pkg/heads/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/broadcaster_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/broadcaster_test.go: `.
		Run(func(args mock.Arguments) {
			chchHeaders <- chHead
		})`
$DIR/pkg/heads/broadcaster_test.go: `.
		Return((<-chan *evmtypes.Head)(chHead), sub, nil)`
$DIR/pkg/heads/broadcaster_test.go: `.Head(1)`
$DIR/pkg/heads/broadcaster_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/heads/broadcaster_test.go: `.Return(h, nil)`
$DIR/pkg/heads/broadcaster_test.go: `.On("Unsubscribe")`
$DIR/pkg/heads/broadcaster_test.go: `.Return()`
$DIR/pkg/heads/broadcaster_test.go: `.On("Err")`
$DIR/pkg/heads/broadcaster_test.go: `.Return(nil)`
$DIR/pkg/heads/broadcaster_test.go: `.NewORM(*ethClient.ConfiguredChainID(), db, 0)`
$DIR/pkg/heads/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/heads/broadcaster_test.go: `.NewSaver(logger, orm, evmCfg.EVM(), evmCfg.EVM().HeadTracker())`
$DIR/pkg/heads/broadcaster_test.go: `.EVM()`
$DIR/pkg/heads/broadcaster_test.go: `.EVM()`
$DIR/pkg/heads/broadcaster_test.go: `.HeadTracker()`
$DIR/pkg/heads/broadcaster_test.go: `.NewMonitor(t)`
$DIR/pkg/heads/broadcaster_test.go: `.Run(t, mailMon)`
$DIR/pkg/heads/broadcaster_test.go: `.NewBroadcaster(logger)`
$DIR/pkg/heads/broadcaster_test.go: `.Run(t, hb)`
$DIR/pkg/heads/broadcaster_test.go: `.NewTracker(logger, ethClient, evmCfg.EVM(), evmCfg.EVM().HeadTracker(), hb, hs, mailMon)`
$DIR/pkg/heads/broadcaster_test.go: `.EVM()`
$DIR/pkg/heads/broadcaster_test.go: `.EVM()`
$DIR/pkg/heads/broadcaster_test.go: `.HeadTracker()`
$DIR/pkg/heads/broadcaster_test.go: `.Run(t, ht)`
$DIR/pkg/heads/broadcaster_test.go: `.Subscribe(checker1)`
$DIR/pkg/heads/broadcaster_test.go: `.Eventually(checker1.OnNewLongestChainCount)`
$DIR/pkg/heads/broadcaster_test.go: `.Should(gomega.Equal(int32(1)))`
$DIR/pkg/heads/broadcaster_test.go: `.Equal(int32(1))`
$DIR/pkg/heads/broadcaster_test.go: `.Subscribe(checker2)`
$DIR/pkg/heads/broadcaster_test.go: `.NewHash()`
$DIR/pkg/heads/broadcaster_test.go: `.New(testutils.FixtureChainID)`
$DIR/pkg/heads/broadcaster_test.go: `.Parent.Store(h)`
$DIR/pkg/heads/broadcaster_test.go: `.Eventually(checker2.OnNewLongestChainCount)`
$DIR/pkg/heads/broadcaster_test.go: `.Equal(int32(1))`
$DIR/pkg/heads/broadcaster_test.go: `.NewWithT(t)`
$DIR/pkg/heads/broadcaster_test.go: `.Test(t)`
$DIR/pkg/heads/broadcaster_test.go: `.NewBroadcaster(lggr)`
$DIR/pkg/heads/broadcaster_test.go: `.Start(tests.Context(t))`
$DIR/pkg/heads/broadcaster_test.go: `.Context(t)`
$DIR/pkg/heads/broadcaster_test.go: `.Subscribe(subscriber1)`
$DIR/pkg/heads/broadcaster_test.go: `.Subscribe(subscriber2)`
$DIR/pkg/heads/broadcaster_test.go: `.BroadcastNewLongestChain(testutils.Head(1))`
$DIR/pkg/heads/broadcaster_test.go: `.Head(1)`
$DIR/pkg/heads/broadcaster_test.go: `.Eventually(subscriber1.OnNewLongestChainCount)`
$DIR/pkg/heads/broadcaster_test.go: `.Should(gomega.Equal(int32(1)))`
$DIR/pkg/heads/broadcaster_test.go: `.Equal(int32(1))`
$DIR/pkg/heads/broadcaster_test.go: `.BroadcastNewLongestChain(testutils.Head(2))`
$DIR/pkg/heads/broadcaster_test.go: `.Head(2)`
$DIR/pkg/heads/broadcaster_test.go: `.Eventually(subscriber2.OnNewLongestChainCount)`
$DIR/pkg/heads/broadcaster_test.go: `.Should(gomega.Equal(int32(2)))`
$DIR/pkg/heads/broadcaster_test.go: `.Equal(int32(2))`
$DIR/pkg/heads/broadcaster_test.go: `.Subscribe(subscriber3)`
$DIR/pkg/heads/broadcaster_test.go: `.BroadcastNewLongestChain(testutils.Head(1))`
$DIR/pkg/heads/broadcaster_test.go: `.Head(1)`
$DIR/pkg/heads/broadcaster_test.go: `.Eventually(subscriber3.OnNewLongestChainCount)`
$DIR/pkg/heads/broadcaster_test.go: `.Should(gomega.Equal(int32(1)))`
$DIR/pkg/heads/broadcaster_test.go: `.Equal(int32(1))`
$DIR/pkg/heads/broadcaster_test.go: `.BroadcastNewLongestChain(testutils.Head(0))`
$DIR/pkg/heads/broadcaster_test.go: `.Head(0)`
$DIR/pkg/heads/broadcaster_test.go: `.OnNewLongestChainCount()`
$DIR/pkg/heads/broadcaster_test.go: `.Test(t)`
$DIR/pkg/heads/broadcaster_test.go: `.NewBroadcaster(lggr)`
$DIR/pkg/heads/broadcaster_test.go: `.Start(tests.Context(t))`
$DIR/pkg/heads/broadcaster_test.go: `.Context(t)`
$DIR/pkg/heads/broadcaster_test.go: `.NewAwaiter()`
$DIR/pkg/heads/broadcaster_test.go: `.NewAwaiter()`
$DIR/pkg/heads/broadcaster_test.go: `.Subscribe(slow)`
$DIR/pkg/heads/broadcaster_test.go: `.Subscribe(fast)`
$DIR/pkg/heads/broadcaster_test.go: `.BroadcastNewLongestChain(testutils.Head(1))`
$DIR/pkg/heads/broadcaster_test.go: `.Head(1)`
$DIR/pkg/heads/broadcaster_test.go: `.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/broadcaster_test.go: `.WaitTimeout(t)`
$DIR/pkg/heads/broadcaster_test.go: `.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/broadcaster_test.go: `.WaitTimeout(t)`
$DIR/pkg/heads/heads_test.go: `latest = heads.LatestHead()`
$DIR/pkg/heads/heads_test.go: `latest = heads.LatestHead()`
$DIR/pkg/heads/heads_test.go: `latest = heads.LatestHead()`
$DIR/pkg/heads/heads_test.go: `head = heads.HeadByHash(utils.NewHash())`
$DIR/pkg/heads/heads_test.go: `testHeads = append(testHeads, &h)`
$DIR/pkg/heads/heads_test.go: `testHeads = append(testHeads, &h)`
$DIR/pkg/heads/heads_test.go: `parentHash = hash`
$DIR/pkg/heads/heads_test.go: `head = heads.HeadByHash(uncleHash)`
$DIR/pkg/heads/heads_test.go: `cycleHead.Number = heads.LatestHead().Number + 1`
$DIR/pkg/heads/heads_test.go: `cycleHead.Number = heads.LatestHead().EarliestInChain().Number - 1`
$DIR/pkg/heads/heads_test.go: `cycleHead = &evmtypes.Head{
			Number:     1000,
			Hash:       common.BigToHash(big.NewInt(1000)),
			ParentHash: common.BigToHash(big.NewInt(1000)),
		}`
$DIR/pkg/heads/heads_test.go: `t.Run("blocks were correctly marked as finalized", ensureProperFinalization)`
$DIR/pkg/heads/heads_test.go: `t.Run("blocks remain finalized after re adding them to the Heads", ensureProperFinalization)`
$DIR/pkg/heads/heads_test.go: `heads.MarkFinalized(h3.Hash, 3)`
$DIR/pkg/heads/heads_test.go: `.NewHeadSet()`
$DIR/pkg/heads/heads_test.go: `.LatestHead()`
$DIR/pkg/heads/heads_test.go: `.LatestHead()`
$DIR/pkg/heads/heads_test.go: `.LatestHead()`
$DIR/pkg/heads/heads_test.go: `.Head(400)`
$DIR/pkg/heads/heads_test.go: `.LatestHead()`
$DIR/pkg/heads/heads_test.go: `.Head(100)`
$DIR/pkg/heads/heads_test.go: `.Head(200)`
$DIR/pkg/heads/heads_test.go: `.Head(300)`
$DIR/pkg/heads/heads_test.go: `.NewHeadSet()`
$DIR/pkg/heads/heads_test.go: `.HeadByHash(testHeads[1].Hash)`
$DIR/pkg/heads/heads_test.go: `.HeadByHash(utils.NewHash())`
$DIR/pkg/heads/heads_test.go: `.NewHash()`
$DIR/pkg/heads/heads_test.go: `.NewHeadSet()`
$DIR/pkg/heads/heads_test.go: `.Count()`
$DIR/pkg/heads/heads_test.go: `.NewHash()`
$DIR/pkg/heads/heads_test.go: `.NewHeadSet()`
$DIR/pkg/heads/heads_test.go: `.BigToHash(big.NewInt(int64(i)))`
$DIR/pkg/heads/heads_test.go: `.NewInt(int64(i))`
$DIR/pkg/heads/heads_test.go: `.NewHead(big.NewInt(int64(i)), hash, parentHash, ubig.NewI(0))`
$DIR/pkg/heads/heads_test.go: `.NewInt(int64(i))`
$DIR/pkg/heads/heads_test.go: `.NewI(0)`
$DIR/pkg/heads/heads_test.go: `.NewHead(big.NewInt(int64(i)), uncleHash, parentHash, ubig.NewI(0))`
$DIR/pkg/heads/heads_test.go: `.NewInt(int64(i))`
$DIR/pkg/heads/heads_test.go: `.NewI(0)`
$DIR/pkg/heads/heads_test.go: `.LatestHead()`
$DIR/pkg/heads/heads_test.go: `.HeadByHash(uncleHash)`
$DIR/pkg/heads/heads_test.go: `.LatestHead()`
$DIR/pkg/heads/heads_test.go: `.EarliestInChain()`
$DIR/pkg/heads/heads_test.go: `.LatestHead()`
$DIR/pkg/heads/heads_test.go: `.LatestHead()`
$DIR/pkg/heads/heads_test.go: `.LatestHead()`
$DIR/pkg/heads/heads_test.go: `.EarliestInChain()`
$DIR/pkg/heads/heads_test.go: `.BigToHash(big.NewInt(1000))`
$DIR/pkg/heads/heads_test.go: `.NewInt(1000)`
$DIR/pkg/heads/heads_test.go: `.BigToHash(big.NewInt(1000))`
$DIR/pkg/heads/heads_test.go: `.NewInt(1000)`
$DIR/pkg/heads/heads_test.go: `.NewHeadSet()`
$DIR/pkg/heads/heads_test.go: `.NewHead(big.NewInt(int64(num)), utils.NewHash(), parent, ubig.NewI(0))`
$DIR/pkg/heads/heads_test.go: `.NewInt(int64(num))`
$DIR/pkg/heads/heads_test.go: `.NewHash()`
$DIR/pkg/heads/heads_test.go: `.NewI(0)`
$DIR/pkg/heads/heads_test.go: `.NewHash()`
$DIR/pkg/heads/heads_test.go: `.Run("blocks were correctly marked as finalized", ensureProperFinalization)`
$DIR/pkg/heads/heads_test.go: `.Run("blocks remain finalized after re adding them to the Heads", ensureProperFinalization)`
$DIR/pkg/heads/heads_test.go: `.MarkFinalized(h3.Hash, 3)`
$DIR/pkg/heads/heads_test.go: `.HeadByHash(h2.Hash)`
$DIR/pkg/heads/heads_test.go: `.IsFinalized.Load()`
$DIR/pkg/heads/listener_test.go: `c.NoNewHeadsThreshold = &commonconfig.Duration{}`
$DIR/pkg/heads/listener_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).Return((<-chan *evmtypes.Head)(chHeads), sub, nil).Once().Run(func(args mock.Arguments) {
		subscribeAwaiter.ItHappened()
	})`
$DIR/pkg/heads/listener_test.go: `subscribeAwaiter.ItHappened()`
$DIR/pkg/heads/listener_test.go: `sub.On("Err").Return(chSubErr)`
$DIR/pkg/heads/listener_test.go: `sub.On("Unsubscribe").Return().Once().Run(func(mock.Arguments) {
		unsubscribeAwaiter.ItHappened()
		close(chHeads)
		close(chErr)
	})`
$DIR/pkg/heads/listener_test.go: `unsubscribeAwaiter.ItHappened()`
$DIR/pkg/heads/listener_test.go: `close(chHeads)`
$DIR/pkg/heads/listener_test.go: `close(chErr)`
$DIR/pkg/heads/listener_test.go: `func() {
		hl := heads.NewListener(lggr, ethClient, evmcfg.EVM(), nil, func(context.Context, *evmtypes.Head) error {
			headCount.Add(1)
			return nil
		})
		require.NoError(t, hl.Start(tests.Context(t)))
		defer func() { assert.NoError(t, hl.Close()) }()

		subscribeAwaiter.AwaitOrFail(t, tests.WaitTimeout(t))
		require.Eventually(t, hl.Connected, tests.WaitTimeout(t), tests.TestInterval)

		chHeads <- testutils.Head(0)
		chHeads <- testutils.Head(1)
		chHeads <- testutils.Head(2)

		require.True(t, hl.ReceivingHeads())
	}()`
$DIR/pkg/heads/listener_test.go: `headCount.Add(1)`
$DIR/pkg/heads/listener_test.go: `subscribeAwaiter.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/listener_test.go: `chHeads <- testutils.Head(0)`
$DIR/pkg/heads/listener_test.go: `chHeads <- testutils.Head(1)`
$DIR/pkg/heads/listener_test.go: `chHeads <- testutils.Head(2)`
$DIR/pkg/heads/listener_test.go: `unsubscribeAwaiter.AwaitOrFail(t)`
$DIR/pkg/heads/listener_test.go: `c.NoNewHeadsThreshold = commonconfig.MustNewDuration(time.Second)`
$DIR/pkg/heads/listener_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).Return((<-chan *evmtypes.Head)(chHeads), sub, nil).Once().Run(func(args mock.Arguments) {
		subscribeAwaiter.ItHappened()
	})`
$DIR/pkg/heads/listener_test.go: `subscribeAwaiter.ItHappened()`
$DIR/pkg/heads/listener_test.go: `sub.On("Err").Return(chSubErr)`
$DIR/pkg/heads/listener_test.go: `sub.On("Unsubscribe").Return().Once().Run(func(_ mock.Arguments) {
		close(chHeads)
		close(chErr)
	})`
$DIR/pkg/heads/listener_test.go: `close(chHeads)`
$DIR/pkg/heads/listener_test.go: `close(chErr)`
$DIR/pkg/heads/listener_test.go: `firstHeadAwaiter.ItHappened()`
$DIR/pkg/heads/listener_test.go: `subscribeAwaiter.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/listener_test.go: `chHeads <- testutils.Head(0)`
$DIR/pkg/heads/listener_test.go: `firstHeadAwaiter.AwaitOrFail(t)`
$DIR/pkg/heads/listener_test.go: `time.Sleep(time.Second * 2)`
$DIR/pkg/heads/listener_test.go: `t.Run(test.name, func(t *testing.T) {
			lggr := logger.Test(t)
			ethClient := clienttest.NewClientWithDefaultChainID(t)
			evmcfg := configtest.NewChainScopedConfig(t, nil)

			hnhCalled := make(chan *evmtypes.Head)

			chSubErrTest := make(chan error)
			var chSubErr <-chan error = chSubErrTest
			sub := clienttest.NewSubscription(t)
			// sub.Err is called twice because we enter the select loop two times: once
			// initially and once again after exactly one head has been received
			sub.On("Err").Return(chSubErr).Twice()

			headsCh := make(chan *evmtypes.Head)
			subscribeAwaiter := testutils.NewAwaiter()
			// Initial subscribe
			ethClient.On("SubscribeToHeads", mock.Anything).Return((<-chan *evmtypes.Head)(headsCh), sub, nil).Once().Run(func(args mock.Arguments) {
				subscribeAwaiter.ItHappened()
			})
			func() {
				hl := heads.NewListener(lggr, ethClient, evmcfg.EVM(), nil, func(_ context.Context, header *evmtypes.Head) error {
					hnhCalled <- header
					return nil
				})
				require.NoError(t, hl.Start(tests.Context(t)))
				defer func() { assert.NoError(t, hl.Close()) }()

				// Put a head on the channel to ensure we test all code paths
				subscribeAwaiter.AwaitOrFail(t, tests.WaitTimeout(t))
				head := testutils.Head(0)
				headsCh <- head

				h := <-hnhCalled
				assert.Equal(t, head, h)

				// Expect a call to unsubscribe on error
				sub.On("Unsubscribe").Once().Run(func(_ mock.Arguments) {
					close(headsCh)
					// geth guarantees that Unsubscribe closes the errors channel
					if !test.closeErr {
						close(chSubErrTest)
					}
				})
				// Expect a resubscribe
				chSubErrTest2 := make(chan error)
				var chSubErr2 <-chan error = chSubErrTest2
				sub2 := clienttest.NewSubscription(t)
				sub2.On("Err").Return(chSubErr2)
				subscribeAwaiter2 := testutils.NewAwaiter()

				headsCh2 := make(chan *evmtypes.Head)
				ethClient.On("SubscribeToHeads", mock.Anything).Return((<-chan *evmtypes.Head)(headsCh2), sub2, nil).Once().Run(func(args mock.Arguments) {
					subscribeAwaiter2.ItHappened()
				})

				// Sending test error
				if test.closeErr {
					close(chSubErrTest)
				} else {
					chSubErrTest <- test.err
				}

				// Wait for it to resubscribe
				subscribeAwaiter2.AwaitOrFail(t, tests.WaitTimeout(t))

				head2 := testutils.Head(1)
				headsCh2 <- head2

				h2 := <-hnhCalled
				assert.Equal(t, head2, h2)

				// Second call to unsubscribe on close
				sub2.On("Unsubscribe").Once().Run(func(_ mock.Arguments) {
					close(headsCh2)
					// geth guarantees that Unsubscribe closes the errors channel
					close(chSubErrTest2)
				})
			}()
		})`
$DIR/pkg/heads/listener_test.go: `sub.On("Err").Return(chSubErr).Twice()`
$DIR/pkg/heads/listener_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).Return((<-chan *evmtypes.Head)(headsCh), sub, nil).Once().Run(func(args mock.Arguments) {
				subscribeAwaiter.ItHappened()
			})`
$DIR/pkg/heads/listener_test.go: `subscribeAwaiter.ItHappened()`
$DIR/pkg/heads/listener_test.go: `func() {
				hl := heads.NewListener(lggr, ethClient, evmcfg.EVM(), nil, func(_ context.Context, header *evmtypes.Head) error {
					hnhCalled <- header
					return nil
				})
				require.NoError(t, hl.Start(tests.Context(t)))
				defer func() { assert.NoError(t, hl.Close()) }()

				// Put a head on the channel to ensure we test all code paths
				subscribeAwaiter.AwaitOrFail(t, tests.WaitTimeout(t))
				head := testutils.Head(0)
				headsCh <- head

				h := <-hnhCalled
				assert.Equal(t, head, h)

				// Expect a call to unsubscribe on error
				sub.On("Unsubscribe").Once().Run(func(_ mock.Arguments) {
					close(headsCh)
					// geth guarantees that Unsubscribe closes the errors channel
					if !test.closeErr {
						close(chSubErrTest)
					}
				})
				// Expect a resubscribe
				chSubErrTest2 := make(chan error)
				var chSubErr2 <-chan error = chSubErrTest2
				sub2 := clienttest.NewSubscription(t)
				sub2.On("Err").Return(chSubErr2)
				subscribeAwaiter2 := testutils.NewAwaiter()

				headsCh2 := make(chan *evmtypes.Head)
				ethClient.On("SubscribeToHeads", mock.Anything).Return((<-chan *evmtypes.Head)(headsCh2), sub2, nil).Once().Run(func(args mock.Arguments) {
					subscribeAwaiter2.ItHappened()
				})

				// Sending test error
				if test.closeErr {
					close(chSubErrTest)
				} else {
					chSubErrTest <- test.err
				}

				// Wait for it to resubscribe
				subscribeAwaiter2.AwaitOrFail(t, tests.WaitTimeout(t))

				head2 := testutils.Head(1)
				headsCh2 <- head2

				h2 := <-hnhCalled
				assert.Equal(t, head2, h2)

				// Second call to unsubscribe on close
				sub2.On("Unsubscribe").Once().Run(func(_ mock.Arguments) {
					close(headsCh2)
					// geth guarantees that Unsubscribe closes the errors channel
					close(chSubErrTest2)
				})
			}()`
$DIR/pkg/heads/listener_test.go: `hnhCalled <- header`
$DIR/pkg/heads/listener_test.go: `subscribeAwaiter.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/listener_test.go: `headsCh <- head`
$DIR/pkg/heads/listener_test.go: `sub.On("Unsubscribe").Once().Run(func(_ mock.Arguments) {
					close(headsCh)
					// geth guarantees that Unsubscribe closes the errors channel
					if !test.closeErr {
						close(chSubErrTest)
					}
				})`
$DIR/pkg/heads/listener_test.go: `close(headsCh)`
$DIR/pkg/heads/listener_test.go: `close(chSubErrTest)`
$DIR/pkg/heads/listener_test.go: `sub2.On("Err").Return(chSubErr2)`
$DIR/pkg/heads/listener_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).Return((<-chan *evmtypes.Head)(headsCh2), sub2, nil).Once().Run(func(args mock.Arguments) {
					subscribeAwaiter2.ItHappened()
				})`
$DIR/pkg/heads/listener_test.go: `subscribeAwaiter2.ItHappened()`
$DIR/pkg/heads/listener_test.go: `close(chSubErrTest)`
$DIR/pkg/heads/listener_test.go: `chSubErrTest <- test.err`
$DIR/pkg/heads/listener_test.go: `subscribeAwaiter2.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/listener_test.go: `headsCh2 <- head2`
$DIR/pkg/heads/listener_test.go: `sub2.On("Unsubscribe").Once().Run(func(_ mock.Arguments) {
					close(headsCh2)
					// geth guarantees that Unsubscribe closes the errors channel
					close(chSubErrTest2)
				})`
$DIR/pkg/heads/listener_test.go: `close(headsCh2)`
$DIR/pkg/heads/listener_test.go: `close(chSubErrTest2)`
$DIR/pkg/heads/listener_test.go: `.Test(t)`
$DIR/pkg/heads/listener_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/listener_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.NoNewHeadsThreshold = &commonconfig.Duration{}
	})`
$DIR/pkg/heads/listener_test.go: `.NewAwaiter()`
$DIR/pkg/heads/listener_test.go: `.NewAwaiter()`
$DIR/pkg/heads/listener_test.go: `.NewSubscription(t)`
$DIR/pkg/heads/listener_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/listener_test.go: `.Return((<-chan *evmtypes.Head)(chHeads), sub, nil)`
$DIR/pkg/heads/listener_test.go: `.Once()`
$DIR/pkg/heads/listener_test.go: `.Run(func(args mock.Arguments) {
		subscribeAwaiter.ItHappened()
	})`
$DIR/pkg/heads/listener_test.go: `.ItHappened()`
$DIR/pkg/heads/listener_test.go: `.On("Err")`
$DIR/pkg/heads/listener_test.go: `.Return(chSubErr)`
$DIR/pkg/heads/listener_test.go: `.On("Unsubscribe")`
$DIR/pkg/heads/listener_test.go: `.Return()`
$DIR/pkg/heads/listener_test.go: `.Once()`
$DIR/pkg/heads/listener_test.go: `.Run(func(mock.Arguments) {
		unsubscribeAwaiter.ItHappened()
		close(chHeads)
		close(chErr)
	})`
$DIR/pkg/heads/listener_test.go: `.ItHappened()`
$DIR/pkg/heads/listener_test.go: `.NewListener(lggr, ethClient, evmcfg.EVM(), nil, func(context.Context, *evmtypes.Head) error {
			headCount.Add(1)
			return nil
		})`
$DIR/pkg/heads/listener_test.go: `.EVM()`
$DIR/pkg/heads/listener_test.go: `.Add(1)`
$DIR/pkg/heads/listener_test.go: `.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/listener_test.go: `.WaitTimeout(t)`
$DIR/pkg/heads/listener_test.go: `.Head(0)`
$DIR/pkg/heads/listener_test.go: `.Head(1)`
$DIR/pkg/heads/listener_test.go: `.Head(2)`
$DIR/pkg/heads/listener_test.go: `.AwaitOrFail(t)`
$DIR/pkg/heads/listener_test.go: `.Load()`
$DIR/pkg/heads/listener_test.go: `.Test(t)`
$DIR/pkg/heads/listener_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/listener_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.NoNewHeadsThreshold = commonconfig.MustNewDuration(time.Second)
	})`
$DIR/pkg/heads/listener_test.go: `.MustNewDuration(time.Second)`
$DIR/pkg/heads/listener_test.go: `.NewAwaiter()`
$DIR/pkg/heads/listener_test.go: `.NewAwaiter()`
$DIR/pkg/heads/listener_test.go: `.NewSubscription(t)`
$DIR/pkg/heads/listener_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/listener_test.go: `.Return((<-chan *evmtypes.Head)(chHeads), sub, nil)`
$DIR/pkg/heads/listener_test.go: `.Once()`
$DIR/pkg/heads/listener_test.go: `.Run(func(args mock.Arguments) {
		subscribeAwaiter.ItHappened()
	})`
$DIR/pkg/heads/listener_test.go: `.ItHappened()`
$DIR/pkg/heads/listener_test.go: `.On("Err")`
$DIR/pkg/heads/listener_test.go: `.Return(chSubErr)`
$DIR/pkg/heads/listener_test.go: `.On("Unsubscribe")`
$DIR/pkg/heads/listener_test.go: `.Return()`
$DIR/pkg/heads/listener_test.go: `.Once()`
$DIR/pkg/heads/listener_test.go: `.Run(func(_ mock.Arguments) {
		close(chHeads)
		close(chErr)
	})`
$DIR/pkg/heads/listener_test.go: `.NewListener(lggr, ethClient, evmcfg.EVM(), nil, func(context.Context, *evmtypes.Head) error {
			firstHeadAwaiter.ItHappened()
			return nil
		})`
$DIR/pkg/heads/listener_test.go: `.EVM()`
$DIR/pkg/heads/listener_test.go: `.ItHappened()`
$DIR/pkg/heads/listener_test.go: `.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/listener_test.go: `.WaitTimeout(t)`
$DIR/pkg/heads/listener_test.go: `.Head(0)`
$DIR/pkg/heads/listener_test.go: `.AwaitOrFail(t)`
$DIR/pkg/heads/listener_test.go: `.Sleep(time.Second * 2)`
$DIR/pkg/heads/listener_test.go: `.New("close 1006 (abnormal closure): unexpected EOF")`
$DIR/pkg/heads/listener_test.go: `.Run(test.name, func(t *testing.T) {
			lggr := logger.Test(t)
			ethClient := clienttest.NewClientWithDefaultChainID(t)
			evmcfg := configtest.NewChainScopedConfig(t, nil)

			hnhCalled := make(chan *evmtypes.Head)

			chSubErrTest := make(chan error)
			var chSubErr <-chan error = chSubErrTest
			sub := clienttest.NewSubscription(t)
			// sub.Err is called twice because we enter the select loop two times: once
			// initially and once again after exactly one head has been received
			sub.On("Err").Return(chSubErr).Twice()

			headsCh := make(chan *evmtypes.Head)
			subscribeAwaiter := testutils.NewAwaiter()
			// Initial subscribe
			ethClient.On("SubscribeToHeads", mock.Anything).Return((<-chan *evmtypes.Head)(headsCh), sub, nil).Once().Run(func(args mock.Arguments) {
				subscribeAwaiter.ItHappened()
			})
			func() {
				hl := heads.NewListener(lggr, ethClient, evmcfg.EVM(), nil, func(_ context.Context, header *evmtypes.Head) error {
					hnhCalled <- header
					return nil
				})
				require.NoError(t, hl.Start(tests.Context(t)))
				defer func() { assert.NoError(t, hl.Close()) }()

				// Put a head on the channel to ensure we test all code paths
				subscribeAwaiter.AwaitOrFail(t, tests.WaitTimeout(t))
				head := testutils.Head(0)
				headsCh <- head

				h := <-hnhCalled
				assert.Equal(t, head, h)

				// Expect a call to unsubscribe on error
				sub.On("Unsubscribe").Once().Run(func(_ mock.Arguments) {
					close(headsCh)
					// geth guarantees that Unsubscribe closes the errors channel
					if !test.closeErr {
						close(chSubErrTest)
					}
				})
				// Expect a resubscribe
				chSubErrTest2 := make(chan error)
				var chSubErr2 <-chan error = chSubErrTest2
				sub2 := clienttest.NewSubscription(t)
				sub2.On("Err").Return(chSubErr2)
				subscribeAwaiter2 := testutils.NewAwaiter()

				headsCh2 := make(chan *evmtypes.Head)
				ethClient.On("SubscribeToHeads", mock.Anything).Return((<-chan *evmtypes.Head)(headsCh2), sub2, nil).Once().Run(func(args mock.Arguments) {
					subscribeAwaiter2.ItHappened()
				})

				// Sending test error
				if test.closeErr {
					close(chSubErrTest)
				} else {
					chSubErrTest <- test.err
				}

				// Wait for it to resubscribe
				subscribeAwaiter2.AwaitOrFail(t, tests.WaitTimeout(t))

				head2 := testutils.Head(1)
				headsCh2 <- head2

				h2 := <-hnhCalled
				assert.Equal(t, head2, h2)

				// Second call to unsubscribe on close
				sub2.On("Unsubscribe").Once().Run(func(_ mock.Arguments) {
					close(headsCh2)
					// geth guarantees that Unsubscribe closes the errors channel
					close(chSubErrTest2)
				})
			}()
		})`
$DIR/pkg/heads/listener_test.go: `.Test(t)`
$DIR/pkg/heads/listener_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/listener_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/heads/listener_test.go: `.NewSubscription(t)`
$DIR/pkg/heads/listener_test.go: `.On("Err")`
$DIR/pkg/heads/listener_test.go: `.Return(chSubErr)`
$DIR/pkg/heads/listener_test.go: `.Twice()`
$DIR/pkg/heads/listener_test.go: `.NewAwaiter()`
$DIR/pkg/heads/listener_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/listener_test.go: `.Return((<-chan *evmtypes.Head)(headsCh), sub, nil)`
$DIR/pkg/heads/listener_test.go: `.Once()`
$DIR/pkg/heads/listener_test.go: `.Run(func(args mock.Arguments) {
				subscribeAwaiter.ItHappened()
			})`
$DIR/pkg/heads/listener_test.go: `.ItHappened()`
$DIR/pkg/heads/listener_test.go: `.NewListener(lggr, ethClient, evmcfg.EVM(), nil, func(_ context.Context, header *evmtypes.Head) error {
					hnhCalled <- header
					return nil
				})`
$DIR/pkg/heads/listener_test.go: `.EVM()`
$DIR/pkg/heads/listener_test.go: `.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/listener_test.go: `.WaitTimeout(t)`
$DIR/pkg/heads/listener_test.go: `.Head(0)`
$DIR/pkg/heads/listener_test.go: `.On("Unsubscribe")`
$DIR/pkg/heads/listener_test.go: `.Once()`
$DIR/pkg/heads/listener_test.go: `.Run(func(_ mock.Arguments) {
					close(headsCh)
					// geth guarantees that Unsubscribe closes the errors channel
					if !test.closeErr {
						close(chSubErrTest)
					}
				})`
$DIR/pkg/heads/listener_test.go: `.NewSubscription(t)`
$DIR/pkg/heads/listener_test.go: `.On("Err")`
$DIR/pkg/heads/listener_test.go: `.Return(chSubErr2)`
$DIR/pkg/heads/listener_test.go: `.NewAwaiter()`
$DIR/pkg/heads/listener_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/listener_test.go: `.Return((<-chan *evmtypes.Head)(headsCh2), sub2, nil)`
$DIR/pkg/heads/listener_test.go: `.Once()`
$DIR/pkg/heads/listener_test.go: `.Run(func(args mock.Arguments) {
					subscribeAwaiter2.ItHappened()
				})`
$DIR/pkg/heads/listener_test.go: `.ItHappened()`
$DIR/pkg/heads/listener_test.go: `.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/listener_test.go: `.WaitTimeout(t)`
$DIR/pkg/heads/listener_test.go: `.Head(1)`
$DIR/pkg/heads/listener_test.go: `.On("Unsubscribe")`
$DIR/pkg/heads/listener_test.go: `.Once()`
$DIR/pkg/heads/listener_test.go: `.Run(func(_ mock.Arguments) {
					close(headsCh2)
					// geth guarantees that Unsubscribe closes the errors channel
					close(chSubErrTest2)
				})`
$DIR/pkg/heads/orm_test.go: `foundHead, err = orm.LatestHead(t.Context())`
$DIR/pkg/heads/orm_test.go: `foundHead, err = orm.LatestHead(t.Context())`
$DIR/pkg/heads/orm_test.go: `err = orm.TrimOldHeads(t.Context(), 6)`
$DIR/pkg/heads/orm_test.go: `err = orm.TrimOldHeads(t.Context(), 7)`
$DIR/pkg/heads/orm_test.go: `hash = head.Hash`
$DIR/pkg/heads/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/orm_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/orm_test.go: `.Head(0)`
$DIR/pkg/heads/orm_test.go: `.LatestHead(t.Context())`
$DIR/pkg/heads/orm_test.go: `.Context()`
$DIR/pkg/heads/orm_test.go: `.LatestHead(t.Context())`
$DIR/pkg/heads/orm_test.go: `.Context()`
$DIR/pkg/heads/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/orm_test.go: `.NewORM(*testutils.FixtureChainID, db, 2)`
$DIR/pkg/heads/orm_test.go: `.Head(0)`
$DIR/pkg/heads/orm_test.go: `.Head(1)`
$DIR/pkg/heads/orm_test.go: `.LatestHead(t.Context())`
$DIR/pkg/heads/orm_test.go: `.Context()`
$DIR/pkg/heads/orm_test.go: `.LatestHead(t.Context())`
$DIR/pkg/heads/orm_test.go: `.Context()`
$DIR/pkg/heads/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/orm_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/orm_test.go: `.Head(i)`
$DIR/pkg/heads/orm_test.go: `.Head(5)`
$DIR/pkg/heads/orm_test.go: `.TrimOldHeads(t.Context(), 5)`
$DIR/pkg/heads/orm_test.go: `.Context()`
$DIR/pkg/heads/orm_test.go: `.LatestHeads(t.Context(), 0)`
$DIR/pkg/heads/orm_test.go: `.Context()`
$DIR/pkg/heads/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/orm_test.go: `.NewORM(*testutils.FixtureChainID, db, 2)`
$DIR/pkg/heads/orm_test.go: `.Head(i)`
$DIR/pkg/heads/orm_test.go: `.Head(5)`
$DIR/pkg/heads/orm_test.go: `.TrimOldHeads(t.Context(), 5)`
$DIR/pkg/heads/orm_test.go: `.Context()`
$DIR/pkg/heads/orm_test.go: `.TrimOldHeads(t.Context(), 6)`
$DIR/pkg/heads/orm_test.go: `.Context()`
$DIR/pkg/heads/orm_test.go: `.TrimOldHeads(t.Context(), 7)`
$DIR/pkg/heads/orm_test.go: `.Context()`
$DIR/pkg/heads/orm_test.go: `.LatestHeads(t.Context(), 0)`
$DIR/pkg/heads/orm_test.go: `.Context()`
$DIR/pkg/heads/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/orm_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/orm_test.go: `.Head(i)`
$DIR/pkg/heads/orm_test.go: `.HeadByHash(tests.Context(t), hash)`
$DIR/pkg/heads/orm_test.go: `.Context(t)`
$DIR/pkg/heads/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/orm_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/orm_test.go: `.Head(123)`
$DIR/pkg/heads/orm_test.go: `.HeadByHash(tests.Context(t), hash)`
$DIR/pkg/heads/orm_test.go: `.Context(t)`
$DIR/pkg/heads/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/orm_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/orm_test.go: `.LatestHeads(tests.Context(t), 100)`
$DIR/pkg/heads/orm_test.go: `.Context(t)`
$DIR/pkg/heads/saver_test.go: `latest = saver.LatestChain()`
$DIR/pkg/heads/saver_test.go: `latest = saver.Chain(head.Hash)`
$DIR/pkg/heads/saver_test.go: `verifyLatestHead(latestHead)`
$DIR/pkg/heads/saver_test.go: `latestHead = saver.LatestChain()`
$DIR/pkg/heads/saver_test.go: `verifyLatestHead(latestHead)`
$DIR/pkg/heads/saver_test.go: `.Head(1)`
$DIR/pkg/heads/saver_test.go: `.Save(tests.Context(t), head)`
$DIR/pkg/heads/saver_test.go: `.Context(t)`
$DIR/pkg/heads/saver_test.go: `.LatestHeadFromDB(tests.Context(t))`
$DIR/pkg/heads/saver_test.go: `.Context(t)`
$DIR/pkg/heads/saver_test.go: `.LatestChain()`
$DIR/pkg/heads/saver_test.go: `.Chain(head.Hash)`
$DIR/pkg/heads/saver_test.go: `.NewHead(big.NewInt(int64(num)), utils.NewHash(), parent, ubig.NewI(0))`
$DIR/pkg/heads/saver_test.go: `.NewInt(int64(num))`
$DIR/pkg/heads/saver_test.go: `.NewHash()`
$DIR/pkg/heads/saver_test.go: `.NewI(0)`
$DIR/pkg/heads/saver_test.go: `.NewHash()`
$DIR/pkg/heads/saver_test.go: `.IdempotentInsertHead(tests.Context(t), h)`
$DIR/pkg/heads/saver_test.go: `.Context(t)`
$DIR/pkg/heads/saver_test.go: `.Load(tests.Context(t), h5.BlockNumber())`
$DIR/pkg/heads/saver_test.go: `.Context(t)`
$DIR/pkg/heads/saver_test.go: `.BlockNumber()`
$DIR/pkg/heads/saver_test.go: `.LatestChain()`
$DIR/pkg/heads/saver_test.go: `.Chain(h2Uncle.Hash)`
$DIR/pkg/heads/saver_test.go: `.ChainLength()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, big.NewInt(0)).Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything, mock.Anything).
		Maybe().
		Return(nil, mockEth.NewSub(t), nil)`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `c.HeadTracker.HistoryDepth = ptr[uint32](100)`
$DIR/pkg/heads/tracker_test.go: `t.Run(test.name, func(t *testing.T) {
			db := testutils.NewSqlxDB(t)
			config := configtest.NewChainScopedConfig(t, nil)
			orm := evmheads.NewORM(*testutils.FixtureChainID, db, 0)

			ethClient := clienttest.NewClientWithDefaultChainID(t)
			chStarted := make(chan struct{})
			mockEth := &clienttest.MockEth{
				EthClient: ethClient,
			}
			ethClient.On("SubscribeToHeads", mock.Anything).
				Maybe().
				Return(
					func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
						defer close(chStarted)
						return make(<-chan *evmtypes.Head), mockEth.NewSub(t), nil
					},
				)
			ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(testutils.Head(0), nil).Maybe()

			fnCall := ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Maybe()
			fnCall.RunFn = func(args mock.Arguments) {
				num := args.Get(1).(*big.Int)
				fnCall.ReturnArguments = mock.Arguments{testutils.Head(num.Int64()), nil}
			}

			if test.initial != nil {
				require.NoError(t, orm.IdempotentInsertHead(tests.Context(t), test.initial))
			}

			ht := createHeadTracker(t, ethClient, config.EVM(), config.EVM().HeadTracker(), orm)
			ht.Start(t)

			if test.toSave != nil {
				err := ht.headSaver.Save(tests.Context(t), test.toSave)
				require.NoError(t, err)
			}

			tests.AssertEventually(t, func() bool {
				latest := ht.headSaver.LatestChain().ToInt()
				return latest != nil && test.want.Cmp(latest) == 0
			})
		})`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).
				Maybe().
				Return(
					func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
						defer close(chStarted)
						return make(<-chan *evmtypes.Head), mockEth.NewSub(t), nil
					},
				)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(testutils.Head(0), nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `fnCall.ReturnArguments = mock.Arguments{testutils.Head(num.Int64()), nil}`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `tests.AssertEventually(t, func() bool {
				latest := ht.headSaver.LatestChain().ToInt()
				return latest != nil && test.want.Cmp(latest) == 0
			})`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(testutils.Head(0), nil).Once()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(testutils.Head(0), nil).Once()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(testutils.Head(0), nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).
		Run(func(mock.Arguments) {
			close(chStarted)
		}).
		Return((<-chan *evmtypes.Head)(ch), sub, nil)`
$DIR/pkg/heads/tracker_test.go: `close(chStarted)`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `t.Run("Finality violation on block hash mismatch", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		config := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.FinalityTagEnabled = ptr(true)
		})
		orm := evmheads.NewORM(*testutils.FixtureChainID, db, 0)

		ethClient := clienttest.NewClientWithDefaultChainID(t)
		chStarted := make(chan struct{})
		mockEth := &clienttest.MockEth{EthClient: ethClient}
		sub := mockEth.NewSub(t)

		h0 := testutils.Head(0)
		h0.IsFinalized.Store(true)

		// for initial load
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h0, nil).Once()
		// for backfill
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(h0, nil).Maybe()
		ethClient.On("HeadByHash", mock.Anything, mock.Anything).Return(h0, nil).Maybe()
		ch := make(chan *evmtypes.Head)
		ethClient.On("SubscribeToHeads", mock.Anything).
			Run(func(mock.Arguments) {
				close(chStarted)
			}).
			Return((<-chan *evmtypes.Head)(ch), sub, nil)
		ethClient.On("LatestFinalizedBlock", mock.Anything).Return(h0, nil).Maybe()

		ht := createHeadTracker(t, ethClient, config.EVM(), config.EVM().HeadTracker(), orm)
		ht.Start(t)
		<-chStarted

		ch <- h0

		invalid0 := testutils.Head(0)
		invalid0.IsFinalized.Store(true)

		invalid1 := testutils.Head(1)
		invalid1.ParentHash = invalid0.Hash
		invalid1.Parent.Store(invalid0)

		ch <- invalid1 // Deliver head with finalized block hash mismatch compared to h0

		g := gomega.NewWithT(t)
		g.Eventually(func() bool {
			report := ht.headTracker.HealthReport()
			return slices.ContainsFunc(maps.Values(report), func(e error) bool {
				return errors.Is(e, types.ErrFinalityViolated)
			})
		}, 5*time.Second, tests.TestInterval).Should(gomega.BeTrue())
	})`
$DIR/pkg/heads/tracker_test.go: `c.FinalityTagEnabled = ptr(true)`
$DIR/pkg/heads/tracker_test.go: `h0.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h0, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(h0, nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByHash", mock.Anything, mock.Anything).Return(h0, nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).
			Run(func(mock.Arguments) {
				close(chStarted)
			}).
			Return((<-chan *evmtypes.Head)(ch), sub, nil)`
$DIR/pkg/heads/tracker_test.go: `close(chStarted)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("LatestFinalizedBlock", mock.Anything).Return(h0, nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `<-chStarted`
$DIR/pkg/heads/tracker_test.go: `ch <- h0`
$DIR/pkg/heads/tracker_test.go: `invalid0.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `invalid1.ParentHash = invalid0.Hash`
$DIR/pkg/heads/tracker_test.go: `invalid1.Parent.Store(invalid0)`
$DIR/pkg/heads/tracker_test.go: `ch <- invalid1`
$DIR/pkg/heads/tracker_test.go: `g.Eventually(func() bool {
			report := ht.headTracker.HealthReport()
			return slices.ContainsFunc(maps.Values(report), func(e error) bool {
				return errors.Is(e, types.ErrFinalityViolated)
			})
		}, 5*time.Second, tests.TestInterval).Should(gomega.BeTrue())`
$DIR/pkg/heads/tracker_test.go: `t.Run("Finality violation on old block", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		config := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.FinalityTagEnabled = ptr(true)
			c.FinalityDepth = ptr(uint32(0))
			// finalty violation on old block possible only with finalty tag
			c.HeadTracker.FinalityTagBypass = ptr(true)
		})
		orm := evmheads.NewORM(*testutils.FixtureChainID, db, 0)

		ethClient := clienttest.NewClientWithDefaultChainID(t)
		chStarted := make(chan struct{})
		mockEth := &clienttest.MockEth{EthClient: ethClient}
		sub := mockEth.NewSub(t)

		h0 := testutils.Head(0)
		h0.IsFinalized.Store(true)

		// for initial load
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h0, nil).Once()
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(h0, nil).Once()
		// for backfill
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(h0, nil).Maybe()
		ethClient.On("HeadByHash", mock.Anything, mock.Anything).Return(h0, nil).Maybe()
		ch := make(chan *evmtypes.Head)
		ethClient.On("SubscribeToHeads", mock.Anything).
			Run(func(mock.Arguments) {
				close(chStarted)
			}).
			Return((<-chan *evmtypes.Head)(ch), sub, nil)

		ht := createHeadTracker(t, ethClient, config.EVM(), config.EVM().HeadTracker(), orm)
		ht.Start(t)
		<-chStarted

		h1 := testutils.Head(1)
		h1.IsFinalized.Store(true)
		h1.ParentHash = h0.Hash
		h1.Parent.Store(h0)
		ch <- h1

		h2 := testutils.Head(2)
		h2.IsFinalized.Store(true)
		h2.ParentHash = h1.Hash
		h2.Parent.Store(h1)
		ch <- h2
		require.NoError(t, ht.headSaver.Save(t.Context(), h2))

		// Send old head
		ch <- h0

		g := gomega.NewWithT(t)
		g.Eventually(func() bool {
			report := ht.headTracker.HealthReport()
			return slices.ContainsFunc(maps.Values(report), func(e error) bool {
				return errors.Is(e, types.ErrFinalityViolated) && strings.Contains(e.Error(), "got very old block")
			})
		}, 5*time.Second, tests.TestInterval).Should(gomega.BeTrue())
	})`
$DIR/pkg/heads/tracker_test.go: `c.FinalityTagEnabled = ptr(true)`
$DIR/pkg/heads/tracker_test.go: `c.FinalityDepth = ptr(uint32(0))`
$DIR/pkg/heads/tracker_test.go: `c.HeadTracker.FinalityTagBypass = ptr(true)`
$DIR/pkg/heads/tracker_test.go: `h0.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h0, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(h0, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(h0, nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByHash", mock.Anything, mock.Anything).Return(h0, nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).
			Run(func(mock.Arguments) {
				close(chStarted)
			}).
			Return((<-chan *evmtypes.Head)(ch), sub, nil)`
$DIR/pkg/heads/tracker_test.go: `close(chStarted)`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `<-chStarted`
$DIR/pkg/heads/tracker_test.go: `h1.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `h1.ParentHash = h0.Hash`
$DIR/pkg/heads/tracker_test.go: `h1.Parent.Store(h0)`
$DIR/pkg/heads/tracker_test.go: `ch <- h1`
$DIR/pkg/heads/tracker_test.go: `h2.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `h2.ParentHash = h1.Hash`
$DIR/pkg/heads/tracker_test.go: `h2.Parent.Store(h1)`
$DIR/pkg/heads/tracker_test.go: `ch <- h2`
$DIR/pkg/heads/tracker_test.go: `ch <- h0`
$DIR/pkg/heads/tracker_test.go: `g.Eventually(func() bool {
			report := ht.headTracker.HealthReport()
			return slices.ContainsFunc(maps.Values(report), func(e error) bool {
				return errors.Is(e, types.ErrFinalityViolated) && strings.Contains(e.Error(), "got very old block")
			})
		}, 5*time.Second, tests.TestInterval).Should(gomega.BeTrue())`
$DIR/pkg/heads/tracker_test.go: `c.FinalityTagEnabled = ptr(true)`
$DIR/pkg/heads/tracker_test.go: `c.FinalityDepth = ptr(uint32(0))`
$DIR/pkg/heads/tracker_test.go: `h0.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(h0, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(h0, nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByHash", mock.Anything, mock.Anything).Return(h0, nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("LatestFinalizedBlock", mock.Anything).Return(h0, nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).
			Run(func(mock.Arguments) {
				close(chStarted)
			}).
			Return((<-chan *evmtypes.Head)(ch), sub, nil)`
$DIR/pkg/heads/tracker_test.go: `close(chStarted)`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `<-chStarted`
$DIR/pkg/heads/tracker_test.go: `h1.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `h1.ParentHash = h0.Hash`
$DIR/pkg/heads/tracker_test.go: `h1.Parent.Store(h0)`
$DIR/pkg/heads/tracker_test.go: `ch <- h1`
$DIR/pkg/heads/tracker_test.go: `h2.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `h2.ParentHash = h1.Hash`
$DIR/pkg/heads/tracker_test.go: `h2.Parent.Store(h1)`
$DIR/pkg/heads/tracker_test.go: `ch <- h2`
$DIR/pkg/heads/tracker_test.go: `ch <- h0`
$DIR/pkg/heads/tracker_test.go: `g.Eventually(func() bool {
			report := ht.headTracker.HealthReport()
			return slices.ContainsFunc(maps.Values(report), func(e error) bool {
				return e != nil
			})
		}, 5*time.Second, tests.TestInterval).Should(gomega.BeFalse())`
$DIR/pkg/heads/tracker_test.go: `c.FinalityTagEnabled = opts.FinalityTagEnable`
$DIR/pkg/heads/tracker_test.go: `c.HeadTracker.HistoryDepth = ptr[uint32](historyDepth)`
$DIR/pkg/heads/tracker_test.go: `c.FinalityDepth = ptr[uint32](finalityDepth)`
$DIR/pkg/heads/tracker_test.go: `c.HeadTracker.MaxAllowedFinalityDepth = opts.MaxAllowedFinalityDepth`
$DIR/pkg/heads/tracker_test.go: `c.HeadTracker.FinalityTagBypass = opts.FinalityTagBypass`
$DIR/pkg/heads/tracker_test.go: `opts.ORM = evmheads.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything, mock.Anything).Return(nil, sub, nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `t.Run("Starts even if failed to get initialHead", func(t *testing.T) {
		ht := newHeadTracker(t, opts{})
		ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(testutils.Head(0), errors.New("failed to get init head"))
		ht.Start(t)
		tests.AssertLogEventually(t, ht.observer, "Error handling initial head")
	})`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(testutils.Head(0), errors.New("failed to get init head"))`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `tests.AssertLogEventually(t, ht.observer, "Error handling initial head")`
$DIR/pkg/heads/tracker_test.go: `t.Run("Starts even if received invalid head", func(t *testing.T) {
		ht := newHeadTracker(t, opts{})
		ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, nil)
		ht.Start(t)
		tests.AssertLogEventually(t, ht.observer, "Got nil initial head")
	})`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, nil)`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `tests.AssertLogEventually(t, ht.observer, "Got nil initial head")`
$DIR/pkg/heads/tracker_test.go: `t.Run("Starts even if fails to get finalizedHead", func(t *testing.T) {
		ht := newHeadTracker(t, opts{FinalityTagEnable: ptr(true), FinalityTagBypass: ptr(false)})
		head := testutils.Head(1000)
		ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(head, nil).Once()
		ht.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, errors.New("failed to load latest finalized")).Once()
		ht.Start(t)
		tests.AssertLogEventually(t, ht.observer, "Error handling initial head")
	})`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(head, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, errors.New("failed to load latest finalized")).Once()`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `tests.AssertLogEventually(t, ht.observer, "Error handling initial head")`
$DIR/pkg/heads/tracker_test.go: `t.Run("Starts even if latest finalizedHead is nil", func(t *testing.T) {
		ht := newHeadTracker(t, opts{FinalityTagEnable: ptr(true), FinalityTagBypass: ptr(false)})
		head := testutils.Head(1000)
		ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(head, nil).Once()
		ht.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, nil).Once()
		ht.ethClient.On("SubscribeToHeads", mock.Anything, mock.Anything).Return(nil, nil, errors.New("failed to connect")).Maybe()
		ht.Start(t)
		tests.AssertLogEventually(t, ht.observer, "Error handling initial head")
	})`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(head, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("SubscribeToHeads", mock.Anything, mock.Anything).Return(nil, nil, errors.New("failed to connect")).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `tests.AssertLogEventually(t, ht.observer, "Error handling initial head")`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(head, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(finalizedHead, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, errors.New("backfill call to finalized failed")).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("SubscribeToHeads", mock.Anything, mock.Anything).Return(nil, nil, errors.New("failed to connect")).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `tests.AssertLogEventually(t, ht.observer, "Received new head")`
$DIR/pkg/heads/tracker_test.go: `tests.AssertEventually(t, func() bool {
			latest := ht.headTracker.LatestChain()
			return latest != nil && latest.Number == head.Number
		})`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(head, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("HeadByNumber", mock.Anything, big.NewInt(finalizedHead.Number)).Return(finalizedHead, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(nil, errors.New("backfill call to finalized failed")).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ht.ethClient.On("SubscribeToHeads", mock.Anything, mock.Anything).Return(nil, nil, errors.New("failed to connect")).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `tests.AssertLogEventually(t, ht.observer, "Received new head")`
$DIR/pkg/heads/tracker_test.go: `tests.AssertEventually(t, func() bool {
			latest := ht.headTracker.LatestChain()
			return latest != nil && latest.Number == head.Number
		})`
$DIR/pkg/heads/tracker_test.go: `t.Run(tc.Name, func(t *testing.T) {
			tc.Run(t, tc.Opts)
		})`
$DIR/pkg/heads/tracker_test.go: `tc.Run(t, tc.Opts)`
$DIR/pkg/heads/tracker_test.go: `t.Run("Disabled Persistence "+tc.Name, func(t *testing.T) {
			opts := tc.Opts
			opts.ORM = evmheads.NewNullORM()
			tc.Run(t, opts)
		})`
$DIR/pkg/heads/tracker_test.go: `opts.ORM = evmheads.NewNullORM()`
$DIR/pkg/heads/tracker_test.go: `tc.Run(t, opts)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				sub := mockEth.NewSub(t)
				chchHeaders <- testutils.NewRawSub(chHead, sub.Err())
				return chHead, sub, nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `chchHeaders <- testutils.NewRawSub(chHead, sub.Err())`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByHash", mock.Anything, mock.Anything).Return(testutils.Head(0), nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `headers.TrySend(&evmtypes.Head{Number: 1, Hash: utils.NewHash(), EVMChainID: ubig.New(testutils.FixtureChainID)})`
$DIR/pkg/heads/tracker_test.go: `tests.AssertEventually(t, func() bool { return checker.OnNewLongestChainCount() == 1 })`
$DIR/pkg/heads/tracker_test.go: `ht.Stop(t)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				return chHead, mockEth.NewSub(t), nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).Return((<-chan *evmtypes.Head)(chHead), nil, errors.New("cannot reconnect"))`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				return chHead, mockEth.NewSub(t), nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `mockEth.SubsErr(errors.New("test error to force reconnect"))`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				sub := mockEth.NewSub(t)
				chchHeaders <- testutils.NewRawSub(ch, sub.Err())
				return ch, sub, nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `chchHeaders <- testutils.NewRawSub(ch, sub.Err())`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByHash", mock.Anything, mock.Anything).Return(testutils.Head(0), nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `headers.TrySend(testutils.Head(1))`
$DIR/pkg/heads/tracker_test.go: `g.Eventually(func() bool {
		report := ht.headTracker.HealthReport()
		return !slices.ContainsFunc(maps.Values(report), func(e error) bool { return e != nil })
	}, 5*time.Second, tests.TestInterval).Should(gomega.BeTrue())`
$DIR/pkg/heads/tracker_test.go: `headers.CloseCh()`
$DIR/pkg/heads/tracker_test.go: `heads[i].ParentHash = parentHash`
$DIR/pkg/heads/tracker_test.go: `parentHash = heads[i].Hash`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(heads[3], nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, big.NewInt(0)).Return(heads[0], nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByHash", mock.Anything, heads[2].Hash).Return(heads[2], nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByHash", mock.Anything, heads[1].Hash).Return(heads[1], nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByHash", mock.Anything, heads[0].Hash).Return(heads[0], nil).Maybe()`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				sub := mockEth.NewSub(t)
				chchHeaders <- testutils.NewRawSub(ch, sub.Err())
				return ch, sub, nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `chchHeaders <- testutils.NewRawSub(ch, sub.Err())`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `headers.TrySend(testutils.Head(1))`
$DIR/pkg/heads/tracker_test.go: `c.FinalityDepth = ptr[uint32](50)`
$DIR/pkg/heads/tracker_test.go: `c.HeadTracker.MaxBufferSize = ptr[uint32](100)`
$DIR/pkg/heads/tracker_test.go: `c.HeadTracker.SamplingInterval = commonconfig.MustNewDuration(2500 * time.Millisecond)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				sub := mockEth.NewSub(t)
				chchHeaders <- testutils.NewRawSub(chHead, sub.Err())
				return chHead, sub, nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `chchHeaders <- testutils.NewRawSub(chHead, sub.Err())`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(head0, nil)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, big.NewInt(0)).Return(head0, nil)`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocks.Head(0))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocks.Head(1))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocks.Head(3))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocks.Head(2))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocks.Head(4))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocks.NewHead(4))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocksForked.Head(2))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocksForked.Head(3))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocksForked.Head(4))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocksForked.Head(5))`
$DIR/pkg/heads/tracker_test.go: `checker.On("OnNewLongestChain", mock.Anything, mock.Anything).
		Run(func(args mock.Arguments) {
			h := args.Get(1).(*evmtypes.Head)
			// This is the new longest chain [0, 5], check that it came with its parents
			assert.Equal(t, uint32(6), h.ChainLength())
			assertChainWithParents(t, blocksForked, 5, 1, h)

			lastLongestChainAwaiter.ItHappened()
		}).Return().Once()`
$DIR/pkg/heads/tracker_test.go: `assertChainWithParents(t, blocksForked, 5, 1, h)`
$DIR/pkg/heads/tracker_test.go: `lastLongestChainAwaiter.ItHappened()`
$DIR/pkg/heads/tracker_test.go: `latestHeadByHashMu.Lock()`
$DIR/pkg/heads/tracker_test.go: `fnCall.ReturnArguments = mock.Arguments{head, nil}`
$DIR/pkg/heads/tracker_test.go: `latestHeadByHashMu.Lock()`
$DIR/pkg/heads/tracker_test.go: `latestHeadByHash[h.Hash] = h`
$DIR/pkg/heads/tracker_test.go: `latestHeadByHashMu.Unlock()`
$DIR/pkg/heads/tracker_test.go: `headers.TrySend(h)`
$DIR/pkg/heads/tracker_test.go: `lastLongestChainAwaiter.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/tracker_test.go: `ht.Stop(t)`
$DIR/pkg/heads/tracker_test.go: `c.FinalityDepth = ptr[uint32](50)`
$DIR/pkg/heads/tracker_test.go: `c.HeadTracker.MaxBufferSize = ptr[uint32](100)`
$DIR/pkg/heads/tracker_test.go: `c.HeadTracker.SamplingInterval = commonconfig.MustNewDuration(0)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("SubscribeToHeads", mock.Anything).
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				sub := mockEth.NewSub(t)
				chchHeaders <- testutils.NewRawSub(chHead, sub.Err())
				return chHead, sub, nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `chchHeaders <- testutils.NewRawSub(chHead, sub.Err())`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(head0, nil)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("HeadByNumber", mock.Anything, big.NewInt(0)).Return(head0, nil)`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocks.Head(0))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocks.Head(1))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocks.Head(3))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocks.Head(2))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocks.Head(4))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocks.NewHead(4))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocksForked.Head(2))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocksForked.Head(3))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocksForked.Head(4))`
$DIR/pkg/heads/tracker_test.go: `headSeq.Append(blocksForked.Head(5))`
$DIR/pkg/heads/tracker_test.go: `checker.On("OnNewLongestChain", mock.Anything, mock.Anything).
		Run(func(args mock.Arguments) {
			h := args.Get(1).(*evmtypes.Head)
			require.Equal(t, int64(0), h.Number)
			require.Equal(t, blocks.Head(0).Hash, h.Hash)
		}).Return().Once()`
$DIR/pkg/heads/tracker_test.go: `checker.On("OnNewLongestChain", mock.Anything, mock.Anything).
		Run(func(args mock.Arguments) {
			h := args.Get(1).(*evmtypes.Head)
			require.Equal(t, int64(1), h.Number)
			require.Equal(t, blocks.Head(1).Hash, h.Hash)
		}).Return().Once()`
$DIR/pkg/heads/tracker_test.go: `checker.On("OnNewLongestChain", mock.Anything, mock.Anything).
		Run(func(args mock.Arguments) {
			h := args.Get(1).(*evmtypes.Head)
			require.Equal(t, int64(3), h.Number)
			require.Equal(t, blocks.Head(3).Hash, h.Hash)
		}).Return().Once()`
$DIR/pkg/heads/tracker_test.go: `checker.On("OnNewLongestChain", mock.Anything, mock.Anything).
		Run(func(args mock.Arguments) {
			h := args.Get(1).(*evmtypes.Head)
			assertChainWithParents(t, blocks, 4, 1, h)
		}).Return().Once()`
$DIR/pkg/heads/tracker_test.go: `assertChainWithParents(t, blocks, 4, 1, h)`
$DIR/pkg/heads/tracker_test.go: `checker.On("OnNewLongestChain", mock.Anything, mock.Anything).
		Run(func(args mock.Arguments) {
			h := args.Get(1).(*evmtypes.Head)
			assertChainWithParents(t, blocksForked, 5, 1, h)
			lastLongestChainAwaiter.ItHappened()
		}).Return().Once()`
$DIR/pkg/heads/tracker_test.go: `assertChainWithParents(t, blocksForked, 5, 1, h)`
$DIR/pkg/heads/tracker_test.go: `lastLongestChainAwaiter.ItHappened()`
$DIR/pkg/heads/tracker_test.go: `ht.Start(t)`
$DIR/pkg/heads/tracker_test.go: `latestHeadByHashMu.Lock()`
$DIR/pkg/heads/tracker_test.go: `fnCall.ReturnArguments = mock.Arguments{head, nil}`
$DIR/pkg/heads/tracker_test.go: `latestHeadByHashMu.Lock()`
$DIR/pkg/heads/tracker_test.go: `latestHeadByHash[h.Hash] = h`
$DIR/pkg/heads/tracker_test.go: `latestHeadByHashMu.Unlock()`
$DIR/pkg/heads/tracker_test.go: `headers.TrySend(h)`
$DIR/pkg/heads/tracker_test.go: `time.Sleep(tests.TestInterval)`
$DIR/pkg/heads/tracker_test.go: `lastLongestChainAwaiter.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/tracker_test.go: `ht.Stop(t)`
$DIR/pkg/heads/tracker_test.go: `t.Run("Enabled Persistence", func(t *testing.T) {
		testHeadTrackerBackfill(t, func(t *testing.T) evmheads.ORM {
			db := testutils.NewSqlxDB(t)
			return evmheads.NewORM(*testutils.FixtureChainID, db, 0)
		})
	})`
$DIR/pkg/heads/tracker_test.go: `testHeadTrackerBackfill(t, func(t *testing.T) evmheads.ORM {
			db := testutils.NewSqlxDB(t)
			return evmheads.NewORM(*testutils.FixtureChainID, db, 0)
		})`
$DIR/pkg/heads/tracker_test.go: `testHeadTrackerBackfill(t, func(t *testing.T) evmheads.ORM {
			return evmheads.NewNullORM()
		})`
$DIR/pkg/heads/tracker_test.go: `h11.ParentHash = utils.NewHash()`
$DIR/pkg/heads/tracker_test.go: `h12.ParentHash = h11.Hash`
$DIR/pkg/heads/tracker_test.go: `h13.ParentHash = h12.Hash`
$DIR/pkg/heads/tracker_test.go: `c.FinalityTagEnabled = ptr(opts.FinalityTagEnabled)`
$DIR/pkg/heads/tracker_test.go: `c.FinalizedBlockOffset = ptr(opts.FinalizedBlockOffset)`
$DIR/pkg/heads/tracker_test.go: `c.FinalityDepth = ptr(opts.FinalityDepth)`
$DIR/pkg/heads/tracker_test.go: `c.SafeDepth = ptr(opts.SafeDepth)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("ConfiguredChainID", mock.Anything).Return(testutils.FixtureChainID, nil)`
$DIR/pkg/heads/tracker_test.go: `t.Run("returns error if failed to get latest safe block (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		const expectedError = "failed to get latest finalized block"
		htu.ethClient.On("LatestSafeBlock", mock.Anything).Return(nil, errors.New(expectedError)).Once()

		_, err := htu.headTracker.LatestSafeBlock(ctx)
		require.ErrorContains(t, err, expectedError)
	})`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("LatestSafeBlock", mock.Anything).Return(nil, errors.New(expectedError)).Once()`
$DIR/pkg/heads/tracker_test.go: `t.Run("returns error if latest safe block is not valid (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		htu.ethClient.On("LatestSafeBlock", mock.Anything).Return(nil, nil).Once()

		_, err := htu.headTracker.LatestSafeBlock(ctx)
		require.ErrorContains(t, err, "failed to get valid latest finalized block")
	})`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("LatestSafeBlock", mock.Anything).Return(nil, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `t.Run("returns latest safe block", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		htu.ethClient.On("LatestSafeBlock", mock.Anything).Return(h11, nil).Once()

		actualS, err := htu.headTracker.LatestSafeBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualS, h11)
	})`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("LatestSafeBlock", mock.Anything).Return(h11, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `t.Run("returns latest safe block with finalityDepth set, and others default", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: false, FinalityDepth: 2, Heads: []*evmtypes.Head{h13, h12, h11}})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()

		actualS, err := htu.headTracker.LatestSafeBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualS.Number, h11.Number)
	})`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `h11.ParentHash = utils.NewHash()`
$DIR/pkg/heads/tracker_test.go: `h12.ParentHash = h11.Hash`
$DIR/pkg/heads/tracker_test.go: `h13.ParentHash = h12.Hash`
$DIR/pkg/heads/tracker_test.go: `c.FinalityTagEnabled = ptr(opts.FinalityTagEnabled)`
$DIR/pkg/heads/tracker_test.go: `c.FinalizedBlockOffset = ptr(opts.FinalizedBlockOffset)`
$DIR/pkg/heads/tracker_test.go: `c.FinalityDepth = ptr(opts.FinalityDepth)`
$DIR/pkg/heads/tracker_test.go: `ethClient.On("ConfiguredChainID", mock.Anything).Return(testutils.FixtureChainID, nil)`
$DIR/pkg/heads/tracker_test.go: `t.Run("returns error if failed to get latest block", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		const expectedError = "failed to fetch latest block"
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, errors.New(expectedError)).Once()

		_, _, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.ErrorContains(t, err, expectedError)
	})`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, errors.New(expectedError)).Once()`
$DIR/pkg/heads/tracker_test.go: `t.Run("returns error if latest block is invalid", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, nil).Once()

		_, _, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.ErrorContains(t, err, "expected latest block to be valid")
	})`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `t.Run("returns error if failed to get latest finalized (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()
		const expectedError = "failed to get latest finalized block"
		htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, errors.New(expectedError)).Once()

		_, _, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.ErrorContains(t, err, expectedError)
	})`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, errors.New(expectedError)).Once()`
$DIR/pkg/heads/tracker_test.go: `t.Run("returns error if latest finalized block is not valid (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()
		htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, nil).Once()

		_, _, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.ErrorContains(t, err, "failed to get valid latest finalized block")
	})`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `t.Run("returns latest finalized block as is if FinalizedBlockOffset is 0 (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()
		htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(h11, nil).Once()

		actualL, actualLF, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualL, h13)
		assert.Equal(t, actualLF, h11)
	})`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(h11, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `t.Run("returns latest finalized block with offset from cache (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true, FinalizedBlockOffset: 1, Heads: []*evmtypes.Head{h13, h12, h11}})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()
		htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(h12, nil).Once()

		actualL, actualLF, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualL.Number, h13.Number)
		assert.Equal(t, actualLF.Number, h11.Number)
	})`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(h12, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `t.Run("returns latest finalized block with offset from RPC (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true, FinalizedBlockOffset: 2, Heads: []*evmtypes.Head{h13, h12, h11}})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()
		htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(h12, nil).Once()
		h10 := testutils.Head(10)
		htu.ethClient.On("HeadByNumber", mock.Anything, big.NewInt(10)).Return(h10, nil).Once()

		actualL, actualLF, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualL.Number, h13.Number)
		assert.Equal(t, actualLF.Number, h10.Number)
	})`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(h12, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, big.NewInt(10)).Return(h10, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `t.Run("returns current head for both latest and finalized for FD = 0 (finality depth)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()

		actualL, actualLF, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualL.Number, h13.Number)
		assert.Equal(t, actualLF.Number, h13.Number)
	})`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `t.Run("returns latest finalized block with offset from cache (finality depth)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityDepth: 1, FinalizedBlockOffset: 1, Heads: []*evmtypes.Head{h13, h12, h11}})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()

		actualL, actualLF, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualL.Number, h13.Number)
		assert.Equal(t, actualLF.Number, h11.Number)
	})`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `htu.ethClient.On("HeadByNumber", mock.Anything, big.NewInt(10)).Return(h10, nil).Once()`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, big.NewInt(0))`
$DIR/pkg/heads/tracker_test.go: `.NewInt(0)`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Maybe()`
$DIR/pkg/heads/tracker_test.go: `.
		Return(nil, mockEth.NewSub(t), nil)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.Head(16)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.headSaver.LatestChain()`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.HeadTracker.HistoryDepth = ptr[uint32](100)
	})`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.Head(201)`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.headSaver.Load(tests.Context(t), latest.Number)`
$DIR/pkg/heads/tracker_test.go: `.Context(t)`
$DIR/pkg/heads/tracker_test.go: `.LatestHead(tests.Context(t))`
$DIR/pkg/heads/tracker_test.go: `.Context(t)`
$DIR/pkg/heads/tracker_test.go: `.Head(5)`
$DIR/pkg/heads/tracker_test.go: `.Head(6)`
$DIR/pkg/heads/tracker_test.go: `.NewInt(6)`
$DIR/pkg/heads/tracker_test.go: `.Head(1)`
$DIR/pkg/heads/tracker_test.go: `.NewInt(5)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.NewInt(5)`
$DIR/pkg/heads/tracker_test.go: `.NewInt(5)`
$DIR/pkg/heads/tracker_test.go: `.NewInt(0)`
$DIR/pkg/heads/tracker_test.go: `.Run(test.name, func(t *testing.T) {
			db := testutils.NewSqlxDB(t)
			config := configtest.NewChainScopedConfig(t, nil)
			orm := evmheads.NewORM(*testutils.FixtureChainID, db, 0)

			ethClient := clienttest.NewClientWithDefaultChainID(t)
			chStarted := make(chan struct{})
			mockEth := &clienttest.MockEth{
				EthClient: ethClient,
			}
			ethClient.On("SubscribeToHeads", mock.Anything).
				Maybe().
				Return(
					func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
						defer close(chStarted)
						return make(<-chan *evmtypes.Head), mockEth.NewSub(t), nil
					},
				)
			ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(testutils.Head(0), nil).Maybe()

			fnCall := ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Maybe()
			fnCall.RunFn = func(args mock.Arguments) {
				num := args.Get(1).(*big.Int)
				fnCall.ReturnArguments = mock.Arguments{testutils.Head(num.Int64()), nil}
			}

			if test.initial != nil {
				require.NoError(t, orm.IdempotentInsertHead(tests.Context(t), test.initial))
			}

			ht := createHeadTracker(t, ethClient, config.EVM(), config.EVM().HeadTracker(), orm)
			ht.Start(t)

			if test.toSave != nil {
				err := ht.headSaver.Save(tests.Context(t), test.toSave)
				require.NoError(t, err)
			}

			tests.AssertEventually(t, func() bool {
				latest := ht.headSaver.LatestChain().ToInt()
				return latest != nil && test.want.Cmp(latest) == 0
			})
		})`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
				Maybe()`
$DIR/pkg/heads/tracker_test.go: `.
				Return(
					func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
						defer close(chStarted)
						return make(<-chan *evmtypes.Head), mockEth.NewSub(t), nil
					},
				)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.Get(1)`
$DIR/pkg/heads/tracker_test.go: `.Head(num.Int64())`
$DIR/pkg/heads/tracker_test.go: `.Int64()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.headSaver.Save(tests.Context(t), test.toSave)`
$DIR/pkg/heads/tracker_test.go: `.Context(t)`
$DIR/pkg/heads/tracker_test.go: `.AssertEventually(t, func() bool {
				latest := ht.headSaver.LatestChain().ToInt()
				return latest != nil && test.want.Cmp(latest) == 0
			})`
$DIR/pkg/heads/tracker_test.go: `.headSaver.LatestChain()`
$DIR/pkg/heads/tracker_test.go: `.ToInt()`
$DIR/pkg/heads/tracker_test.go: `.want.Cmp(latest)`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Run(func(mock.Arguments) {
			close(chStarted)
		})`
$DIR/pkg/heads/tracker_test.go: `.
		Return((<-chan *evmtypes.Head)(ch), sub, nil)`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.Run("Finality violation on block hash mismatch", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		config := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.FinalityTagEnabled = ptr(true)
		})
		orm := evmheads.NewORM(*testutils.FixtureChainID, db, 0)

		ethClient := clienttest.NewClientWithDefaultChainID(t)
		chStarted := make(chan struct{})
		mockEth := &clienttest.MockEth{EthClient: ethClient}
		sub := mockEth.NewSub(t)

		h0 := testutils.Head(0)
		h0.IsFinalized.Store(true)

		// for initial load
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h0, nil).Once()
		// for backfill
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(h0, nil).Maybe()
		ethClient.On("HeadByHash", mock.Anything, mock.Anything).Return(h0, nil).Maybe()
		ch := make(chan *evmtypes.Head)
		ethClient.On("SubscribeToHeads", mock.Anything).
			Run(func(mock.Arguments) {
				close(chStarted)
			}).
			Return((<-chan *evmtypes.Head)(ch), sub, nil)
		ethClient.On("LatestFinalizedBlock", mock.Anything).Return(h0, nil).Maybe()

		ht := createHeadTracker(t, ethClient, config.EVM(), config.EVM().HeadTracker(), orm)
		ht.Start(t)
		<-chStarted

		ch <- h0

		invalid0 := testutils.Head(0)
		invalid0.IsFinalized.Store(true)

		invalid1 := testutils.Head(1)
		invalid1.ParentHash = invalid0.Hash
		invalid1.Parent.Store(invalid0)

		ch <- invalid1 // Deliver head with finalized block hash mismatch compared to h0

		g := gomega.NewWithT(t)
		g.Eventually(func() bool {
			report := ht.headTracker.HealthReport()
			return slices.ContainsFunc(maps.Values(report), func(e error) bool {
				return errors.Is(e, types.ErrFinalityViolated)
			})
		}, 5*time.Second, tests.TestInterval).Should(gomega.BeTrue())
	})`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.FinalityTagEnabled = ptr(true)
		})`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(h0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByHash", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
			Run(func(mock.Arguments) {
				close(chStarted)
			})`
$DIR/pkg/heads/tracker_test.go: `.
			Return((<-chan *evmtypes.Head)(ch), sub, nil)`
$DIR/pkg/heads/tracker_test.go: `.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `.Head(1)`
$DIR/pkg/heads/tracker_test.go: `.Parent.Store(invalid0)`
$DIR/pkg/heads/tracker_test.go: `.NewWithT(t)`
$DIR/pkg/heads/tracker_test.go: `.Eventually(func() bool {
			report := ht.headTracker.HealthReport()
			return slices.ContainsFunc(maps.Values(report), func(e error) bool {
				return errors.Is(e, types.ErrFinalityViolated)
			})
		}, 5*time.Second, tests.TestInterval)`
$DIR/pkg/heads/tracker_test.go: `.headTracker.HealthReport()`
$DIR/pkg/heads/tracker_test.go: `.ContainsFunc(maps.Values(report), func(e error) bool {
				return errors.Is(e, types.ErrFinalityViolated)
			})`
$DIR/pkg/heads/tracker_test.go: `.Values(report)`
$DIR/pkg/heads/tracker_test.go: `.Is(e, types.ErrFinalityViolated)`
$DIR/pkg/heads/tracker_test.go: `.Should(gomega.BeTrue())`
$DIR/pkg/heads/tracker_test.go: `.BeTrue()`
$DIR/pkg/heads/tracker_test.go: `.Run("Finality violation on old block", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		config := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.FinalityTagEnabled = ptr(true)
			c.FinalityDepth = ptr(uint32(0))
			// finalty violation on old block possible only with finalty tag
			c.HeadTracker.FinalityTagBypass = ptr(true)
		})
		orm := evmheads.NewORM(*testutils.FixtureChainID, db, 0)

		ethClient := clienttest.NewClientWithDefaultChainID(t)
		chStarted := make(chan struct{})
		mockEth := &clienttest.MockEth{EthClient: ethClient}
		sub := mockEth.NewSub(t)

		h0 := testutils.Head(0)
		h0.IsFinalized.Store(true)

		// for initial load
		ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h0, nil).Once()
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(h0, nil).Once()
		// for backfill
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(h0, nil).Maybe()
		ethClient.On("HeadByHash", mock.Anything, mock.Anything).Return(h0, nil).Maybe()
		ch := make(chan *evmtypes.Head)
		ethClient.On("SubscribeToHeads", mock.Anything).
			Run(func(mock.Arguments) {
				close(chStarted)
			}).
			Return((<-chan *evmtypes.Head)(ch), sub, nil)

		ht := createHeadTracker(t, ethClient, config.EVM(), config.EVM().HeadTracker(), orm)
		ht.Start(t)
		<-chStarted

		h1 := testutils.Head(1)
		h1.IsFinalized.Store(true)
		h1.ParentHash = h0.Hash
		h1.Parent.Store(h0)
		ch <- h1

		h2 := testutils.Head(2)
		h2.IsFinalized.Store(true)
		h2.ParentHash = h1.Hash
		h2.Parent.Store(h1)
		ch <- h2
		require.NoError(t, ht.headSaver.Save(t.Context(), h2))

		// Send old head
		ch <- h0

		g := gomega.NewWithT(t)
		g.Eventually(func() bool {
			report := ht.headTracker.HealthReport()
			return slices.ContainsFunc(maps.Values(report), func(e error) bool {
				return errors.Is(e, types.ErrFinalityViolated) && strings.Contains(e.Error(), "got very old block")
			})
		}, 5*time.Second, tests.TestInterval).Should(gomega.BeTrue())
	})`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.FinalityTagEnabled = ptr(true)
			c.FinalityDepth = ptr(uint32(0))
			// finalty violation on old block possible only with finalty tag
			c.HeadTracker.FinalityTagBypass = ptr(true)
		})`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(h0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByHash", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
			Run(func(mock.Arguments) {
				close(chStarted)
			})`
$DIR/pkg/heads/tracker_test.go: `.
			Return((<-chan *evmtypes.Head)(ch), sub, nil)`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.Head(1)`
$DIR/pkg/heads/tracker_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `.Parent.Store(h0)`
$DIR/pkg/heads/tracker_test.go: `.Head(2)`
$DIR/pkg/heads/tracker_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `.Parent.Store(h1)`
$DIR/pkg/heads/tracker_test.go: `.NewWithT(t)`
$DIR/pkg/heads/tracker_test.go: `.Eventually(func() bool {
			report := ht.headTracker.HealthReport()
			return slices.ContainsFunc(maps.Values(report), func(e error) bool {
				return errors.Is(e, types.ErrFinalityViolated) && strings.Contains(e.Error(), "got very old block")
			})
		}, 5*time.Second, tests.TestInterval)`
$DIR/pkg/heads/tracker_test.go: `.headTracker.HealthReport()`
$DIR/pkg/heads/tracker_test.go: `.ContainsFunc(maps.Values(report), func(e error) bool {
				return errors.Is(e, types.ErrFinalityViolated) && strings.Contains(e.Error(), "got very old block")
			})`
$DIR/pkg/heads/tracker_test.go: `.Values(report)`
$DIR/pkg/heads/tracker_test.go: `.Is(e, types.ErrFinalityViolated)`
$DIR/pkg/heads/tracker_test.go: `.Contains(e.Error(), "got very old block")`
$DIR/pkg/heads/tracker_test.go: `.Should(gomega.BeTrue())`
$DIR/pkg/heads/tracker_test.go: `.BeTrue()`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.FinalityTagEnabled = ptr(true)
			c.FinalityDepth = ptr(uint32(0))
		})`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByHash", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
			Run(func(mock.Arguments) {
				close(chStarted)
			})`
$DIR/pkg/heads/tracker_test.go: `.
			Return((<-chan *evmtypes.Head)(ch), sub, nil)`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.Head(1)`
$DIR/pkg/heads/tracker_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `.Parent.Store(h0)`
$DIR/pkg/heads/tracker_test.go: `.Head(2)`
$DIR/pkg/heads/tracker_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/heads/tracker_test.go: `.Parent.Store(h1)`
$DIR/pkg/heads/tracker_test.go: `.NewWithT(t)`
$DIR/pkg/heads/tracker_test.go: `.Eventually(func() bool {
			report := ht.headTracker.HealthReport()
			return slices.ContainsFunc(maps.Values(report), func(e error) bool {
				return e != nil
			})
		}, 5*time.Second, tests.TestInterval)`
$DIR/pkg/heads/tracker_test.go: `.headTracker.HealthReport()`
$DIR/pkg/heads/tracker_test.go: `.ContainsFunc(maps.Values(report), func(e error) bool {
				return e != nil
			})`
$DIR/pkg/heads/tracker_test.go: `.Values(report)`
$DIR/pkg/heads/tracker_test.go: `.Should(gomega.BeFalse())`
$DIR/pkg/heads/tracker_test.go: `.BeFalse()`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			if opts.FinalityTagEnable != nil {
				c.FinalityTagEnabled = opts.FinalityTagEnable
			}
			c.HeadTracker.HistoryDepth = ptr[uint32](historyDepth)
			c.FinalityDepth = ptr[uint32](finalityDepth)
			if opts.MaxAllowedFinalityDepth != nil {
				c.HeadTracker.MaxAllowedFinalityDepth = opts.MaxAllowedFinalityDepth
			}

			if opts.FinalityTagBypass != nil {
				c.HeadTracker.FinalityTagBypass = opts.FinalityTagBypass
			}
		})`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, sub, nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.Run("Starts even if failed to get initialHead", func(t *testing.T) {
		ht := newHeadTracker(t, opts{})
		ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(testutils.Head(0), errors.New("failed to get init head"))
		ht.Start(t)
		tests.AssertLogEventually(t, ht.observer, "Error handling initial head")
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.Head(0), errors.New("failed to get init head"))`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.New("failed to get init head")`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.AssertLogEventually(t, ht.observer, "Error handling initial head")`
$DIR/pkg/heads/tracker_test.go: `.Run("Starts even if received invalid head", func(t *testing.T) {
		ht := newHeadTracker(t, opts{})
		ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, nil)
		ht.Start(t)
		tests.AssertLogEventually(t, ht.observer, "Got nil initial head")
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, nil)`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.AssertLogEventually(t, ht.observer, "Got nil initial head")`
$DIR/pkg/heads/tracker_test.go: `.Run("Starts even if fails to get finalizedHead", func(t *testing.T) {
		ht := newHeadTracker(t, opts{FinalityTagEnable: ptr(true), FinalityTagBypass: ptr(false)})
		head := testutils.Head(1000)
		ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(head, nil).Once()
		ht.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, errors.New("failed to load latest finalized")).Once()
		ht.Start(t)
		tests.AssertLogEventually(t, ht.observer, "Error handling initial head")
	})`
$DIR/pkg/heads/tracker_test.go: `.Head(1000)`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(head, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, errors.New("failed to load latest finalized"))`
$DIR/pkg/heads/tracker_test.go: `.New("failed to load latest finalized")`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.AssertLogEventually(t, ht.observer, "Error handling initial head")`
$DIR/pkg/heads/tracker_test.go: `.Run("Starts even if latest finalizedHead is nil", func(t *testing.T) {
		ht := newHeadTracker(t, opts{FinalityTagEnable: ptr(true), FinalityTagBypass: ptr(false)})
		head := testutils.Head(1000)
		ht.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(head, nil).Once()
		ht.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, nil).Once()
		ht.ethClient.On("SubscribeToHeads", mock.Anything, mock.Anything).Return(nil, nil, errors.New("failed to connect")).Maybe()
		ht.Start(t)
		tests.AssertLogEventually(t, ht.observer, "Error handling initial head")
	})`
$DIR/pkg/heads/tracker_test.go: `.Head(1000)`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(head, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("SubscribeToHeads", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, nil, errors.New("failed to connect"))`
$DIR/pkg/heads/tracker_test.go: `.New("failed to connect")`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.AssertLogEventually(t, ht.observer, "Error handling initial head")`
$DIR/pkg/heads/tracker_test.go: `.Head(1000)`
$DIR/pkg/heads/tracker_test.go: `.Context(t)`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(head, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.Head(800)`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(finalizedHead, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, errors.New("backfill call to finalized failed"))`
$DIR/pkg/heads/tracker_test.go: `.New("backfill call to finalized failed")`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("SubscribeToHeads", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, nil, errors.New("failed to connect"))`
$DIR/pkg/heads/tracker_test.go: `.New("failed to connect")`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.AssertLogEventually(t, ht.observer, "Received new head")`
$DIR/pkg/heads/tracker_test.go: `.AssertEventually(t, func() bool {
			latest := ht.headTracker.LatestChain()
			return latest != nil && latest.Number == head.Number
		})`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestChain()`
$DIR/pkg/heads/tracker_test.go: `.Head(1000)`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(head, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.Head(head.Number - finalityDepth)`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, big.NewInt(finalizedHead.Number))`
$DIR/pkg/heads/tracker_test.go: `.NewInt(finalizedHead.Number)`
$DIR/pkg/heads/tracker_test.go: `.Return(finalizedHead, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.Context(t)`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, errors.New("backfill call to finalized failed"))`
$DIR/pkg/heads/tracker_test.go: `.New("backfill call to finalized failed")`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("SubscribeToHeads", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, nil, errors.New("failed to connect"))`
$DIR/pkg/heads/tracker_test.go: `.New("failed to connect")`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.AssertLogEventually(t, ht.observer, "Received new head")`
$DIR/pkg/heads/tracker_test.go: `.AssertEventually(t, func() bool {
			latest := ht.headTracker.LatestChain()
			return latest != nil && latest.Number == head.Number
		})`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestChain()`
$DIR/pkg/heads/tracker_test.go: `.Run(tc.Name, func(t *testing.T) {
			tc.Run(t, tc.Opts)
		})`
$DIR/pkg/heads/tracker_test.go: `.Run(t, tc.Opts)`
$DIR/pkg/heads/tracker_test.go: `.Run("Disabled Persistence "+tc.Name, func(t *testing.T) {
			opts := tc.Opts
			opts.ORM = evmheads.NewNullORM()
			tc.Run(t, opts)
		})`
$DIR/pkg/heads/tracker_test.go: `.NewNullORM()`
$DIR/pkg/heads/tracker_test.go: `.Run(t, opts)`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				sub := mockEth.NewSub(t)
				chchHeaders <- testutils.NewRawSub(chHead, sub.Err())
				return chHead, sub, nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.NewRawSub(chHead, sub.Err())`
$DIR/pkg/heads/tracker_test.go: `.Err()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByHash", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.TrySend(&evmtypes.Head{Number: 1, Hash: utils.NewHash(), EVMChainID: ubig.New(testutils.FixtureChainID)})`
$DIR/pkg/heads/tracker_test.go: `.NewHash()`
$DIR/pkg/heads/tracker_test.go: `.New(testutils.FixtureChainID)`
$DIR/pkg/heads/tracker_test.go: `.AssertEventually(t, func() bool { return checker.OnNewLongestChainCount() == 1 })`
$DIR/pkg/heads/tracker_test.go: `.OnNewLongestChainCount()`
$DIR/pkg/heads/tracker_test.go: `.Stop(t)`
$DIR/pkg/heads/tracker_test.go: `.OnNewLongestChainCount()`
$DIR/pkg/heads/tracker_test.go: `.NewWithT(t)`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				return chHead, mockEth.NewSub(t), nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return((<-chan *evmtypes.Head)(chHead), nil, errors.New("cannot reconnect"))`
$DIR/pkg/heads/tracker_test.go: `.New("cannot reconnect")`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				return chHead, mockEth.NewSub(t), nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.SubsErr(errors.New("test error to force reconnect"))`
$DIR/pkg/heads/tracker_test.go: `.New("test error to force reconnect")`
$DIR/pkg/heads/tracker_test.go: `.Eventually(checker.OnNewLongestChainCount, 5*time.Second, tests.TestInterval)`
$DIR/pkg/heads/tracker_test.go: `.Equal(int32(1))`
$DIR/pkg/heads/tracker_test.go: `.NewWithT(t)`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				sub := mockEth.NewSub(t)
				chchHeaders <- testutils.NewRawSub(ch, sub.Err())
				return ch, sub, nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.NewRawSub(ch, sub.Err())`
$DIR/pkg/heads/tracker_test.go: `.Err()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByHash", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.Head(0), nil)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.TrySend(testutils.Head(1))`
$DIR/pkg/heads/tracker_test.go: `.Head(1)`
$DIR/pkg/heads/tracker_test.go: `.Eventually(func() bool {
		report := ht.headTracker.HealthReport()
		return !slices.ContainsFunc(maps.Values(report), func(e error) bool { return e != nil })
	}, 5*time.Second, tests.TestInterval)`
$DIR/pkg/heads/tracker_test.go: `.headTracker.HealthReport()`
$DIR/pkg/heads/tracker_test.go: `.ContainsFunc(maps.Values(report), func(e error) bool { return e != nil })`
$DIR/pkg/heads/tracker_test.go: `.Values(report)`
$DIR/pkg/heads/tracker_test.go: `.Should(gomega.BeTrue())`
$DIR/pkg/heads/tracker_test.go: `.BeTrue()`
$DIR/pkg/heads/tracker_test.go: `.CloseCh()`
$DIR/pkg/heads/tracker_test.go: `.Eventually(checker.OnNewLongestChainCount, 5*time.Second, tests.TestInterval)`
$DIR/pkg/heads/tracker_test.go: `.Equal(int32(1))`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.Head(1)`
$DIR/pkg/heads/tracker_test.go: `.Head(2)`
$DIR/pkg/heads/tracker_test.go: `.Head(3)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(heads[3], nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, big.NewInt(0))`
$DIR/pkg/heads/tracker_test.go: `.NewInt(0)`
$DIR/pkg/heads/tracker_test.go: `.Return(heads[0], nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByHash", mock.Anything, heads[2].Hash)`
$DIR/pkg/heads/tracker_test.go: `.Return(heads[2], nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByHash", mock.Anything, heads[1].Hash)`
$DIR/pkg/heads/tracker_test.go: `.Return(heads[1], nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByHash", mock.Anything, heads[0].Hash)`
$DIR/pkg/heads/tracker_test.go: `.Return(heads[0], nil)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				sub := mockEth.NewSub(t)
				chchHeaders <- testutils.NewRawSub(ch, sub.Err())
				return ch, sub, nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.NewRawSub(ch, sub.Err())`
$DIR/pkg/heads/tracker_test.go: `.Err()`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.TrySend(testutils.Head(1))`
$DIR/pkg/heads/tracker_test.go: `.Head(1)`
$DIR/pkg/heads/tracker_test.go: `.LatestHead(tests.Context(t))`
$DIR/pkg/heads/tracker_test.go: `.Context(t)`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.FinalityDepth = ptr[uint32](50)
		// Need to set the buffer to something large since we inject a lot of heads at once and otherwise they will be dropped
		c.HeadTracker.MaxBufferSize = ptr[uint32](100)
		c.HeadTracker.SamplingInterval = commonconfig.MustNewDuration(2500 * time.Millisecond)
	})`
$DIR/pkg/heads/tracker_test.go: `.MustNewDuration(2500 * time.Millisecond)`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*config.EVM().ChainID(), db, 0)`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.ChainID()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				sub := mockEth.NewSub(t)
				chchHeaders <- testutils.NewRawSub(chHead, sub.Err())
				return chHead, sub, nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.NewRawSub(chHead, sub.Err())`
$DIR/pkg/heads/tracker_test.go: `.Err()`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(head0, nil)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, big.NewInt(0))`
$DIR/pkg/heads/tracker_test.go: `.NewInt(0)`
$DIR/pkg/heads/tracker_test.go: `.Return(head0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocks.Head(0))`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocks.Head(1))`
$DIR/pkg/heads/tracker_test.go: `.Head(1)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocks.Head(3))`
$DIR/pkg/heads/tracker_test.go: `.Head(3)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocks.Head(2))`
$DIR/pkg/heads/tracker_test.go: `.Head(2)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocks.Head(4))`
$DIR/pkg/heads/tracker_test.go: `.Head(4)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocks.NewHead(4))`
$DIR/pkg/heads/tracker_test.go: `.NewHead(4)`
$DIR/pkg/heads/tracker_test.go: `.ForkAt(t, 2, 5)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocksForked.Head(2))`
$DIR/pkg/heads/tracker_test.go: `.Head(2)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocksForked.Head(3))`
$DIR/pkg/heads/tracker_test.go: `.Head(3)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocksForked.Head(4))`
$DIR/pkg/heads/tracker_test.go: `.Head(4)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocksForked.Head(5))`
$DIR/pkg/heads/tracker_test.go: `.Head(5)`
$DIR/pkg/heads/tracker_test.go: `.NewAwaiter()`
$DIR/pkg/heads/tracker_test.go: `.On("OnNewLongestChain", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Run(func(args mock.Arguments) {
			h := args.Get(1).(*evmtypes.Head)
			// This is the new longest chain [0, 5], check that it came with its parents
			assert.Equal(t, uint32(6), h.ChainLength())
			assertChainWithParents(t, blocksForked, 5, 1, h)

			lastLongestChainAwaiter.ItHappened()
		})`
$DIR/pkg/heads/tracker_test.go: `.Get(1)`
$DIR/pkg/heads/tracker_test.go: `.ItHappened()`
$DIR/pkg/heads/tracker_test.go: `.Return()`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByHash", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.Lock()`
$DIR/pkg/heads/tracker_test.go: `.Unlock()`
$DIR/pkg/heads/tracker_test.go: `.Get(1)`
$DIR/pkg/heads/tracker_test.go: `.Lock()`
$DIR/pkg/heads/tracker_test.go: `.Unlock()`
$DIR/pkg/heads/tracker_test.go: `.TrySend(h)`
$DIR/pkg/heads/tracker_test.go: `.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/tracker_test.go: `.WaitTimeout(t)`
$DIR/pkg/heads/tracker_test.go: `.Stop(t)`
$DIR/pkg/heads/tracker_test.go: `.headSaver.Chain(h.Hash)`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.FinalityDepth = ptr[uint32](50)
		// Need to set the buffer to something large since we inject a lot of heads at once and otherwise they will be dropped
		c.HeadTracker.MaxBufferSize = ptr[uint32](100)
		c.HeadTracker.SamplingInterval = commonconfig.MustNewDuration(0)
	})`
$DIR/pkg/heads/tracker_test.go: `.MustNewDuration(0)`
$DIR/pkg/heads/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.On("SubscribeToHeads", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Return(
			func(ctx context.Context) (<-chan *evmtypes.Head, ethereum.Subscription, error) {
				sub := mockEth.NewSub(t)
				chchHeaders <- testutils.NewRawSub(chHead, sub.Err())
				return chHead, sub, nil
			},
		)`
$DIR/pkg/heads/tracker_test.go: `.NewSub(t)`
$DIR/pkg/heads/tracker_test.go: `.NewRawSub(chHead, sub.Err())`
$DIR/pkg/heads/tracker_test.go: `.Err()`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(head0, nil)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByNumber", mock.Anything, big.NewInt(0))`
$DIR/pkg/heads/tracker_test.go: `.NewInt(0)`
$DIR/pkg/heads/tracker_test.go: `.Return(head0, nil)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocks.Head(0))`
$DIR/pkg/heads/tracker_test.go: `.Head(0)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocks.Head(1))`
$DIR/pkg/heads/tracker_test.go: `.Head(1)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocks.Head(3))`
$DIR/pkg/heads/tracker_test.go: `.Head(3)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocks.Head(2))`
$DIR/pkg/heads/tracker_test.go: `.Head(2)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocks.Head(4))`
$DIR/pkg/heads/tracker_test.go: `.Head(4)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocks.NewHead(4))`
$DIR/pkg/heads/tracker_test.go: `.NewHead(4)`
$DIR/pkg/heads/tracker_test.go: `.ForkAt(t, 2, 5)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocksForked.Head(2))`
$DIR/pkg/heads/tracker_test.go: `.Head(2)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocksForked.Head(3))`
$DIR/pkg/heads/tracker_test.go: `.Head(3)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocksForked.Head(4))`
$DIR/pkg/heads/tracker_test.go: `.Head(4)`
$DIR/pkg/heads/tracker_test.go: `.Append(blocksForked.Head(5))`
$DIR/pkg/heads/tracker_test.go: `.Head(5)`
$DIR/pkg/heads/tracker_test.go: `.NewAwaiter()`
$DIR/pkg/heads/tracker_test.go: `.On("OnNewLongestChain", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Run(func(args mock.Arguments) {
			h := args.Get(1).(*evmtypes.Head)
			require.Equal(t, int64(0), h.Number)
			require.Equal(t, blocks.Head(0).Hash, h.Hash)
		})`
$DIR/pkg/heads/tracker_test.go: `.Get(1)`
$DIR/pkg/heads/tracker_test.go: `.Return()`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.On("OnNewLongestChain", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Run(func(args mock.Arguments) {
			h := args.Get(1).(*evmtypes.Head)
			require.Equal(t, int64(1), h.Number)
			require.Equal(t, blocks.Head(1).Hash, h.Hash)
		})`
$DIR/pkg/heads/tracker_test.go: `.Get(1)`
$DIR/pkg/heads/tracker_test.go: `.Return()`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.On("OnNewLongestChain", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Run(func(args mock.Arguments) {
			h := args.Get(1).(*evmtypes.Head)
			require.Equal(t, int64(3), h.Number)
			require.Equal(t, blocks.Head(3).Hash, h.Hash)
		})`
$DIR/pkg/heads/tracker_test.go: `.Get(1)`
$DIR/pkg/heads/tracker_test.go: `.Return()`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.On("OnNewLongestChain", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Run(func(args mock.Arguments) {
			h := args.Get(1).(*evmtypes.Head)
			assertChainWithParents(t, blocks, 4, 1, h)
		})`
$DIR/pkg/heads/tracker_test.go: `.Get(1)`
$DIR/pkg/heads/tracker_test.go: `.Return()`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.On("OnNewLongestChain", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.
		Run(func(args mock.Arguments) {
			h := args.Get(1).(*evmtypes.Head)
			assertChainWithParents(t, blocksForked, 5, 1, h)
			lastLongestChainAwaiter.ItHappened()
		})`
$DIR/pkg/heads/tracker_test.go: `.Get(1)`
$DIR/pkg/heads/tracker_test.go: `.ItHappened()`
$DIR/pkg/heads/tracker_test.go: `.Return()`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.Start(t)`
$DIR/pkg/heads/tracker_test.go: `.On("HeadByHash", mock.Anything, mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Maybe()`
$DIR/pkg/heads/tracker_test.go: `.Lock()`
$DIR/pkg/heads/tracker_test.go: `.Unlock()`
$DIR/pkg/heads/tracker_test.go: `.Get(1)`
$DIR/pkg/heads/tracker_test.go: `.Lock()`
$DIR/pkg/heads/tracker_test.go: `.Unlock()`
$DIR/pkg/heads/tracker_test.go: `.TrySend(h)`
$DIR/pkg/heads/tracker_test.go: `.Sleep(tests.TestInterval)`
$DIR/pkg/heads/tracker_test.go: `.AwaitOrFail(t, tests.WaitTimeout(t))`
$DIR/pkg/heads/tracker_test.go: `.WaitTimeout(t)`
$DIR/pkg/heads/tracker_test.go: `.Stop(t)`
$DIR/pkg/heads/tracker_test.go: `.headSaver.Chain(h.Hash)`
$DIR/pkg/heads/tracker_test.go: `.Run("Enabled Persistence", func(t *testing.T) {
		testHeadTrackerBackfill(t, func(t *testing.T) evmheads.ORM {
			db := testutils.NewSqlxDB(t)
			return evmheads.NewORM(*testutils.FixtureChainID, db, 0)
		})
	})`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.NewNullORM()`
$DIR/pkg/heads/tracker_test.go: `.Context()`
$DIR/pkg/heads/tracker_test.go: `.Head(11)`
$DIR/pkg/heads/tracker_test.go: `.NewHash()`
$DIR/pkg/heads/tracker_test.go: `.Head(12)`
$DIR/pkg/heads/tracker_test.go: `.Head(13)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.FinalityTagEnabled = ptr(opts.FinalityTagEnabled)
			c.FinalizedBlockOffset = ptr(opts.FinalizedBlockOffset)
			c.FinalityDepth = ptr(opts.FinalityDepth)
			c.SafeDepth = ptr(opts.SafeDepth)
		})`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.NewClient(t)`
$DIR/pkg/heads/tracker_test.go: `.On("ConfiguredChainID", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.FixtureChainID, nil)`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.headSaver.Load(t.Context(), 0)`
$DIR/pkg/heads/tracker_test.go: `.Context()`
$DIR/pkg/heads/tracker_test.go: `.Run("returns error if failed to get latest safe block (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		const expectedError = "failed to get latest finalized block"
		htu.ethClient.On("LatestSafeBlock", mock.Anything).Return(nil, errors.New(expectedError)).Once()

		_, err := htu.headTracker.LatestSafeBlock(ctx)
		require.ErrorContains(t, err, expectedError)
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("LatestSafeBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, errors.New(expectedError))`
$DIR/pkg/heads/tracker_test.go: `.New(expectedError)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestSafeBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.Run("returns error if latest safe block is not valid (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		htu.ethClient.On("LatestSafeBlock", mock.Anything).Return(nil, nil).Once()

		_, err := htu.headTracker.LatestSafeBlock(ctx)
		require.ErrorContains(t, err, "failed to get valid latest finalized block")
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("LatestSafeBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestSafeBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.Run("returns latest safe block", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		htu.ethClient.On("LatestSafeBlock", mock.Anything).Return(h11, nil).Once()

		actualS, err := htu.headTracker.LatestSafeBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualS, h11)
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("LatestSafeBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h11, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestSafeBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.Run("returns latest safe block with finalityDepth set, and others default", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: false, FinalityDepth: 2, Heads: []*evmtypes.Head{h13, h12, h11}})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()

		actualS, err := htu.headTracker.LatestSafeBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualS.Number, h11.Number)
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(h13, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestSafeBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(h13, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestSafeBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.Context(t)`
$DIR/pkg/heads/tracker_test.go: `.Head(11)`
$DIR/pkg/heads/tracker_test.go: `.NewHash()`
$DIR/pkg/heads/tracker_test.go: `.Head(12)`
$DIR/pkg/heads/tracker_test.go: `.Head(13)`
$DIR/pkg/heads/tracker_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.FinalityTagEnabled = ptr(opts.FinalityTagEnabled)
			c.FinalizedBlockOffset = ptr(opts.FinalizedBlockOffset)
			c.FinalityDepth = ptr(opts.FinalityDepth)
		})`
$DIR/pkg/heads/tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/heads/tracker_test.go: `.NewORM(*testutils.FixtureChainID, db, 0)`
$DIR/pkg/heads/tracker_test.go: `.NewClient(t)`
$DIR/pkg/heads/tracker_test.go: `.On("ConfiguredChainID", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(testutils.FixtureChainID, nil)`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.EVM()`
$DIR/pkg/heads/tracker_test.go: `.HeadTracker()`
$DIR/pkg/heads/tracker_test.go: `.headSaver.Load(tests.Context(t), 0)`
$DIR/pkg/heads/tracker_test.go: `.Context(t)`
$DIR/pkg/heads/tracker_test.go: `.Run("returns error if failed to get latest block", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		const expectedError = "failed to fetch latest block"
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, errors.New(expectedError)).Once()

		_, _, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.ErrorContains(t, err, expectedError)
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, errors.New(expectedError))`
$DIR/pkg/heads/tracker_test.go: `.New(expectedError)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestAndFinalizedBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.Run("returns error if latest block is invalid", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, nil).Once()

		_, _, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.ErrorContains(t, err, "expected latest block to be valid")
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestAndFinalizedBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.Run("returns error if failed to get latest finalized (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()
		const expectedError = "failed to get latest finalized block"
		htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, errors.New(expectedError)).Once()

		_, _, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.ErrorContains(t, err, expectedError)
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(h13, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, errors.New(expectedError))`
$DIR/pkg/heads/tracker_test.go: `.New(expectedError)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestAndFinalizedBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.Run("returns error if latest finalized block is not valid (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()
		htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, nil).Once()

		_, _, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.ErrorContains(t, err, "failed to get valid latest finalized block")
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(h13, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(nil, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestAndFinalizedBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.Run("returns latest finalized block as is if FinalizedBlockOffset is 0 (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()
		htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(h11, nil).Once()

		actualL, actualLF, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualL, h13)
		assert.Equal(t, actualLF, h11)
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(h13, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h11, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestAndFinalizedBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.Run("returns latest finalized block with offset from cache (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true, FinalizedBlockOffset: 1, Heads: []*evmtypes.Head{h13, h12, h11}})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()
		htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(h12, nil).Once()

		actualL, actualLF, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualL.Number, h13.Number)
		assert.Equal(t, actualLF.Number, h11.Number)
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(h13, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h12, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestAndFinalizedBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.Run("returns latest finalized block with offset from RPC (finality tag)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityTagEnabled: true, FinalizedBlockOffset: 2, Heads: []*evmtypes.Head{h13, h12, h11}})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()
		htu.ethClient.On("LatestFinalizedBlock", mock.Anything).Return(h12, nil).Once()
		h10 := testutils.Head(10)
		htu.ethClient.On("HeadByNumber", mock.Anything, big.NewInt(10)).Return(h10, nil).Once()

		actualL, actualLF, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualL.Number, h13.Number)
		assert.Equal(t, actualLF.Number, h10.Number)
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(h13, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/heads/tracker_test.go: `.Return(h12, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.Head(10)`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, big.NewInt(10))`
$DIR/pkg/heads/tracker_test.go: `.NewInt(10)`
$DIR/pkg/heads/tracker_test.go: `.Return(h10, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestAndFinalizedBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.Run("returns current head for both latest and finalized for FD = 0 (finality depth)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()

		actualL, actualLF, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualL.Number, h13.Number)
		assert.Equal(t, actualLF.Number, h13.Number)
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(h13, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestAndFinalizedBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.Run("returns latest finalized block with offset from cache (finality depth)", func(t *testing.T) {
		htu := newHeadTrackerUniverse(t, opts{FinalityDepth: 1, FinalizedBlockOffset: 1, Heads: []*evmtypes.Head{h13, h12, h11}})
		htu.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(h13, nil).Once()

		actualL, actualLF, err := htu.headTracker.LatestAndFinalizedBlock(ctx)
		require.NoError(t, err)
		assert.Equal(t, actualL.Number, h13.Number)
		assert.Equal(t, actualLF.Number, h11.Number)
	})`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(h13, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestAndFinalizedBlock(ctx)`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/heads/tracker_test.go: `.Return(h13, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.Head(10)`
$DIR/pkg/heads/tracker_test.go: `.ethClient.On("HeadByNumber", mock.Anything, big.NewInt(10))`
$DIR/pkg/heads/tracker_test.go: `.NewInt(10)`
$DIR/pkg/heads/tracker_test.go: `.Return(h10, nil)`
$DIR/pkg/heads/tracker_test.go: `.Once()`
$DIR/pkg/heads/tracker_test.go: `.headTracker.LatestAndFinalizedBlock(ctx)`
$DIR/pkg/keys/mutex_test.go: `err = rm.Unlock(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `err = rm.TryLock(TXMv2)`
$DIR/pkg/keys/mutex_test.go: `err = rm.Unlock(TXMv2)`
$DIR/pkg/keys/mutex_test.go: `err = rm.TryLock(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `err = rm.Unlock(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `err = rm.Unlock(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `.TryLock(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `.Unlock(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `.TryLock(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `.TryLock(TXMv2)`
$DIR/pkg/keys/mutex_test.go: `.Unlock(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `.Unlock(TXMv2)`
$DIR/pkg/keys/mutex_test.go: `.TryLock(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `.TryLock(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `.Unlock(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `.Unlock(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `.IsLocked(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `.IsLocked(TXMv1)`
$DIR/pkg/keys/mutex_test.go: `.IsLocked(TXMv1)`
$DIR/pkg/log/integration_test.go: `helper.lb.AddDependents(2)`
$DIR/pkg/log/integration_test.go: `helper.register(listener, newMockContract(t), 1)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `g.Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval).Should(gomega.Equal(int32(0)))`
$DIR/pkg/log/integration_test.go: `helper.lb.DependentReady()`
$DIR/pkg/log/integration_test.go: `g.Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval).Should(gomega.Equal(int32(0)))`
$DIR/pkg/log/integration_test.go: `helper.lb.DependentReady()`
$DIR/pkg/log/integration_test.go: `g.Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval).Should(gomega.Equal(int32(1)))`
$DIR/pkg/log/integration_test.go: `helper.unsubscribeAll()`
$DIR/pkg/log/integration_test.go: `testutils.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `helper.mockEth = mockEth`
$DIR/pkg/log/integration_test.go: `backfillCount.Store(1)`
$DIR/pkg/log/integration_test.go: `helper.register(listener, newMockContract(t), numConfirmations)`
$DIR/pkg/log/integration_test.go: `helper.register(listener, newMockContract(t), 1)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `gomega.NewWithT(t).Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval).Should(gomega.Equal(int32(1)))`
$DIR/pkg/log/integration_test.go: `gomega.NewWithT(t).Consistently(func() int32 { return helper.mockEth.UnsubscribeCallCount() }, 1*time.Second, DBPollingInterval).Should(gomega.Equal(int32(0)))`
$DIR/pkg/log/integration_test.go: `helper.unsubscribeAll()`
$DIR/pkg/log/integration_test.go: `backfillCount.Store(2)`
$DIR/pkg/log/integration_test.go: `helper.register(listenerLast, newMockContract(t), 1)`
$DIR/pkg/log/integration_test.go: `gomega.NewWithT(t).Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval).Should(gomega.Equal(int32(2)))`
$DIR/pkg/log/integration_test.go: `gomega.NewWithT(t).Consistently(func() int32 { return helper.mockEth.UnsubscribeCallCount() }, 1*time.Second, DBPollingInterval).Should(gomega.Equal(int32(1)))`
$DIR/pkg/log/integration_test.go: `testutils.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `helper.mockEth = mockEth`
$DIR/pkg/log/integration_test.go: `helper.register(listener, newMockContract(t), uint32(maxNumConfirmations))`
$DIR/pkg/log/integration_test.go: `helper.register(listener2, newMockContract(t), uint32(2))`
$DIR/pkg/log/integration_test.go: `func() {
		helper.start()
		defer helper.stop()

		require.Eventually(t, func() bool { return helper.mockEth.SubscribeCallCount() == 1 }, testutils.WaitTimeout(t), time.Second)
		require.Eventually(t, func() bool { return backfillCount.Load() == 1 }, testutils.WaitTimeout(t), time.Second)

		helper.lb.ReplayFromBlock(replayFrom, false)

		require.Eventually(t, func() bool { return backfillCount.Load() >= 2 }, testutils.WaitTimeout(t), time.Second)
	}()`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.lb.ReplayFromBlock(replayFrom, false)`
$DIR/pkg/log/integration_test.go: `testutils.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `helper.mockEth = mockEth`
$DIR/pkg/log/integration_test.go: `helper.register(listener, contract, 2)`
$DIR/pkg/log/integration_test.go: `func() {
		helper.start()
		defer helper.stop()

		// To start, no logs are sent
		require.Eventually(t, func() bool { return len(listener.getUniqueLogs()) == 0 }, testutils.WaitTimeout(t), time.Second,
			"expected unique logs to be 0 but was %d", len(listener.getUniqueLogs()))

		// Replay from block 2, the logs should be delivered. An incoming head must be simulated to
		// trigger log delivery.
		helper.lb.ReplayFromBlock(2, false)
		<-simulateIncomingHeads(t, blocks.Slice(10, 11), helper.lb)
		require.Eventually(t, func() bool { return len(listener.getUniqueLogs()) == 2 }, testutils.WaitTimeout(t), time.Second,
			"expected unique logs to be 2 but was %d", len(listener.getUniqueLogs()))

		// Replay again, the logs are already marked consumed, so they should not be included in
		// getUniqueLogs.
		helper.lb.ReplayFromBlock(2, false)
		<-simulateIncomingHeads(t, blocks.Slice(11, 12), helper.lb)
		require.Eventually(t, func() bool { return len(listener.getUniqueLogs()) == 2 }, testutils.WaitTimeout(t), time.Second,
			"expected unique logs to be 2 but was %d", len(listener.getUniqueLogs()))

		// Replay again with forceBroadcast. The logs are consumed again.
		helper.lb.ReplayFromBlock(2, true)
		<-simulateIncomingHeads(t, blocks.Slice(12, 13), helper.lb)
		require.Eventually(t, func() bool { return len(listener.getUniqueLogs()) == 4 }, testutils.WaitTimeout(t), time.Second,
			"expected unique logs to be 4 but was %d", len(listener.getUniqueLogs()))
	}()`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.lb.ReplayFromBlock(2, false)`
$DIR/pkg/log/integration_test.go: `<-simulateIncomingHeads(t, blocks.Slice(10, 11), helper.lb)`
$DIR/pkg/log/integration_test.go: `helper.lb.ReplayFromBlock(2, false)`
$DIR/pkg/log/integration_test.go: `<-simulateIncomingHeads(t, blocks.Slice(11, 12), helper.lb)`
$DIR/pkg/log/integration_test.go: `helper.lb.ReplayFromBlock(2, true)`
$DIR/pkg/log/integration_test.go: `<-simulateIncomingHeads(t, blocks.Slice(12, 13), helper.lb)`
$DIR/pkg/log/integration_test.go: `t.Run("pool two logs from subscription, then shut down", func(t *testing.T) {
		helper := newBroadcasterHelper(t, 0, 1, logs, func(c *toml.EVMConfig) {
			c.FinalityDepth = ptr[uint32](confs)
		})
		ctx := testutils.Context(t)
		orm := log.NewORM(helper.db, *testutils.FixtureChainID)

		listener := helper.newLogListenerWithJob("one")
		listener.SkipMarkingConsumed(true)
		listener2 := helper.newLogListenerWithJob("two")
		listener2.SkipMarkingConsumed(true)
		expBlock := int64(log1.BlockNumber)
		helper.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(0, 2), orm, &expBlock, func() {
			chRawLogs := <-helper.chchRawLogs
			chRawLogs.TrySend(log1)
			chRawLogs.TrySend(log2)
		})
		// Pool min block in DB and neither listener received a broadcast
		blockNum, err := orm.GetPendingMinBlock(ctx)
		require.NoError(t, err)
		require.NotNil(t, blockNum)
		require.Equal(t, int64(log1.BlockNumber), *blockNum)
		require.Empty(t, listener.getUniqueLogs())
		require.Empty(t, listener2.getUniqueLogs())
		helper.requireBroadcastCount(0)
	})`
$DIR/pkg/log/integration_test.go: `c.FinalityDepth = ptr[uint32](confs)`
$DIR/pkg/log/integration_test.go: `listener.SkipMarkingConsumed(true)`
$DIR/pkg/log/integration_test.go: `listener2.SkipMarkingConsumed(true)`
$DIR/pkg/log/integration_test.go: `helper.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(0, 2), orm, &expBlock, func() {
			chRawLogs := <-helper.chchRawLogs
			chRawLogs.TrySend(log1)
			chRawLogs.TrySend(log2)
		})`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(log1)`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(log2)`
$DIR/pkg/log/integration_test.go: `helper.requireBroadcastCount(0)`
$DIR/pkg/log/integration_test.go: `t.Run("backfill pool with both, then broadcast one, but don't consume", func(t *testing.T) {
		helper := newBroadcasterHelper(t, 2, 1, logs, func(c *toml.EVMConfig) {
			c.FinalityDepth = ptr[uint32](confs)
		})
		ctx := testutils.Context(t)
		orm := log.NewORM(helper.db, *testutils.FixtureChainID)
		contract1.On("ParseLog", log1).Return(flux_aggregator_wrapper.FluxAggregatorNewRound{}, nil)
		contract2.On("ParseLog", log2).Return(flux_aggregator_wrapper.FluxAggregatorAnswerUpdated{}, nil)

		listener := helper.newLogListenerWithJob("one")
		listener.SkipMarkingConsumed(true)
		listener2 := helper.newLogListenerWithJob("two")
		listener2.SkipMarkingConsumed(true)
		expBlock := int64(log2.BlockNumber)
		helper.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(2, 5), orm, &expBlock, nil)

		// Pool min block in DB and one listener received but didn't consume
		blockNum, err := orm.GetPendingMinBlock(ctx)
		require.NoError(t, err)
		require.NotNil(t, blockNum)
		require.Equal(t, int64(log2.BlockNumber), *blockNum)
		require.NotEmpty(t, listener.getUniqueLogs())
		require.Empty(t, listener2.getUniqueLogs())
		c, err := orm.WasBroadcastConsumed(ctx, log1.BlockHash, log1.Index, listener.JobID())
		require.NoError(t, err)
		require.False(t, c)
	})`
$DIR/pkg/log/integration_test.go: `c.FinalityDepth = ptr[uint32](confs)`
$DIR/pkg/log/integration_test.go: `contract1.On("ParseLog", log1).Return(flux_aggregator_wrapper.FluxAggregatorNewRound{}, nil)`
$DIR/pkg/log/integration_test.go: `contract2.On("ParseLog", log2).Return(flux_aggregator_wrapper.FluxAggregatorAnswerUpdated{}, nil)`
$DIR/pkg/log/integration_test.go: `listener.SkipMarkingConsumed(true)`
$DIR/pkg/log/integration_test.go: `listener2.SkipMarkingConsumed(true)`
$DIR/pkg/log/integration_test.go: `helper.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(2, 5), orm, &expBlock, nil)`
$DIR/pkg/log/integration_test.go: `t.Run("backfill pool and broadcast two, but only consume one", func(t *testing.T) {
		helper := newBroadcasterHelper(t, 4, 1, logs, func(c *toml.EVMConfig) {
			c.FinalityDepth = ptr[uint32](confs)
		})
		ctx := testutils.Context(t)
		orm := log.NewORM(helper.db, *testutils.FixtureChainID)

		listener := helper.newLogListenerWithJob("one")
		listener2 := helper.newLogListenerWithJob("two")
		listener2.SkipMarkingConsumed(true)
		helper.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(5, 8), orm, nil, nil)

		// Pool empty and one consumed but other didn't
		blockNum, err := orm.GetPendingMinBlock(ctx)
		require.NoError(t, err)
		require.Nil(t, blockNum)
		require.NotEmpty(t, listener.getUniqueLogs())
		require.NotEmpty(t, listener2.getUniqueLogs())
		c, err := orm.WasBroadcastConsumed(ctx, log1.BlockHash, log1.Index, listener.JobID())
		require.NoError(t, err)
		require.True(t, c)
		c, err = orm.WasBroadcastConsumed(ctx, log2.BlockHash, log2.Index, listener2.JobID())
		require.NoError(t, err)
		require.False(t, c)
	})`
$DIR/pkg/log/integration_test.go: `c.FinalityDepth = ptr[uint32](confs)`
$DIR/pkg/log/integration_test.go: `listener2.SkipMarkingConsumed(true)`
$DIR/pkg/log/integration_test.go: `helper.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(5, 8), orm, nil, nil)`
$DIR/pkg/log/integration_test.go: `c, err = orm.WasBroadcastConsumed(ctx, log2.BlockHash, log2.Index, listener2.JobID())`
$DIR/pkg/log/integration_test.go: `c.FinalityDepth = ptr[uint32](confs)`
$DIR/pkg/log/integration_test.go: `helper.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(8, 9), orm, nil, nil)`
$DIR/pkg/log/integration_test.go: `testutils.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `c.BlockBackfillSkip = ptr(true)`
$DIR/pkg/log/integration_test.go: `c.BlockBackfillDepth = ptr[uint32](15)`
$DIR/pkg/log/integration_test.go: `helper.mockEth = mockEth`
$DIR/pkg/log/integration_test.go: `helper.register(listener, newMockContract(t), uint32(10))`
$DIR/pkg/log/integration_test.go: `helper.register(listener2, newMockContract(t), uint32(2))`
$DIR/pkg/log/integration_test.go: `backfillCount.Store(1)`
$DIR/pkg/log/integration_test.go: `func() {
		helper.start()
		defer helper.stop()

		require.Eventually(t, func() bool { return helper.mockEth.SubscribeCallCount() == 1 }, testutils.WaitTimeout(t), time.Second)
		require.Eventually(t, func() bool { return backfillCount.Load() == 1 }, testutils.WaitTimeout(t), time.Second)
	}()`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `testutils.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `c.LogBackfillBatchSize = ptr(uint32(batchSize))`
$DIR/pkg/log/integration_test.go: `helper.mockEth = mockEth`
$DIR/pkg/log/integration_test.go: `lggr.Infof("Log Batch: --------- times %v - %v, %v", times, fromBlock, toBlock)`
$DIR/pkg/log/integration_test.go: `helper.register(listener, newMockContract(t), numConfirmations)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.unsubscribeAll()`
$DIR/pkg/log/integration_test.go: `testutils.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `backfilledLogs = append(backfilledLogs, aLog)`
$DIR/pkg/log/integration_test.go: `c.LogBackfillBatchSize = ptr(batchSize)`
$DIR/pkg/log/integration_test.go: `helper.mockEth = mockEth`
$DIR/pkg/log/integration_test.go: `lggr.Warnf("Log Batch: --------- times %v - %v, %v", times, fromBlock, toBlock)`
$DIR/pkg/log/integration_test.go: `helper.register(listener, newMockContract(t), 1)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `g.Eventually(func() int64 { return backfillCount.Load() }, testutils.WaitTimeout(t), time.Second).Should(gomega.Equal(int64(expectedBatches)))`
$DIR/pkg/log/integration_test.go: `helper.unsubscribeAll()`
$DIR/pkg/log/integration_test.go: `helper.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `helper.register(listener2, contract1, 1)`
$DIR/pkg/log/integration_test.go: `helper.register(listener3, contract2, 1)`
$DIR/pkg/log/integration_test.go: `helper.register(listener4, contract2, 1)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(log)`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(log)`
$DIR/pkg/log/integration_test.go: `<-headsDone`
$DIR/pkg/log/integration_test.go: `helper.requireBroadcastCount(12)`
$DIR/pkg/log/integration_test.go: `requireEqualLogs(t, addr1SentLogs, listener1.received.getUniqueLogs())`
$DIR/pkg/log/integration_test.go: `requireEqualLogs(t, addr1SentLogs, listener2.received.getUniqueLogs())`
$DIR/pkg/log/integration_test.go: `requireEqualLogs(t, addr2SentLogs, listener3.received.getUniqueLogs())`
$DIR/pkg/log/integration_test.go: `requireEqualLogs(t, addr2SentLogs, listener4.received.getUniqueLogs())`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `helper.register(listener2, contract1, 8)`
$DIR/pkg/log/integration_test.go: `_ = simulateIncomingHeads(t, blocks.Slice(0, 10), helper.lb)`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(log)`
$DIR/pkg/log/integration_test.go: `helper.requireBroadcastCount(5)`
$DIR/pkg/log/integration_test.go: `helper.stop()`
$DIR/pkg/log/integration_test.go: `requireEqualLogs(t,
		addr1SentLogs,
		listener1.received.getUniqueLogs(),
	)`
$DIR/pkg/log/integration_test.go: `requireEqualLogs(t,
		[]types.Log{
			addr1SentLogs[0],
			addr1SentLogs[1],
		},
		listener2.received.getUniqueLogs(),
	)`
$DIR/pkg/log/integration_test.go: `requireEqualLogs(t,
		listener1.received.getUniqueLogs(),
		listener1.received.getLogs(),
	)`
$DIR/pkg/log/integration_test.go: `requireEqualLogs(t,
		listener2.received.getUniqueLogs(),
		listener2.received.getLogs(),
	)`
$DIR/pkg/log/integration_test.go: `c.FinalityDepth = ptr[uint32](1)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `helper.register(listener2, contract1, 3)`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(log)`
$DIR/pkg/log/integration_test.go: `helper.requireBroadcastCount(6)`
$DIR/pkg/log/integration_test.go: `<-headsDone`
$DIR/pkg/log/integration_test.go: `helper.register(listener3, contract1, 1)`
$DIR/pkg/log/integration_test.go: `<-simulateIncomingHeads(t, blocks.Slice(6, 9), helper.lb)`
$DIR/pkg/log/integration_test.go: `helper.requireBroadcastCount(8)`
$DIR/pkg/log/integration_test.go: `helper.register(listener4, contract1, 1)`
$DIR/pkg/log/integration_test.go: `<-simulateIncomingHeads(t, blocks.Slice(9, 12), helper.lb)`
$DIR/pkg/log/integration_test.go: `c.FinalityDepth = ptr[uint32](4)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `helper.register(listener2, contract1, 3)`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(log)`
$DIR/pkg/log/integration_test.go: `<-headsDone`
$DIR/pkg/log/integration_test.go: `helper.requireBroadcastCount(6)`
$DIR/pkg/log/integration_test.go: `helper.register(listener3, contract1, 1)`
$DIR/pkg/log/integration_test.go: `<-simulateIncomingHeads(t, blocks.Slice(7, 9), helper.lb)`
$DIR/pkg/log/integration_test.go: `helper.requireBroadcastCount(9)`
$DIR/pkg/log/integration_test.go: `helper.register(listener4, contract1, 1)`
$DIR/pkg/log/integration_test.go: `<-simulateIncomingHeads(t, blocks.Slice(10, 12), helper.lb)`
$DIR/pkg/log/integration_test.go: `c.FinalityDepth = ptr[uint32](3)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.registerWithTopicValues(listener0, contract1, 1,
		map[common.Hash][][]log.Topic{
			topic: {}, // no filters, so all values allowed
		},
	)`
$DIR/pkg/log/integration_test.go: `helper.registerWithTopicValues(listener1, contract1, 1,
		map[common.Hash][][]log.Topic{
			topic: {{} /**/, {}}, // two empty filters, so all values allowed
		},
	)`
$DIR/pkg/log/integration_test.go: `helper.registerWithTopicValues(listener2, contract1, 1,
		map[common.Hash][][]log.Topic{
			topic: {
				{log.Topic(field1Value1), log.Topic(field1Value2)} /**/, {log.Topic(field2Value1), log.Topic(field2Value2)}, // two values for each field allowed
			},
		},
	)`
$DIR/pkg/log/integration_test.go: `helper.registerWithTopicValues(listener3, contract1, 1,
		map[common.Hash][][]log.Topic{
			topic: {
				{log.Topic(field1Value1), log.Topic(field1Value2)} /**/, {}, // two values allowed for field 1, and any values for field 2
			},
		},
	)`
$DIR/pkg/log/integration_test.go: `helper.registerWithTopicValues(listener4, contract1, 1,
		map[common.Hash][][]log.Topic{
			topic: {
				{log.Topic(field1Value1)} /**/, {log.Topic(field2Value1)}, // some values allowed
			},
		},
	)`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(log)`
$DIR/pkg/log/integration_test.go: `<-headsDone`
$DIR/pkg/log/integration_test.go: `c.FinalityDepth = ptr[uint32](2)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(addr1SentLogs[0])`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(addr1SentLogs[1])`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(addr1SentLogs[2])`
$DIR/pkg/log/integration_test.go: `<-simulateIncomingHeads(t, blocks.Slice(0, 4), helper.lb)`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(addr1SentLogs[3])`
$DIR/pkg/log/integration_test.go: `<-simulateIncomingHeads(t, blocks.Slice(4, 9), helper.lb)`
$DIR/pkg/log/integration_test.go: `helper.requireBroadcastCount(4)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(log)`
$DIR/pkg/log/integration_test.go: `<-simulateIncomingHeads(t, blocks.Slice(0, 10), helper.lb)`
$DIR/pkg/log/integration_test.go: `helper.requireBroadcastCount(3)`
$DIR/pkg/log/integration_test.go: `helper.stop()`
$DIR/pkg/log/integration_test.go: `requireEqualLogs(t,
		addr1SentLogs,
		listener1.received.getUniqueLogs(),
	)`
$DIR/pkg/log/integration_test.go: `c.FinalityDepth = ptr[uint32](2)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `<-simulateIncomingHeads(t, blocks.Slice(0, 7), helper.lb)`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(log)`
$DIR/pkg/log/integration_test.go: `<-simulateIncomingHeads(t, blocks.Slice(7, 9), helper.lb)`
$DIR/pkg/log/integration_test.go: `helper.requireBroadcastCount(3)`
$DIR/pkg/log/integration_test.go: `helper.stop()`
$DIR/pkg/log/integration_test.go: `requireEqualLogs(t,
		addr1SentLogs,
		listener1.received.getUniqueLogs(),
	)`
$DIR/pkg/log/integration_test.go: `testutils.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `ethClient.On("ConfiguredChainID", mock.Anything).Return(testutils.FixtureChainID)`
$DIR/pkg/log/integration_test.go: `ethClient.On("SubscribeFilterLogs", mock.Anything, mock.Anything, mock.Anything).
		Return(
			func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) ethereum.Subscription {
				defer close(chStarted)
				sub := mockEth.NewSub(t)
				chchRawLogs <- testutils.NewRawSub(ch, sub.Err())
				return sub
			},
			func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) error {
				return nil
			},
		).
		Once()`
$DIR/pkg/log/integration_test.go: `chchRawLogs <- testutils.NewRawSub(ch, sub.Err())`
$DIR/pkg/log/integration_test.go: `ethClient.On("SubscribeFilterLogs", mock.Anything, mock.Anything, mock.Anything).
		Return(
			func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) ethereum.Subscription {
				sub := mockEth.NewSub(t)
				chchRawLogs <- testutils.NewRawSub(ch, sub.Err())
				return sub
			},
			func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) error {
				return nil
			},
		).
		Times(3)`
$DIR/pkg/log/integration_test.go: `chchRawLogs <- testutils.NewRawSub(ch, sub.Err())`
$DIR/pkg/log/integration_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).
		Return(&evmtypes.Head{Number: blockHeight}, nil)`
$DIR/pkg/log/integration_test.go: `ethClient.On("FilterLogs", mock.Anything, mock.Anything).
		Run(func(args mock.Arguments) {
			query := args.Get(1).(ethereum.FilterQuery)
			require.Equal(t, big.NewInt(expectedBlock), query.FromBlock)
			require.Contains(t, query.Addresses, contract0.Address())
			require.Len(t, query.Addresses, 1)
		}).
		Return(nil, nil).
		Times(backfillTimes)`
$DIR/pkg/log/integration_test.go: `ethClient.On("FilterLogs", mock.Anything, mock.Anything).
		Run(func(args mock.Arguments) {
			query := args.Get(1).(ethereum.FilterQuery)
			require.Equal(t, big.NewInt(expectedBlock), query.FromBlock)
			require.Contains(t, query.Addresses, contract0.Address())
			require.Contains(t, query.Addresses, contract1.Address())
			require.Len(t, query.Addresses, 2)
		}).
		Return(nil, nil).
		Once()`
$DIR/pkg/log/integration_test.go: `ethClient.On("FilterLogs", mock.Anything, mock.Anything).
		Run(func(args mock.Arguments) {
			query := args.Get(1).(ethereum.FilterQuery)
			require.Equal(t, big.NewInt(expectedBlock), query.FromBlock)
			require.Contains(t, query.Addresses, contract0.Address())
			require.Contains(t, query.Addresses, contract1.Address())
			require.Contains(t, query.Addresses, contract2.Address())
			require.Len(t, query.Addresses, 3)
		}).
		Return(nil, nil).
		Once()`
$DIR/pkg/log/integration_test.go: `helper.lb.AddDependents(1)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.register(listener0, contract0, 1)`
$DIR/pkg/log/integration_test.go: `helper.lb.DependentReady()`
$DIR/pkg/log/integration_test.go: `helper.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `helper.register(listener2, contract2, 1)`
$DIR/pkg/log/integration_test.go: `helper.lb.ReplayFromBlock(125, false)`
$DIR/pkg/log/integration_test.go: `logsA[uint(n)] = blocks.LogOnBlockNumWithIndex(uint64(n), 0, addrA)`
$DIR/pkg/log/integration_test.go: `logsB[uint(n)] = blocks.LogOnBlockNumWithIndex(uint64(n), 1, addrB)`
$DIR/pkg/log/integration_test.go: `t.Run(test.name, func(t *testing.T) {
			const backfillDepth = 5
			helper := newBroadcasterHelper(t, int64(test.blockHeight1), 2, nil, func(c *toml.EVMConfig) {
				// something other than default
				c.BlockBackfillDepth = ptr[uint32](backfillDepth)
			})

			helper.start()
			defer helper.stop()

			logListenerA := helper.newLogListenerWithJob("logListenerA")
			logListenerB := helper.newLogListenerWithJob("logListenerB")

			contractA, err := flux_aggregator_wrapper.NewFluxAggregator(addrA, nil)
			require.NoError(t, err)
			contractB, err := flux_aggregator_wrapper.NewFluxAggregator(addrB, nil)
			require.NoError(t, err)

			// Register listener A
			helper.register(logListenerA, contractA, 1)

			// Send initial logs
			chRawLogs1 := <-helper.chchRawLogs
			headsDone := simulateIncomingHeads(t, blocks.Slice(test.blockHeight1, test.blockHeight2+2),
				helper.lb, headTrackableFunc(func(_ context.Context, head *evmtypes.Head) {
					n := uint(head.Number)
					if l, ok := logsA[n]; ok && slices.Contains(test.batch1, n) {
						chRawLogs1.TrySend(l)
					}
				}))

			helper.requireBroadcastCount(len(test.batch1))
			expectedA := newReceived(pickLogs(logsA, test.batch1))
			logListenerA.requireAllReceived(t, expectedA)

			<-headsDone
			helper.mockEth.EthClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(&evmtypes.Head{Number: int64(test.blockHeight2)}, nil).Once()

			combinedLogs := append(pickLogs(logsA, test.backfillableLogs), pickLogs(logsB, test.backfillableLogs)...)
			call := helper.mockEth.EthClient.On("FilterLogs", mock.Anything, mock.Anything).Return(combinedLogs, nil).Once()
			call.Run(func(args mock.Arguments) {
				// Validate that the ethereum.FilterQuery is specified correctly for the backfill that we expect
				fromBlock := args.Get(1).(ethereum.FilterQuery).FromBlock
				expected := big.NewInt(0)

				blockNumber := helper.lb.BackfillBlockNumber()
				if blockNumber.Valid && blockNumber.Int64 > int64(test.blockHeight2-backfillDepth) {
					expected = big.NewInt(blockNumber.Int64)
				} else if test.blockHeight2 > backfillDepth {
					expected = big.NewInt(int64(test.blockHeight2) - backfillDepth)
				}
				require.Equal(t, expected, fromBlock)
			})

			// Register listener B (triggers re-subscription)
			helper.register(logListenerB, contractB, 1)

			// Send second batch of new logs
			chRawLogs2 := <-helper.chchRawLogs
			headsDone = simulateIncomingHeads(t, blocks.Slice(test.blockHeight2, -1),
				helper.lb, headTrackableFunc(func(_ context.Context, head *evmtypes.Head) {
					n := uint(head.Number)
					if l, ok := logsA[n]; ok && slices.Contains(test.batch2, n) {
						chRawLogs2.TrySend(l)
					}
					if l, ok := logsB[n]; ok && slices.Contains(test.batch2, n) {
						chRawLogs2.TrySend(l)
					}
				}))

			defer func() { <-headsDone }()

			expectedA = newReceived(pickLogs(logsA, test.expectedFilteredA))
			expectedB := newReceived(pickLogs(logsB, test.expectedFilteredB))
			logListenerA.requireAllReceived(t, expectedA)
			logListenerB.requireAllReceived(t, expectedB)
			helper.requireBroadcastCount(len(test.expectedFilteredA) + len(test.expectedFilteredB))
		})`
$DIR/pkg/log/integration_test.go: `c.BlockBackfillDepth = ptr[uint32](backfillDepth)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.register(logListenerA, contractA, 1)`
$DIR/pkg/log/integration_test.go: `chRawLogs1.TrySend(l)`
$DIR/pkg/log/integration_test.go: `helper.requireBroadcastCount(len(test.batch1))`
$DIR/pkg/log/integration_test.go: `logListenerA.requireAllReceived(t, expectedA)`
$DIR/pkg/log/integration_test.go: `<-headsDone`
$DIR/pkg/log/integration_test.go: `helper.mockEth.EthClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(&evmtypes.Head{Number: int64(test.blockHeight2)}, nil).Once()`
$DIR/pkg/log/integration_test.go: `call.Run(func(args mock.Arguments) {
				// Validate that the ethereum.FilterQuery is specified correctly for the backfill that we expect
				fromBlock := args.Get(1).(ethereum.FilterQuery).FromBlock
				expected := big.NewInt(0)

				blockNumber := helper.lb.BackfillBlockNumber()
				if blockNumber.Valid && blockNumber.Int64 > int64(test.blockHeight2-backfillDepth) {
					expected = big.NewInt(blockNumber.Int64)
				} else if test.blockHeight2 > backfillDepth {
					expected = big.NewInt(int64(test.blockHeight2) - backfillDepth)
				}
				require.Equal(t, expected, fromBlock)
			})`
$DIR/pkg/log/integration_test.go: `expected = big.NewInt(blockNumber.Int64)`
$DIR/pkg/log/integration_test.go: `expected = big.NewInt(int64(test.blockHeight2) - backfillDepth)`
$DIR/pkg/log/integration_test.go: `helper.register(logListenerB, contractB, 1)`
$DIR/pkg/log/integration_test.go: `chRawLogs2.TrySend(l)`
$DIR/pkg/log/integration_test.go: `chRawLogs2.TrySend(l)`
$DIR/pkg/log/integration_test.go: `<-headsDone`
$DIR/pkg/log/integration_test.go: `expectedA = newReceived(pickLogs(logsA, test.expectedFilteredA))`
$DIR/pkg/log/integration_test.go: `logListenerA.requireAllReceived(t, expectedA)`
$DIR/pkg/log/integration_test.go: `logListenerB.requireAllReceived(t, expectedB)`
$DIR/pkg/log/integration_test.go: `helper.requireBroadcastCount(len(test.expectedFilteredA) + len(test.expectedFilteredB))`
$DIR/pkg/log/integration_test.go: `chCombined = lb.ExportedAppendLogChannel(chCombined, ch3)`
$DIR/pkg/log/integration_test.go: `ch1 <- log`
$DIR/pkg/log/integration_test.go: `ch2 <- log`
$DIR/pkg/log/integration_test.go: `ch3 <- log`
$DIR/pkg/log/integration_test.go: `expected = append(expected, logs3...)`
$DIR/pkg/log/integration_test.go: `i++`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `contract.On("ParseLog", log1).Return(flux_aggregator_wrapper.FluxAggregatorNewRound{}, nil)`
$DIR/pkg/log/integration_test.go: `contract.On("ParseLog", log2).Return(flux_aggregator_wrapper.FluxAggregatorAnswerUpdated{}, nil)`
$DIR/pkg/log/integration_test.go: `helper.register(logListener, contract, uint32(5))`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(log1)`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(log2)`
$DIR/pkg/log/integration_test.go: `<-headsDone`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.register(listenerA, contract, 1)`
$DIR/pkg/log/integration_test.go: `helper.register(listenerB, contract, 3)`
$DIR/pkg/log/integration_test.go: `helper.lb.OnNewLongestChain(ctx, x)`
$DIR/pkg/log/integration_test.go: `chRawLogs.TrySend(x)`
$DIR/pkg/log/integration_test.go: `time.Sleep(250 * time.Millisecond)`
$DIR/pkg/log/integration_test.go: `g.Eventually(func() []uint64 { return listenerA.getUniqueLogsBlockNumbers() }, testutils.WaitTimeout(t), time.Second).
		Should(gomega.Equal([]uint64{0, 1, 2, 1, 2, 3, 3}))`
$DIR/pkg/log/integration_test.go: `g.Eventually(func() []uint64 { return listenerB.getUniqueLogsBlockNumbers() }, testutils.WaitTimeout(t), time.Second).
		Should(gomega.Equal([]uint64{0, 1, 1, 2, 2}))`
$DIR/pkg/log/integration_test.go: `helper.unsubscribeAll()`
$DIR/pkg/log/integration_test.go: `helper.mockEth.EthClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(&evmtypes.Head{Number: blockHeight}, nil).Times(1)`
$DIR/pkg/log/integration_test.go: `helper.mockEth.EthClient.On("FilterLogs", mock.Anything, mock.Anything).Return(nil, nil).Times(1)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.registerWithTopics(listener1, contract, topics1, 1)`
$DIR/pkg/log/integration_test.go: `g.Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval).Should(gomega.Equal(int32(1)))`
$DIR/pkg/log/integration_test.go: `<-helper.chchRawLogs`
$DIR/pkg/log/integration_test.go: `helper.registerWithTopics(listener2, contract, topics2, 1)`
$DIR/pkg/log/integration_test.go: `g.Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval).Should(gomega.Equal(int32(2)))`
$DIR/pkg/log/integration_test.go: `testutils.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `ethClient.On("ConfiguredChainID").Return(big.NewInt(0)).Maybe()`
$DIR/pkg/log/integration_test.go: `ethClient.On("SubscribeFilterLogs", mock.Anything, mock.Anything, mock.Anything).
		Return(
			func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) ethereum.Subscription {
				sub := mockEth.NewSub(t)
				logsChCh <- testutils.NewRawSub(ch, sub.Err())
				return sub
			},
			func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) error {
				return nil
			},
		).
		Once()`
$DIR/pkg/log/integration_test.go: `logsChCh <- testutils.NewRawSub(ch, sub.Err())`
$DIR/pkg/log/integration_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).
		Return(&evmtypes.Head{Number: 1}, nil)`
$DIR/pkg/log/integration_test.go: `ethClient.On("FilterLogs", mock.Anything, mock.Anything).
		Return(nil, nil)`
$DIR/pkg/log/integration_test.go: `helper.start()`
$DIR/pkg/log/integration_test.go: `helper.register(listener1, contract1, 0)`
$DIR/pkg/log/integration_test.go: `helper.register(listener2, contract1, 0)`
$DIR/pkg/log/integration_test.go: `logs.TrySend(log)`
$DIR/pkg/log/integration_test.go: `gm.Eventually(func() bool {
		helper.lb.Pause()
		defer helper.lb.Resume()
		return helper.lb.LogsFromBlock(bh) == len(addr1SentLogs)
	}, 2*time.Second, 100*time.Millisecond).Should(gomega.BeTrue())`
$DIR/pkg/log/integration_test.go: `helper.lb.Pause()`
$DIR/pkg/log/integration_test.go: `helper.lb.OnNewLongestChain(testutils.Context(t), &evmtypes.Head{Number: 2})`
$DIR/pkg/log/integration_test.go: `gm.Eventually(func() bool {
		return len(listener1.getUniqueLogs()) == len(addr1SentLogs) && len(listener2.getUniqueLogs()) == len(addr1SentLogs)
	}, 2*time.Second, DBPollingInterval).Should(gomega.BeTrue())`
$DIR/pkg/log/integration_test.go: `.NewWithT(t)`
$DIR/pkg/log/integration_test.go: `.lb.AddDependents(2)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("A")`
$DIR/pkg/log/integration_test.go: `.register(listener, newMockContract(t), 1)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval)`
$DIR/pkg/log/integration_test.go: `.mockEth.SubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.Should(gomega.Equal(int32(0)))`
$DIR/pkg/log/integration_test.go: `.Equal(int32(0))`
$DIR/pkg/log/integration_test.go: `.lb.DependentReady()`
$DIR/pkg/log/integration_test.go: `.Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval)`
$DIR/pkg/log/integration_test.go: `.mockEth.SubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.Should(gomega.Equal(int32(0)))`
$DIR/pkg/log/integration_test.go: `.Equal(int32(0))`
$DIR/pkg/log/integration_test.go: `.lb.DependentReady()`
$DIR/pkg/log/integration_test.go: `.Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval)`
$DIR/pkg/log/integration_test.go: `.mockEth.SubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.Should(gomega.Equal(int32(1)))`
$DIR/pkg/log/integration_test.go: `.Equal(int32(1))`
$DIR/pkg/log/integration_test.go: `.unsubscribeAll()`
$DIR/pkg/log/integration_test.go: `.Consistently(func() int32 { return helper.mockEth.UnsubscribeCallCount() }, 1*time.Second, DBPollingInterval)`
$DIR/pkg/log/integration_test.go: `.mockEth.UnsubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.Equal(int32(1))`
$DIR/pkg/log/integration_test.go: `.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `.config.BlockBackfillDepth()`
$DIR/pkg/log/integration_test.go: `.Store(1)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("initial")`
$DIR/pkg/log/integration_test.go: `.register(listener, newMockContract(t), numConfirmations)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("")`
$DIR/pkg/log/integration_test.go: `.register(listener, newMockContract(t), 1)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.NewWithT(t)`
$DIR/pkg/log/integration_test.go: `.Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval)`
$DIR/pkg/log/integration_test.go: `.mockEth.SubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.Should(gomega.Equal(int32(1)))`
$DIR/pkg/log/integration_test.go: `.Equal(int32(1))`
$DIR/pkg/log/integration_test.go: `.NewWithT(t)`
$DIR/pkg/log/integration_test.go: `.Consistently(func() int32 { return helper.mockEth.UnsubscribeCallCount() }, 1*time.Second, DBPollingInterval)`
$DIR/pkg/log/integration_test.go: `.mockEth.UnsubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.Should(gomega.Equal(int32(0)))`
$DIR/pkg/log/integration_test.go: `.Equal(int32(0))`
$DIR/pkg/log/integration_test.go: `.unsubscribeAll()`
$DIR/pkg/log/integration_test.go: `.Store(2)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("last")`
$DIR/pkg/log/integration_test.go: `.register(listenerLast, newMockContract(t), 1)`
$DIR/pkg/log/integration_test.go: `.NewWithT(t)`
$DIR/pkg/log/integration_test.go: `.Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval)`
$DIR/pkg/log/integration_test.go: `.mockEth.SubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.Should(gomega.Equal(int32(2)))`
$DIR/pkg/log/integration_test.go: `.Equal(int32(2))`
$DIR/pkg/log/integration_test.go: `.NewWithT(t)`
$DIR/pkg/log/integration_test.go: `.Consistently(func() int32 { return helper.mockEth.UnsubscribeCallCount() }, 1*time.Second, DBPollingInterval)`
$DIR/pkg/log/integration_test.go: `.mockEth.UnsubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.Should(gomega.Equal(int32(1)))`
$DIR/pkg/log/integration_test.go: `.Equal(int32(1))`
$DIR/pkg/log/integration_test.go: `.Load()`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("one")`
$DIR/pkg/log/integration_test.go: `.register(listener, newMockContract(t), uint32(maxNumConfirmations))`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("two")`
$DIR/pkg/log/integration_test.go: `.register(listener2, newMockContract(t), uint32(2))`
$DIR/pkg/log/integration_test.go: `.config.BlockBackfillDepth()`
$DIR/pkg/log/integration_test.go: `.Add(1)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.lb.ReplayFromBlock(replayFrom, false)`
$DIR/pkg/log/integration_test.go: `.mockEth.UnsubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(testutils.NewAddress(), nil)`
$DIR/pkg/log/integration_test.go: `.NewAddress()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(3, contract.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(7, contract.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener")`
$DIR/pkg/log/integration_test.go: `.register(listener, contract, 2)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.lb.ReplayFromBlock(2, false)`
$DIR/pkg/log/integration_test.go: `.Slice(10, 11)`
$DIR/pkg/log/integration_test.go: `.lb.ReplayFromBlock(2, false)`
$DIR/pkg/log/integration_test.go: `.Slice(11, 12)`
$DIR/pkg/log/integration_test.go: `.lb.ReplayFromBlock(2, true)`
$DIR/pkg/log/integration_test.go: `.Slice(12, 13)`
$DIR/pkg/log/integration_test.go: `.mockEth.UnsubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(log1Block, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(log2Block, contract2.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.Run("pool two logs from subscription, then shut down", func(t *testing.T) {
		helper := newBroadcasterHelper(t, 0, 1, logs, func(c *toml.EVMConfig) {
			c.FinalityDepth = ptr[uint32](confs)
		})
		ctx := testutils.Context(t)
		orm := log.NewORM(helper.db, *testutils.FixtureChainID)

		listener := helper.newLogListenerWithJob("one")
		listener.SkipMarkingConsumed(true)
		listener2 := helper.newLogListenerWithJob("two")
		listener2.SkipMarkingConsumed(true)
		expBlock := int64(log1.BlockNumber)
		helper.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(0, 2), orm, &expBlock, func() {
			chRawLogs := <-helper.chchRawLogs
			chRawLogs.TrySend(log1)
			chRawLogs.TrySend(log2)
		})
		// Pool min block in DB and neither listener received a broadcast
		blockNum, err := orm.GetPendingMinBlock(ctx)
		require.NoError(t, err)
		require.NotNil(t, blockNum)
		require.Equal(t, int64(log1.BlockNumber), *blockNum)
		require.Empty(t, listener.getUniqueLogs())
		require.Empty(t, listener2.getUniqueLogs())
		helper.requireBroadcastCount(0)
	})`
$DIR/pkg/log/integration_test.go: `.Context(t)`
$DIR/pkg/log/integration_test.go: `.NewORM(helper.db, *testutils.FixtureChainID)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("one")`
$DIR/pkg/log/integration_test.go: `.SkipMarkingConsumed(true)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("two")`
$DIR/pkg/log/integration_test.go: `.SkipMarkingConsumed(true)`
$DIR/pkg/log/integration_test.go: `.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(0, 2), orm, &expBlock, func() {
			chRawLogs := <-helper.chchRawLogs
			chRawLogs.TrySend(log1)
			chRawLogs.TrySend(log2)
		})`
$DIR/pkg/log/integration_test.go: `.Slice(0, 2)`
$DIR/pkg/log/integration_test.go: `.TrySend(log1)`
$DIR/pkg/log/integration_test.go: `.TrySend(log2)`
$DIR/pkg/log/integration_test.go: `.GetPendingMinBlock(ctx)`
$DIR/pkg/log/integration_test.go: `.requireBroadcastCount(0)`
$DIR/pkg/log/integration_test.go: `.Run("backfill pool with both, then broadcast one, but don't consume", func(t *testing.T) {
		helper := newBroadcasterHelper(t, 2, 1, logs, func(c *toml.EVMConfig) {
			c.FinalityDepth = ptr[uint32](confs)
		})
		ctx := testutils.Context(t)
		orm := log.NewORM(helper.db, *testutils.FixtureChainID)
		contract1.On("ParseLog", log1).Return(flux_aggregator_wrapper.FluxAggregatorNewRound{}, nil)
		contract2.On("ParseLog", log2).Return(flux_aggregator_wrapper.FluxAggregatorAnswerUpdated{}, nil)

		listener := helper.newLogListenerWithJob("one")
		listener.SkipMarkingConsumed(true)
		listener2 := helper.newLogListenerWithJob("two")
		listener2.SkipMarkingConsumed(true)
		expBlock := int64(log2.BlockNumber)
		helper.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(2, 5), orm, &expBlock, nil)

		// Pool min block in DB and one listener received but didn't consume
		blockNum, err := orm.GetPendingMinBlock(ctx)
		require.NoError(t, err)
		require.NotNil(t, blockNum)
		require.Equal(t, int64(log2.BlockNumber), *blockNum)
		require.NotEmpty(t, listener.getUniqueLogs())
		require.Empty(t, listener2.getUniqueLogs())
		c, err := orm.WasBroadcastConsumed(ctx, log1.BlockHash, log1.Index, listener.JobID())
		require.NoError(t, err)
		require.False(t, c)
	})`
$DIR/pkg/log/integration_test.go: `.Context(t)`
$DIR/pkg/log/integration_test.go: `.NewORM(helper.db, *testutils.FixtureChainID)`
$DIR/pkg/log/integration_test.go: `.On("ParseLog", log1)`
$DIR/pkg/log/integration_test.go: `.Return(flux_aggregator_wrapper.FluxAggregatorNewRound{}, nil)`
$DIR/pkg/log/integration_test.go: `.On("ParseLog", log2)`
$DIR/pkg/log/integration_test.go: `.Return(flux_aggregator_wrapper.FluxAggregatorAnswerUpdated{}, nil)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("one")`
$DIR/pkg/log/integration_test.go: `.SkipMarkingConsumed(true)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("two")`
$DIR/pkg/log/integration_test.go: `.SkipMarkingConsumed(true)`
$DIR/pkg/log/integration_test.go: `.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(2, 5), orm, &expBlock, nil)`
$DIR/pkg/log/integration_test.go: `.Slice(2, 5)`
$DIR/pkg/log/integration_test.go: `.GetPendingMinBlock(ctx)`
$DIR/pkg/log/integration_test.go: `.WasBroadcastConsumed(ctx, log1.BlockHash, log1.Index, listener.JobID())`
$DIR/pkg/log/integration_test.go: `.JobID()`
$DIR/pkg/log/integration_test.go: `.Run("backfill pool and broadcast two, but only consume one", func(t *testing.T) {
		helper := newBroadcasterHelper(t, 4, 1, logs, func(c *toml.EVMConfig) {
			c.FinalityDepth = ptr[uint32](confs)
		})
		ctx := testutils.Context(t)
		orm := log.NewORM(helper.db, *testutils.FixtureChainID)

		listener := helper.newLogListenerWithJob("one")
		listener2 := helper.newLogListenerWithJob("two")
		listener2.SkipMarkingConsumed(true)
		helper.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(5, 8), orm, nil, nil)

		// Pool empty and one consumed but other didn't
		blockNum, err := orm.GetPendingMinBlock(ctx)
		require.NoError(t, err)
		require.Nil(t, blockNum)
		require.NotEmpty(t, listener.getUniqueLogs())
		require.NotEmpty(t, listener2.getUniqueLogs())
		c, err := orm.WasBroadcastConsumed(ctx, log1.BlockHash, log1.Index, listener.JobID())
		require.NoError(t, err)
		require.True(t, c)
		c, err = orm.WasBroadcastConsumed(ctx, log2.BlockHash, log2.Index, listener2.JobID())
		require.NoError(t, err)
		require.False(t, c)
	})`
$DIR/pkg/log/integration_test.go: `.Context(t)`
$DIR/pkg/log/integration_test.go: `.NewORM(helper.db, *testutils.FixtureChainID)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("one")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("two")`
$DIR/pkg/log/integration_test.go: `.SkipMarkingConsumed(true)`
$DIR/pkg/log/integration_test.go: `.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(5, 8), orm, nil, nil)`
$DIR/pkg/log/integration_test.go: `.Slice(5, 8)`
$DIR/pkg/log/integration_test.go: `.GetPendingMinBlock(ctx)`
$DIR/pkg/log/integration_test.go: `.WasBroadcastConsumed(ctx, log1.BlockHash, log1.Index, listener.JobID())`
$DIR/pkg/log/integration_test.go: `.JobID()`
$DIR/pkg/log/integration_test.go: `.WasBroadcastConsumed(ctx, log2.BlockHash, log2.Index, listener2.JobID())`
$DIR/pkg/log/integration_test.go: `.JobID()`
$DIR/pkg/log/integration_test.go: `.Context(t)`
$DIR/pkg/log/integration_test.go: `.NewORM(helper.db, *testutils.FixtureChainID)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("one")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("two")`
$DIR/pkg/log/integration_test.go: `.simulateHeads(t, listener, listener2, contract1, contract2, confs, blocks.Slice(8, 9), orm, nil, nil)`
$DIR/pkg/log/integration_test.go: `.Slice(8, 9)`
$DIR/pkg/log/integration_test.go: `.GetPendingMinBlock(ctx)`
$DIR/pkg/log/integration_test.go: `.WasBroadcastConsumed(ctx, log2.BlockHash, log2.Index, listener2.JobID())`
$DIR/pkg/log/integration_test.go: `.JobID()`
$DIR/pkg/log/integration_test.go: `.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("one")`
$DIR/pkg/log/integration_test.go: `.register(listener, newMockContract(t), uint32(10))`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("two")`
$DIR/pkg/log/integration_test.go: `.register(listener2, newMockContract(t), uint32(2))`
$DIR/pkg/log/integration_test.go: `.Store(1)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.mockEth.UnsubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `.config.BlockBackfillDepth()`
$DIR/pkg/log/integration_test.go: `.Test(t)`
$DIR/pkg/log/integration_test.go: `.Add(1)`
$DIR/pkg/log/integration_test.go: `.Infof("Log Batch: --------- times %v - %v, %v", times, fromBlock, toBlock)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("initial")`
$DIR/pkg/log/integration_test.go: `.register(listener, newMockContract(t), numConfirmations)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.unsubscribeAll()`
$DIR/pkg/log/integration_test.go: `.mockEth.UnsubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `.NewWithT(t)`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(testutils.NewAddress(), nil)`
$DIR/pkg/log/integration_test.go: `.NewAddress()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(0, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.Test(t)`
$DIR/pkg/log/integration_test.go: `.Add(1)`
$DIR/pkg/log/integration_test.go: `.Warnf("Log Batch: --------- times %v - %v, %v", times, fromBlock, toBlock)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("initial")`
$DIR/pkg/log/integration_test.go: `.register(listener, newMockContract(t), 1)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.Eventually(func() int64 { return backfillCount.Load() }, testutils.WaitTimeout(t), time.Second)`
$DIR/pkg/log/integration_test.go: `.Load()`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.Should(gomega.Equal(int64(expectedBatches)))`
$DIR/pkg/log/integration_test.go: `.Equal(int64(expectedBatches))`
$DIR/pkg/log/integration_test.go: `.unsubscribeAll()`
$DIR/pkg/log/integration_test.go: `.Eventually(func() int32 { return helper.mockEth.UnsubscribeCallCount() }, testutils.WaitTimeout(t), time.Second)`
$DIR/pkg/log/integration_test.go: `.mockEth.UnsubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.BeNumerically(">=", int32(1))`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(testutils.NewAddress(), nil)`
$DIR/pkg/log/integration_test.go: `.NewAddress()`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(testutils.NewAddress(), nil)`
$DIR/pkg/log/integration_test.go: `.NewAddress()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(1, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(2, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(3, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(4, contract2.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(5, contract2.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(6, contract2.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 1")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 2")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 3")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 4")`
$DIR/pkg/log/integration_test.go: `.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `.register(listener2, contract1, 1)`
$DIR/pkg/log/integration_test.go: `.register(listener3, contract2, 1)`
$DIR/pkg/log/integration_test.go: `.register(listener4, contract2, 1)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.Slice(0, 10)`
$DIR/pkg/log/integration_test.go: `.unsubscribeAll()`
$DIR/pkg/log/integration_test.go: `.TrySend(log)`
$DIR/pkg/log/integration_test.go: `.TrySend(log)`
$DIR/pkg/log/integration_test.go: `.requireBroadcastCount(12)`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(testutils.NewAddress(), nil)`
$DIR/pkg/log/integration_test.go: `.NewAddress()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(1, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(2, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(3, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 1")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 2")`
$DIR/pkg/log/integration_test.go: `.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `.register(listener2, contract1, 8)`
$DIR/pkg/log/integration_test.go: `.Slice(0, 10)`
$DIR/pkg/log/integration_test.go: `.TrySend(log)`
$DIR/pkg/log/integration_test.go: `.requireBroadcastCount(5)`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.received.getLogs()`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.received.getLogs()`
$DIR/pkg/log/integration_test.go: `.received.logsOnBlocks()`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(testutils.NewAddress(), nil)`
$DIR/pkg/log/integration_test.go: `.NewAddress()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(1, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(2, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(3, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 1")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 2")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 3")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 4")`
$DIR/pkg/log/integration_test.go: `.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `.register(listener2, contract1, 3)`
$DIR/pkg/log/integration_test.go: `.Slice(0, 6)`
$DIR/pkg/log/integration_test.go: `.TrySend(log)`
$DIR/pkg/log/integration_test.go: `.requireBroadcastCount(6)`
$DIR/pkg/log/integration_test.go: `.register(listener3, contract1, 1)`
$DIR/pkg/log/integration_test.go: `.Slice(6, 9)`
$DIR/pkg/log/integration_test.go: `.requireBroadcastCount(8)`
$DIR/pkg/log/integration_test.go: `.register(listener4, contract1, 1)`
$DIR/pkg/log/integration_test.go: `.Slice(9, 12)`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(testutils.NewAddress(), nil)`
$DIR/pkg/log/integration_test.go: `.NewAddress()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(1, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(2, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(3, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 1")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 2")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 3")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 4")`
$DIR/pkg/log/integration_test.go: `.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `.register(listener2, contract1, 3)`
$DIR/pkg/log/integration_test.go: `.Slice(0, 6)`
$DIR/pkg/log/integration_test.go: `.TrySend(log)`
$DIR/pkg/log/integration_test.go: `.requireBroadcastCount(6)`
$DIR/pkg/log/integration_test.go: `.register(listener3, contract1, 1)`
$DIR/pkg/log/integration_test.go: `.Slice(7, 9)`
$DIR/pkg/log/integration_test.go: `.requireBroadcastCount(9)`
$DIR/pkg/log/integration_test.go: `.register(listener4, contract1, 1)`
$DIR/pkg/log/integration_test.go: `.Slice(10, 12)`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(testutils.NewAddress(), nil)`
$DIR/pkg/log/integration_test.go: `.NewAddress()`
$DIR/pkg/log/integration_test.go: `.Topic()`
$DIR/pkg/log/integration_test.go: `.NewHash()`
$DIR/pkg/log/integration_test.go: `.NewHash()`
$DIR/pkg/log/integration_test.go: `.NewHash()`
$DIR/pkg/log/integration_test.go: `.NewHash()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumWithTopics(1, 0, contract1.Address(), []common.Hash{topic, field1Value1, field2Value1})`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumWithTopics(1, 1, contract1.Address(), []common.Hash{topic, field1Value2, field2Value2})`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumWithTopics(2, 0, contract1.Address(), []common.Hash{topic, utils.NewHash(), field2Value2})`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.NewHash()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumWithTopics(2, 1, contract1.Address(), []common.Hash{topic, field1Value2, utils.NewHash()})`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.NewHash()`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 0")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 1")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 2")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 3")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 4")`
$DIR/pkg/log/integration_test.go: `.registerWithTopicValues(listener0, contract1, 1,
		map[common.Hash][][]log.Topic{
			topic: {}, // no filters, so all values allowed
		},
	)`
$DIR/pkg/log/integration_test.go: `.registerWithTopicValues(listener1, contract1, 1,
		map[common.Hash][][]log.Topic{
			topic: {{} /**/, {}}, // two empty filters, so all values allowed
		},
	)`
$DIR/pkg/log/integration_test.go: `.registerWithTopicValues(listener2, contract1, 1,
		map[common.Hash][][]log.Topic{
			topic: {
				{log.Topic(field1Value1), log.Topic(field1Value2)} /**/, {log.Topic(field2Value1), log.Topic(field2Value2)}, // two values for each field allowed
			},
		},
	)`
$DIR/pkg/log/integration_test.go: `.Topic(field1Value1)`
$DIR/pkg/log/integration_test.go: `.Topic(field1Value2)`
$DIR/pkg/log/integration_test.go: `.Topic(field2Value1)`
$DIR/pkg/log/integration_test.go: `.Topic(field2Value2)`
$DIR/pkg/log/integration_test.go: `.registerWithTopicValues(listener3, contract1, 1,
		map[common.Hash][][]log.Topic{
			topic: {
				{log.Topic(field1Value1), log.Topic(field1Value2)} /**/, {}, // two values allowed for field 1, and any values for field 2
			},
		},
	)`
$DIR/pkg/log/integration_test.go: `.Topic(field1Value1)`
$DIR/pkg/log/integration_test.go: `.Topic(field1Value2)`
$DIR/pkg/log/integration_test.go: `.registerWithTopicValues(listener4, contract1, 1,
		map[common.Hash][][]log.Topic{
			topic: {
				{log.Topic(field1Value1)} /**/, {log.Topic(field2Value1)}, // some values allowed
			},
		},
	)`
$DIR/pkg/log/integration_test.go: `.Topic(field1Value1)`
$DIR/pkg/log/integration_test.go: `.Topic(field2Value1)`
$DIR/pkg/log/integration_test.go: `.Slice(0, 6)`
$DIR/pkg/log/integration_test.go: `.TrySend(log)`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(testutils.NewAddress(), nil)`
$DIR/pkg/log/integration_test.go: `.NewAddress()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(1, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(2, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(3, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumWithIndex(3, 1, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 1")`
$DIR/pkg/log/integration_test.go: `.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `.TrySend(addr1SentLogs[0])`
$DIR/pkg/log/integration_test.go: `.TrySend(addr1SentLogs[1])`
$DIR/pkg/log/integration_test.go: `.TrySend(addr1SentLogs[2])`
$DIR/pkg/log/integration_test.go: `.Slice(0, 4)`
$DIR/pkg/log/integration_test.go: `.TrySend(addr1SentLogs[3])`
$DIR/pkg/log/integration_test.go: `.Slice(4, 9)`
$DIR/pkg/log/integration_test.go: `.requireBroadcastCount(4)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(testutils.NewAddress(), nil)`
$DIR/pkg/log/integration_test.go: `.NewAddress()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(1, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(2, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(3, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 1")`
$DIR/pkg/log/integration_test.go: `.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `.TrySend(log)`
$DIR/pkg/log/integration_test.go: `.Slice(0, 10)`
$DIR/pkg/log/integration_test.go: `.requireBroadcastCount(3)`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.received.getLogs()`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(testutils.NewAddress(), nil)`
$DIR/pkg/log/integration_test.go: `.NewAddress()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(1, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(2, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(3, contract1.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listener 1")`
$DIR/pkg/log/integration_test.go: `.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `.Slice(0, 7)`
$DIR/pkg/log/integration_test.go: `.TrySend(log)`
$DIR/pkg/log/integration_test.go: `.Slice(7, 9)`
$DIR/pkg/log/integration_test.go: `.requireBroadcastCount(3)`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.received.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.received.getLogs()`
$DIR/pkg/log/integration_test.go: `.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `.NewClient(t)`
$DIR/pkg/log/integration_test.go: `.On("ConfiguredChainID", mock.Anything)`
$DIR/pkg/log/integration_test.go: `.Return(testutils.FixtureChainID)`
$DIR/pkg/log/integration_test.go: `.On("SubscribeFilterLogs", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/log/integration_test.go: `.
		Return(
			func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) ethereum.Subscription {
				defer close(chStarted)
				sub := mockEth.NewSub(t)
				chchRawLogs <- testutils.NewRawSub(ch, sub.Err())
				return sub
			},
			func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) error {
				return nil
			},
		)`
$DIR/pkg/log/integration_test.go: `.NewSub(t)`
$DIR/pkg/log/integration_test.go: `.NewRawSub(ch, sub.Err())`
$DIR/pkg/log/integration_test.go: `.Err()`
$DIR/pkg/log/integration_test.go: `.
		Once()`
$DIR/pkg/log/integration_test.go: `.On("SubscribeFilterLogs", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/log/integration_test.go: `.
		Return(
			func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) ethereum.Subscription {
				sub := mockEth.NewSub(t)
				chchRawLogs <- testutils.NewRawSub(ch, sub.Err())
				return sub
			},
			func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) error {
				return nil
			},
		)`
$DIR/pkg/log/integration_test.go: `.NewSub(t)`
$DIR/pkg/log/integration_test.go: `.NewRawSub(ch, sub.Err())`
$DIR/pkg/log/integration_test.go: `.Err()`
$DIR/pkg/log/integration_test.go: `.
		Times(3)`
$DIR/pkg/log/integration_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/log/integration_test.go: `.
		Return(&evmtypes.Head{Number: blockHeight}, nil)`
$DIR/pkg/log/integration_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/log/integration_test.go: `.
		Run(func(args mock.Arguments) {
			query := args.Get(1).(ethereum.FilterQuery)
			require.Equal(t, big.NewInt(expectedBlock), query.FromBlock)
			require.Contains(t, query.Addresses, contract0.Address())
			require.Len(t, query.Addresses, 1)
		})`
$DIR/pkg/log/integration_test.go: `.Get(1)`
$DIR/pkg/log/integration_test.go: `.
		Return(nil, nil)`
$DIR/pkg/log/integration_test.go: `.
		Times(backfillTimes)`
$DIR/pkg/log/integration_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/log/integration_test.go: `.
		Run(func(args mock.Arguments) {
			query := args.Get(1).(ethereum.FilterQuery)
			require.Equal(t, big.NewInt(expectedBlock), query.FromBlock)
			require.Contains(t, query.Addresses, contract0.Address())
			require.Contains(t, query.Addresses, contract1.Address())
			require.Len(t, query.Addresses, 2)
		})`
$DIR/pkg/log/integration_test.go: `.Get(1)`
$DIR/pkg/log/integration_test.go: `.
		Return(nil, nil)`
$DIR/pkg/log/integration_test.go: `.
		Once()`
$DIR/pkg/log/integration_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/log/integration_test.go: `.
		Run(func(args mock.Arguments) {
			query := args.Get(1).(ethereum.FilterQuery)
			require.Equal(t, big.NewInt(expectedBlock), query.FromBlock)
			require.Contains(t, query.Addresses, contract0.Address())
			require.Contains(t, query.Addresses, contract1.Address())
			require.Contains(t, query.Addresses, contract2.Address())
			require.Len(t, query.Addresses, 3)
		})`
$DIR/pkg/log/integration_test.go: `.Get(1)`
$DIR/pkg/log/integration_test.go: `.
		Return(nil, nil)`
$DIR/pkg/log/integration_test.go: `.
		Once()`
$DIR/pkg/log/integration_test.go: `.lb.AddDependents(1)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("0")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("1")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("2")`
$DIR/pkg/log/integration_test.go: `.register(listener0, contract0, 1)`
$DIR/pkg/log/integration_test.go: `.unsubscribeAll()`
$DIR/pkg/log/integration_test.go: `.lb.DependentReady()`
$DIR/pkg/log/integration_test.go: `.After(testutils.WaitTimeout(t))`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.After(testutils.WaitTimeout(t))`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.register(listener1, contract1, 1)`
$DIR/pkg/log/integration_test.go: `.After(testutils.WaitTimeout(t))`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.register(listener2, contract2, 1)`
$DIR/pkg/log/integration_test.go: `.After(testutils.WaitTimeout(t))`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.lb.ReplayFromBlock(125, false)`
$DIR/pkg/log/integration_test.go: `.After(testutils.WaitTimeout(t))`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.AssertExpectations(t)`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.HexToAddress("0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")`
$DIR/pkg/log/integration_test.go: `.HexToAddress("0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb")`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumWithIndex(uint64(n), 0, addrA)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumWithIndex(uint64(n), 1, addrB)`
$DIR/pkg/log/integration_test.go: `.Run(test.name, func(t *testing.T) {
			const backfillDepth = 5
			helper := newBroadcasterHelper(t, int64(test.blockHeight1), 2, nil, func(c *toml.EVMConfig) {
				// something other than default
				c.BlockBackfillDepth = ptr[uint32](backfillDepth)
			})

			helper.start()
			defer helper.stop()

			logListenerA := helper.newLogListenerWithJob("logListenerA")
			logListenerB := helper.newLogListenerWithJob("logListenerB")

			contractA, err := flux_aggregator_wrapper.NewFluxAggregator(addrA, nil)
			require.NoError(t, err)
			contractB, err := flux_aggregator_wrapper.NewFluxAggregator(addrB, nil)
			require.NoError(t, err)

			// Register listener A
			helper.register(logListenerA, contractA, 1)

			// Send initial logs
			chRawLogs1 := <-helper.chchRawLogs
			headsDone := simulateIncomingHeads(t, blocks.Slice(test.blockHeight1, test.blockHeight2+2),
				helper.lb, headTrackableFunc(func(_ context.Context, head *evmtypes.Head) {
					n := uint(head.Number)
					if l, ok := logsA[n]; ok && slices.Contains(test.batch1, n) {
						chRawLogs1.TrySend(l)
					}
				}))

			helper.requireBroadcastCount(len(test.batch1))
			expectedA := newReceived(pickLogs(logsA, test.batch1))
			logListenerA.requireAllReceived(t, expectedA)

			<-headsDone
			helper.mockEth.EthClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(&evmtypes.Head{Number: int64(test.blockHeight2)}, nil).Once()

			combinedLogs := append(pickLogs(logsA, test.backfillableLogs), pickLogs(logsB, test.backfillableLogs)...)
			call := helper.mockEth.EthClient.On("FilterLogs", mock.Anything, mock.Anything).Return(combinedLogs, nil).Once()
			call.Run(func(args mock.Arguments) {
				// Validate that the ethereum.FilterQuery is specified correctly for the backfill that we expect
				fromBlock := args.Get(1).(ethereum.FilterQuery).FromBlock
				expected := big.NewInt(0)

				blockNumber := helper.lb.BackfillBlockNumber()
				if blockNumber.Valid && blockNumber.Int64 > int64(test.blockHeight2-backfillDepth) {
					expected = big.NewInt(blockNumber.Int64)
				} else if test.blockHeight2 > backfillDepth {
					expected = big.NewInt(int64(test.blockHeight2) - backfillDepth)
				}
				require.Equal(t, expected, fromBlock)
			})

			// Register listener B (triggers re-subscription)
			helper.register(logListenerB, contractB, 1)

			// Send second batch of new logs
			chRawLogs2 := <-helper.chchRawLogs
			headsDone = simulateIncomingHeads(t, blocks.Slice(test.blockHeight2, -1),
				helper.lb, headTrackableFunc(func(_ context.Context, head *evmtypes.Head) {
					n := uint(head.Number)
					if l, ok := logsA[n]; ok && slices.Contains(test.batch2, n) {
						chRawLogs2.TrySend(l)
					}
					if l, ok := logsB[n]; ok && slices.Contains(test.batch2, n) {
						chRawLogs2.TrySend(l)
					}
				}))

			defer func() { <-headsDone }()

			expectedA = newReceived(pickLogs(logsA, test.expectedFilteredA))
			expectedB := newReceived(pickLogs(logsB, test.expectedFilteredB))
			logListenerA.requireAllReceived(t, expectedA)
			logListenerB.requireAllReceived(t, expectedB)
			helper.requireBroadcastCount(len(test.expectedFilteredA) + len(test.expectedFilteredB))
		})`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("logListenerA")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("logListenerB")`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(addrA, nil)`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(addrB, nil)`
$DIR/pkg/log/integration_test.go: `.register(logListenerA, contractA, 1)`
$DIR/pkg/log/integration_test.go: `.Slice(test.blockHeight1, test.blockHeight2+2)`
$DIR/pkg/log/integration_test.go: `.Contains(test.batch1, n)`
$DIR/pkg/log/integration_test.go: `.TrySend(l)`
$DIR/pkg/log/integration_test.go: `.requireBroadcastCount(len(test.batch1))`
$DIR/pkg/log/integration_test.go: `.requireAllReceived(t, expectedA)`
$DIR/pkg/log/integration_test.go: `.mockEth.EthClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/log/integration_test.go: `.Return(&evmtypes.Head{Number: int64(test.blockHeight2)}, nil)`
$DIR/pkg/log/integration_test.go: `.Once()`
$DIR/pkg/log/integration_test.go: `.mockEth.EthClient.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/log/integration_test.go: `.Return(combinedLogs, nil)`
$DIR/pkg/log/integration_test.go: `.Once()`
$DIR/pkg/log/integration_test.go: `.Run(func(args mock.Arguments) {
				// Validate that the ethereum.FilterQuery is specified correctly for the backfill that we expect
				fromBlock := args.Get(1).(ethereum.FilterQuery).FromBlock
				expected := big.NewInt(0)

				blockNumber := helper.lb.BackfillBlockNumber()
				if blockNumber.Valid && blockNumber.Int64 > int64(test.blockHeight2-backfillDepth) {
					expected = big.NewInt(blockNumber.Int64)
				} else if test.blockHeight2 > backfillDepth {
					expected = big.NewInt(int64(test.blockHeight2) - backfillDepth)
				}
				require.Equal(t, expected, fromBlock)
			})`
$DIR/pkg/log/integration_test.go: `.Get(1)`
$DIR/pkg/log/integration_test.go: `.NewInt(0)`
$DIR/pkg/log/integration_test.go: `.lb.BackfillBlockNumber()`
$DIR/pkg/log/integration_test.go: `.NewInt(blockNumber.Int64)`
$DIR/pkg/log/integration_test.go: `.NewInt(int64(test.blockHeight2) - backfillDepth)`
$DIR/pkg/log/integration_test.go: `.register(logListenerB, contractB, 1)`
$DIR/pkg/log/integration_test.go: `.Slice(test.blockHeight2, -1)`
$DIR/pkg/log/integration_test.go: `.Contains(test.batch2, n)`
$DIR/pkg/log/integration_test.go: `.TrySend(l)`
$DIR/pkg/log/integration_test.go: `.Contains(test.batch2, n)`
$DIR/pkg/log/integration_test.go: `.TrySend(l)`
$DIR/pkg/log/integration_test.go: `.requireAllReceived(t, expectedA)`
$DIR/pkg/log/integration_test.go: `.requireAllReceived(t, expectedB)`
$DIR/pkg/log/integration_test.go: `.requireBroadcastCount(len(test.expectedFilteredA) + len(test.expectedFilteredB))`
$DIR/pkg/log/integration_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/log/integration_test.go: `.RunHealthy(t, mailboxtest.NewMonitor(t))`
$DIR/pkg/log/integration_test.go: `.NewMonitor(t)`
$DIR/pkg/log/integration_test.go: `.NewBroadcaster(nil, ethClient, nil, logger.Test(t), nil, mailMon)`
$DIR/pkg/log/integration_test.go: `.Test(t)`
$DIR/pkg/log/integration_test.go: `.ExportedAppendLogChannel(ch1, ch2)`
$DIR/pkg/log/integration_test.go: `.ExportedAppendLogChannel(chCombined, ch3)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("logListener")`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(0, contract.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(1, contract.Address())`
$DIR/pkg/log/integration_test.go: `.Address()`
$DIR/pkg/log/integration_test.go: `.On("ParseLog", log1)`
$DIR/pkg/log/integration_test.go: `.Return(flux_aggregator_wrapper.FluxAggregatorNewRound{}, nil)`
$DIR/pkg/log/integration_test.go: `.On("ParseLog", log2)`
$DIR/pkg/log/integration_test.go: `.Return(flux_aggregator_wrapper.FluxAggregatorAnswerUpdated{}, nil)`
$DIR/pkg/log/integration_test.go: `.register(logListener, contract, uint32(5))`
$DIR/pkg/log/integration_test.go: `.Slice(3, 20)`
$DIR/pkg/log/integration_test.go: `.TrySend(log1)`
$DIR/pkg/log/integration_test.go: `.TrySend(log2)`
$DIR/pkg/log/integration_test.go: `.NewWithT(t)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.ForkAt(t, 1, 5)`
$DIR/pkg/log/integration_test.go: `.NewAddress()`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(0, addr)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(1, addr)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(2, addr)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumRemoved(1, addr)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumRemoved(2, addr)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(1, addr)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNum(2, addr)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumWithIndex(3, 0, addr)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumWithIndex(3, 1, addr)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumRemoved(1, addr)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumRemoved(2, addr)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumWithIndexRemoved(3, 0, addr)`
$DIR/pkg/log/integration_test.go: `.LogOnBlockNumWithIndexRemoved(3, 1, addr)`
$DIR/pkg/log/integration_test.go: `.Head(0)`
$DIR/pkg/log/integration_test.go: `.Head(2)`
$DIR/pkg/log/integration_test.go: `.Head(3)`
$DIR/pkg/log/integration_test.go: `.Head(1)`
$DIR/pkg/log/integration_test.go: `.Head(2)`
$DIR/pkg/log/integration_test.go: `.Head(3)`
$DIR/pkg/log/integration_test.go: `.Head(4)`
$DIR/pkg/log/integration_test.go: `.Head(4)`
$DIR/pkg/log/integration_test.go: `.Head(5)`
$DIR/pkg/log/integration_test.go: `.Head(6)`
$DIR/pkg/log/integration_test.go: `.Head(7)`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(addr, nil)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listenerA")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("listenerB")`
$DIR/pkg/log/integration_test.go: `.register(listenerA, contract, 1)`
$DIR/pkg/log/integration_test.go: `.register(listenerB, contract, 3)`
$DIR/pkg/log/integration_test.go: `.Context(t)`
$DIR/pkg/log/integration_test.go: `.lb.OnNewLongestChain(ctx, x)`
$DIR/pkg/log/integration_test.go: `.TrySend(x)`
$DIR/pkg/log/integration_test.go: `.Sleep(250 * time.Millisecond)`
$DIR/pkg/log/integration_test.go: `.Eventually(func() []uint64 { return listenerA.getUniqueLogsBlockNumbers() }, testutils.WaitTimeout(t), time.Second)`
$DIR/pkg/log/integration_test.go: `.getUniqueLogsBlockNumbers()`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.
		Should(gomega.Equal([]uint64{0, 1, 2, 1, 2, 3, 3}))`
$DIR/pkg/log/integration_test.go: `.Equal([]uint64{0, 1, 2, 1, 2, 3, 3})`
$DIR/pkg/log/integration_test.go: `.Eventually(func() []uint64 { return listenerB.getUniqueLogsBlockNumbers() }, testutils.WaitTimeout(t), time.Second)`
$DIR/pkg/log/integration_test.go: `.getUniqueLogsBlockNumbers()`
$DIR/pkg/log/integration_test.go: `.WaitTimeout(t)`
$DIR/pkg/log/integration_test.go: `.
		Should(gomega.Equal([]uint64{0, 1, 1, 2, 2}))`
$DIR/pkg/log/integration_test.go: `.Equal([]uint64{0, 1, 1, 2, 2})`
$DIR/pkg/log/integration_test.go: `.unsubscribeAll()`
$DIR/pkg/log/integration_test.go: `.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.NewWithT(t)`
$DIR/pkg/log/integration_test.go: `.mockEth.EthClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/log/integration_test.go: `.Return(&evmtypes.Head{Number: blockHeight}, nil)`
$DIR/pkg/log/integration_test.go: `.Times(1)`
$DIR/pkg/log/integration_test.go: `.mockEth.EthClient.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/log/integration_test.go: `.Return(nil, nil)`
$DIR/pkg/log/integration_test.go: `.Times(1)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.NewAddress()`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(addr1, nil)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("1")`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("2")`
$DIR/pkg/log/integration_test.go: `.registerWithTopics(listener1, contract, topics1, 1)`
$DIR/pkg/log/integration_test.go: `.Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval)`
$DIR/pkg/log/integration_test.go: `.mockEth.SubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.Should(gomega.Equal(int32(1)))`
$DIR/pkg/log/integration_test.go: `.Equal(int32(1))`
$DIR/pkg/log/integration_test.go: `.registerWithTopics(listener2, contract, topics2, 1)`
$DIR/pkg/log/integration_test.go: `.Consistently(func() int32 { return helper.mockEth.SubscribeCallCount() }, 1*time.Second, DBPollingInterval)`
$DIR/pkg/log/integration_test.go: `.mockEth.SubscribeCallCount()`
$DIR/pkg/log/integration_test.go: `.Should(gomega.Equal(int32(2)))`
$DIR/pkg/log/integration_test.go: `.Equal(int32(2))`
$DIR/pkg/log/integration_test.go: `.SkipShortDB(t)`
$DIR/pkg/log/integration_test.go: `.NewWithT(t)`
$DIR/pkg/log/integration_test.go: `.NewClient(t)`
$DIR/pkg/log/integration_test.go: `.On("ConfiguredChainID")`
$DIR/pkg/log/integration_test.go: `.Return(big.NewInt(0))`
$DIR/pkg/log/integration_test.go: `.NewInt(0)`
$DIR/pkg/log/integration_test.go: `.Maybe()`
$DIR/pkg/log/integration_test.go: `.On("SubscribeFilterLogs", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/log/integration_test.go: `.
		Return(
			func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) ethereum.Subscription {
				sub := mockEth.NewSub(t)
				logsChCh <- testutils.NewRawSub(ch, sub.Err())
				return sub
			},
			func(ctx context.Context, q ethereum.FilterQuery, ch chan<- types.Log) error {
				return nil
			},
		)`
$DIR/pkg/log/integration_test.go: `.NewSub(t)`
$DIR/pkg/log/integration_test.go: `.NewRawSub(ch, sub.Err())`
$DIR/pkg/log/integration_test.go: `.Err()`
$DIR/pkg/log/integration_test.go: `.
		Once()`
$DIR/pkg/log/integration_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/log/integration_test.go: `.
		Return(&evmtypes.Head{Number: 1}, nil)`
$DIR/pkg/log/integration_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/log/integration_test.go: `.
		Return(nil, nil)`
$DIR/pkg/log/integration_test.go: `.start()`
$DIR/pkg/log/integration_test.go: `.stop()`
$DIR/pkg/log/integration_test.go: `.HexToAddress("0xf0d54349aDdcf704F77AE15b96510dEA15cb7952")`
$DIR/pkg/log/integration_test.go: `.NewFluxAggregator(addr, nil)`
$DIR/pkg/log/integration_test.go: `.NewHash()`
$DIR/pkg/log/integration_test.go: `.Topic()`
$DIR/pkg/log/integration_test.go: `.NewHash()`
$DIR/pkg/log/integration_test.go: `.NewHash()`
$DIR/pkg/log/integration_test.go: `.Topic()`
$DIR/pkg/log/integration_test.go: `.NewHash()`
$DIR/pkg/log/integration_test.go: `.NewHash()`
$DIR/pkg/log/integration_test.go: `.Topic()`
$DIR/pkg/log/integration_test.go: `.NewHash()`
$DIR/pkg/log/integration_test.go: `.NewHash()`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("1")`
$DIR/pkg/log/integration_test.go: `.register(listener1, contract1, 0)`
$DIR/pkg/log/integration_test.go: `.newLogListenerWithJob("2")`
$DIR/pkg/log/integration_test.go: `.register(listener2, contract1, 0)`
$DIR/pkg/log/integration_test.go: `.TrySend(log)`
$DIR/pkg/log/integration_test.go: `.Eventually(func() bool {
		helper.lb.Pause()
		defer helper.lb.Resume()
		return helper.lb.LogsFromBlock(bh) == len(addr1SentLogs)
	}, 2*time.Second, 100*time.Millisecond)`
$DIR/pkg/log/integration_test.go: `.lb.Pause()`
$DIR/pkg/log/integration_test.go: `.lb.Resume()`
$DIR/pkg/log/integration_test.go: `.lb.LogsFromBlock(bh)`
$DIR/pkg/log/integration_test.go: `.Should(gomega.BeTrue())`
$DIR/pkg/log/integration_test.go: `.BeTrue()`
$DIR/pkg/log/integration_test.go: `.lb.OnNewLongestChain(testutils.Context(t), &evmtypes.Head{Number: 2})`
$DIR/pkg/log/integration_test.go: `.Context(t)`
$DIR/pkg/log/integration_test.go: `.Eventually(func() bool {
		return len(listener1.getUniqueLogs()) == len(addr1SentLogs) && len(listener2.getUniqueLogs()) == len(addr1SentLogs)
	}, 2*time.Second, DBPollingInterval)`
$DIR/pkg/log/integration_test.go: `.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.Should(gomega.BeTrue())`
$DIR/pkg/log/integration_test.go: `.BeTrue()`
$DIR/pkg/log/integration_test.go: `.Consistently(func() bool {
		return len(listener1.getUniqueLogs()) == len(addr1SentLogs) && len(listener2.getUniqueLogs()) == len(addr1SentLogs)
	}, 1*time.Second, DBPollingInterval)`
$DIR/pkg/log/integration_test.go: `.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.getUniqueLogs()`
$DIR/pkg/log/integration_test.go: `.BeTrue()`
$DIR/pkg/log/orm_test.go: `t.Run("WasBroadcastConsumed_DNE", func(t *testing.T) {
		_, err := orm.WasBroadcastConsumed(testutils.Context(t), rawLog.BlockHash, rawLog.Index, listener.JobID())
		require.NoError(t, err)
	})`
$DIR/pkg/log/orm_test.go: `t.Run("WasBroadcastConsumed_false", func(t *testing.T) {
		was, err := orm.WasBroadcastConsumed(testutils.Context(t), rawLog.BlockHash, rawLog.Index, listener.JobID())
		require.NoError(t, err)
		require.False(t, was)
	})`
$DIR/pkg/log/orm_test.go: `err = orm.SetPendingMinBlock(ctx, &num10)`
$DIR/pkg/log/orm_test.go: `num, err = orm.GetPendingMinBlock(ctx)`
$DIR/pkg/log/orm_test.go: `err = orm.SetPendingMinBlock(ctx, nil)`
$DIR/pkg/log/orm_test.go: `num, err = orm.GetPendingMinBlock(ctx)`
$DIR/pkg/log/orm_test.go: `logBefore.BlockNumber = 34`
$DIR/pkg/log/orm_test.go: `logAt.BlockNumber = 38`
$DIR/pkg/log/orm_test.go: `logAfter.BlockNumber = 40`
$DIR/pkg/log/orm_test.go: `consumed, err = orm.WasBroadcastConsumed(ctx, logAt.BlockHash, logAt.Index, job1)`
$DIR/pkg/log/orm_test.go: `consumed, err = orm.WasBroadcastConsumed(ctx, logAfter.BlockHash, logAfter.Index, job2)`
$DIR/pkg/log/orm_test.go: `t.Run(tt.name, func(t *testing.T) {
			db := testutils.NewSqlxDB(t)
			ctx := testutils.Context(t)
			orm := log.NewORM(db, *testutils.FixtureChainID)

			jobID := mustInsertV2JobSpec(t, db, common.BigToAddress(big.NewInt(rand.Int63())))

			for _, b := range tt.broadcasts {
				if b.Consumed {
					err := orm.MarkBroadcastConsumed(ctx, b.BlockHash, b.BlockNumber.Uint64(), b.LogIndex, jobID)
					require.NoError(t, err)
				} else {
					err := orm.CreateBroadcast(ctx, b.BlockHash, b.BlockNumber.Uint64(), b.LogIndex, jobID)
					require.NoError(t, err)
				}
			}
			if tt.pendingBlockNum != nil {
				require.NoError(t, orm.SetPendingMinBlock(ctx, tt.pendingBlockNum))
			}

			pendingBlockNum, err := orm.Reinitialize(ctx)
			require.NoError(t, err)
			assert.Equal(t, tt.expPendingBlockNum, pendingBlockNum)

			pendingBlockNum, err = orm.GetPendingMinBlock(ctx)
			if assert.NoError(t, err) {
				assert.Equal(t, tt.expPendingBlockNum, pendingBlockNum)
			}

			bs, err := orm.FindBroadcasts(ctx, 0, 20)
			if assert.NoError(t, err) {
				for _, b := range bs {
					assert.True(t, b.Consumed)
				}
			}
		})`
$DIR/pkg/log/orm_test.go: `pendingBlockNum, err = orm.GetPendingMinBlock(ctx)`
$DIR/pkg/log/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/log/orm_test.go: `.NewORM(db, *testutils.FixtureChainID)`
$DIR/pkg/log/orm_test.go: `.NewAddress()`
$DIR/pkg/log/orm_test.go: `.JobID()`
$DIR/pkg/log/orm_test.go: `.FixtureChainID.String()`
$DIR/pkg/log/orm_test.go: `.Exec(selectQuery, queryArgs...)`
$DIR/pkg/log/orm_test.go: `.RowsAffected()`
$DIR/pkg/log/orm_test.go: `.Run("WasBroadcastConsumed_DNE", func(t *testing.T) {
		_, err := orm.WasBroadcastConsumed(testutils.Context(t), rawLog.BlockHash, rawLog.Index, listener.JobID())
		require.NoError(t, err)
	})`
$DIR/pkg/log/orm_test.go: `.WasBroadcastConsumed(testutils.Context(t), rawLog.BlockHash, rawLog.Index, listener.JobID())`
$DIR/pkg/log/orm_test.go: `.Context(t)`
$DIR/pkg/log/orm_test.go: `.JobID()`
$DIR/pkg/log/orm_test.go: `.Run("WasBroadcastConsumed_false", func(t *testing.T) {
		was, err := orm.WasBroadcastConsumed(testutils.Context(t), rawLog.BlockHash, rawLog.Index, listener.JobID())
		require.NoError(t, err)
		require.False(t, was)
	})`
$DIR/pkg/log/orm_test.go: `.WasBroadcastConsumed(testutils.Context(t), rawLog.BlockHash, rawLog.Index, listener.JobID())`
$DIR/pkg/log/orm_test.go: `.Context(t)`
$DIR/pkg/log/orm_test.go: `.JobID()`
$DIR/pkg/log/orm_test.go: `.WasBroadcastConsumed(testutils.Context(t), rawLog.BlockHash, rawLog.Index, listener.JobID())`
$DIR/pkg/log/orm_test.go: `.Context(t)`
$DIR/pkg/log/orm_test.go: `.JobID()`
$DIR/pkg/log/orm_test.go: `.Context(t)`
$DIR/pkg/log/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/log/orm_test.go: `.NewORM(db, *testutils.FixtureChainID)`
$DIR/pkg/log/orm_test.go: `.GetPendingMinBlock(ctx)`
$DIR/pkg/log/orm_test.go: `.SetPendingMinBlock(ctx, &num10)`
$DIR/pkg/log/orm_test.go: `.GetPendingMinBlock(ctx)`
$DIR/pkg/log/orm_test.go: `.SetPendingMinBlock(ctx, nil)`
$DIR/pkg/log/orm_test.go: `.GetPendingMinBlock(ctx)`
$DIR/pkg/log/orm_test.go: `.Context(t)`
$DIR/pkg/log/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/log/orm_test.go: `.NewORM(db, *testutils.FixtureChainID)`
$DIR/pkg/log/orm_test.go: `.NewAddress()`
$DIR/pkg/log/orm_test.go: `.NewAddress()`
$DIR/pkg/log/orm_test.go: `.WasBroadcastConsumed(ctx, logBefore.BlockHash, logBefore.Index, job1)`
$DIR/pkg/log/orm_test.go: `.WasBroadcastConsumed(ctx, logAt.BlockHash, logAt.Index, job1)`
$DIR/pkg/log/orm_test.go: `.WasBroadcastConsumed(ctx, logAfter.BlockHash, logAfter.Index, job2)`
$DIR/pkg/log/orm_test.go: `.BigToHash(big.NewInt(rand.Int63()))`
$DIR/pkg/log/orm_test.go: `.NewInt(rand.Int63())`
$DIR/pkg/log/orm_test.go: `.Int63()`
$DIR/pkg/log/orm_test.go: `.NewInt(blockNum)`
$DIR/pkg/log/orm_test.go: `.Uint32()`
$DIR/pkg/log/orm_test.go: `.BigToHash(big.NewInt(rand.Int63()))`
$DIR/pkg/log/orm_test.go: `.NewInt(rand.Int63())`
$DIR/pkg/log/orm_test.go: `.Int63()`
$DIR/pkg/log/orm_test.go: `.NewInt(blockNum)`
$DIR/pkg/log/orm_test.go: `.Uint32()`
$DIR/pkg/log/orm_test.go: `.IntFrom(10)`
$DIR/pkg/log/orm_test.go: `.Ptr()`
$DIR/pkg/log/orm_test.go: `.IntFrom(10)`
$DIR/pkg/log/orm_test.go: `.Ptr()`
$DIR/pkg/log/orm_test.go: `.IntFrom(9)`
$DIR/pkg/log/orm_test.go: `.Ptr()`
$DIR/pkg/log/orm_test.go: `.IntFrom(10)`
$DIR/pkg/log/orm_test.go: `.Ptr()`
$DIR/pkg/log/orm_test.go: `.IntFrom(9)`
$DIR/pkg/log/orm_test.go: `.Ptr()`
$DIR/pkg/log/orm_test.go: `.IntFrom(10)`
$DIR/pkg/log/orm_test.go: `.Ptr()`
$DIR/pkg/log/orm_test.go: `.IntFrom(10)`
$DIR/pkg/log/orm_test.go: `.Ptr()`
$DIR/pkg/log/orm_test.go: `.Run(tt.name, func(t *testing.T) {
			db := testutils.NewSqlxDB(t)
			ctx := testutils.Context(t)
			orm := log.NewORM(db, *testutils.FixtureChainID)

			jobID := mustInsertV2JobSpec(t, db, common.BigToAddress(big.NewInt(rand.Int63())))

			for _, b := range tt.broadcasts {
				if b.Consumed {
					err := orm.MarkBroadcastConsumed(ctx, b.BlockHash, b.BlockNumber.Uint64(), b.LogIndex, jobID)
					require.NoError(t, err)
				} else {
					err := orm.CreateBroadcast(ctx, b.BlockHash, b.BlockNumber.Uint64(), b.LogIndex, jobID)
					require.NoError(t, err)
				}
			}
			if tt.pendingBlockNum != nil {
				require.NoError(t, orm.SetPendingMinBlock(ctx, tt.pendingBlockNum))
			}

			pendingBlockNum, err := orm.Reinitialize(ctx)
			require.NoError(t, err)
			assert.Equal(t, tt.expPendingBlockNum, pendingBlockNum)

			pendingBlockNum, err = orm.GetPendingMinBlock(ctx)
			if assert.NoError(t, err) {
				assert.Equal(t, tt.expPendingBlockNum, pendingBlockNum)
			}

			bs, err := orm.FindBroadcasts(ctx, 0, 20)
			if assert.NoError(t, err) {
				for _, b := range bs {
					assert.True(t, b.Consumed)
				}
			}
		})`
$DIR/pkg/log/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/log/orm_test.go: `.Context(t)`
$DIR/pkg/log/orm_test.go: `.NewORM(db, *testutils.FixtureChainID)`
$DIR/pkg/log/orm_test.go: `.BigToAddress(big.NewInt(rand.Int63()))`
$DIR/pkg/log/orm_test.go: `.NewInt(rand.Int63())`
$DIR/pkg/log/orm_test.go: `.Int63()`
$DIR/pkg/log/orm_test.go: `.MarkBroadcastConsumed(ctx, b.BlockHash, b.BlockNumber.Uint64(), b.LogIndex, jobID)`
$DIR/pkg/log/orm_test.go: `.BlockNumber.Uint64()`
$DIR/pkg/log/orm_test.go: `.CreateBroadcast(ctx, b.BlockHash, b.BlockNumber.Uint64(), b.LogIndex, jobID)`
$DIR/pkg/log/orm_test.go: `.BlockNumber.Uint64()`
$DIR/pkg/log/orm_test.go: `.Reinitialize(ctx)`
$DIR/pkg/log/orm_test.go: `.GetPendingMinBlock(ctx)`
$DIR/pkg/log/orm_test.go: `.FindBroadcasts(ctx, 0, 20)`
$DIR/pkg/log/pool_test.go: `l2.Index = 43`
$DIR/pkg/log/pool_test.go: `l2 = l1`
$DIR/pkg/log/pool_test.go: `l2.TxIndex = 13`
$DIR/pkg/log/pool_test.go: `l3.BlockNumber = 3`
$DIR/pkg/log/pool_test.go: `l3.BlockHash = common.BigToHash(big.NewInt(3))`
$DIR/pkg/log/pool_test.go: `l4.BlockNumber = 0`
$DIR/pkg/log/pool_test.go: `l4.BlockHash = common.BigToHash(big.NewInt(0))`
$DIR/pkg/log/pool_test.go: `p.addLog(L1)`
$DIR/pkg/log/pool_test.go: `p.addLog(L1)`
$DIR/pkg/log/pool_test.go: `p.addLog(L21)`
$DIR/pkg/log/pool_test.go: `p.addLog(L22)`
$DIR/pkg/log/pool_test.go: `p.addLog(L3)`
$DIR/pkg/log/pool_test.go: `p.addLog(L1)`
$DIR/pkg/log/pool_test.go: `p.addLog(L21)`
$DIR/pkg/log/pool_test.go: `p.addLog(L3)`
$DIR/pkg/log/pool_test.go: `t.Run(test.name, func(t *testing.T) {
			logsOnBlocks, minBlockNumToSend := p.getLogsToSend(test.latestBlockNumber)
			assert.Equal(t, test.expectedMinBlockNumToSend, minBlockNumToSend)
			assert.ElementsMatch(t, test.expectedLogs, logsOnBlocks)
		})`
$DIR/pkg/log/pool_test.go: `t.Run(test.name, func(t *testing.T) {
			var p iLogPool = newLogPool(logger.Test(t))
			p.addLog(L1)
			p.addLog(L21)
			p.addLog(L3)

			oldestKeptBlock := p.deleteOlderLogs(test.keptDepth)

			assert.Equal(t, test.expectedOldestBlock, oldestKeptBlock)
			keptLogs, _ := p.getLogsToSend(4)
			assert.ElementsMatch(t, test.expectedKeptLogs, keptLogs)
		})`
$DIR/pkg/log/pool_test.go: `p.addLog(L1)`
$DIR/pkg/log/pool_test.go: `p.addLog(L21)`
$DIR/pkg/log/pool_test.go: `p.addLog(L3)`
$DIR/pkg/log/pool_test.go: `t.Run(test.name, func(t *testing.T) {
			var p iLogPool = newLogPool(logger.Test(t))
			p.addLog(L21)
			p.addLog(L22)
			p.addLog(L23)
			p.addLog(L3)

			p.removeBlock(test.blockHash, test.blockNumber)

			assert.Equal(t, 0, p.testOnly_getNumLogsForBlock(test.blockHash))
			p.deleteOlderLogs(int64(test.blockNumber)) // Pruning logs for easier testing next line
			logsOnBlock, _ := p.getLogsToSend(int64(test.blockNumber))
			assert.ElementsMatch(t, test.expectedRemainingLogs, logsOnBlock)
		})`
$DIR/pkg/log/pool_test.go: `p.addLog(L21)`
$DIR/pkg/log/pool_test.go: `p.addLog(L22)`
$DIR/pkg/log/pool_test.go: `p.addLog(L23)`
$DIR/pkg/log/pool_test.go: `p.addLog(L3)`
$DIR/pkg/log/pool_test.go: `p.removeBlock(test.blockHash, test.blockNumber)`
$DIR/pkg/log/pool_test.go: `p.deleteOlderLogs(int64(test.blockNumber))`
$DIR/pkg/log/pool_test.go: `.Test(t)`
$DIR/pkg/log/pool_test.go: `.BigToHash(big.NewInt(1))`
$DIR/pkg/log/pool_test.go: `.NewInt(1)`
$DIR/pkg/log/pool_test.go: `.BigToHash(big.NewInt(3))`
$DIR/pkg/log/pool_test.go: `.NewInt(3)`
$DIR/pkg/log/pool_test.go: `.BigToHash(big.NewInt(0))`
$DIR/pkg/log/pool_test.go: `.NewInt(0)`
$DIR/pkg/log/pool_test.go: `.testOnly_getNumLogsForBlock(l4.BlockHash)`
$DIR/pkg/log/pool_test.go: `.Test(t)`
$DIR/pkg/log/pool_test.go: `.addLog(L1)`
$DIR/pkg/log/pool_test.go: `.addLog(L1)`
$DIR/pkg/log/pool_test.go: `.addLog(L21)`
$DIR/pkg/log/pool_test.go: `.addLog(L22)`
$DIR/pkg/log/pool_test.go: `.addLog(L3)`
$DIR/pkg/log/pool_test.go: `.getAndDeleteAll()`
$DIR/pkg/log/pool_test.go: `.testOnly_getNumLogsForBlock(L3.BlockHash)`
$DIR/pkg/log/pool_test.go: `.Test(t)`
$DIR/pkg/log/pool_test.go: `.getLogsToSend(1)`
$DIR/pkg/log/pool_test.go: `.Test(t)`
$DIR/pkg/log/pool_test.go: `.addLog(L1)`
$DIR/pkg/log/pool_test.go: `.addLog(L21)`
$DIR/pkg/log/pool_test.go: `.addLog(L3)`
$DIR/pkg/log/pool_test.go: `.Run(test.name, func(t *testing.T) {
			logsOnBlocks, minBlockNumToSend := p.getLogsToSend(test.latestBlockNumber)
			assert.Equal(t, test.expectedMinBlockNumToSend, minBlockNumToSend)
			assert.ElementsMatch(t, test.expectedLogs, logsOnBlocks)
		})`
$DIR/pkg/log/pool_test.go: `.getLogsToSend(test.latestBlockNumber)`
$DIR/pkg/log/pool_test.go: `.Test(t)`
$DIR/pkg/log/pool_test.go: `.deleteOlderLogs(1)`
$DIR/pkg/log/pool_test.go: `.Run(test.name, func(t *testing.T) {
			var p iLogPool = newLogPool(logger.Test(t))
			p.addLog(L1)
			p.addLog(L21)
			p.addLog(L3)

			oldestKeptBlock := p.deleteOlderLogs(test.keptDepth)

			assert.Equal(t, test.expectedOldestBlock, oldestKeptBlock)
			keptLogs, _ := p.getLogsToSend(4)
			assert.ElementsMatch(t, test.expectedKeptLogs, keptLogs)
		})`
$DIR/pkg/log/pool_test.go: `.Test(t)`
$DIR/pkg/log/pool_test.go: `.addLog(L1)`
$DIR/pkg/log/pool_test.go: `.addLog(L21)`
$DIR/pkg/log/pool_test.go: `.addLog(L3)`
$DIR/pkg/log/pool_test.go: `.deleteOlderLogs(test.keptDepth)`
$DIR/pkg/log/pool_test.go: `.getLogsToSend(4)`
$DIR/pkg/log/pool_test.go: `.Test(t)`
$DIR/pkg/log/pool_test.go: `.Run(test.name, func(t *testing.T) {
			var p iLogPool = newLogPool(logger.Test(t))
			p.addLog(L21)
			p.addLog(L22)
			p.addLog(L23)
			p.addLog(L3)

			p.removeBlock(test.blockHash, test.blockNumber)

			assert.Equal(t, 0, p.testOnly_getNumLogsForBlock(test.blockHash))
			p.deleteOlderLogs(int64(test.blockNumber)) // Pruning logs for easier testing next line
			logsOnBlock, _ := p.getLogsToSend(int64(test.blockNumber))
			assert.ElementsMatch(t, test.expectedRemainingLogs, logsOnBlock)
		})`
$DIR/pkg/log/pool_test.go: `.Test(t)`
$DIR/pkg/log/pool_test.go: `.addLog(L21)`
$DIR/pkg/log/pool_test.go: `.addLog(L22)`
$DIR/pkg/log/pool_test.go: `.addLog(L23)`
$DIR/pkg/log/pool_test.go: `.addLog(L3)`
$DIR/pkg/log/pool_test.go: `.removeBlock(test.blockHash, test.blockNumber)`
$DIR/pkg/log/pool_test.go: `.deleteOlderLogs(int64(test.blockNumber))`
$DIR/pkg/log/pool_test.go: `.getLogsToSend(int64(test.blockNumber))`
$DIR/pkg/log/registrations_test.go: `r.addSubscriber(sub)`
$DIR/pkg/log/registrations_test.go: `r.addSubscriber(subB)`
$DIR/pkg/log/registrations_test.go: `r.addSubscriber(sub2)`
$DIR/pkg/log/registrations_test.go: `r.removeSubscriber(sub)`
$DIR/pkg/log/registrations_test.go: `logsWithTopics[topic1] = topicValueFilters1`
$DIR/pkg/log/registrations_test.go: `logsWithTopics[topic2] = topicValueFilters2`
$DIR/pkg/log/registrations_test.go: `logsWithTopics[topic3] = topicValueFilters3`
$DIR/pkg/log/registrations_test.go: `logsWithTopics3[topic4] = topicValueFilters4`
$DIR/pkg/log/registrations_test.go: `opts3.LogsWithTopics = logsWithTopics3`
$DIR/pkg/log/registrations_test.go: `opts4.MinIncomingConfirmations = 42`
$DIR/pkg/log/registrations_test.go: `opts5.MinIncomingConfirmations = 21`
$DIR/pkg/log/registrations_test.go: `t.Run("addSubscriber", func(t *testing.T) {
		needsResub := r.addSubscriber(sub)
		assert.True(t, needsResub)

		// same contract, same topics
		needsResub = r.addSubscriber(sub2)
		assert.False(t, needsResub)

		// same contract, different topics
		needsResub = r.addSubscriber(sub3)
		assert.True(t, needsResub)

		assert.Equal(t, 1, int(r.highestNumConfirmations))

		// same contract, same topics, different MinIncomingConfirmations
		needsResub = r.addSubscriber(sub4)
		// resub required because confirmations went higher
		assert.True(t, needsResub)
		assert.Equal(t, 42, int(r.highestNumConfirmations))

		// same contract, same topics, midrange MinIncomingConfirmations
		needsResub = r.addSubscriber(sub5)
		// resub NOT required because confirmations is lower than the highest
		assert.False(t, needsResub)
		assert.Equal(t, 42, int(r.highestNumConfirmations))

		assert.Len(t, r.registeredSubs, 5)
		assert.Contains(t, r.registeredSubs, sub)
		assert.Contains(t, r.registeredSubs, sub2)
		assert.Contains(t, r.registeredSubs, sub3)
		assert.Contains(t, r.registeredSubs, sub4)
		assert.Contains(t, r.registeredSubs, sub5)

		assert.Len(t, r.handlersByConfs, 3)
		require.Contains(t, r.handlersByConfs, uint32(1))
		require.Contains(t, r.handlersByConfs, uint32(21))
		require.Contains(t, r.handlersByConfs, uint32(42))

		// contractAddress => logTopic => Listener
		handlers1 := r.handlersByConfs[1].lookupSubs
		assert.Len(t, handlers1, 1)
		assert.Contains(t, handlers1, contractAddr)
		h1 := handlers1[contractAddr]
		// 4 topics on this contract addr
		assert.Len(t, h1, 4)
		assert.Contains(t, h1, topic1)
		assert.Contains(t, h1, topic2)
		assert.Contains(t, h1, topic3)
		assert.Contains(t, h1, topic4)
		// topics map to their subscribers
		assert.Len(t, h1[topic1], 2) // listeners 1 and 2
		assert.Contains(t, h1[topic1], sub)
		assert.Contains(t, h1[topic1], sub2)
		assert.Len(t, h1[topic2], 2) // listeners 1 and 2
		assert.Contains(t, h1[topic2], sub)
		assert.Contains(t, h1[topic2], sub2)
		assert.Len(t, h1[topic3], 2) // listeners 1 and 2
		assert.Contains(t, h1[topic3], sub)
		assert.Contains(t, h1[topic3], sub2)
		assert.Len(t, h1[topic4], 1) // listener 3
		assert.Contains(t, h1[topic4], sub3)

		handlers42 := r.handlersByConfs[42].lookupSubs
		assert.Len(t, handlers42, 1)
		assert.Contains(t, handlers1, contractAddr)
		h42 := handlers42[contractAddr]
		// 1 topic on this contract addr
		assert.Len(t, h42, 1)
		assert.Contains(t, h1, topic4)
		// topic maps to its subscriber
		assert.Len(t, h42[topic4], 1) // listener 4
		assert.Contains(t, h42[topic4], sub4)

		handlers21 := r.handlersByConfs[21].lookupSubs
		assert.Len(t, handlers21, 1)
		assert.Contains(t, handlers1, contractAddr)
		h21 := handlers21[contractAddr]
		// 1 topic on this contract addr
		assert.Len(t, h21, 1)
		assert.Contains(t, h1, topic4)
		// topic maps to its subscriber
		assert.Len(t, h21[topic4], 1) // listener 5
		assert.Contains(t, h21[topic4], sub5)
	})`
$DIR/pkg/log/registrations_test.go: `needsResub = r.addSubscriber(sub2)`
$DIR/pkg/log/registrations_test.go: `needsResub = r.addSubscriber(sub3)`
$DIR/pkg/log/registrations_test.go: `needsResub = r.addSubscriber(sub4)`
$DIR/pkg/log/registrations_test.go: `needsResub = r.addSubscriber(sub5)`
$DIR/pkg/log/registrations_test.go: `needsResub = r.removeSubscriber(sub2)`
$DIR/pkg/log/registrations_test.go: `needsResub = r.removeSubscriber(sub3)`
$DIR/pkg/log/registrations_test.go: `needsResub = r.removeSubscriber(sub4)`
$DIR/pkg/log/registrations_test.go: `needsResub = r.removeSubscriber(sub5)`
$DIR/pkg/log/registrations_test.go: `.NewAddress()`
$DIR/pkg/log/registrations_test.go: `.addSubscriber(sub)`
$DIR/pkg/log/registrations_test.go: `.NewAddress()`
$DIR/pkg/log/registrations_test.go: `.addSubscriber(subB)`
$DIR/pkg/log/registrations_test.go: `.addSubscriber(sub2)`
$DIR/pkg/log/registrations_test.go: `.removeSubscriber(sub)`
$DIR/pkg/log/registrations_test.go: `.NewAddress()`
$DIR/pkg/log/registrations_test.go: `.NewHash()`
$DIR/pkg/log/registrations_test.go: `.NewHash()`
$DIR/pkg/log/registrations_test.go: `.NewHash()`
$DIR/pkg/log/registrations_test.go: `.NewHash()`
$DIR/pkg/log/registrations_test.go: `.Run("addSubscriber", func(t *testing.T) {
		needsResub := r.addSubscriber(sub)
		assert.True(t, needsResub)

		// same contract, same topics
		needsResub = r.addSubscriber(sub2)
		assert.False(t, needsResub)

		// same contract, different topics
		needsResub = r.addSubscriber(sub3)
		assert.True(t, needsResub)

		assert.Equal(t, 1, int(r.highestNumConfirmations))

		// same contract, same topics, different MinIncomingConfirmations
		needsResub = r.addSubscriber(sub4)
		// resub required because confirmations went higher
		assert.True(t, needsResub)
		assert.Equal(t, 42, int(r.highestNumConfirmations))

		// same contract, same topics, midrange MinIncomingConfirmations
		needsResub = r.addSubscriber(sub5)
		// resub NOT required because confirmations is lower than the highest
		assert.False(t, needsResub)
		assert.Equal(t, 42, int(r.highestNumConfirmations))

		assert.Len(t, r.registeredSubs, 5)
		assert.Contains(t, r.registeredSubs, sub)
		assert.Contains(t, r.registeredSubs, sub2)
		assert.Contains(t, r.registeredSubs, sub3)
		assert.Contains(t, r.registeredSubs, sub4)
		assert.Contains(t, r.registeredSubs, sub5)

		assert.Len(t, r.handlersByConfs, 3)
		require.Contains(t, r.handlersByConfs, uint32(1))
		require.Contains(t, r.handlersByConfs, uint32(21))
		require.Contains(t, r.handlersByConfs, uint32(42))

		// contractAddress => logTopic => Listener
		handlers1 := r.handlersByConfs[1].lookupSubs
		assert.Len(t, handlers1, 1)
		assert.Contains(t, handlers1, contractAddr)
		h1 := handlers1[contractAddr]
		// 4 topics on this contract addr
		assert.Len(t, h1, 4)
		assert.Contains(t, h1, topic1)
		assert.Contains(t, h1, topic2)
		assert.Contains(t, h1, topic3)
		assert.Contains(t, h1, topic4)
		// topics map to their subscribers
		assert.Len(t, h1[topic1], 2) // listeners 1 and 2
		assert.Contains(t, h1[topic1], sub)
		assert.Contains(t, h1[topic1], sub2)
		assert.Len(t, h1[topic2], 2) // listeners 1 and 2
		assert.Contains(t, h1[topic2], sub)
		assert.Contains(t, h1[topic2], sub2)
		assert.Len(t, h1[topic3], 2) // listeners 1 and 2
		assert.Contains(t, h1[topic3], sub)
		assert.Contains(t, h1[topic3], sub2)
		assert.Len(t, h1[topic4], 1) // listener 3
		assert.Contains(t, h1[topic4], sub3)

		handlers42 := r.handlersByConfs[42].lookupSubs
		assert.Len(t, handlers42, 1)
		assert.Contains(t, handlers1, contractAddr)
		h42 := handlers42[contractAddr]
		// 1 topic on this contract addr
		assert.Len(t, h42, 1)
		assert.Contains(t, h1, topic4)
		// topic maps to its subscriber
		assert.Len(t, h42[topic4], 1) // listener 4
		assert.Contains(t, h42[topic4], sub4)

		handlers21 := r.handlersByConfs[21].lookupSubs
		assert.Len(t, handlers21, 1)
		assert.Contains(t, handlers1, contractAddr)
		h21 := handlers21[contractAddr]
		// 1 topic on this contract addr
		assert.Len(t, h21, 1)
		assert.Contains(t, h1, topic4)
		// topic maps to its subscriber
		assert.Len(t, h21[topic4], 1) // listener 5
		assert.Contains(t, h21[topic4], sub5)
	})`
$DIR/pkg/log/registrations_test.go: `.addSubscriber(sub)`
$DIR/pkg/log/registrations_test.go: `.addSubscriber(sub2)`
$DIR/pkg/log/registrations_test.go: `.addSubscriber(sub3)`
$DIR/pkg/log/registrations_test.go: `.addSubscriber(sub4)`
$DIR/pkg/log/registrations_test.go: `.addSubscriber(sub5)`
$DIR/pkg/log/registrations_test.go: `.removeSubscriber(sub)`
$DIR/pkg/log/registrations_test.go: `.removeSubscriber(sub2)`
$DIR/pkg/log/registrations_test.go: `.removeSubscriber(sub3)`
$DIR/pkg/log/registrations_test.go: `.removeSubscriber(sub4)`
$DIR/pkg/log/registrations_test.go: `.removeSubscriber(sub5)`
$DIR/pkg/logpoller/latency_monitor_test.go: `t.Run("Slow client with latency 80% block production rate", func(t *testing.T) {
		client.latency = time.Duration(0.8 * float64(blockProductionRate))
		_, _ = lm.HeadByNumber(t.Context(), nil)
		_, _ = lm.HeadByHash(t.Context(), common.Hash{})

		// Should not track latency on block range
		filter := ethereum.FilterQuery{FromBlock: big.NewInt(123), ToBlock: big.NewInt(456), BlockHash: nil}
		_, _ = lm.FilterLogs(t.Context(), filter)
		require.Equal(t, 2, logs.Len())

		// Should track latency for a specific block hash call
		filter = ethereum.FilterQuery{FromBlock: nil, ToBlock: nil, BlockHash: &common.Hash{}}
		_, _ = lm.FilterLogs(t.Context(), filter)
		require.Equal(t, 3, logs.Len())
	})`
$DIR/pkg/logpoller/latency_monitor_test.go: `client.latency = time.Duration(0.8 * float64(blockProductionRate))`
$DIR/pkg/logpoller/latency_monitor_test.go: `_, _ = lm.HeadByNumber(t.Context(), nil)`
$DIR/pkg/logpoller/latency_monitor_test.go: `_, _ = lm.HeadByHash(t.Context(), common.Hash{})`
$DIR/pkg/logpoller/latency_monitor_test.go: `_, _ = lm.FilterLogs(t.Context(), filter)`
$DIR/pkg/logpoller/latency_monitor_test.go: `filter = ethereum.FilterQuery{FromBlock: nil, ToBlock: nil, BlockHash: &common.Hash{}}`
$DIR/pkg/logpoller/latency_monitor_test.go: `_, _ = lm.FilterLogs(t.Context(), filter)`
$DIR/pkg/logpoller/latency_monitor_test.go: `client.latency = 0`
$DIR/pkg/logpoller/latency_monitor_test.go: `_ = logs.TakeAll()`
$DIR/pkg/logpoller/latency_monitor_test.go: `_, _ = lm.HeadByNumber(t.Context(), nil)`
$DIR/pkg/logpoller/latency_monitor_test.go: `_, _ = lm.HeadByHash(t.Context(), common.Hash{})`
$DIR/pkg/logpoller/latency_monitor_test.go: `_, _ = lm.FilterLogs(t.Context(), filter)`
$DIR/pkg/logpoller/latency_monitor_test.go: `.TestObserved(t, zapcore.DebugLevel)`
$DIR/pkg/logpoller/latency_monitor_test.go: `.NewLatencyMonitor(client, lggr, blockProductionRate)`
$DIR/pkg/logpoller/latency_monitor_test.go: `.Run("Slow client with latency 80% block production rate", func(t *testing.T) {
		client.latency = time.Duration(0.8 * float64(blockProductionRate))
		_, _ = lm.HeadByNumber(t.Context(), nil)
		_, _ = lm.HeadByHash(t.Context(), common.Hash{})

		// Should not track latency on block range
		filter := ethereum.FilterQuery{FromBlock: big.NewInt(123), ToBlock: big.NewInt(456), BlockHash: nil}
		_, _ = lm.FilterLogs(t.Context(), filter)
		require.Equal(t, 2, logs.Len())

		// Should track latency for a specific block hash call
		filter = ethereum.FilterQuery{FromBlock: nil, ToBlock: nil, BlockHash: &common.Hash{}}
		_, _ = lm.FilterLogs(t.Context(), filter)
		require.Equal(t, 3, logs.Len())
	})`
$DIR/pkg/logpoller/latency_monitor_test.go: `.Duration(0.8 * float64(blockProductionRate))`
$DIR/pkg/logpoller/latency_monitor_test.go: `.HeadByNumber(t.Context(), nil)`
$DIR/pkg/logpoller/latency_monitor_test.go: `.Context()`
$DIR/pkg/logpoller/latency_monitor_test.go: `.HeadByHash(t.Context(), common.Hash{})`
$DIR/pkg/logpoller/latency_monitor_test.go: `.Context()`
$DIR/pkg/logpoller/latency_monitor_test.go: `.NewInt(123)`
$DIR/pkg/logpoller/latency_monitor_test.go: `.NewInt(456)`
$DIR/pkg/logpoller/latency_monitor_test.go: `.FilterLogs(t.Context(), filter)`
$DIR/pkg/logpoller/latency_monitor_test.go: `.Context()`
$DIR/pkg/logpoller/latency_monitor_test.go: `.FilterLogs(t.Context(), filter)`
$DIR/pkg/logpoller/latency_monitor_test.go: `.Context()`
$DIR/pkg/logpoller/latency_monitor_test.go: `.TakeAll()`
$DIR/pkg/logpoller/latency_monitor_test.go: `.HeadByNumber(t.Context(), nil)`
$DIR/pkg/logpoller/latency_monitor_test.go: `.Context()`
$DIR/pkg/logpoller/latency_monitor_test.go: `.HeadByHash(t.Context(), common.Hash{})`
$DIR/pkg/logpoller/latency_monitor_test.go: `.Context()`
$DIR/pkg/logpoller/latency_monitor_test.go: `.FilterLogs(t.Context(), filter)`
$DIR/pkg/logpoller/latency_monitor_test.go: `.Context()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `validateFiltersTable(t, lp, orm)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `err = lp.RegisterFilter(ctx, Filter{Name: "Emitter Log 1 + 2", EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID, EmitterABI.Events["Log2"].ID}, Addresses: []common.Address{a2}})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `validateFiltersTable(t, lp, orm)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `err = lp.RegisterFilter(ctx, Filter{Name: "Emitter Log 1 + 2 dupe", EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID, EmitterABI.Events["Log2"].ID}, Addresses: []common.Address{a2}})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `validateFiltersTable(t, lp, orm)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `err = lp.RegisterFilter(ctx, Filter{Name: "no address", EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID}})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `err = lp.RegisterFilter(ctx, Filter{Name: "No event", Addresses: []common.Address{a1}})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `validateFiltersTable(t, lp, orm)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `err = lp.UnregisterFilter(ctx, "Filter doesn't exist")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `_, ok = lp.filters["Emitter Log 1 + 2"]`
$DIR/pkg/logpoller/log_poller_internal_test.go: `_, ok = lp.filters["Emitter Log 1 + 2 dupe"]`
$DIR/pkg/logpoller/log_poller_internal_test.go: `err = lp.UnregisterFilter(ctx, "Emitter Log 1 + 2")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `_, ok = lp.filters["Emitter Log 1 + 2"]`
$DIR/pkg/logpoller/log_poller_internal_test.go: `validateFiltersTable(t, lp, orm)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `err = lp.UnregisterFilter(ctx, "Emitter Log 1 + 2 dupe")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `err = lp.UnregisterFilter(ctx, "Emitter Log 1")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run(c.name, func(t *testing.T) {
			logs := convertLogs(c.logs, c.blocks, lggr, big.NewInt(53))
			require.Len(t, logs, c.expected)
			for i := 0; i < c.expected; i++ {
				if len(c.blocks) == 1 {
					assert.Equal(t, c.blocks[0].BlockTimestamp, logs[i].BlockTimestamp)
				} else {
					assert.Equal(t, logs[i].BlockTimestamp, c.blocks[i].BlockTimestamp)
				}
			}
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("assert backup poller (safe tag < finalized < latest)", func(t *testing.T) {
		latestBlock := int64(4)
		const finalityDepth = 2
		head := &evmtypes.Head{Number: latestBlock}
		finalizedHead := &evmtypes.Head{Number: latestBlock - finalityDepth}
		safeHead := &evmtypes.Head{Number: latestBlock - finalityDepth - 1} // forcing safe head to be lower than finalized head
		expectedSafeBlockNumber := finalizedHead.Number
		assertBackupPollerStartup(t, head, finalizedHead, safeHead, finalityDepth, expectedSafeBlockNumber)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `assertBackupPollerStartup(t, head, finalizedHead, safeHead, finalityDepth, expectedSafeBlockNumber)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `assertBackupPollerStartup(t, head, finalizedHead, safeHead, finalityDepth, expectedSafeBlockNumber)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `head.Store(newHead(4))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.EXPECT().HeadByHash(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, hash common.Hash) (*evmtypes.Head, error) {
		return &evmtypes.Head{Number: hash.Big().Int64(), Hash: hash}, nil
	}).Maybe()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.On("HeadByNumber", mock.Anything, mock.Anything).Return(func(context.Context, *big.Int) (*evmtypes.Head, error) {
		return head.Load(), nil
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.On("ConfiguredChainID").Return(chainID, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.On("LatestAndFinalizedBlock", mock.Anything).Return(func(ctx context.Context) (*evmtypes.Head, *evmtypes.Head, error) {
		h := head.Load()
		finalized := newHead(h.Number - lpOpts.FinalityDepth)
		return h, finalized, nil
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.EXPECT().LatestSafeBlock(mock.Anything).Return(safe, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.PollAndSaveLogs(ctx, 4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("abort before replayStart received", func(t *testing.T) {
		// Replay() should abort immediately if caller's context is cancelled before request signal is read
		cancelCtx, cancel := context.WithCancel(testutils.Context(t))
		cancel()
		err := lp.Replay(cancelCtx, 3)
		assert.ErrorIs(t, err, ErrReplayRequestAborted)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `cancel()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("returns error code on replay complete", func(t *testing.T) {
		ctx := testutils.Context(t)
		ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil).Once()
		mockBatchCallContext(t, ec)
		anyErr := pkgerrors.New("any error")
		done := make(chan struct{})
		go func() {
			defer close(done)
			recvStartReplay(ctx, 2)
			lp.replayComplete <- anyErr
		}()
		assert.ErrorIs(t, lp.Replay(ctx, 1), anyErr)
		<-done
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `mockBatchCallContext(t, ec)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `recvStartReplay(ctx, 2)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.replayComplete <- anyErr`
$DIR/pkg/logpoller/log_poller_internal_test.go: `<-done`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("late abort returns ErrReplayInProgress", func(t *testing.T) {
		cancelCtx, cancel := context.WithTimeout(testutils.Context(t), time.Second) // Intentionally abort replay after 1s
		done := make(chan struct{})
		go func() {
			defer close(done)
			recvStartReplay(cancelCtx, 4)
			cancel()
		}()
		assert.ErrorIs(t, lp.Replay(cancelCtx, 4), ErrReplayInProgress)
		<-done
		lp.replayComplete <- nil
		lp.wg.Wait()
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `recvStartReplay(cancelCtx, 4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `cancel()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `<-done`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.replayComplete <- nil`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.wg.Wait()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("client abort doesnt hang run loop", func(t *testing.T) {
		ctx := testutils.Context(t)
		lp.backupPollerNextBlock = 0

		pass := make(chan struct{})
		cancelled := make(chan struct{})

		rctx, rcancel := context.WithCancel(testutils.Context(t))
		var wg sync.WaitGroup
		defer func() { wg.Wait() }()
		ec.On("FilterLogs", mock.Anything, mock.Anything).Once().Return([]types.Log{log1}, nil).Run(func(args mock.Arguments) {
			head.Store(&evmtypes.Head{Number: 4})
			wg.Add(1)
			go func() {
				defer wg.Done()
				assert.ErrorIs(t, lp.Replay(rctx, 4), ErrReplayInProgress)
				close(cancelled)
			}()
		})
		ec.On("FilterLogs", mock.Anything, mock.Anything).Once().Return([]types.Log{log1}, nil).Run(func(args mock.Arguments) {
			rcancel()
			wg.Add(1)
			go func() {
				defer wg.Done()
				select {
				case lp.replayStart <- 4:
					close(pass)
				case <-ctx.Done():
					return
				}
			}()
			// We cannot return until we're sure that Replay() received the cancellation signal,
			// otherwise replayComplete<- might be sent first
			<-cancelled
		})

		ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil).Maybe() // in case task gets delayed by >= 100ms

		head.Store(newHead(5))
		t.Cleanup(lp.reset)
		servicetest.Run(t, lp)

		select {
		case <-ctx.Done():
			t.Errorf("timed out waiting for lp.run() to respond to second replay event")
		case <-pass:
		}
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.backupPollerNextBlock = 0`
$DIR/pkg/logpoller/log_poller_internal_test.go: `wg.Wait()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.On("FilterLogs", mock.Anything, mock.Anything).Once().Return([]types.Log{log1}, nil).Run(func(args mock.Arguments) {
			head.Store(&evmtypes.Head{Number: 4})
			wg.Add(1)
			go func() {
				defer wg.Done()
				assert.ErrorIs(t, lp.Replay(rctx, 4), ErrReplayInProgress)
				close(cancelled)
			}()
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `head.Store(&evmtypes.Head{Number: 4})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `wg.Add(1)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `close(cancelled)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.On("FilterLogs", mock.Anything, mock.Anything).Once().Return([]types.Log{log1}, nil).Run(func(args mock.Arguments) {
			rcancel()
			wg.Add(1)
			go func() {
				defer wg.Done()
				select {
				case lp.replayStart <- 4:
					close(pass)
				case <-ctx.Done():
					return
				}
			}()
			// We cannot return until we're sure that Replay() received the cancellation signal,
			// otherwise replayComplete<- might be sent first
			<-cancelled
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `rcancel()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `wg.Add(1)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `close(pass)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `<-cancelled`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil).Maybe()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `head.Store(newHead(5))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Cleanup(lp.reset)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `servicetest.Run(t, lp)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.On("FilterLogs", mock.Anything, mock.Anything).Unset()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("shutdown during replay", func(t *testing.T) {
		ctx := testutils.Context(t)
		lp.backupPollerNextBlock = 0

		pass := make(chan struct{})
		done := make(chan struct{})
		defer func() { <-done }()

		ec.On("FilterLogs", mock.Anything, mock.Anything).Once().Return([]types.Log{log1}, nil).Run(func(args mock.Arguments) {
			go func() {
				defer close(done)

				head.Store(newHead(4)) // Restore latest block to 4, so this matches the fromBlock requested
				select {
				case lp.replayStart <- 4:
				case <-ctx.Done():
				}
			}()
		})
		ec.On("FilterLogs", mock.Anything, mock.Anything).Once().Return([]types.Log{log1}, nil).Run(func(args mock.Arguments) {
			go func() {
				assert.NoError(t, lp.Close())

				// prevent double close
				lp.reset()
				assert.NoError(t, lp.Start(ctx))

				close(pass)
			}()
		})
		ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil)

		t.Cleanup(lp.reset)
		head.Store(newHead(6)) // Latest block must be > lastProcessed in order for SaveAndPollLogs() to call FilterLogs()
		servicetest.Run(t, lp)

		select {
		case <-ctx.Done():
			t.Error("timed out waiting for lp.run() to respond to shutdown event during replay")
		case <-pass:
		}
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.backupPollerNextBlock = 0`
$DIR/pkg/logpoller/log_poller_internal_test.go: `<-done`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.On("FilterLogs", mock.Anything, mock.Anything).Once().Return([]types.Log{log1}, nil).Run(func(args mock.Arguments) {
			go func() {
				defer close(done)

				head.Store(newHead(4)) // Restore latest block to 4, so this matches the fromBlock requested
				select {
				case lp.replayStart <- 4:
				case <-ctx.Done():
				}
			}()
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `head.Store(newHead(4))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `select {
				case lp.replayStart <- 4:
				case <-ctx.Done():
				}`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.On("FilterLogs", mock.Anything, mock.Anything).Once().Return([]types.Log{log1}, nil).Run(func(args mock.Arguments) {
			go func() {
				assert.NoError(t, lp.Close())

				// prevent double close
				lp.reset()
				assert.NoError(t, lp.Start(ctx))

				close(pass)
			}()
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.reset()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `close(pass)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Cleanup(lp.reset)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `head.Store(newHead(6))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `servicetest.Run(t, lp)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("ReplayAsync success", func(t *testing.T) {
		t.Cleanup(lp.reset)

		head.Store(&evmtypes.Head{Number: 5})
		ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil)
		mockBatchCallContext(t, ec)
		servicetest.Run(t, lp)

		lp.ReplayAsync(1)

		recvStartReplay(testutils.Context(t), 4)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Cleanup(lp.reset)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `head.Store(&evmtypes.Head{Number: 5})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `mockBatchCallContext(t, ec)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `servicetest.Run(t, lp)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.ReplayAsync(1)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `recvStartReplay(testutils.Context(t), 4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("ReplayAsync error", func(t *testing.T) {
		ctx := testutils.Context(t)
		t.Cleanup(lp.reset)
		servicetest.Run(t, lp)
		head.Store(&evmtypes.Head{Number: 4})

		anyErr := pkgerrors.New("async error")
		observedLogs.TakeAll()

		lp.ReplayAsync(4)
		recvStartReplay(testutils.Context(t), 4)

		select {
		case lp.replayComplete <- anyErr:
			time.Sleep(2 * time.Second)
		case <-ctx.Done():
			t.Error("timed out waiting to send replaceComplete")
		}
		require.Equal(t, 1, observedLogs.Len())
		assert.Equal(t, observedLogs.All()[0].Message, anyErr.Error())
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Cleanup(lp.reset)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `servicetest.Run(t, lp)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `head.Store(&evmtypes.Head{Number: 4})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `observedLogs.TakeAll()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.ReplayAsync(4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `recvStartReplay(testutils.Context(t), 4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `time.Sleep(2 * time.Second)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("run regular replay when there are not blocks in db", func(t *testing.T) {
		ctx := testutils.Context(t)
		err := lp.orm.DeleteLogsAndBlocksAfter(ctx, 0)
		require.NoError(t, err)

		lp.ReplayAsync(1)
		recvStartReplay(testutils.Context(t), 1)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.ReplayAsync(1)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `recvStartReplay(testutils.Context(t), 1)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `err = lp.orm.InsertBlock(ctx, common.BigToHash(big.NewInt(h.Number)), h.Number, h.Timestamp, h.Number, h.Number)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `mockBatchCallContext(t, ec)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `err = lp.Replay(ctx, 1)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("headTracker returns an error", func(t *testing.T) {
		headTracker := headstest.NewTracker[*evmtypes.Head, common.Hash](t)
		const expectedError = "finalized block is not available yet"
		headTracker.On("LatestAndFinalizedBlock", mock.Anything).Return(&evmtypes.Head{}, &evmtypes.Head{}, errors.New(expectedError))

		lp := NewLogPoller(nil, nil, lggr, headTracker, lpOpts)
		_, _, err := lp.latestBlocks(t.Context())
		require.ErrorContains(t, err, expectedError)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.On("LatestAndFinalizedBlock", mock.Anything).Return(&evmtypes.Head{}, &evmtypes.Head{}, errors.New(expectedError))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `finalizedBlock.IsFinalized.Store(true)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.On("LatestAndFinalizedBlock", mock.Anything).Return(head, finalizedBlock, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("headTracker returns an error", func(t *testing.T) {
		headTracker := headstest.NewTracker[*evmtypes.Head, common.Hash](t)
		const expectedError = "safe block is not available yet"
		headTracker.On("LatestSafeBlock", mock.Anything).Return(&evmtypes.Head{}, errors.New(expectedError))

		lp := NewLogPoller(nil, nil, lggr, headTracker, lpOpts)
		_, err := lp.latestSafeBlock(t.Context(), 0)
		require.ErrorContains(t, err, expectedError)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.On("LatestSafeBlock", mock.Anything).Return(&evmtypes.Head{}, errors.New(expectedError))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("headTracker returns valid chain", func(t *testing.T) {
		headTracker := headstest.NewTracker[*evmtypes.Head, common.Hash](t)
		safeBlock := &evmtypes.Head{Number: 2}
		headTracker.On("LatestSafeBlock", mock.Anything).Return(safeBlock, nil)

		lp := NewLogPoller(nil, nil, lggr, headTracker, lpOpts)
		safeBlockNumber, err := lp.latestSafeBlock(t.Context(), 1)
		require.NoError(t, err)
		assert.Equal(t, safeBlock.Number, safeBlockNumber)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.On("LatestSafeBlock", mock.Anything).Return(safeBlock, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.On("LatestSafeBlock", mock.Anything).Return(safeBlock, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `mockBatchCallContext(t, ec)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `blockValidationReq = finalizedBlock`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run(fmt.Sprintf("%s where useFinalityTag=%t", tc.name, lp.useFinalityTag), func(t *testing.T) {
				blocks, err := lp.fetchBlocks(ctx, tc.blocksRequested, blockValidationReq, tc.chainReference)
				if tc.expectedErr != nil {
					require.Equal(t, err.Error(), tc.expectedErr.Error())
					return // PASS
				}
				require.NoError(t, err)
				for _, blockRequested := range tc.blocksRequested {
					assert.Equal(t, blockRequested, uint64(blocks[blockRequested].Number)) //nolint:gosec // G115
				}
			})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("Finalized DB block is not present in RPC's chain", func(t *testing.T) {
		lggr, _ := logger.TestObserved(t, zapcore.ErrorLevel)
		orm := NewORM(testutils.NewRandomEVMChainID(), db, lggr)
		headTracker := headstest.NewTracker[*evmtypes.Head, common.Hash](t)
		finalized := newHead(5)
		latest := newHead(16)
		headTracker.EXPECT().LatestAndFinalizedBlock(mock.Anything).RunAndReturn(func(ctx context.Context) (*evmtypes.Head, *evmtypes.Head, error) {
			return latest, finalized, nil
		}).Once()
		headTracker.EXPECT().LatestSafeBlock(mock.Anything).Return(finalized, nil).Once()
		ec := clienttest.NewClient(t)
		ec.EXPECT().HeadByNumber(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})
		ec.EXPECT().FilterLogs(mock.Anything, mock.Anything).Return([]types.Log{{BlockNumber: 5}}, nil).Once()
		mockBatchCallContext(t, ec)
		// insert finalized block with different hash than in RPC
		require.NoError(t, orm.InsertBlock(t.Context(), common.HexToHash("0x123"), 2, time.Unix(10, 0), 2, 2))
		lp := NewLogPoller(orm, ec, lggr, headTracker, lpOpts)
		lp.PollAndSaveLogs(t.Context(), 4)
		require.ErrorIs(t, lp.HealthReport()[lp.Name()], commontypes.ErrFinalityViolated)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.EXPECT().LatestAndFinalizedBlock(mock.Anything).RunAndReturn(func(ctx context.Context) (*evmtypes.Head, *evmtypes.Head, error) {
			return latest, finalized, nil
		}).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.EXPECT().LatestSafeBlock(mock.Anything).Return(finalized, nil).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.EXPECT().HeadByNumber(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.EXPECT().FilterLogs(mock.Anything, mock.Anything).Return([]types.Log{{BlockNumber: 5}}, nil).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `mockBatchCallContext(t, ec)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.PollAndSaveLogs(t.Context(), 4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("RPCs contradict each other and return different finalized blocks", func(t *testing.T) {
		lggr, _ := logger.TestObserved(t, zapcore.ErrorLevel)
		orm := NewORM(testutils.NewRandomEVMChainID(), db, lggr)
		headTracker := headstest.NewTracker[*evmtypes.Head, common.Hash](t)
		finalized := newHead(5)
		latest := newHead(16)
		headTracker.EXPECT().LatestAndFinalizedBlock(mock.Anything).Return(latest, finalized, nil).Once()
		headTracker.EXPECT().LatestSafeBlock(mock.Anything).Return(finalized, nil).Once()
		ec := clienttest.NewClient(t)
		ec.EXPECT().HeadByNumber(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})
		ec.EXPECT().FilterLogs(mock.Anything, mock.Anything).Return([]types.Log{{BlockNumber: 5}}, nil).Once()
		mockBatchCallContextWithHead(t, ec, func(num int64) evmtypes.Head {
			// return new hash for every call
			return evmtypes.Head{Number: num, Hash: utils.NewHash()}
		})
		lp := NewLogPoller(orm, ec, lggr, headTracker, lpOpts)
		lp.PollAndSaveLogs(t.Context(), 4)
		require.ErrorIs(t, lp.HealthReport()[lp.Name()], commontypes.ErrFinalityViolated)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.EXPECT().LatestAndFinalizedBlock(mock.Anything).Return(latest, finalized, nil).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.EXPECT().LatestSafeBlock(mock.Anything).Return(finalized, nil).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.EXPECT().HeadByNumber(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.EXPECT().FilterLogs(mock.Anything, mock.Anything).Return([]types.Log{{BlockNumber: 5}}, nil).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `mockBatchCallContextWithHead(t, ec, func(num int64) evmtypes.Head {
			// return new hash for every call
			return evmtypes.Head{Number: num, Hash: utils.NewHash()}
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.PollAndSaveLogs(t.Context(), 4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `t.Run("Log's hash does not match block's", func(t *testing.T) {
		lggr, _ := logger.TestObserved(t, zapcore.ErrorLevel)
		orm := NewORM(testutils.NewRandomEVMChainID(), db, lggr)
		headTracker := headstest.NewTracker[*evmtypes.Head, common.Hash](t)
		finalized := newHead(5)
		latest := newHead(16)
		headTracker.EXPECT().LatestAndFinalizedBlock(mock.Anything).Return(latest, finalized, nil).Once()
		headTracker.EXPECT().LatestSafeBlock(mock.Anything).Return(finalized, nil).Once()
		ec := clienttest.NewClient(t)
		ec.EXPECT().HeadByNumber(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})
		ec.EXPECT().FilterLogs(mock.Anything, mock.Anything).Return([]types.Log{{BlockNumber: 5, BlockHash: common.HexToHash("0x123")}}, nil).Once()
		mockBatchCallContext(t, ec)
		lp := NewLogPoller(orm, ec, lggr, headTracker, lpOpts)
		lp.PollAndSaveLogs(t.Context(), 4)
		require.ErrorIs(t, lp.HealthReport()[lp.Name()], commontypes.ErrFinalityViolated)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.EXPECT().LatestAndFinalizedBlock(mock.Anything).Return(latest, finalized, nil).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.EXPECT().LatestSafeBlock(mock.Anything).Return(finalized, nil).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.EXPECT().HeadByNumber(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.EXPECT().FilterLogs(mock.Anything, mock.Anything).Return([]types.Log{{BlockNumber: 5, BlockHash: common.HexToHash("0x123")}}, nil).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `mockBatchCallContext(t, ec)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.PollAndSaveLogs(t.Context(), 4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.EXPECT().LatestAndFinalizedBlock(mock.Anything).Return(latest, finalized, nil).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `headTracker.EXPECT().LatestSafeBlock(mock.Anything).Return(finalized, nil).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.EXPECT().ConfiguredChainID().Return(chainID)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.EXPECT().HeadByNumber(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `ec.EXPECT().FilterLogs(mock.Anything, mock.Anything).Return([]types.Log{{BlockNumber: 5, BlockHash: common.BigToHash(big.NewInt(5)), Topics: []common.Hash{{}}}}, nil).Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `mockBatchCallContext(t, ec)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `lp.PollAndSaveLogs(t.Context(), 4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.HexToAddress("0x2ab9a2dc53736b361b72d900cdf9f78f9406fbbb")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.HexToAddress("0x2ab9a2dc53736b361b72d900cdf9f78f9406fbbc")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.TestObserved(t, zapcore.InfoLevel)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewSqlxDB(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Filter(nil, nil, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.RegisterFilter(ctx, Filter{Name: "Emitter Log 1", EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID}, Addresses: []common.Address{a1}})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.RegisterFilter(ctx, Filter{Name: "Emitter Log 1 + 2", EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID, EmitterABI.Events["Log2"].ID}, Addresses: []common.Address{a2}})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.RegisterFilter(ctx, Filter{Name: "Emitter Log 1 + 2 dupe", EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID, EmitterABI.Events["Log2"].ID}, Addresses: []common.Address{a2}})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.RegisterFilter(ctx, Filter{Name: "no address", EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID}})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.RegisterFilter(ctx, Filter{Name: "No event", Addresses: []common.Address{a1}})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.UnregisterFilter(ctx, "Filter doesn't exist")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.UnregisterFilter(ctx, "Emitter Log 1 + 2")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.UnregisterFilter(ctx, "Emitter Log 1 + 2 dupe")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.UnregisterFilter(ctx, "Emitter Log 1")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.orm.LoadFilters(ctx)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Filter(nil, nil, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Test(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Now()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Now()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run(c.name, func(t *testing.T) {
			logs := convertLogs(c.logs, c.blocks, lggr, big.NewInt(53))
			require.Len(t, logs, c.expected)
			for i := 0; i < c.expected; i++ {
				if len(c.blocks) == 1 {
					assert.Equal(t, c.blocks[0].BlockTimestamp, logs[i].BlockTimestamp)
				} else {
					assert.Equal(t, logs[i].BlockTimestamp, c.blocks[i].BlockTimestamp)
				}
			}
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewInt(53)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("assert backup poller (safe tag < finalized < latest)", func(t *testing.T) {
		latestBlock := int64(4)
		const finalityDepth = 2
		head := &evmtypes.Head{Number: latestBlock}
		finalizedHead := &evmtypes.Head{Number: latestBlock - finalityDepth}
		safeHead := &evmtypes.Head{Number: latestBlock - finalityDepth - 1} // forcing safe head to be lower than finalized head
		expectedSafeBlockNumber := finalizedHead.Number
		assertBackupPollerStartup(t, head, finalizedHead, safeHead, finalityDepth, expectedSafeBlockNumber)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.HexToAddress("0x2ab9a2dc53736b361b72d900cdf9f78f9406fbbc")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.TestObserved(t, zapcore.ErrorLevel)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewSqlxDB(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Store(newHead(4))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.BigToHash(big.NewInt(head.Load().Number))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewInt(head.Load().Number)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Load()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Load()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.HexToHash("0x1234")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Bytes()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewClient(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.HeadByHash(mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.RunAndReturn(func(ctx context.Context, hash common.Hash) (*evmtypes.Head, error) {
		return &evmtypes.Head{Number: hash.Big().Int64(), Hash: hash}, nil
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Big()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Int64()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Maybe()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(func(context.Context, *big.Int) (*evmtypes.Head, error) {
		return head.Load(), nil
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Load()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{log1}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("ConfiguredChainID")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(chainID, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("LatestAndFinalizedBlock", mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(func(ctx context.Context) (*evmtypes.Head, *evmtypes.Head, error) {
		h := head.Load()
		finalized := newHead(h.Number - lpOpts.FinalityDepth)
		return h, finalized, nil
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Load()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.LatestSafeBlock(mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(safe, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.PollAndSaveLogs(ctx, 4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.LatestBlock(ctx)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("abort before replayStart received", func(t *testing.T) {
		// Replay() should abort immediately if caller's context is cancelled before request signal is read
		cancelCtx, cancel := context.WithCancel(testutils.Context(t))
		cancel()
		err := lp.Replay(cancelCtx, 3)
		assert.ErrorIs(t, err, ErrReplayRequestAborted)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.WithCancel(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Replay(cancelCtx, 3)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Done()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("returns error code on replay complete", func(t *testing.T) {
		ctx := testutils.Context(t)
		ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil).Once()
		mockBatchCallContext(t, ec)
		anyErr := pkgerrors.New("any error")
		done := make(chan struct{})
		go func() {
			defer close(done)
			recvStartReplay(ctx, 2)
			lp.replayComplete <- anyErr
		}()
		assert.ErrorIs(t, lp.Replay(ctx, 1), anyErr)
		<-done
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{log1}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.New("any error")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("late abort returns ErrReplayInProgress", func(t *testing.T) {
		cancelCtx, cancel := context.WithTimeout(testutils.Context(t), time.Second) // Intentionally abort replay after 1s
		done := make(chan struct{})
		go func() {
			defer close(done)
			recvStartReplay(cancelCtx, 4)
			cancel()
		}()
		assert.ErrorIs(t, lp.Replay(cancelCtx, 4), ErrReplayInProgress)
		<-done
		lp.replayComplete <- nil
		lp.wg.Wait()
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.WithTimeout(testutils.Context(t), time.Second)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.wg.Wait()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("client abort doesnt hang run loop", func(t *testing.T) {
		ctx := testutils.Context(t)
		lp.backupPollerNextBlock = 0

		pass := make(chan struct{})
		cancelled := make(chan struct{})

		rctx, rcancel := context.WithCancel(testutils.Context(t))
		var wg sync.WaitGroup
		defer func() { wg.Wait() }()
		ec.On("FilterLogs", mock.Anything, mock.Anything).Once().Return([]types.Log{log1}, nil).Run(func(args mock.Arguments) {
			head.Store(&evmtypes.Head{Number: 4})
			wg.Add(1)
			go func() {
				defer wg.Done()
				assert.ErrorIs(t, lp.Replay(rctx, 4), ErrReplayInProgress)
				close(cancelled)
			}()
		})
		ec.On("FilterLogs", mock.Anything, mock.Anything).Once().Return([]types.Log{log1}, nil).Run(func(args mock.Arguments) {
			rcancel()
			wg.Add(1)
			go func() {
				defer wg.Done()
				select {
				case lp.replayStart <- 4:
					close(pass)
				case <-ctx.Done():
					return
				}
			}()
			// We cannot return until we're sure that Replay() received the cancellation signal,
			// otherwise replayComplete<- might be sent first
			<-cancelled
		})

		ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil).Maybe() // in case task gets delayed by >= 100ms

		head.Store(newHead(5))
		t.Cleanup(lp.reset)
		servicetest.Run(t, lp)

		select {
		case <-ctx.Done():
			t.Errorf("timed out waiting for lp.run() to respond to second replay event")
		case <-pass:
		}
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.WithCancel(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Wait()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{log1}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run(func(args mock.Arguments) {
			head.Store(&evmtypes.Head{Number: 4})
			wg.Add(1)
			go func() {
				defer wg.Done()
				assert.ErrorIs(t, lp.Replay(rctx, 4), ErrReplayInProgress)
				close(cancelled)
			}()
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Store(&evmtypes.Head{Number: 4})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Add(1)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Done()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{log1}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run(func(args mock.Arguments) {
			rcancel()
			wg.Add(1)
			go func() {
				defer wg.Done()
				select {
				case lp.replayStart <- 4:
					close(pass)
				case <-ctx.Done():
					return
				}
			}()
			// We cannot return until we're sure that Replay() received the cancellation signal,
			// otherwise replayComplete<- might be sent first
			<-cancelled
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Add(1)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Done()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Done()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{log1}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Maybe()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Store(newHead(5))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Cleanup(lp.reset)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run(t, lp)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Done()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Unset()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("shutdown during replay", func(t *testing.T) {
		ctx := testutils.Context(t)
		lp.backupPollerNextBlock = 0

		pass := make(chan struct{})
		done := make(chan struct{})
		defer func() { <-done }()

		ec.On("FilterLogs", mock.Anything, mock.Anything).Once().Return([]types.Log{log1}, nil).Run(func(args mock.Arguments) {
			go func() {
				defer close(done)

				head.Store(newHead(4)) // Restore latest block to 4, so this matches the fromBlock requested
				select {
				case lp.replayStart <- 4:
				case <-ctx.Done():
				}
			}()
		})
		ec.On("FilterLogs", mock.Anything, mock.Anything).Once().Return([]types.Log{log1}, nil).Run(func(args mock.Arguments) {
			go func() {
				assert.NoError(t, lp.Close())

				// prevent double close
				lp.reset()
				assert.NoError(t, lp.Start(ctx))

				close(pass)
			}()
		})
		ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil)

		t.Cleanup(lp.reset)
		head.Store(newHead(6)) // Latest block must be > lastProcessed in order for SaveAndPollLogs() to call FilterLogs()
		servicetest.Run(t, lp)

		select {
		case <-ctx.Done():
			t.Error("timed out waiting for lp.run() to respond to shutdown event during replay")
		case <-pass:
		}
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{log1}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run(func(args mock.Arguments) {
			go func() {
				defer close(done)

				head.Store(newHead(4)) // Restore latest block to 4, so this matches the fromBlock requested
				select {
				case lp.replayStart <- 4:
				case <-ctx.Done():
				}
			}()
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Store(newHead(4))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Done()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{log1}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run(func(args mock.Arguments) {
			go func() {
				assert.NoError(t, lp.Close())

				// prevent double close
				lp.reset()
				assert.NoError(t, lp.Start(ctx))

				close(pass)
			}()
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.reset()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{log1}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Cleanup(lp.reset)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Store(newHead(6))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run(t, lp)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Done()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("ReplayAsync success", func(t *testing.T) {
		t.Cleanup(lp.reset)

		head.Store(&evmtypes.Head{Number: 5})
		ec.On("FilterLogs", mock.Anything, mock.Anything).Return([]types.Log{log1}, nil)
		mockBatchCallContext(t, ec)
		servicetest.Run(t, lp)

		lp.ReplayAsync(1)

		recvStartReplay(testutils.Context(t), 4)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Cleanup(lp.reset)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Store(&evmtypes.Head{Number: 5})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{log1}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run(t, lp)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.ReplayAsync(1)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("ReplayAsync error", func(t *testing.T) {
		ctx := testutils.Context(t)
		t.Cleanup(lp.reset)
		servicetest.Run(t, lp)
		head.Store(&evmtypes.Head{Number: 4})

		anyErr := pkgerrors.New("async error")
		observedLogs.TakeAll()

		lp.ReplayAsync(4)
		recvStartReplay(testutils.Context(t), 4)

		select {
		case lp.replayComplete <- anyErr:
			time.Sleep(2 * time.Second)
		case <-ctx.Done():
			t.Error("timed out waiting to send replaceComplete")
		}
		require.Equal(t, 1, observedLogs.Len())
		assert.Equal(t, observedLogs.All()[0].Message, anyErr.Error())
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Cleanup(lp.reset)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run(t, lp)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Store(&evmtypes.Head{Number: 4})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.New("async error")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.TakeAll()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.ReplayAsync(4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Sleep(2 * time.Second)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Done()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("run regular replay when there are not blocks in db", func(t *testing.T) {
		ctx := testutils.Context(t)
		err := lp.orm.DeleteLogsAndBlocksAfter(ctx, 0)
		require.NoError(t, err)

		lp.ReplayAsync(1)
		recvStartReplay(testutils.Context(t), 1)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.orm.DeleteLogsAndBlocksAfter(ctx, 0)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.ReplayAsync(1)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.orm.DeleteLogsAndBlocksAfter(ctx, 0)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Load()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.orm.InsertBlock(ctx, common.BigToHash(big.NewInt(h.Number)), h.Number, h.Timestamp, h.Number, h.Number)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.BigToHash(big.NewInt(h.Number))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewInt(h.Number)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{log1}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Replay(ctx, 1)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Test(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("headTracker returns an error", func(t *testing.T) {
		headTracker := headstest.NewTracker[*evmtypes.Head, common.Hash](t)
		const expectedError = "finalized block is not available yet"
		headTracker.On("LatestAndFinalizedBlock", mock.Anything).Return(&evmtypes.Head{}, &evmtypes.Head{}, errors.New(expectedError))

		lp := NewLogPoller(nil, nil, lggr, headTracker, lpOpts)
		_, _, err := lp.latestBlocks(t.Context())
		require.ErrorContains(t, err, expectedError)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("LatestAndFinalizedBlock", mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(&evmtypes.Head{}, &evmtypes.Head{}, errors.New(expectedError))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.New(expectedError)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.latestBlocks(t.Context())`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("LatestAndFinalizedBlock", mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(head, finalizedBlock, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.latestBlocks(t.Context())`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Test(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("headTracker returns an error", func(t *testing.T) {
		headTracker := headstest.NewTracker[*evmtypes.Head, common.Hash](t)
		const expectedError = "safe block is not available yet"
		headTracker.On("LatestSafeBlock", mock.Anything).Return(&evmtypes.Head{}, errors.New(expectedError))

		lp := NewLogPoller(nil, nil, lggr, headTracker, lpOpts)
		_, err := lp.latestSafeBlock(t.Context(), 0)
		require.ErrorContains(t, err, expectedError)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("LatestSafeBlock", mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(&evmtypes.Head{}, errors.New(expectedError))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.New(expectedError)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.latestSafeBlock(t.Context(), 0)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("headTracker returns valid chain", func(t *testing.T) {
		headTracker := headstest.NewTracker[*evmtypes.Head, common.Hash](t)
		safeBlock := &evmtypes.Head{Number: 2}
		headTracker.On("LatestSafeBlock", mock.Anything).Return(safeBlock, nil)

		lp := NewLogPoller(nil, nil, lggr, headTracker, lpOpts)
		safeBlockNumber, err := lp.latestSafeBlock(t.Context(), 1)
		require.NoError(t, err)
		assert.Equal(t, safeBlock.Number, safeBlockNumber)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("LatestSafeBlock", mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(safeBlock, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.latestSafeBlock(t.Context(), 1)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.On("LatestSafeBlock", mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(safeBlock, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.latestSafeBlock(t.Context(), latestFinalizedBlockNumber)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Test(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewSqlxDB(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewClient(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.New("received unfinalized block 8 while expecting finalized block (latestFinalizedBlockNumber = 5)")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.BigToHash(big.NewInt(2))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewInt(2)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.New("expected RPC's finalized block hash at hegiht 1 to be 0x0000000000000000000000000000000000000000000000000000000000000002 but got 0x0000000000000000000000000000000000000000000000000000000000000001: finality violated")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.BigToHash(big.NewInt(1))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run(fmt.Sprintf("%s where useFinalityTag=%t", tc.name, lp.useFinalityTag), func(t *testing.T) {
				blocks, err := lp.fetchBlocks(ctx, tc.blocksRequested, blockValidationReq, tc.chainReference)
				if tc.expectedErr != nil {
					require.Equal(t, err.Error(), tc.expectedErr.Error())
					return // PASS
				}
				require.NoError(t, err)
				for _, blockRequested := range tc.blocksRequested {
					assert.Equal(t, blockRequested, uint64(blocks[blockRequested].Number)) //nolint:gosec // G115
				}
			})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Sprintf("%s where useFinalityTag=%t", tc.name, lp.useFinalityTag)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.fetchBlocks(ctx, tc.blocksRequested, blockValidationReq, tc.chainReference)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewSqlxDB(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("Finalized DB block is not present in RPC's chain", func(t *testing.T) {
		lggr, _ := logger.TestObserved(t, zapcore.ErrorLevel)
		orm := NewORM(testutils.NewRandomEVMChainID(), db, lggr)
		headTracker := headstest.NewTracker[*evmtypes.Head, common.Hash](t)
		finalized := newHead(5)
		latest := newHead(16)
		headTracker.EXPECT().LatestAndFinalizedBlock(mock.Anything).RunAndReturn(func(ctx context.Context) (*evmtypes.Head, *evmtypes.Head, error) {
			return latest, finalized, nil
		}).Once()
		headTracker.EXPECT().LatestSafeBlock(mock.Anything).Return(finalized, nil).Once()
		ec := clienttest.NewClient(t)
		ec.EXPECT().HeadByNumber(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})
		ec.EXPECT().FilterLogs(mock.Anything, mock.Anything).Return([]types.Log{{BlockNumber: 5}}, nil).Once()
		mockBatchCallContext(t, ec)
		// insert finalized block with different hash than in RPC
		require.NoError(t, orm.InsertBlock(t.Context(), common.HexToHash("0x123"), 2, time.Unix(10, 0), 2, 2))
		lp := NewLogPoller(orm, ec, lggr, headTracker, lpOpts)
		lp.PollAndSaveLogs(t.Context(), 4)
		require.ErrorIs(t, lp.HealthReport()[lp.Name()], commontypes.ErrFinalityViolated)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.TestObserved(t, zapcore.ErrorLevel)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.LatestAndFinalizedBlock(mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.RunAndReturn(func(ctx context.Context) (*evmtypes.Head, *evmtypes.Head, error) {
			return latest, finalized, nil
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.LatestSafeBlock(mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(finalized, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewClient(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.HeadByNumber(mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Int64()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.FilterLogs(mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{{BlockNumber: 5}}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.PollAndSaveLogs(t.Context(), 4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("RPCs contradict each other and return different finalized blocks", func(t *testing.T) {
		lggr, _ := logger.TestObserved(t, zapcore.ErrorLevel)
		orm := NewORM(testutils.NewRandomEVMChainID(), db, lggr)
		headTracker := headstest.NewTracker[*evmtypes.Head, common.Hash](t)
		finalized := newHead(5)
		latest := newHead(16)
		headTracker.EXPECT().LatestAndFinalizedBlock(mock.Anything).Return(latest, finalized, nil).Once()
		headTracker.EXPECT().LatestSafeBlock(mock.Anything).Return(finalized, nil).Once()
		ec := clienttest.NewClient(t)
		ec.EXPECT().HeadByNumber(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})
		ec.EXPECT().FilterLogs(mock.Anything, mock.Anything).Return([]types.Log{{BlockNumber: 5}}, nil).Once()
		mockBatchCallContextWithHead(t, ec, func(num int64) evmtypes.Head {
			// return new hash for every call
			return evmtypes.Head{Number: num, Hash: utils.NewHash()}
		})
		lp := NewLogPoller(orm, ec, lggr, headTracker, lpOpts)
		lp.PollAndSaveLogs(t.Context(), 4)
		require.ErrorIs(t, lp.HealthReport()[lp.Name()], commontypes.ErrFinalityViolated)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.TestObserved(t, zapcore.ErrorLevel)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.LatestAndFinalizedBlock(mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(latest, finalized, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.LatestSafeBlock(mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(finalized, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewClient(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.HeadByNumber(mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Int64()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.FilterLogs(mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{{BlockNumber: 5}}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewHash()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.PollAndSaveLogs(t.Context(), 4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Run("Log's hash does not match block's", func(t *testing.T) {
		lggr, _ := logger.TestObserved(t, zapcore.ErrorLevel)
		orm := NewORM(testutils.NewRandomEVMChainID(), db, lggr)
		headTracker := headstest.NewTracker[*evmtypes.Head, common.Hash](t)
		finalized := newHead(5)
		latest := newHead(16)
		headTracker.EXPECT().LatestAndFinalizedBlock(mock.Anything).Return(latest, finalized, nil).Once()
		headTracker.EXPECT().LatestSafeBlock(mock.Anything).Return(finalized, nil).Once()
		ec := clienttest.NewClient(t)
		ec.EXPECT().HeadByNumber(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})
		ec.EXPECT().FilterLogs(mock.Anything, mock.Anything).Return([]types.Log{{BlockNumber: 5, BlockHash: common.HexToHash("0x123")}}, nil).Once()
		mockBatchCallContext(t, ec)
		lp := NewLogPoller(orm, ec, lggr, headTracker, lpOpts)
		lp.PollAndSaveLogs(t.Context(), 4)
		require.ErrorIs(t, lp.HealthReport()[lp.Name()], commontypes.ErrFinalityViolated)
	})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.TestObserved(t, zapcore.ErrorLevel)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.LatestAndFinalizedBlock(mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(latest, finalized, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.LatestSafeBlock(mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(finalized, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewClient(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.HeadByNumber(mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Int64()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.FilterLogs(mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{{BlockNumber: 5, BlockHash: common.HexToHash("0x123")}}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.HexToHash("0x123")`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.PollAndSaveLogs(t.Context(), 4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.TestObserved(t, zapcore.ErrorLevel)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.LatestAndFinalizedBlock(mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(latest, finalized, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.LatestSafeBlock(mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(finalized, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewClient(t)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.ConfiguredChainID()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return(chainID)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.HeadByNumber(mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.RunAndReturn(func(ctx context.Context, number *big.Int) (*evmtypes.Head, error) {
			return newHead(number.Int64()), nil
		})`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Int64()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.EXPECT()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.FilterLogs(mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Return([]types.Log{{BlockNumber: 5, BlockHash: common.BigToHash(big.NewInt(5)), Topics: []common.Hash{{}}}}, nil)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.BigToHash(big.NewInt(5))`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.NewInt(5)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.PollAndSaveLogs(t.Context(), 4)`
$DIR/pkg/logpoller/log_poller_internal_test.go: `.Context()`
$DIR/pkg/logpoller/log_poller_test.go: `func() {
		defer logRuntime(t, time.Now())
		_, err1 := o.SelectLogs(ctx, 750000, 800000, address1, event1)
		require.NoError(t, err1)
	}()`
$DIR/pkg/logpoller/log_poller_test.go: `func() {
		defer logRuntime(t, time.Now())
		_, err1 := o.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0, []common.Address{address1}, []common.Hash{event1}, 0)
		require.NoError(t, err1)
	}()`
$DIR/pkg/logpoller/log_poller_test.go: `func() {
		defer logRuntime(t, time.Now())
		lgs, err1 := o.SelectLogsDataWordRange(ctx, address1, event1, 0, logpoller.EvmWord(50000), logpoller.EvmWord(50020), 0)
		require.NoError(t, err1)
		// 10 since every other log is for address1
		require.Len(t, lgs, 10)
	}()`
$DIR/pkg/logpoller/log_poller_test.go: `func() {
		defer logRuntime(t, time.Now())
		lgs, err1 := o.SelectIndexedLogs(ctx, address2, event1, 1, []common.Hash{logpoller.EvmWord(50000), logpoller.EvmWord(50020)}, 0)
		require.NoError(t, err1)
		require.Len(t, lgs, 2)
	}()`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `_, err1 = th.Emitter1.EmitLog2(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `testutils.RequireEventually(t, func() bool {
		l, err2 := th.LogPoller.Logs(ctx, 3, 3, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)
		require.NoError(t, err2)
		return len(l) == 1
	})`
$DIR/pkg/logpoller/log_poller_test.go: `err = th.LogPoller.RegisterFilter(ctx, logpoller.Filter{
		Name:      "Emitter - log2",
		EventSigs: []common.Hash{EmitterABI.Events["Log2"].ID},
		Addresses: []common.Address{th.EmitterAddress1},
	})`
$DIR/pkg/logpoller/log_poller_test.go: `logs, err = th.LogPoller.Logs(ctx, 2, 7, EmitterABI.Events["Log2"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `logs, err = th.LogPoller.Logs(ctx, 2, 7, EmitterABI.Events["Log2"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `cancel()`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run(tt.name, func(t *testing.T) {
			th := SetupTH(t,
				logpoller.Opts{
					UseFinalityTag:           tt.finalityTag,
					FinalityDepth:            tt.finalityDepth,
					BackfillBatchSize:        3,
					RPCBatchSize:             2,
					KeepFinalizedBlocksDepth: 1000,
					BackupPollerBlockDelay:   100,
				},
			)

			ctx := testutils.Context(t)

			filter1 := logpoller.Filter{
				Name: "filter1",
				EventSigs: []common.Hash{
					EmitterABI.Events["Log1"].ID,
					EmitterABI.Events["Log2"].ID},
				Addresses: []common.Address{th.EmitterAddress1},
			}
			err := th.LogPoller.RegisterFilter(ctx, filter1)
			require.NoError(t, err)

			filters, err := th.ORM.LoadFilters(ctx)
			require.NoError(t, err)
			require.Len(t, filters, 1)
			require.Equal(t, filter1, filters["filter1"])

			err = th.LogPoller.RegisterFilter(ctx,
				logpoller.Filter{
					Name:      "filter2",
					EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
					Addresses: []common.Address{th.EmitterAddress2},
				})
			require.NoError(t, err)

			defer func() {
				assert.NoError(t, th.LogPoller.UnregisterFilter(ctx, "filter1"))
			}()
			defer func() {
				assert.NoError(t, th.LogPoller.UnregisterFilter(ctx, "filter2"))
			}()

			for n := 1; n < 31; n++ {
				h := th.Backend.Commit()
				require.Len(t, h, 32)
			}

			// generate some tx's with logs
			tx1, err := th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})
			require.NoError(t, err)
			require.NotNil(t, tx1)

			tx2, err := th.Emitter1.EmitLog2(th.Owner, []*big.Int{big.NewInt(2)})
			require.NoError(t, err)
			require.NotNil(t, tx2)

			tx3, err := th.Emitter2.EmitLog1(th.Owner, []*big.Int{big.NewInt(3)})
			require.NoError(t, err)
			require.NotNil(t, tx3)

			th.Backend.Commit() // commit block 32 with 3 tx's included

			block32, err := th.Client.BlockByNumber(ctx, nil)
			require.NoError(t, err)
			require.Equal(t, uint64(32), block32.Number().Uint64())

			// Ensure that the logs have been included in this rpc server's view of the blockchain
			txs := block32.Body().Transactions
			require.Len(t, txs, 3)
			receipt, err := th.Client.TransactionReceipt(ctx, txs[0].Hash())
			require.NoError(t, err)
			require.NotZero(t, receipt)
			require.Len(t, receipt.Logs, 1)

			// Simulate an optimism rpc server, which is behind and still syncing
			backupRPC := simulated.NewBackend(types.GenesisAlloc{
				th.Owner.From: {
					Balance: big.NewInt(0).Mul(big.NewInt(10), big.NewInt(1e18)),
				},
			}, simulated.WithBlockGasLimit(10e6))

			primaryRPC := th.Backend // save primaryRPC for later

			// Failover to simulated optimism rpc on block 30
			th.Client.RegisterHeadByNumberCallback(func(ctx context.Context, c *client.SimulatedBackendClient, n *big.Int) error {
				if n.Int64() != 32 {
					return nil
				}
				th.SetActiveClient(backupRPC, chaintype.ChainOptimismBedrock)
				return nil
			})

			currentBlockNumber := th.PollAndSaveLogs(ctx, 1)
			require.Equal(t, int64(33), currentBlockNumber)

			// logs shouldn't show up yet
			logs, err := th.LogPoller.Logs(ctx, 32, 32, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)
			require.NoError(t, err)
			require.Empty(t, logs)

			th.finalizeThroughBlock(t, 32)

			b, ok := primaryRPC.(*Backend)
			require.True(t, ok)
			th.SetActiveClient(b, chaintype.ChainOptimismBedrock) // restore primary rpc

			// Run ordinary poller + backup poller at least once
			require.NoError(t, err)
			currentBlockNumber = th.PollAndSaveLogs(ctx, currentBlockNumber)
			require.Equal(t, int64(33), currentBlockNumber)
			require.NoError(t, th.LogPoller.BackupPollAndSaveLogs(ctx))
			latestBlock, err := th.LogPoller.LatestBlock(ctx)
			require.NoError(t, err)
			require.Equal(t, currentBlockNumber-1, latestBlock.BlockNumber) // shouldn't change

			// logs still shouldn't show up, because we don't want to backfill the last finalized log
			//  to help with reorg detection
			logs, err = th.LogPoller.Logs(ctx, 32, 32, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)
			require.NoError(t, err)
			require.Empty(t, logs)
			th.Backend.Commit()
			th.finalizeThroughBlock(t, 64)

			// Run ordinary poller + backup poller at least once more
			th.LogPoller.PollAndSaveLogs(ctx, currentBlockNumber)
			require.NoError(t, th.LogPoller.BackupPollAndSaveLogs(ctx))
			currentBlock, err := th.LogPoller.LatestBlock(ctx)
			require.NoError(t, err)

			require.Equal(t, int64(64), currentBlock.BlockNumber)

			// all 3 logs in block 34 should show up now, thanks to backup logger
			logs, err = th.LogPoller.Logs(ctx, 30, 37, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)
			require.NoError(t, err)
			assert.Len(t, logs, 1)
			logs, err = th.LogPoller.Logs(ctx, 32, 32, EmitterABI.Events["Log2"].ID, th.EmitterAddress1)
			require.NoError(t, err)
			assert.Len(t, logs, 1)
			logs, err = th.LogPoller.Logs(ctx, 32, 36, EmitterABI.Events["Log1"].ID, th.EmitterAddress2)
			require.NoError(t, err)
			assert.Len(t, logs, 1)
		})`
$DIR/pkg/logpoller/log_poller_test.go: `err = th.LogPoller.RegisterFilter(ctx,
				logpoller.Filter{
					Name:      "filter2",
					EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
					Addresses: []common.Address{th.EmitterAddress2},
				})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.Client.RegisterHeadByNumberCallback(func(ctx context.Context, c *client.SimulatedBackendClient, n *big.Int) error {
				if n.Int64() != 32 {
					return nil
				}
				th.SetActiveClient(backupRPC, chaintype.ChainOptimismBedrock)
				return nil
			})`
$DIR/pkg/logpoller/log_poller_test.go: `th.SetActiveClient(backupRPC, chaintype.ChainOptimismBedrock)`
$DIR/pkg/logpoller/log_poller_test.go: `th.finalizeThroughBlock(t, 32)`
$DIR/pkg/logpoller/log_poller_test.go: `th.SetActiveClient(b, chaintype.ChainOptimismBedrock)`
$DIR/pkg/logpoller/log_poller_test.go: `currentBlockNumber = th.PollAndSaveLogs(ctx, currentBlockNumber)`
$DIR/pkg/logpoller/log_poller_test.go: `logs, err = th.LogPoller.Logs(ctx, 32, 32, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.finalizeThroughBlock(t, 64)`
$DIR/pkg/logpoller/log_poller_test.go: `th.LogPoller.PollAndSaveLogs(ctx, currentBlockNumber)`
$DIR/pkg/logpoller/log_poller_test.go: `logs, err = th.LogPoller.Logs(ctx, 30, 37, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `logs, err = th.LogPoller.Logs(ctx, 32, 32, EmitterABI.Events["Log2"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `logs, err = th.LogPoller.Logs(ctx, 32, 36, EmitterABI.Events["Log1"].ID, th.EmitterAddress2)`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.finalizeThroughBlock(t, 42)`
$DIR/pkg/logpoller/log_poller_test.go: `logs, err = th.LogPoller.Logs(
		ctx,
		0,
		43,
		EmitterABI.Events["Log1"].ID,
		th.EmitterAddress1,
	)`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.PollAndSaveLogs(ctx, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `err = th.LogPoller.RegisterFilter(ctx, logpoller.Filter{
		Name:      "Test Emitter",
		EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
		Addresses: []common.Address{th.EmitterAddress1},
	})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.finalizeThroughBlock(t, firstBatchBlock)`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.finalizeThroughBlock(t, secondBatchBlock)`
$DIR/pkg/logpoller/log_poller_test.go: `th.AdjustTime(t, delay1)`
$DIR/pkg/logpoller/log_poller_test.go: `blk, err = th.Client.BlockByNumber(ctx, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `blk, err = th.Client.BlockByHash(ctx, hash)`
$DIR/pkg/logpoller/log_poller_test.go: `th.AdjustTime(t, delay2)`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter2.EmitLog2(th.Owner, []*big.Int{big.NewInt(2)})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Client.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `blk, err = th.Client.BlockByNumber(ctx, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `th.PollAndSaveLogs(ctx, lb.BlockNumber+1)`
$DIR/pkg/logpoller/log_poller_test.go: `testParams.MinSuccessfulTests = 100`
$DIR/pkg/logpoller/log_poller_test.go: `owner.GasPrice = big.NewInt(10e9)`
$DIR/pkg/logpoller/log_poller_test.go: `p.Property("synchronized with geth", prop.ForAll(func(mineOrReorg []uint64) bool {
		// After the set of reorgs, we should have the same canonical blocks that geth does.
		t.Log("Starting test", mineOrReorg)
		chainID := testutils.NewRandomEVMChainID()
		// Set up a test chain with a log emitting contract deployed.
		orm := logpoller.NewORM(chainID, db, lggr)
		// Note this property test is run concurrently and the sim is not threadsafe.
		backend := simulated.NewBackend(types.GenesisAlloc{
			owner.From: {
				Balance: big.NewInt(0).Mul(big.NewInt(10), big.NewInt(1e18)),
			},
		}, simulated.WithBlockGasLimit(10e6))
		ec := backend.Client()
		_, _, emitter1, err := log_emitter.DeployLogEmitter(owner, ec)
		require.NoError(t, err)

		lpOpts := logpoller.Opts{
			PollPeriod:               15 * time.Second,
			FinalityDepth:            int64(finalityDepth),
			BackfillBatchSize:        3,
			RPCBatchSize:             2,
			KeepFinalizedBlocksDepth: 1000,
		}
		simulatedClient := client.NewSimulatedBackendClient(t, backend, chainID)
		ht := headstest.NewSimulatedHeadTracker(simulatedClient, lpOpts.UseFinalityTag, lpOpts.FinalityDepth)
		lp := logpoller.NewLogPoller(orm, simulatedClient, lggr, ht, lpOpts)
		for i := 0; i < finalityDepth; i++ { // Have enough blocks that we could reorg the full finalityDepth-1.
			backend.Commit()
		}
		currentBlockNumber := int64(1)
		lp.PollAndSaveLogs(testutils.Context(t), currentBlockNumber)
		currentBlock, err := lp.LatestBlock(testutils.Context(t))
		require.NoError(t, err)
		matchesGeth := func() bool {
			// Check every block is identical
			latest, err1 := ec.BlockByNumber(testutils.Context(t), nil)
			require.NoError(t, err1)
			for i := 1; i < int(latest.NumberU64()); i++ {
				ourBlock, err1 := lp.BlockByNumber(testutils.Context(t), int64(i))
				require.NoError(t, err1)
				gethBlock, err1 := ec.BlockByNumber(testutils.Context(t), big.NewInt(int64(i)))
				require.NoError(t, err1)
				if ourBlock.BlockHash != gethBlock.Hash() {
					t.Logf("Initial poll our block differs at height %d got %x want %x\n", i, ourBlock.BlockHash, gethBlock.Hash())
					return false
				}
			}
			return true
		}
		if !matchesGeth() {
			return false
		}
		// Randomly pick to mine or reorg
		for i := 0; i < numChainInserts; i++ {
			if rand.Int63()%2 == 0 {
				// Mine blocks
				for j := 0; j < int(mineOrReorg[i]); j++ {
					backend.Commit()
					latest, err1 := ec.BlockByNumber(testutils.Context(t), nil)
					require.NoError(t, err1)
					t.Log("mined block", latest.Hash())
				}
			} else {
				// Reorg blocks
				latest, err1 := ec.BlockByNumber(testutils.Context(t), nil)
				require.NoError(t, err1)
				reorgedBlock := big.NewInt(0).Sub(latest.Number(), big.NewInt(int64(mineOrReorg[i])))
				reorg, err1 := ec.BlockByNumber(testutils.Context(t), reorgedBlock)
				require.NoError(t, err1)
				require.NoError(t, backend.Fork(reorg.Hash()))

				t.Logf("Reorging from (%v, %x) back to (%v, %x)\n", latest.NumberU64(), latest.Hash(), reorgedBlock.Uint64(), reorg.Hash())
				// Actually need to change the block here to trigger the reorg.
				_, err1 = emitter1.EmitLog1(owner, []*big.Int{big.NewInt(1)})
				require.NoError(t, err1)
				for j := 0; j < int(mineOrReorg[i]+1); j++ { // Need +1 to make it actually longer height so we detect it.
					backend.Commit()
				}
				latest, err1 = ec.BlockByNumber(testutils.Context(t), nil)
				require.NoError(t, err1)
				t.Logf("New latest (%v, %x), latest parent %x)\n", latest.NumberU64(), latest.Hash(), latest.ParentHash())
			}
			lp.PollAndSaveLogs(testutils.Context(t), currentBlock.BlockNumber)
			currentBlock, err = lp.LatestBlock(testutils.Context(t))
			require.NoError(t, err)
		}
		return matchesGeth()
	}, gen.SliceOfN(numChainInserts, gen.UInt64Range(1, uint64(finalityDepth-1)))))`
$DIR/pkg/logpoller/log_poller_test.go: `backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `lp.PollAndSaveLogs(testutils.Context(t), currentBlockNumber)`
$DIR/pkg/logpoller/log_poller_test.go: `backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `_, err1 = emitter1.EmitLog1(owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `latest, err1 = ec.BlockByNumber(testutils.Context(t), nil)`
$DIR/pkg/logpoller/log_poller_test.go: `lp.PollAndSaveLogs(testutils.Context(t), currentBlock.BlockNumber)`
$DIR/pkg/logpoller/log_poller_test.go: `currentBlock, err = lp.LatestBlock(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run(tt.name, func(t *testing.T) {
			lpOpts := logpoller.Opts{
				UseFinalityTag:           tt.finalityTag,
				FinalityDepth:            tt.finalityDepth,
				BackfillBatchSize:        3,
				RPCBatchSize:             2,
				KeepFinalizedBlocksDepth: 1000,
			}
			th := SetupTH(t, lpOpts)

			// Set up a log poller listening for log emitter logs.
			err := th.LogPoller.RegisterFilter(testutils.Context(t), logpoller.Filter{
				Name:      "Test Emitter 1 & 2",
				EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID, EmitterABI.Events["Log2"].ID},
				Addresses: []common.Address{th.EmitterAddress1, th.EmitterAddress2},
			})
			require.NoError(t, err)

			b, err := th.Client.BlockByNumber(testutils.Context(t), nil)
			require.NoError(t, err)
			require.Equal(t, uint64(1), b.NumberU64())

			// Test scenario: single block in chain, no logs.
			// Chain genesis <- 1
			// DB: empty
			newStart := th.PollAndSaveLogs(testutils.Context(t), 1)
			assert.Equal(t, int64(2), newStart)

			// We expect to have saved block 1.
			lpb, err := th.ORM.SelectBlockByNumber(testutils.Context(t), 1)
			require.NoError(t, err)
			assert.Equal(t, lpb.BlockHash, b.Hash())
			assert.Equal(t, lpb.BlockNumber, int64(b.NumberU64()))
			assert.Equal(t, int64(1), int64(b.NumberU64()))

			// No logs.
			lgs, err := th.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 1)
			require.NoError(t, err)
			assert.Empty(t, lgs)
			th.assertHaveCanonical(t, 1, 1)

			// Polling again should be a noop, since we are at the latest.
			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(2), newStart)
			latest, err := th.ORM.SelectLatestBlock(testutils.Context(t))
			require.NoError(t, err)
			assert.Equal(t, int64(1), latest.BlockNumber)
			th.assertHaveCanonical(t, 1, 1)

			// Test scenario: one log 2 block chain.
			// Chain gen <- 1 <- 2 (L1)
			// DB: 1
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})
			require.NoError(t, err)
			th.Backend.Commit()

			// Polling should get us the L1 log.
			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(3), newStart)
			latest, err = th.ORM.SelectLatestBlock(testutils.Context(t))
			require.NoError(t, err)
			assert.Equal(t, int64(2), latest.BlockNumber)
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 3)
			require.NoError(t, err)
			require.Len(t, lgs, 1)
			assert.Equal(t, th.EmitterAddress1, lgs[0].Address)
			assert.Equal(t, latest.BlockHash, lgs[0].BlockHash)
			assert.Equal(t, latest.BlockTimestamp, lgs[0].BlockTimestamp)
			assert.Equal(t, hexutil.Encode(lgs[0].Topics[0]), EmitterABI.Events["Log1"].ID.String())
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000001`),
				lgs[0].Data)

			// Test scenario: single block reorg with log.
			// Chain gen <- 1 <- 2 (L1_1)
			//                \ 2'(L1_2) <- 3
			// DB: 1, 2
			// - Detect a reorg,
			// - Update the block 2's hash
			// - Save L1_2
			// - L1_1 deleted
			lca, err := th.Client.BlockByNumber(testutils.Context(t), big.NewInt(1))
			require.NoError(t, err)
			require.NoError(t, th.Backend.Fork(lca.Hash()))
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(2)})
			require.NoError(t, err)
			// Create 2'
			th.Backend.Commit()
			// Create 3 (we need a new block for us to do any polling and detect the reorg).
			th.Backend.Commit()

			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(4), newStart)
			latest, err = th.ORM.SelectLatestBlock(testutils.Context(t))
			require.NoError(t, err)
			assert.Equal(t, int64(3), latest.BlockNumber)
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 3)
			require.NoError(t, err)
			require.Len(t, lgs, 1)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000002`), lgs[0].Data)
			th.assertHaveCanonical(t, 1, 3)

			parent, err := th.Client.BlockByNumber(testutils.Context(t), big.NewInt(1))
			require.NoError(t, err)

			// Test scenario: reorg back to a chain that looks similar to the original chain. (simulated geth used to allow
			// re-org'ing back to exactly the same chain--now the best we can do is re-emit the same logs on a new one to simulate that)
			// Chain gen <- 1 <- 2 (L1_1)
			//               \ 2' (L1_2) <- 3
			//                \ 2''(L1_1) <- 3' <- 4
			require.NoError(t, th.Backend.Fork(parent.Hash()))
			// Re-emit L1 to make 2'' tip look like original 2 tip
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})
			require.NoError(t, err)
			th.Backend.Commit()
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(3)})
			require.NoError(t, err)
			// Create 3'
			th.Backend.Commit()
			// Create 4
			th.Backend.Commit()

			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(5), newStart)
			latest, err = th.ORM.SelectLatestBlock(testutils.Context(t))
			require.NoError(t, err)
			assert.Equal(t, int64(4), latest.BlockNumber)
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 3)
			require.NoError(t, err)

			require.Len(t, lgs, 2)
			assert.Equal(t, int64(2), lgs[0].BlockNumber)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000001`), lgs[0].Data)
			assert.Equal(t, int64(3), lgs[1].BlockNumber)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000003`), lgs[1].Data)
			th.assertHaveCanonical(t, 1, 1)
			th.assertHaveCanonical(t, 3, 4)
			th.assertDontHave(t, 2, 2) // 2 gets backfilled

			// Test scenario: multiple logs per block for many blocks (also after reorg).
			// Chain gen <- 1 <- 2 (L1_1) <- 3' L1_3 <- 4 <- 5 (L1_4, L2_5) <- 6 (L1_6)
			//                \ 2'(L1_2) <- 3
			// DB: 1, 2', 3'
			// - Should save 4, 5, 6 blocks
			// - Should obtain logs L1_3, L2_5, L1_6
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(4)})
			require.NoError(t, err)
			_, err = th.Emitter2.EmitLog1(th.Owner, []*big.Int{big.NewInt(5)})
			require.NoError(t, err)
			// Create 4
			th.Backend.Commit()
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(6)})
			require.NoError(t, err)
			// Create 5
			th.Backend.Commit()

			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(7), newStart)
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 4, 6)
			require.NoError(t, err)
			require.Len(t, lgs, 3)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000004`), lgs[0].Data)
			assert.Equal(t, th.EmitterAddress1, lgs[0].Address)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000005`), lgs[1].Data)
			assert.Equal(t, th.EmitterAddress2, lgs[1].Address)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000006`), lgs[2].Data)
			assert.Equal(t, th.EmitterAddress1, lgs[2].Address)
			th.assertHaveCanonical(t, 1, 1)
			th.assertDontHave(t, 2, 2) // 2 gets backfilled
			th.assertHaveCanonical(t, 3, 6)

			// Test scenario: node down for exactly finality + 2 blocks
			// Note we only backfill up to finalized - 1 blocks, because we need to save the
			// Chain gen <- 1 <- 2 (L1_1) <- 3' L1_3 <- 4 <- 5 (L1_4, L2_5) <- 6 (L1_6) <- 7 (L1_7) <- 8 (L1_8) <- 9 (L1_9) <- 10 (L1_10)
			//                \ 2'(L1_2) <- 3
			// DB: 1, 2, 3, 4, 5, 6
			// - We expect block 7 to backfilled (treated as finalized)
			// - Then block 8-10 to be handled block by block (treated as unfinalized).
			for i := 7; i < 11; i++ {
				_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})
				require.NoError(t, err)
				th.Backend.Commit()
			}

			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(11), newStart)
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 7, 9)
			require.NoError(t, err)
			require.Len(t, lgs, 3)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000007`), lgs[0].Data)
			assert.Equal(t, int64(7), lgs[0].BlockNumber)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000008`), lgs[1].Data)
			assert.Equal(t, int64(8), lgs[1].BlockNumber)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000009`), lgs[2].Data)
			assert.Equal(t, int64(9), lgs[2].BlockNumber)
			th.assertHaveCanonical(t, 8, 10)

			// Test scenario large backfill (multiple batches)
			// Chain gen <- 1 <- 2 (L1_1) <- 3' L1_3 <- 4 <- 5 (L1_4, L2_5) <- 6 (L1_6) <- 7 (L1_7) <- 8 (L1_8) <- 9 (L1_9) <- 10..32
			//                \ 2'(L1_2) <- 3
			// DB: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
			// - 11 - 13 backfilled in batch 1
			// - 14 - 16 backfilled in batch 2
			// ...
			// - 33, 34, 35 to be treated as unfinalized
			for i := 11; i < 36; i++ {
				_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})
				require.NoError(t, err)
				th.Backend.Commit()
			}

			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(36), newStart)
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 11, 36)
			require.NoError(t, err)
			assert.Len(t, lgs, 25)
			th.assertHaveCanonical(t, 32, 36) // Should have last finalized block plus unfinalized blocks
			th.assertDontHave(t, 11, 13)      // Should not have older finalized blocks
			th.assertDontHave(t, 14, 16)      // Should not have older finalized blocks

			// Verify that a custom block timestamp will get written to db correctly also
			b, err = th.Client.BlockByNumber(testutils.Context(t), nil)
			require.NoError(t, err)
			require.Equal(t, uint64(35), b.NumberU64())
			blockTimestamp := b.Time()
			th.AdjustTime(t, time.Hour)
			th.Backend.Commit()

			b, err = th.Client.BlockByNumber(testutils.Context(t), nil)
			require.NoError(t, err)
			require.Equal(t, blockTimestamp+uint64(time.Hour/time.Second)+1, b.Time())
		})`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertHaveCanonical(t, 1, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertHaveCanonical(t, 1, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `latest, err = th.ORM.SelectLatestBlock(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 3)`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(2)})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `latest, err = th.ORM.SelectLatestBlock(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 3)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertHaveCanonical(t, 1, 3)`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(3)})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `latest, err = th.ORM.SelectLatestBlock(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 3)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertHaveCanonical(t, 1, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertHaveCanonical(t, 3, 4)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertDontHave(t, 2, 2)`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(4)})`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter2.EmitLog1(th.Owner, []*big.Int{big.NewInt(5)})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(6)})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 4, 6)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertHaveCanonical(t, 1, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertDontHave(t, 2, 2)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertHaveCanonical(t, 3, 6)`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 7, 9)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertHaveCanonical(t, 8, 10)`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 11, 36)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertHaveCanonical(t, 32, 36)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertDontHave(t, 11, 13)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertDontHave(t, 14, 16)`
$DIR/pkg/logpoller/log_poller_test.go: `b, err = th.Client.BlockByNumber(testutils.Context(t), nil)`
$DIR/pkg/logpoller/log_poller_test.go: `th.AdjustTime(t, time.Hour)`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `b, err = th.Client.BlockByNumber(testutils.Context(t), nil)`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run(tt.name, func(t *testing.T) {
			th := SetupTH(t, logpoller.Opts{
				UseFinalityTag:           tt.finalityTag,
				FinalityDepth:            tt.finalityDepth,
				BackfillBatchSize:        3,
				RPCBatchSize:             2,
				KeepFinalizedBlocksDepth: 1000,
				BackupPollerBlockDelay:   100,
			})
			// Set up a log poller listening for log emitter logs.
			err := th.LogPoller.RegisterFilter(testutils.Context(t), logpoller.Filter{
				Name:      "Test Emitter",
				EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
				Addresses: []common.Address{th.EmitterAddress1},
			})
			require.NoError(t, err)

			// Test scenario
			// Chain gen <- 1 <- 2 <- ... <- 32 (finalized) <- 33 (L1_1)
			th.finalizeThroughBlock(t, 32)
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})
			require.NoError(t, err)
			th.Backend.Commit()

			// Polling should get us the L1 log.
			firstPoll := th.PollAndSaveLogs(testutils.Context(t), 1)
			assert.Equal(t, int64(34), firstPoll)
			assert.NoError(t, th.LogPoller.Healthy())

			// Fork deeper than finality depth
			// Chain gen <- 1 <- 2 <- 3 <- ... <- 32 (finalized) <- 33 (L1_1)
			//              \      <- 3' <- ... <- 31' <- 32' (finalized) <- 33' <- 34' (L1_2)
			lca, err := th.Client.BlockByNumber(testutils.Context(t), big.NewInt(2))
			require.NoError(t, err)
			require.NoError(t, th.Backend.Fork(lca.Hash()))

			// Create 3'
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(3)})
			require.NoError(t, err)
			th.Backend.Commit()

			th.finalizeThroughBlock(t, 32)

			// Create 33' - 34'
			for i := 33; i < 35; i++ {
				_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})
				require.NoError(t, err)
				th.Backend.Commit()
			}

			secondPoll := th.PollAndSaveLogs(testutils.Context(t), firstPoll)
			assert.Equal(t, firstPoll, secondPoll)
			require.Equal(t, commontypes.ErrFinalityViolated, th.LogPoller.Healthy())
			require.Equal(t, commontypes.ErrFinalityViolated, th.LogPoller.HealthReport()[th.LogPoller.Name()])

			// Manually remove re-org'd chain from the log poller to bring it back to life
			// LogPoller should be healthy again after first poll
			// Chain gen <- 1 <- 2
			//                    \ <- 3' <- 4' <- 5' <- 32' (finalized) <- 33' <- 34' (L1_2)
			require.NoError(t, th.ORM.DeleteLogsAndBlocksAfter(testutils.Context(t), 3))
			// Poll from latest
			recoveryPoll := th.PollAndSaveLogs(testutils.Context(t), 1)
			assert.Equal(t, int64(35), recoveryPoll)
			require.NoError(t, th.LogPoller.Healthy())
			require.NoError(t, th.LogPoller.HealthReport()[th.LogPoller.Name()])
		})`
$DIR/pkg/logpoller/log_poller_test.go: `th.finalizeThroughBlock(t, 32)`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(3)})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.finalizeThroughBlock(t, 32)`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run(tt.name, func(t *testing.T) {
			lpOpts := logpoller.Opts{
				UseFinalityTag:           tt.finalityTag,
				FinalityDepth:            tt.finalityDepth,
				BackfillBatchSize:        50,
				RPCBatchSize:             50,
				KeepFinalizedBlocksDepth: 1000,
			}
			th := SetupTH(t, lpOpts)
			// Set up a log poller listening for log emitter logs.
			err := th.LogPoller.RegisterFilter(testutils.Context(t), logpoller.Filter{
				Name:      "Test Emitter",
				EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
				Addresses: []common.Address{th.EmitterAddress1},
			})
			require.NoError(t, err)

			// Test scenario: one log 2 block chain.
			// Chain gen <- 1 <- 2 (L1_1)
			// DB: 1
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})
			require.NoError(t, err)
			th.Backend.Commit()

			// Polling should get us the L1 log.
			newStart := th.PollAndSaveLogs(testutils.Context(t), 1)
			assert.NoError(t, th.LogPoller.Healthy())
			assert.Equal(t, int64(3), newStart)
			// Check that L1_1 has a proper data payload
			lgs, err := th.ORM.SelectLogsByBlockRange(testutils.Context(t), 2, 2)
			require.NoError(t, err)
			require.NotEmpty(t, lgs)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000001`), lgs[0].Data)

			// Single block reorg and log poller not working for a while, mine blocks and progress with finalization
			// Chain gen <- 1 <- 2 (L1_1)
			//                \ 2'(L1_2) <- 3' <- 4' <- ... <- 32' (finalized on chain) <- 33' <- 34' <- 35'
			lca, err := th.Client.BlockByNumber(testutils.Context(t), big.NewInt(1))
			require.NoError(t, err)
			require.NoError(t, th.Backend.Fork(lca.Hash()))
			// Create 2'
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(2)})
			require.NoError(t, err)
			th.Backend.Commit()
			// Create 3-35
			for i := 3; i <= 35; i++ {
				_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})
				require.NoError(t, err)
				th.Backend.Commit()
			}
			th.finalizeThroughBlock(t, 32)

			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(36), newStart)
			assert.NoError(t, th.LogPoller.Healthy())

			// Expect L1_2 to be properly updated
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 2, 31)
			require.NoError(t, err)
			require.Len(t, lgs, 30)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000002`), lgs[0].Data)
			th.assertHaveCanonical(t, 1, 2)
			th.assertDontHave(t, 2, 31) // These blocks are backfilled
			th.assertHaveCanonical(t, 32, 36)
		})`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(2)})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.finalizeThroughBlock(t, 32)`
$DIR/pkg/logpoller/log_poller_test.go: `newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 2, 31)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertHaveCanonical(t, 1, 2)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertDontHave(t, 2, 31)`
$DIR/pkg/logpoller/log_poller_test.go: `th.assertHaveCanonical(t, 32, 36)`
$DIR/pkg/logpoller/log_poller_test.go: `err = th.LogPoller.RegisterFilter(testutils.Context(t), filter2)`
$DIR/pkg/logpoller/log_poller_test.go: `err = th.LogPoller.RegisterFilter(testutils.Context(t), filter3)`
$DIR/pkg/logpoller/log_poller_test.go: `filter, ok = filters["second Filter"]`
$DIR/pkg/logpoller/log_poller_test.go: `filter, ok = filters["third Filter"]`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run("HasFilter", func(t *testing.T) {
		assert.True(t, th.LogPoller.HasFilter("first Filter"))
		assert.True(t, th.LogPoller.HasFilter("second Filter"))
		assert.True(t, th.LogPoller.HasFilter("third Filter"))
		assert.False(t, th.LogPoller.HasFilter("fourth Filter"))
	})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(2)})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `err = th.LogPoller.RegisterFilter(testutils.Context(t), logpoller.Filter{
		Name:      "GetBlocks Test",
		EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID, EmitterABI.Events["Log2"].ID},
		Addresses: []common.Address{th.EmitterAddress1, th.EmitterAddress2},
	})`
$DIR/pkg/logpoller/log_poller_test.go: `blockNums = []uint64{1}`
$DIR/pkg/logpoller/log_poller_test.go: `blocks, err = th.LogPoller.GetBlocksRange(testutils.Context(t), blockNums)`
$DIR/pkg/logpoller/log_poller_test.go: `blockNums = []uint64{2}`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.LogPoller.GetBlocksRange(testutils.Context(t), blockNums)`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.ORM.SelectBlockByNumber(testutils.Context(t), 2)`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.ORM.SelectBlockByNumber(testutils.Context(t), 3)`
$DIR/pkg/logpoller/log_poller_test.go: `th.LogPoller.PollAndSaveLogs(testutils.Context(t), 1)`
$DIR/pkg/logpoller/log_poller_test.go: `blockNums = []uint64{1, 2}`
$DIR/pkg/logpoller/log_poller_test.go: `blocks, err = th.LogPoller.GetBlocksRange(testutils.Context(t), blockNums)`
$DIR/pkg/logpoller/log_poller_test.go: `blockNums = []uint64{2, 1}`
$DIR/pkg/logpoller/log_poller_test.go: `cancel()`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = th.LogPoller.GetBlocksRange(ctx, blockNums)`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `requested = int64(15)`
$DIR/pkg/logpoller/log_poller_test.go: `fromBlock, err = th.LogPoller.GetReplayFromBlock(testutils.Context(t), requested)`
$DIR/pkg/logpoller/log_poller_test.go: `requested = int64(7)`
$DIR/pkg/logpoller/log_poller_test.go: `fromBlock, err = th.LogPoller.GetReplayFromBlock(testutils.Context(t), requested)`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = emitter.EmitLog1(owner, []*big.Int{big.NewInt(9)})`
$DIR/pkg/logpoller/log_poller_test.go: `_, err = emitter.EmitLog1(owner, []*big.Int{big.NewInt(7)})`
$DIR/pkg/logpoller/log_poller_test.go: `backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `err = lp.Replay(ctx, 5)`
$DIR/pkg/logpoller/log_poller_test.go: `err = lp.Replay(ctx, 2)`
$DIR/pkg/logpoller/log_poller_test.go: `time.Sleep(100 * time.Millisecond)`
$DIR/pkg/logpoller/log_poller_test.go: `testutils.RequireEventually(t, func() bool {
		return observedLogs.Len() >= 1
	})`
$DIR/pkg/logpoller/log_poller_test.go: `err = lp.Close()`
$DIR/pkg/logpoller/log_poller_test.go: `logMsgs[(obs.Entry.Message)] = 1`
$DIR/pkg/logpoller/log_poller_test.go: `logMsgs[(obs.Entry.Message)]++`
$DIR/pkg/logpoller/log_poller_test.go: `ec.On("HeadByNumber", mock.Anything, mock.Anything).Return(func(ctx context.Context, blockNumber *big.Int) (*evmtypes.Head, error) {
		if blockNumber == nil {
			require.FailNow(t, "unexpected call to get current head")
		}
		return &evmtypes.Head{Number: blockNumber.Int64(), ParentHash: common.HexToHash(fmt.Sprintf("0x%x", blockNumber.Int64()-1))}, nil
	})`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run("halves size until small enough, then succeeds", func(t *testing.T) {
		// Simulate latestBlock = 300
		head.Number = 300
		head.Hash = common.HexToHash("0x1234") // needed to satisfy validation in fetchBlocks()
		finalized.Number = head.Number - lpOpts.FinalityDepth

		headTracker.On("LatestAndFinalizedBlock", mock.Anything).Return(head, finalized, nil).Once()
		headTracker.On("LatestSafeBlock", mock.Anything).Return(finalized, nil).Once()

		headByHash := ec.On("HeadByHash", mock.Anything, mock.Anything).Return(func(ctx context.Context, blockHash common.Hash) (*evmtypes.Head, error) {
			return &evmtypes.Head{Hash: blockHash}, nil
		})

		batchCallContext := ec.On("BatchCallContext", mock.Anything, mock.Anything).Return(
			func(ctx context.Context, calls []rpc.BatchElem) error {
				for i := range calls {
					blockNumberHex := calls[i].Args[0].(string)
					if blockNumberHex == "latest" {
						calls[i].Result = head
						continue
					}
					blockNumber, ok := new(big.Int).SetString(blockNumberHex[2:], 16)
					require.True(t, ok, blockNumberHex)

					calls[i].Result = &evmtypes.Head{
						Number:     blockNumber.Int64(),
						Hash:       common.HexToHash(fmt.Sprintf("0x%x", blockNumber.Int64())),
						ParentHash: common.HexToHash(fmt.Sprintf("0x%x", blockNumber.Int64()-1)),
					}
				}
				return nil
			},
		)

		filterLogsCall = ec.On("FilterLogs", mock.Anything, mock.Anything).Return(func(ctx context.Context, fq ethereum.FilterQuery) (logs []types.Log, err error) {
			if fq.BlockHash != nil {
				return []types.Log{}, nil // succeed when single block requested
			}
			from := fq.FromBlock.Uint64()
			to := fq.ToBlock.Uint64()
			if to-from >= 8 {
				return []types.Log{}, context.DeadlineExceeded // simulate RPC client timeout as a "too many results" scenario
			}
			if to-from >= 4 {
				return []types.Log{}, tooLargeErr // return "too many results" error if block range spans 4 or more blocks
			}
			return logs, err
		})

		addr := testutils.NewAddress()
		err := lp.RegisterFilter(ctx, logpoller.Filter{
			Name:      "Integration test",
			EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
			Addresses: []common.Address{addr},
		})
		require.NoError(t, err)
		lp.PollAndSaveLogs(ctx, 5)
		block, err2 := o.SelectLatestBlock(ctx)
		require.NoError(t, err2)
		assert.Equal(t, int64(298), block.BlockNumber)

		logs := obs.FilterLevelExact(zapcore.WarnLevel).FilterMessageSnippet("halving block range batch size").FilterFieldKey("newBatchSize").All()
		// Should have tried again 3 times--first reducing batch size to 10, then 5, then 2
		require.Len(t, logs, 3)
		for i, s := range expected[:3] {
			assert.Equal(t, s, logs[i].ContextMap()["newBatchSize"])
		}
		filterLogsCall.Unset()
		batchCallContext.Unset()
		headByHash.Unset()
	})`
$DIR/pkg/logpoller/log_poller_test.go: `head.Number = 300`
$DIR/pkg/logpoller/log_poller_test.go: `head.Hash = common.HexToHash("0x1234")`
$DIR/pkg/logpoller/log_poller_test.go: `finalized.Number = head.Number - lpOpts.FinalityDepth`
$DIR/pkg/logpoller/log_poller_test.go: `headTracker.On("LatestAndFinalizedBlock", mock.Anything).Return(head, finalized, nil).Once()`
$DIR/pkg/logpoller/log_poller_test.go: `headTracker.On("LatestSafeBlock", mock.Anything).Return(finalized, nil).Once()`
$DIR/pkg/logpoller/log_poller_test.go: `calls[i].Result = head`
$DIR/pkg/logpoller/log_poller_test.go: `calls[i].Result = &evmtypes.Head{
						Number:     blockNumber.Int64(),
						Hash:       common.HexToHash(fmt.Sprintf("0x%x", blockNumber.Int64())),
						ParentHash: common.HexToHash(fmt.Sprintf("0x%x", blockNumber.Int64()-1)),
					}`
$DIR/pkg/logpoller/log_poller_test.go: `lp.PollAndSaveLogs(ctx, 5)`
$DIR/pkg/logpoller/log_poller_test.go: `filterLogsCall.Unset()`
$DIR/pkg/logpoller/log_poller_test.go: `batchCallContext.Unset()`
$DIR/pkg/logpoller/log_poller_test.go: `headByHash.Unset()`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run("Halves size until single block, then reports critical error", func(t *testing.T) {
		obs.TakeAll()

		// Now jump to block 500, but return error no matter how small the block range gets.
		//  Should exit the loop with a critical error instead of hanging.
		head.Number = 500
		finalized.Number = head.Number - lpOpts.FinalityDepth
		headTracker.On("LatestAndFinalizedBlock", mock.Anything).Return(head, finalized, nil).Once()
		headTracker.On("LatestSafeBlock", mock.Anything).Return(finalized, nil).Once()
		filterLogsCall = ec.On("FilterLogs", mock.Anything, mock.Anything).Return(func(ctx context.Context, fq ethereum.FilterQuery) (logs []types.Log, err error) {
			if fq.BlockHash != nil {
				return []types.Log{}, nil // succeed when single block requested
			}
			return []types.Log{}, tooLargeErr // return "too many results" error if block range spans 4 or more blocks
		})

		lp.PollAndSaveLogs(ctx, 298)
		block, err := o.SelectLatestBlock(ctx)
		if err != nil {
			require.ErrorContains(t, err, "no rows") // In case this subtest is run by itself
		} else {
			assert.Equal(t, int64(298), block.BlockNumber)
		}
		warns := obs.FilterMessageSnippet("halving block range").FilterLevelExact(zapcore.WarnLevel).All()
		crit := obs.FilterMessageSnippet("failed to retrieve logs").FilterLevelExact(zapcore.DPanicLevel).All()
		require.Len(t, warns, 4)
		for i, s := range expected {
			assert.Equal(t, s, warns[i].ContextMap()["newBatchSize"])
		}

		require.Len(t, crit, 1)
		assert.Contains(t, crit[0].Message, "Too many log results in a single block")
		filterLogsCall.Unset()
	})`
$DIR/pkg/logpoller/log_poller_test.go: `obs.TakeAll()`
$DIR/pkg/logpoller/log_poller_test.go: `head.Number = 500`
$DIR/pkg/logpoller/log_poller_test.go: `finalized.Number = head.Number - lpOpts.FinalityDepth`
$DIR/pkg/logpoller/log_poller_test.go: `headTracker.On("LatestAndFinalizedBlock", mock.Anything).Return(head, finalized, nil).Once()`
$DIR/pkg/logpoller/log_poller_test.go: `headTracker.On("LatestSafeBlock", mock.Anything).Return(finalized, nil).Once()`
$DIR/pkg/logpoller/log_poller_test.go: `lp.PollAndSaveLogs(ctx, 298)`
$DIR/pkg/logpoller/log_poller_test.go: `filterLogsCall.Unset()`
$DIR/pkg/logpoller/log_poller_test.go: `head.Number = 500`
$DIR/pkg/logpoller/log_poller_test.go: `finalized.Number = head.Number - lpOpts.FinalityDepth`
$DIR/pkg/logpoller/log_poller_test.go: `obs.TakeAll()`
$DIR/pkg/logpoller/log_poller_test.go: `headTracker.On("LatestAndFinalizedBlock", mock.Anything).Return(head, finalized, nil).Once()`
$DIR/pkg/logpoller/log_poller_test.go: `headTracker.On("LatestSafeBlock", mock.Anything).Return(finalized, nil).Once()`
$DIR/pkg/logpoller/log_poller_test.go: `lp.PollAndSaveLogs(ctx, 298)`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.finalizeThroughBlock(t, h.Number.Int64())`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run(tt.name, func(t *testing.T) {
			lpOpts := logpoller.Opts{
				UseFinalityTag:           tt.useFinalityTag,
				FinalityDepth:            tt.finalityDepth,
				BackfillBatchSize:        3,
				RPCBatchSize:             2,
				KeepFinalizedBlocksDepth: 1000,
			}
			th := SetupTH(t, lpOpts)
			// Should return error before the first poll and save
			_, err := th.LogPoller.LatestBlock(ctx)
			require.Error(t, err)

			// Create a couple of blocks
			for i := 0; i < numberOfBlocks-1; i++ {
				th.Backend.Commit()
			}

			if tt.useFinalityTag {
				th.finalizeThroughBlock(t, tt.expectedFinalizedBlock)
			}

			th.PollAndSaveLogs(ctx, 1)

			latestBlock, err := th.LogPoller.LatestBlock(ctx)
			require.NoError(t, err)
			require.Equal(t, int64(numberOfBlocks), latestBlock.BlockNumber)
			require.Equal(t, tt.expectedFinalizedBlock, latestBlock.FinalizedBlockNumber)
		})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `th.finalizeThroughBlock(t, tt.expectedFinalizedBlock)`
$DIR/pkg/logpoller/log_poller_test.go: `th.PollAndSaveLogs(ctx, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run(tt.name, func(t *testing.T) {
			lpOpts := logpoller.Opts{
				UseFinalityTag:           tt.finalityTag,
				FinalityDepth:            tt.finalityDepth,
				BackfillBatchSize:        3,
				RPCBatchSize:             2,
				KeepFinalizedBlocksDepth: 1000,
				BackupPollerBlockDelay:   100,
			}
			th := SetupTH(t, lpOpts)

			header, err := th.Client.HeaderByNumber(ctx, nil)
			require.NoError(t, err)
			require.LessOrEqual(t, header.Time, uint64(math.MaxInt64))
			genesisBlockTime := time.Unix(int64(header.Time), 0) //nolint:gosec // G115 false positive

			// Emit some logs in blocks
			for i := 0; i < emittedLogs; i++ {
				_, err2 := th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})
				require.NoError(t, err2)
				th.Backend.Commit()
			}

			// First PollAndSave, no filters are registered
			currentBlock := th.PollAndSaveLogs(ctx, 1)

			err = th.LogPoller.RegisterFilter(ctx, logpoller.Filter{
				Name:      "Test Emitter",
				EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
				Addresses: []common.Address{th.EmitterAddress1},
			})
			require.NoError(t, err)

			// Finalize current block, because backup always backfill up to one block before last finalized
			if tt.finalityTag {
				th.finalizeThroughBlock(t, currentBlock)
			} else {
				for i := 0; i < int(tt.finalityDepth)+1; i++ {
					th.Backend.Commit()
				}
			}

			// LogPoller should backfill entire history
			require.NoError(t, th.LogPoller.BackupPollAndSaveLogs(ctx))
			require.NoError(t, err)

			// Make sure that all logs are backfilled
			logs, err := th.LogPoller.Logs(
				ctx,
				0,
				currentBlock,
				EmitterABI.Events["Log1"].ID,
				th.EmitterAddress1,
			)
			require.NoError(t, err)
			require.Len(t, logs, emittedLogs)

			// We should get all the logs by the block_timestamp
			logs, err = th.LogPoller.LogsCreatedAfter(
				ctx,
				EmitterABI.Events["Log1"].ID,
				th.EmitterAddress1,
				genesisBlockTime,
				0,
			)
			require.NoError(t, err)
			require.Len(t, logs, emittedLogs)
		})`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `err = th.LogPoller.RegisterFilter(ctx, logpoller.Filter{
				Name:      "Test Emitter",
				EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
				Addresses: []common.Address{th.EmitterAddress1},
			})`
$DIR/pkg/logpoller/log_poller_test.go: `th.finalizeThroughBlock(t, currentBlock)`
$DIR/pkg/logpoller/log_poller_test.go: `th.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `logs, err = th.LogPoller.LogsCreatedAfter(
				ctx,
				EmitterABI.Events["Log1"].ID,
				th.EmitterAddress1,
				genesisBlockTime,
				0,
			)`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run(tt.name, func(t *testing.T) {
			lpOpts := logpoller.Opts{
				UseFinalityTag:           true,
				BackfillBatchSize:        3,
				RPCBatchSize:             2,
				KeepFinalizedBlocksDepth: tt.keepFinalizedBlocksDepth,
			}
			th := SetupTH(t, lpOpts)

			for i := 1; i <= tt.blockToCreate; i++ {
				err := th.ORM.InsertBlock(ctx, utils.RandomBytes32(), int64(i+10), time.Now(), int64(i), int64(i))
				require.NoError(t, err)
			}

			if tt.wantErr {
				_, err := th.LogPoller.PruneOldBlocks(ctx)
				require.Error(t, err)
				return
			}

			allDeleted, err := th.LogPoller.PruneOldBlocks(ctx)
			require.NoError(t, err)
			assert.True(t, allDeleted)
			blocks, err := th.ORM.GetBlocksRange(ctx, 0, math.MaxInt64)
			require.NoError(t, err)
			assert.Len(t, blocks, tt.blocksLeft)
		})`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run("Fails, if failed to select oldest block", func(t *testing.T) {
		_, err := lp.FindLCA(ctx)
		require.ErrorContains(t, err, "failed to select the latest block")
	})`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run("Fails, if caller's context canceled", func(t *testing.T) {
		lCtx, cancel := context.WithCancel(ctx)
		ec.On("HeadByHash", mock.Anything, latestBlockHash).Return(nil, nil).Run(func(_ mock.Arguments) {
			cancel()
		}).Once()
		_, err := lp.FindLCA(lCtx)
		require.ErrorContains(t, err, "aborted, FindLCA request cancelled")
	})`
$DIR/pkg/logpoller/log_poller_test.go: `ec.On("HeadByHash", mock.Anything, latestBlockHash).Return(nil, nil).Run(func(_ mock.Arguments) {
			cancel()
		}).Once()`
$DIR/pkg/logpoller/log_poller_test.go: `cancel()`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run("Fails, if RPC returns an error", func(t *testing.T) {
		expectedError := errors.New("failed to call RPC")
		ec.On("HeadByHash", mock.Anything, latestBlockHash).Return(nil, expectedError).Once()
		_, err := lp.FindLCA(ctx)
		require.ErrorContains(t, err, expectedError.Error())
	})`
$DIR/pkg/logpoller/log_poller_test.go: `ec.On("HeadByHash", mock.Anything, latestBlockHash).Return(nil, expectedError).Once()`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run("Fails, if block numbers do not match", func(t *testing.T) {
		ec.On("HeadByHash", mock.Anything, latestBlockHash).Return(&evmtypes.Head{
			Number: 123,
		}, nil).Once()
		_, err := lp.FindLCA(ctx)
		require.ErrorContains(t, err, "expected block numbers to match")
	})`
$DIR/pkg/logpoller/log_poller_test.go: `ec.On("HeadByHash", mock.Anything, latestBlockHash).Return(&evmtypes.Head{
			Number: 123,
		}, nil).Once()`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run("Fails, if none of the blocks in db matches on chain", func(t *testing.T) {
		ec.On("HeadByHash", mock.Anything, mock.Anything).Return(nil, nil).Times(3)
		_, err := lp.FindLCA(ctx)
		require.ErrorContains(t, err, "failed to find LCA, this means that whole database LogPoller state was reorged out of chain or RPC/Core node is misconfigured")
	})`
$DIR/pkg/logpoller/log_poller_test.go: `ec.On("HeadByHash", mock.Anything, mock.Anything).Return(nil, nil).Times(3)`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run(tc.Name, func(t *testing.T) {
			// reset the database
			require.NoError(t, orm.DeleteLogsAndBlocksAfter(ctx, 0))
			for _, b := range tc.Blocks {
				blockHashI++
				hash := common.BigToHash(big.NewInt(blockHashI))
				require.NoError(t, orm.InsertBlock(ctx, hash, int64(b.BN), time.Now(), 0, 0))
				// Hashes are unique for all test cases
				var onChainBlock *evmtypes.Head
				if b.Exists {
					onChainBlock = &evmtypes.Head{Number: int64(b.BN)}
				}
				ec.On("HeadByHash", mock.Anything, hash).Return(onChainBlock, nil).Maybe()
			}

			result, err := lp.FindLCA(ctx)
			if tc.ExpectedError != nil {
				require.ErrorContains(t, err, tc.ExpectedError.Error())
			} else {
				require.NotNil(t, result)
				require.Equal(t, result.BlockNumber, int64(tc.ExpectedBlockNumber), "expected block numbers to match")
			}
		})`
$DIR/pkg/logpoller/log_poller_test.go: `blockHashI++`
$DIR/pkg/logpoller/log_poller_test.go: `onChainBlock = &evmtypes.Head{Number: int64(b.BN)}`
$DIR/pkg/logpoller/log_poller_test.go: `ec.On("HeadByHash", mock.Anything, hash).Return(onChainBlock, nil).Maybe()`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run("Valid combination of filters", func(t *testing.T) {
		result, err := logpoller.Where(expr1, expr2, expr3, expr4)
		require.NoError(t, err)
		assert.Equal(t, []query.Expression{expr1, expr2, expr3, expr4}, result)
	})`
$DIR/pkg/logpoller/log_poller_test.go: `t.Run("No expressions (should return empty slice)", func(t *testing.T) {
		result, err := logpoller.Where()
		require.NoError(t, err)
		assert.Equal(t, []query.Expression{}, result)
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewIndependentSqlxDB(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(137)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewORM(big.NewInt(137), db, logger.Test(t))`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(137)`
$DIR/pkg/logpoller/log_poller_test.go: `.Test(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Now()`
$DIR/pkg/logpoller/log_poller_test.go: `.SelectLogs(ctx, 750000, 800000, address1, event1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Now()`
$DIR/pkg/logpoller/log_poller_test.go: `.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0, []common.Address{address1}, []common.Hash{event1}, 0)`
$DIR/pkg/logpoller/log_poller_test.go: `.Now()`
$DIR/pkg/logpoller/log_poller_test.go: `.SelectLogsDataWordRange(ctx, address1, event1, 0, logpoller.EvmWord(50000), logpoller.EvmWord(50020), 0)`
$DIR/pkg/logpoller/log_poller_test.go: `.EvmWord(50000)`
$DIR/pkg/logpoller/log_poller_test.go: `.EvmWord(50020)`
$DIR/pkg/logpoller/log_poller_test.go: `.Now()`
$DIR/pkg/logpoller/log_poller_test.go: `.SelectIndexedLogs(ctx, address2, event1, 1, []common.Hash{logpoller.EvmWord(50000), logpoller.EvmWord(50020)}, 0)`
$DIR/pkg/logpoller/log_poller_test.go: `.EvmWord(50000)`
$DIR/pkg/logpoller/log_poller_test.go: `.EvmWord(50020)`
$DIR/pkg/logpoller/log_poller_test.go: `.Now()`
$DIR/pkg/logpoller/log_poller_test.go: `.SelectIndexedLogsTopicRange(ctx, address1, event1, 1, logpoller.EvmWord(50000), logpoller.EvmWord(50020), 0)`
$DIR/pkg/logpoller/log_poller_test.go: `.EvmWord(50000)`
$DIR/pkg/logpoller/log_poller_test.go: `.EvmWord(50020)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog2(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(ctx, 4, 7, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `.RequireEventually(t, func() bool {
		l, err2 := th.LogPoller.Logs(ctx, 3, 3, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)
		require.NoError(t, err2)
		return len(l) == 1
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(ctx, 3, 3, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(ctx, logpoller.Filter{
		Name:      "Emitter - log2",
		EventSigs: []common.Hash{EmitterABI.Events["Log2"].ID},
		Addresses: []common.Address{th.EmitterAddress1},
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(ctx, 2, 7, EmitterABI.Events["Log2"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(ctx, 2, 7, EmitterABI.Events["Log2"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `.WithCancel(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Replay(ctx, 4)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run(tt.name, func(t *testing.T) {
			th := SetupTH(t,
				logpoller.Opts{
					UseFinalityTag:           tt.finalityTag,
					FinalityDepth:            tt.finalityDepth,
					BackfillBatchSize:        3,
					RPCBatchSize:             2,
					KeepFinalizedBlocksDepth: 1000,
					BackupPollerBlockDelay:   100,
				},
			)

			ctx := testutils.Context(t)

			filter1 := logpoller.Filter{
				Name: "filter1",
				EventSigs: []common.Hash{
					EmitterABI.Events["Log1"].ID,
					EmitterABI.Events["Log2"].ID},
				Addresses: []common.Address{th.EmitterAddress1},
			}
			err := th.LogPoller.RegisterFilter(ctx, filter1)
			require.NoError(t, err)

			filters, err := th.ORM.LoadFilters(ctx)
			require.NoError(t, err)
			require.Len(t, filters, 1)
			require.Equal(t, filter1, filters["filter1"])

			err = th.LogPoller.RegisterFilter(ctx,
				logpoller.Filter{
					Name:      "filter2",
					EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
					Addresses: []common.Address{th.EmitterAddress2},
				})
			require.NoError(t, err)

			defer func() {
				assert.NoError(t, th.LogPoller.UnregisterFilter(ctx, "filter1"))
			}()
			defer func() {
				assert.NoError(t, th.LogPoller.UnregisterFilter(ctx, "filter2"))
			}()

			for n := 1; n < 31; n++ {
				h := th.Backend.Commit()
				require.Len(t, h, 32)
			}

			// generate some tx's with logs
			tx1, err := th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})
			require.NoError(t, err)
			require.NotNil(t, tx1)

			tx2, err := th.Emitter1.EmitLog2(th.Owner, []*big.Int{big.NewInt(2)})
			require.NoError(t, err)
			require.NotNil(t, tx2)

			tx3, err := th.Emitter2.EmitLog1(th.Owner, []*big.Int{big.NewInt(3)})
			require.NoError(t, err)
			require.NotNil(t, tx3)

			th.Backend.Commit() // commit block 32 with 3 tx's included

			block32, err := th.Client.BlockByNumber(ctx, nil)
			require.NoError(t, err)
			require.Equal(t, uint64(32), block32.Number().Uint64())

			// Ensure that the logs have been included in this rpc server's view of the blockchain
			txs := block32.Body().Transactions
			require.Len(t, txs, 3)
			receipt, err := th.Client.TransactionReceipt(ctx, txs[0].Hash())
			require.NoError(t, err)
			require.NotZero(t, receipt)
			require.Len(t, receipt.Logs, 1)

			// Simulate an optimism rpc server, which is behind and still syncing
			backupRPC := simulated.NewBackend(types.GenesisAlloc{
				th.Owner.From: {
					Balance: big.NewInt(0).Mul(big.NewInt(10), big.NewInt(1e18)),
				},
			}, simulated.WithBlockGasLimit(10e6))

			primaryRPC := th.Backend // save primaryRPC for later

			// Failover to simulated optimism rpc on block 30
			th.Client.RegisterHeadByNumberCallback(func(ctx context.Context, c *client.SimulatedBackendClient, n *big.Int) error {
				if n.Int64() != 32 {
					return nil
				}
				th.SetActiveClient(backupRPC, chaintype.ChainOptimismBedrock)
				return nil
			})

			currentBlockNumber := th.PollAndSaveLogs(ctx, 1)
			require.Equal(t, int64(33), currentBlockNumber)

			// logs shouldn't show up yet
			logs, err := th.LogPoller.Logs(ctx, 32, 32, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)
			require.NoError(t, err)
			require.Empty(t, logs)

			th.finalizeThroughBlock(t, 32)

			b, ok := primaryRPC.(*Backend)
			require.True(t, ok)
			th.SetActiveClient(b, chaintype.ChainOptimismBedrock) // restore primary rpc

			// Run ordinary poller + backup poller at least once
			require.NoError(t, err)
			currentBlockNumber = th.PollAndSaveLogs(ctx, currentBlockNumber)
			require.Equal(t, int64(33), currentBlockNumber)
			require.NoError(t, th.LogPoller.BackupPollAndSaveLogs(ctx))
			latestBlock, err := th.LogPoller.LatestBlock(ctx)
			require.NoError(t, err)
			require.Equal(t, currentBlockNumber-1, latestBlock.BlockNumber) // shouldn't change

			// logs still shouldn't show up, because we don't want to backfill the last finalized log
			//  to help with reorg detection
			logs, err = th.LogPoller.Logs(ctx, 32, 32, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)
			require.NoError(t, err)
			require.Empty(t, logs)
			th.Backend.Commit()
			th.finalizeThroughBlock(t, 64)

			// Run ordinary poller + backup poller at least once more
			th.LogPoller.PollAndSaveLogs(ctx, currentBlockNumber)
			require.NoError(t, th.LogPoller.BackupPollAndSaveLogs(ctx))
			currentBlock, err := th.LogPoller.LatestBlock(ctx)
			require.NoError(t, err)

			require.Equal(t, int64(64), currentBlock.BlockNumber)

			// all 3 logs in block 34 should show up now, thanks to backup logger
			logs, err = th.LogPoller.Logs(ctx, 30, 37, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)
			require.NoError(t, err)
			assert.Len(t, logs, 1)
			logs, err = th.LogPoller.Logs(ctx, 32, 32, EmitterABI.Events["Log2"].ID, th.EmitterAddress1)
			require.NoError(t, err)
			assert.Len(t, logs, 1)
			logs, err = th.LogPoller.Logs(ctx, 32, 36, EmitterABI.Events["Log1"].ID, th.EmitterAddress2)
			require.NoError(t, err)
			assert.Len(t, logs, 1)
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(ctx, filter1)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.LoadFilters(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(ctx,
				logpoller.Filter{
					Name:      "filter2",
					EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
					Addresses: []common.Address{th.EmitterAddress2},
				})`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog2(th.Owner, []*big.Int{big.NewInt(2)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter2.EmitLog1(th.Owner, []*big.Int{big.NewInt(3)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(3)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByNumber(ctx, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Body()`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.TransactionReceipt(ctx, txs[0].Hash())`
$DIR/pkg/logpoller/log_poller_test.go: `.Hash()`
$DIR/pkg/logpoller/log_poller_test.go: `.NewBackend(types.GenesisAlloc{
				th.Owner.From: {
					Balance: big.NewInt(0).Mul(big.NewInt(10), big.NewInt(1e18)),
				},
			}, simulated.WithBlockGasLimit(10e6))`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(0)`
$DIR/pkg/logpoller/log_poller_test.go: `.Mul(big.NewInt(10), big.NewInt(1e18))`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(10)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1e18)`
$DIR/pkg/logpoller/log_poller_test.go: `.WithBlockGasLimit(10e6)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.RegisterHeadByNumberCallback(func(ctx context.Context, c *client.SimulatedBackendClient, n *big.Int) error {
				if n.Int64() != 32 {
					return nil
				}
				th.SetActiveClient(backupRPC, chaintype.ChainOptimismBedrock)
				return nil
			})`
$DIR/pkg/logpoller/log_poller_test.go: `.Int64()`
$DIR/pkg/logpoller/log_poller_test.go: `.SetActiveClient(backupRPC, chaintype.ChainOptimismBedrock)`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(ctx, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(ctx, 32, 32, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `.finalizeThroughBlock(t, 32)`
$DIR/pkg/logpoller/log_poller_test.go: `.SetActiveClient(b, chaintype.ChainOptimismBedrock)`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(ctx, currentBlockNumber)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.LatestBlock(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(ctx, 32, 32, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.finalizeThroughBlock(t, 64)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.PollAndSaveLogs(ctx, currentBlockNumber)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.LatestBlock(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(ctx, 30, 37, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(ctx, 32, 32, EmitterABI.Events["Log2"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(ctx, 32, 36, EmitterABI.Events["Log1"].ID, th.EmitterAddress2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(ctx, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(ctx, logpoller.Filter{
		Name:      "Test Emitter",
		EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
		Addresses: []common.Address{th.EmitterAddress1},
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(
		ctx,
		0,
		42,
		EmitterABI.Events["Log1"].ID,
		th.EmitterAddress1,
	)`
$DIR/pkg/logpoller/log_poller_test.go: `.finalizeThroughBlock(t, 42)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(
		ctx,
		0,
		43,
		EmitterABI.Events["Log1"].ID,
		th.EmitterAddress1,
	)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.HeaderByNumber(ctx, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(ctx, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.LatestBlock(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(ctx, logpoller.Filter{
		Name:      "Test Emitter",
		EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
		Addresses: []common.Address{th.EmitterAddress1},
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(
		ctx,
		0,
		header.Number.Int64()+1,
		EmitterABI.Events["Log1"].ID,
		th.EmitterAddress1,
	)`
$DIR/pkg/logpoller/log_poller_test.go: `.Number.Int64()`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(0x100 + i))})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(0x100 + i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(ctx, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.finalizeThroughBlock(t, firstBatchBlock)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(0x200 + i))})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(0x200 + i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(ctx, firstBatchBlock)`
$DIR/pkg/logpoller/log_poller_test.go: `.finalizeThroughBlock(t, secondBatchBlock)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(ctx, logpoller.Filter{
		Name:      "Test Emitter",
		EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
		Addresses: []common.Address{th.EmitterAddress1},
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(
		ctx,
		0,
		secondBatchBlock,
		EmitterABI.Events["Log1"].ID,
		th.EmitterAddress1,
	)`
$DIR/pkg/logpoller/log_poller_test.go: `.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000201`)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(ctx, logpoller.Filter{Name: "convertLogs", EventSigs: events, Addresses: addresses})`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByNumber(ctx, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Time()`
$DIR/pkg/logpoller/log_poller_test.go: `.AdjustTime(t, delay1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByNumber(ctx, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByHash(ctx, hash)`
$DIR/pkg/logpoller/log_poller_test.go: `.AdjustTime(t, delay2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter2.EmitLog2(th.Owner, []*big.Int{big.NewInt(2)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByNumber(ctx, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(2)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(5)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.FilterLogs(ctx, query)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.LatestBlock(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(ctx, lb.BlockNumber+1)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(ctx, 0, 20, EmitterABI.Events["Log1"].ID, th.EmitterAddress1)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(ctx, 0, 20, EmitterABI.Events["Log2"].ID, th.EmitterAddress2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByHash(ctx, lg1[0].BlockHash)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByHash(ctx, lg2[0].BlockHash)`
$DIR/pkg/logpoller/log_poller_test.go: `.Time()`
$DIR/pkg/logpoller/log_poller_test.go: `.BlockTimestamp.UTC()`
$DIR/pkg/logpoller/log_poller_test.go: `.Unix()`
$DIR/pkg/logpoller/log_poller_test.go: `.DefaultTestParameters()`
$DIR/pkg/logpoller/log_poller_test.go: `.NewProperties(testParams)`
$DIR/pkg/logpoller/log_poller_test.go: `.Test(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewSqlxDB(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.MustNewSimTransactor(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(10e9)`
$DIR/pkg/logpoller/log_poller_test.go: `.Property("synchronized with geth", prop.ForAll(func(mineOrReorg []uint64) bool {
		// After the set of reorgs, we should have the same canonical blocks that geth does.
		t.Log("Starting test", mineOrReorg)
		chainID := testutils.NewRandomEVMChainID()
		// Set up a test chain with a log emitting contract deployed.
		orm := logpoller.NewORM(chainID, db, lggr)
		// Note this property test is run concurrently and the sim is not threadsafe.
		backend := simulated.NewBackend(types.GenesisAlloc{
			owner.From: {
				Balance: big.NewInt(0).Mul(big.NewInt(10), big.NewInt(1e18)),
			},
		}, simulated.WithBlockGasLimit(10e6))
		ec := backend.Client()
		_, _, emitter1, err := log_emitter.DeployLogEmitter(owner, ec)
		require.NoError(t, err)

		lpOpts := logpoller.Opts{
			PollPeriod:               15 * time.Second,
			FinalityDepth:            int64(finalityDepth),
			BackfillBatchSize:        3,
			RPCBatchSize:             2,
			KeepFinalizedBlocksDepth: 1000,
		}
		simulatedClient := client.NewSimulatedBackendClient(t, backend, chainID)
		ht := headstest.NewSimulatedHeadTracker(simulatedClient, lpOpts.UseFinalityTag, lpOpts.FinalityDepth)
		lp := logpoller.NewLogPoller(orm, simulatedClient, lggr, ht, lpOpts)
		for i := 0; i < finalityDepth; i++ { // Have enough blocks that we could reorg the full finalityDepth-1.
			backend.Commit()
		}
		currentBlockNumber := int64(1)
		lp.PollAndSaveLogs(testutils.Context(t), currentBlockNumber)
		currentBlock, err := lp.LatestBlock(testutils.Context(t))
		require.NoError(t, err)
		matchesGeth := func() bool {
			// Check every block is identical
			latest, err1 := ec.BlockByNumber(testutils.Context(t), nil)
			require.NoError(t, err1)
			for i := 1; i < int(latest.NumberU64()); i++ {
				ourBlock, err1 := lp.BlockByNumber(testutils.Context(t), int64(i))
				require.NoError(t, err1)
				gethBlock, err1 := ec.BlockByNumber(testutils.Context(t), big.NewInt(int64(i)))
				require.NoError(t, err1)
				if ourBlock.BlockHash != gethBlock.Hash() {
					t.Logf("Initial poll our block differs at height %d got %x want %x\n", i, ourBlock.BlockHash, gethBlock.Hash())
					return false
				}
			}
			return true
		}
		if !matchesGeth() {
			return false
		}
		// Randomly pick to mine or reorg
		for i := 0; i < numChainInserts; i++ {
			if rand.Int63()%2 == 0 {
				// Mine blocks
				for j := 0; j < int(mineOrReorg[i]); j++ {
					backend.Commit()
					latest, err1 := ec.BlockByNumber(testutils.Context(t), nil)
					require.NoError(t, err1)
					t.Log("mined block", latest.Hash())
				}
			} else {
				// Reorg blocks
				latest, err1 := ec.BlockByNumber(testutils.Context(t), nil)
				require.NoError(t, err1)
				reorgedBlock := big.NewInt(0).Sub(latest.Number(), big.NewInt(int64(mineOrReorg[i])))
				reorg, err1 := ec.BlockByNumber(testutils.Context(t), reorgedBlock)
				require.NoError(t, err1)
				require.NoError(t, backend.Fork(reorg.Hash()))

				t.Logf("Reorging from (%v, %x) back to (%v, %x)\n", latest.NumberU64(), latest.Hash(), reorgedBlock.Uint64(), reorg.Hash())
				// Actually need to change the block here to trigger the reorg.
				_, err1 = emitter1.EmitLog1(owner, []*big.Int{big.NewInt(1)})
				require.NoError(t, err1)
				for j := 0; j < int(mineOrReorg[i]+1); j++ { // Need +1 to make it actually longer height so we detect it.
					backend.Commit()
				}
				latest, err1 = ec.BlockByNumber(testutils.Context(t), nil)
				require.NoError(t, err1)
				t.Logf("New latest (%v, %x), latest parent %x)\n", latest.NumberU64(), latest.Hash(), latest.ParentHash())
			}
			lp.PollAndSaveLogs(testutils.Context(t), currentBlock.BlockNumber)
			currentBlock, err = lp.LatestBlock(testutils.Context(t))
			require.NoError(t, err)
		}
		return matchesGeth()
	}, gen.SliceOfN(numChainInserts, gen.UInt64Range(1, uint64(finalityDepth-1)))))`
$DIR/pkg/logpoller/log_poller_test.go: `.ForAll(func(mineOrReorg []uint64) bool {
		// After the set of reorgs, we should have the same canonical blocks that geth does.
		t.Log("Starting test", mineOrReorg)
		chainID := testutils.NewRandomEVMChainID()
		// Set up a test chain with a log emitting contract deployed.
		orm := logpoller.NewORM(chainID, db, lggr)
		// Note this property test is run concurrently and the sim is not threadsafe.
		backend := simulated.NewBackend(types.GenesisAlloc{
			owner.From: {
				Balance: big.NewInt(0).Mul(big.NewInt(10), big.NewInt(1e18)),
			},
		}, simulated.WithBlockGasLimit(10e6))
		ec := backend.Client()
		_, _, emitter1, err := log_emitter.DeployLogEmitter(owner, ec)
		require.NoError(t, err)

		lpOpts := logpoller.Opts{
			PollPeriod:               15 * time.Second,
			FinalityDepth:            int64(finalityDepth),
			BackfillBatchSize:        3,
			RPCBatchSize:             2,
			KeepFinalizedBlocksDepth: 1000,
		}
		simulatedClient := client.NewSimulatedBackendClient(t, backend, chainID)
		ht := headstest.NewSimulatedHeadTracker(simulatedClient, lpOpts.UseFinalityTag, lpOpts.FinalityDepth)
		lp := logpoller.NewLogPoller(orm, simulatedClient, lggr, ht, lpOpts)
		for i := 0; i < finalityDepth; i++ { // Have enough blocks that we could reorg the full finalityDepth-1.
			backend.Commit()
		}
		currentBlockNumber := int64(1)
		lp.PollAndSaveLogs(testutils.Context(t), currentBlockNumber)
		currentBlock, err := lp.LatestBlock(testutils.Context(t))
		require.NoError(t, err)
		matchesGeth := func() bool {
			// Check every block is identical
			latest, err1 := ec.BlockByNumber(testutils.Context(t), nil)
			require.NoError(t, err1)
			for i := 1; i < int(latest.NumberU64()); i++ {
				ourBlock, err1 := lp.BlockByNumber(testutils.Context(t), int64(i))
				require.NoError(t, err1)
				gethBlock, err1 := ec.BlockByNumber(testutils.Context(t), big.NewInt(int64(i)))
				require.NoError(t, err1)
				if ourBlock.BlockHash != gethBlock.Hash() {
					t.Logf("Initial poll our block differs at height %d got %x want %x\n", i, ourBlock.BlockHash, gethBlock.Hash())
					return false
				}
			}
			return true
		}
		if !matchesGeth() {
			return false
		}
		// Randomly pick to mine or reorg
		for i := 0; i < numChainInserts; i++ {
			if rand.Int63()%2 == 0 {
				// Mine blocks
				for j := 0; j < int(mineOrReorg[i]); j++ {
					backend.Commit()
					latest, err1 := ec.BlockByNumber(testutils.Context(t), nil)
					require.NoError(t, err1)
					t.Log("mined block", latest.Hash())
				}
			} else {
				// Reorg blocks
				latest, err1 := ec.BlockByNumber(testutils.Context(t), nil)
				require.NoError(t, err1)
				reorgedBlock := big.NewInt(0).Sub(latest.Number(), big.NewInt(int64(mineOrReorg[i])))
				reorg, err1 := ec.BlockByNumber(testutils.Context(t), reorgedBlock)
				require.NoError(t, err1)
				require.NoError(t, backend.Fork(reorg.Hash()))

				t.Logf("Reorging from (%v, %x) back to (%v, %x)\n", latest.NumberU64(), latest.Hash(), reorgedBlock.Uint64(), reorg.Hash())
				// Actually need to change the block here to trigger the reorg.
				_, err1 = emitter1.EmitLog1(owner, []*big.Int{big.NewInt(1)})
				require.NoError(t, err1)
				for j := 0; j < int(mineOrReorg[i]+1); j++ { // Need +1 to make it actually longer height so we detect it.
					backend.Commit()
				}
				latest, err1 = ec.BlockByNumber(testutils.Context(t), nil)
				require.NoError(t, err1)
				t.Logf("New latest (%v, %x), latest parent %x)\n", latest.NumberU64(), latest.Hash(), latest.ParentHash())
			}
			lp.PollAndSaveLogs(testutils.Context(t), currentBlock.BlockNumber)
			currentBlock, err = lp.LatestBlock(testutils.Context(t))
			require.NoError(t, err)
		}
		return matchesGeth()
	}, gen.SliceOfN(numChainInserts, gen.UInt64Range(1, uint64(finalityDepth-1))))`
$DIR/pkg/logpoller/log_poller_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/log_poller_test.go: `.NewORM(chainID, db, lggr)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewBackend(types.GenesisAlloc{
			owner.From: {
				Balance: big.NewInt(0).Mul(big.NewInt(10), big.NewInt(1e18)),
			},
		}, simulated.WithBlockGasLimit(10e6))`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(0)`
$DIR/pkg/logpoller/log_poller_test.go: `.Mul(big.NewInt(10), big.NewInt(1e18))`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(10)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1e18)`
$DIR/pkg/logpoller/log_poller_test.go: `.WithBlockGasLimit(10e6)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client()`
$DIR/pkg/logpoller/log_poller_test.go: `.DeployLogEmitter(owner, ec)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewSimulatedBackendClient(t, backend, chainID)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewSimulatedHeadTracker(simulatedClient, lpOpts.UseFinalityTag, lpOpts.FinalityDepth)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewLogPoller(orm, simulatedClient, lggr, ht, lpOpts)`
$DIR/pkg/logpoller/log_poller_test.go: `.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), currentBlockNumber)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LatestBlock(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.BlockByNumber(testutils.Context(t), nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NumberU64()`
$DIR/pkg/logpoller/log_poller_test.go: `.BlockByNumber(testutils.Context(t), int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.BlockByNumber(testutils.Context(t), big.NewInt(int64(i)))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Hash()`
$DIR/pkg/logpoller/log_poller_test.go: `.Int63()`
$DIR/pkg/logpoller/log_poller_test.go: `.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.BlockByNumber(testutils.Context(t), nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.BlockByNumber(testutils.Context(t), nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(0)`
$DIR/pkg/logpoller/log_poller_test.go: `.Sub(latest.Number(), big.NewInt(int64(mineOrReorg[i])))`
$DIR/pkg/logpoller/log_poller_test.go: `.Number()`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(mineOrReorg[i]))`
$DIR/pkg/logpoller/log_poller_test.go: `.BlockByNumber(testutils.Context(t), reorgedBlock)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.EmitLog1(owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.BlockByNumber(testutils.Context(t), nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), currentBlock.BlockNumber)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LatestBlock(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.SliceOfN(numChainInserts, gen.UInt64Range(1, uint64(finalityDepth-1)))`
$DIR/pkg/logpoller/log_poller_test.go: `.UInt64Range(1, uint64(finalityDepth-1))`
$DIR/pkg/logpoller/log_poller_test.go: `.Run(tt.name, func(t *testing.T) {
			lpOpts := logpoller.Opts{
				UseFinalityTag:           tt.finalityTag,
				FinalityDepth:            tt.finalityDepth,
				BackfillBatchSize:        3,
				RPCBatchSize:             2,
				KeepFinalizedBlocksDepth: 1000,
			}
			th := SetupTH(t, lpOpts)

			// Set up a log poller listening for log emitter logs.
			err := th.LogPoller.RegisterFilter(testutils.Context(t), logpoller.Filter{
				Name:      "Test Emitter 1 & 2",
				EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID, EmitterABI.Events["Log2"].ID},
				Addresses: []common.Address{th.EmitterAddress1, th.EmitterAddress2},
			})
			require.NoError(t, err)

			b, err := th.Client.BlockByNumber(testutils.Context(t), nil)
			require.NoError(t, err)
			require.Equal(t, uint64(1), b.NumberU64())

			// Test scenario: single block in chain, no logs.
			// Chain genesis <- 1
			// DB: empty
			newStart := th.PollAndSaveLogs(testutils.Context(t), 1)
			assert.Equal(t, int64(2), newStart)

			// We expect to have saved block 1.
			lpb, err := th.ORM.SelectBlockByNumber(testutils.Context(t), 1)
			require.NoError(t, err)
			assert.Equal(t, lpb.BlockHash, b.Hash())
			assert.Equal(t, lpb.BlockNumber, int64(b.NumberU64()))
			assert.Equal(t, int64(1), int64(b.NumberU64()))

			// No logs.
			lgs, err := th.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 1)
			require.NoError(t, err)
			assert.Empty(t, lgs)
			th.assertHaveCanonical(t, 1, 1)

			// Polling again should be a noop, since we are at the latest.
			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(2), newStart)
			latest, err := th.ORM.SelectLatestBlock(testutils.Context(t))
			require.NoError(t, err)
			assert.Equal(t, int64(1), latest.BlockNumber)
			th.assertHaveCanonical(t, 1, 1)

			// Test scenario: one log 2 block chain.
			// Chain gen <- 1 <- 2 (L1)
			// DB: 1
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})
			require.NoError(t, err)
			th.Backend.Commit()

			// Polling should get us the L1 log.
			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(3), newStart)
			latest, err = th.ORM.SelectLatestBlock(testutils.Context(t))
			require.NoError(t, err)
			assert.Equal(t, int64(2), latest.BlockNumber)
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 3)
			require.NoError(t, err)
			require.Len(t, lgs, 1)
			assert.Equal(t, th.EmitterAddress1, lgs[0].Address)
			assert.Equal(t, latest.BlockHash, lgs[0].BlockHash)
			assert.Equal(t, latest.BlockTimestamp, lgs[0].BlockTimestamp)
			assert.Equal(t, hexutil.Encode(lgs[0].Topics[0]), EmitterABI.Events["Log1"].ID.String())
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000001`),
				lgs[0].Data)

			// Test scenario: single block reorg with log.
			// Chain gen <- 1 <- 2 (L1_1)
			//                \ 2'(L1_2) <- 3
			// DB: 1, 2
			// - Detect a reorg,
			// - Update the block 2's hash
			// - Save L1_2
			// - L1_1 deleted
			lca, err := th.Client.BlockByNumber(testutils.Context(t), big.NewInt(1))
			require.NoError(t, err)
			require.NoError(t, th.Backend.Fork(lca.Hash()))
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(2)})
			require.NoError(t, err)
			// Create 2'
			th.Backend.Commit()
			// Create 3 (we need a new block for us to do any polling and detect the reorg).
			th.Backend.Commit()

			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(4), newStart)
			latest, err = th.ORM.SelectLatestBlock(testutils.Context(t))
			require.NoError(t, err)
			assert.Equal(t, int64(3), latest.BlockNumber)
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 3)
			require.NoError(t, err)
			require.Len(t, lgs, 1)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000002`), lgs[0].Data)
			th.assertHaveCanonical(t, 1, 3)

			parent, err := th.Client.BlockByNumber(testutils.Context(t), big.NewInt(1))
			require.NoError(t, err)

			// Test scenario: reorg back to a chain that looks similar to the original chain. (simulated geth used to allow
			// re-org'ing back to exactly the same chain--now the best we can do is re-emit the same logs on a new one to simulate that)
			// Chain gen <- 1 <- 2 (L1_1)
			//               \ 2' (L1_2) <- 3
			//                \ 2''(L1_1) <- 3' <- 4
			require.NoError(t, th.Backend.Fork(parent.Hash()))
			// Re-emit L1 to make 2'' tip look like original 2 tip
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})
			require.NoError(t, err)
			th.Backend.Commit()
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(3)})
			require.NoError(t, err)
			// Create 3'
			th.Backend.Commit()
			// Create 4
			th.Backend.Commit()

			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(5), newStart)
			latest, err = th.ORM.SelectLatestBlock(testutils.Context(t))
			require.NoError(t, err)
			assert.Equal(t, int64(4), latest.BlockNumber)
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 3)
			require.NoError(t, err)

			require.Len(t, lgs, 2)
			assert.Equal(t, int64(2), lgs[0].BlockNumber)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000001`), lgs[0].Data)
			assert.Equal(t, int64(3), lgs[1].BlockNumber)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000003`), lgs[1].Data)
			th.assertHaveCanonical(t, 1, 1)
			th.assertHaveCanonical(t, 3, 4)
			th.assertDontHave(t, 2, 2) // 2 gets backfilled

			// Test scenario: multiple logs per block for many blocks (also after reorg).
			// Chain gen <- 1 <- 2 (L1_1) <- 3' L1_3 <- 4 <- 5 (L1_4, L2_5) <- 6 (L1_6)
			//                \ 2'(L1_2) <- 3
			// DB: 1, 2', 3'
			// - Should save 4, 5, 6 blocks
			// - Should obtain logs L1_3, L2_5, L1_6
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(4)})
			require.NoError(t, err)
			_, err = th.Emitter2.EmitLog1(th.Owner, []*big.Int{big.NewInt(5)})
			require.NoError(t, err)
			// Create 4
			th.Backend.Commit()
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(6)})
			require.NoError(t, err)
			// Create 5
			th.Backend.Commit()

			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(7), newStart)
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 4, 6)
			require.NoError(t, err)
			require.Len(t, lgs, 3)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000004`), lgs[0].Data)
			assert.Equal(t, th.EmitterAddress1, lgs[0].Address)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000005`), lgs[1].Data)
			assert.Equal(t, th.EmitterAddress2, lgs[1].Address)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000006`), lgs[2].Data)
			assert.Equal(t, th.EmitterAddress1, lgs[2].Address)
			th.assertHaveCanonical(t, 1, 1)
			th.assertDontHave(t, 2, 2) // 2 gets backfilled
			th.assertHaveCanonical(t, 3, 6)

			// Test scenario: node down for exactly finality + 2 blocks
			// Note we only backfill up to finalized - 1 blocks, because we need to save the
			// Chain gen <- 1 <- 2 (L1_1) <- 3' L1_3 <- 4 <- 5 (L1_4, L2_5) <- 6 (L1_6) <- 7 (L1_7) <- 8 (L1_8) <- 9 (L1_9) <- 10 (L1_10)
			//                \ 2'(L1_2) <- 3
			// DB: 1, 2, 3, 4, 5, 6
			// - We expect block 7 to backfilled (treated as finalized)
			// - Then block 8-10 to be handled block by block (treated as unfinalized).
			for i := 7; i < 11; i++ {
				_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})
				require.NoError(t, err)
				th.Backend.Commit()
			}

			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(11), newStart)
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 7, 9)
			require.NoError(t, err)
			require.Len(t, lgs, 3)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000007`), lgs[0].Data)
			assert.Equal(t, int64(7), lgs[0].BlockNumber)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000008`), lgs[1].Data)
			assert.Equal(t, int64(8), lgs[1].BlockNumber)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000009`), lgs[2].Data)
			assert.Equal(t, int64(9), lgs[2].BlockNumber)
			th.assertHaveCanonical(t, 8, 10)

			// Test scenario large backfill (multiple batches)
			// Chain gen <- 1 <- 2 (L1_1) <- 3' L1_3 <- 4 <- 5 (L1_4, L2_5) <- 6 (L1_6) <- 7 (L1_7) <- 8 (L1_8) <- 9 (L1_9) <- 10..32
			//                \ 2'(L1_2) <- 3
			// DB: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
			// - 11 - 13 backfilled in batch 1
			// - 14 - 16 backfilled in batch 2
			// ...
			// - 33, 34, 35 to be treated as unfinalized
			for i := 11; i < 36; i++ {
				_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})
				require.NoError(t, err)
				th.Backend.Commit()
			}

			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(36), newStart)
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 11, 36)
			require.NoError(t, err)
			assert.Len(t, lgs, 25)
			th.assertHaveCanonical(t, 32, 36) // Should have last finalized block plus unfinalized blocks
			th.assertDontHave(t, 11, 13)      // Should not have older finalized blocks
			th.assertDontHave(t, 14, 16)      // Should not have older finalized blocks

			// Verify that a custom block timestamp will get written to db correctly also
			b, err = th.Client.BlockByNumber(testutils.Context(t), nil)
			require.NoError(t, err)
			require.Equal(t, uint64(35), b.NumberU64())
			blockTimestamp := b.Time()
			th.AdjustTime(t, time.Hour)
			th.Backend.Commit()

			b, err = th.Client.BlockByNumber(testutils.Context(t), nil)
			require.NoError(t, err)
			require.Equal(t, blockTimestamp+uint64(time.Hour/time.Second)+1, b.Time())
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(testutils.Context(t), logpoller.Filter{
				Name:      "Test Emitter 1 & 2",
				EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID, EmitterABI.Events["Log2"].ID},
				Addresses: []common.Address{th.EmitterAddress1, th.EmitterAddress2},
			})`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByNumber(testutils.Context(t), nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectBlockByNumber(testutils.Context(t), 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertHaveCanonical(t, 1, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectLatestBlock(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertHaveCanonical(t, 1, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectLatestBlock(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 3)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByNumber(testutils.Context(t), big.NewInt(1))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(2)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectLatestBlock(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 3)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertHaveCanonical(t, 1, 3)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByNumber(testutils.Context(t), big.NewInt(1))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(3)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(3)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectLatestBlock(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectLogsByBlockRange(testutils.Context(t), 1, 3)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertHaveCanonical(t, 1, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertHaveCanonical(t, 3, 4)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertDontHave(t, 2, 2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(4)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(4)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter2.EmitLog1(th.Owner, []*big.Int{big.NewInt(5)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(5)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(6)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(6)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectLogsByBlockRange(testutils.Context(t), 4, 6)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertHaveCanonical(t, 1, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertDontHave(t, 2, 2)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertHaveCanonical(t, 3, 6)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectLogsByBlockRange(testutils.Context(t), 7, 9)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertHaveCanonical(t, 8, 10)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectLogsByBlockRange(testutils.Context(t), 11, 36)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertHaveCanonical(t, 32, 36)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertDontHave(t, 11, 13)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertDontHave(t, 14, 16)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByNumber(testutils.Context(t), nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Time()`
$DIR/pkg/logpoller/log_poller_test.go: `.AdjustTime(t, time.Hour)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByNumber(testutils.Context(t), nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run(tt.name, func(t *testing.T) {
			th := SetupTH(t, logpoller.Opts{
				UseFinalityTag:           tt.finalityTag,
				FinalityDepth:            tt.finalityDepth,
				BackfillBatchSize:        3,
				RPCBatchSize:             2,
				KeepFinalizedBlocksDepth: 1000,
				BackupPollerBlockDelay:   100,
			})
			// Set up a log poller listening for log emitter logs.
			err := th.LogPoller.RegisterFilter(testutils.Context(t), logpoller.Filter{
				Name:      "Test Emitter",
				EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
				Addresses: []common.Address{th.EmitterAddress1},
			})
			require.NoError(t, err)

			// Test scenario
			// Chain gen <- 1 <- 2 <- ... <- 32 (finalized) <- 33 (L1_1)
			th.finalizeThroughBlock(t, 32)
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})
			require.NoError(t, err)
			th.Backend.Commit()

			// Polling should get us the L1 log.
			firstPoll := th.PollAndSaveLogs(testutils.Context(t), 1)
			assert.Equal(t, int64(34), firstPoll)
			assert.NoError(t, th.LogPoller.Healthy())

			// Fork deeper than finality depth
			// Chain gen <- 1 <- 2 <- 3 <- ... <- 32 (finalized) <- 33 (L1_1)
			//              \      <- 3' <- ... <- 31' <- 32' (finalized) <- 33' <- 34' (L1_2)
			lca, err := th.Client.BlockByNumber(testutils.Context(t), big.NewInt(2))
			require.NoError(t, err)
			require.NoError(t, th.Backend.Fork(lca.Hash()))

			// Create 3'
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(3)})
			require.NoError(t, err)
			th.Backend.Commit()

			th.finalizeThroughBlock(t, 32)

			// Create 33' - 34'
			for i := 33; i < 35; i++ {
				_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})
				require.NoError(t, err)
				th.Backend.Commit()
			}

			secondPoll := th.PollAndSaveLogs(testutils.Context(t), firstPoll)
			assert.Equal(t, firstPoll, secondPoll)
			require.Equal(t, commontypes.ErrFinalityViolated, th.LogPoller.Healthy())
			require.Equal(t, commontypes.ErrFinalityViolated, th.LogPoller.HealthReport()[th.LogPoller.Name()])

			// Manually remove re-org'd chain from the log poller to bring it back to life
			// LogPoller should be healthy again after first poll
			// Chain gen <- 1 <- 2
			//                    \ <- 3' <- 4' <- 5' <- 32' (finalized) <- 33' <- 34' (L1_2)
			require.NoError(t, th.ORM.DeleteLogsAndBlocksAfter(testutils.Context(t), 3))
			// Poll from latest
			recoveryPoll := th.PollAndSaveLogs(testutils.Context(t), 1)
			assert.Equal(t, int64(35), recoveryPoll)
			require.NoError(t, th.LogPoller.Healthy())
			require.NoError(t, th.LogPoller.HealthReport()[th.LogPoller.Name()])
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(testutils.Context(t), logpoller.Filter{
				Name:      "Test Emitter",
				EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
				Addresses: []common.Address{th.EmitterAddress1},
			})`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.finalizeThroughBlock(t, 32)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByNumber(testutils.Context(t), big.NewInt(2))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(3)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(3)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.finalizeThroughBlock(t, 32)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), firstPoll)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run(tt.name, func(t *testing.T) {
			lpOpts := logpoller.Opts{
				UseFinalityTag:           tt.finalityTag,
				FinalityDepth:            tt.finalityDepth,
				BackfillBatchSize:        50,
				RPCBatchSize:             50,
				KeepFinalizedBlocksDepth: 1000,
			}
			th := SetupTH(t, lpOpts)
			// Set up a log poller listening for log emitter logs.
			err := th.LogPoller.RegisterFilter(testutils.Context(t), logpoller.Filter{
				Name:      "Test Emitter",
				EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
				Addresses: []common.Address{th.EmitterAddress1},
			})
			require.NoError(t, err)

			// Test scenario: one log 2 block chain.
			// Chain gen <- 1 <- 2 (L1_1)
			// DB: 1
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})
			require.NoError(t, err)
			th.Backend.Commit()

			// Polling should get us the L1 log.
			newStart := th.PollAndSaveLogs(testutils.Context(t), 1)
			assert.NoError(t, th.LogPoller.Healthy())
			assert.Equal(t, int64(3), newStart)
			// Check that L1_1 has a proper data payload
			lgs, err := th.ORM.SelectLogsByBlockRange(testutils.Context(t), 2, 2)
			require.NoError(t, err)
			require.NotEmpty(t, lgs)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000001`), lgs[0].Data)

			// Single block reorg and log poller not working for a while, mine blocks and progress with finalization
			// Chain gen <- 1 <- 2 (L1_1)
			//                \ 2'(L1_2) <- 3' <- 4' <- ... <- 32' (finalized on chain) <- 33' <- 34' <- 35'
			lca, err := th.Client.BlockByNumber(testutils.Context(t), big.NewInt(1))
			require.NoError(t, err)
			require.NoError(t, th.Backend.Fork(lca.Hash()))
			// Create 2'
			_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(2)})
			require.NoError(t, err)
			th.Backend.Commit()
			// Create 3-35
			for i := 3; i <= 35; i++ {
				_, err = th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})
				require.NoError(t, err)
				th.Backend.Commit()
			}
			th.finalizeThroughBlock(t, 32)

			newStart = th.PollAndSaveLogs(testutils.Context(t), newStart)
			assert.Equal(t, int64(36), newStart)
			assert.NoError(t, th.LogPoller.Healthy())

			// Expect L1_2 to be properly updated
			lgs, err = th.ORM.SelectLogsByBlockRange(testutils.Context(t), 2, 31)
			require.NoError(t, err)
			require.Len(t, lgs, 30)
			assert.Equal(t, hexutil.MustDecode(`0x0000000000000000000000000000000000000000000000000000000000000002`), lgs[0].Data)
			th.assertHaveCanonical(t, 1, 2)
			th.assertDontHave(t, 2, 31) // These blocks are backfilled
			th.assertHaveCanonical(t, 32, 36)
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(testutils.Context(t), logpoller.Filter{
				Name:      "Test Emitter",
				EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
				Addresses: []common.Address{th.EmitterAddress1},
			})`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectLogsByBlockRange(testutils.Context(t), 2, 2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.BlockByNumber(testutils.Context(t), big.NewInt(1))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(2)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.finalizeThroughBlock(t, 32)`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), newStart)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectLogsByBlockRange(testutils.Context(t), 2, 31)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertHaveCanonical(t, 1, 2)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertDontHave(t, 2, 31)`
$DIR/pkg/logpoller/log_poller_test.go: `.assertHaveCanonical(t, 32, 36)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(testutils.Context(t), filter1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(testutils.Context(t), filter2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(testutils.Context(t), filter3)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.LoadFilters(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run("HasFilter", func(t *testing.T) {
		assert.True(t, th.LogPoller.HasFilter("first Filter"))
		assert.True(t, th.LogPoller.HasFilter("second Filter"))
		assert.True(t, th.LogPoller.HasFilter("third Filter"))
		assert.False(t, th.LogPoller.HasFilter("fourth Filter"))
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.GetFilters()`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(1)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(2)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(testutils.Context(t), logpoller.Filter{
		Name:      "GetBlocks Test",
		EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID, EmitterABI.Events["Log2"].ID},
		Addresses: []common.Address{th.EmitterAddress1, th.EmitterAddress2},
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.GetBlocksRange(testutils.Context(t), blockNums)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.GetBlocksRange(testutils.Context(t), blockNums)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.GetBlocksRange(testutils.Context(t), blockNums)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectBlockByNumber(testutils.Context(t), 2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.GetBlocksRange(testutils.Context(t), blockNums)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectBlockByNumber(testutils.Context(t), 3)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.GetBlocksRange(testutils.Context(t), blockNums2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.PollAndSaveLogs(testutils.Context(t), 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.SelectBlockByNumber(testutils.Context(t), 3)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.GetBlocksRange(testutils.Context(t), blockNums)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.GetBlocksRange(testutils.Context(t), blockNums)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.GetBlocksRange(testutils.Context(t), blockNums)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.WithCancel(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.GetBlocksRange(ctx, blockNums)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.GetReplayFromBlock(testutils.Context(t), requested)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(testutils.Context(t), 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.GetReplayFromBlock(testutils.Context(t), requested)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.LatestBlock(testutils.Context(t))`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.GetReplayFromBlock(testutils.Context(t), requested)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.TestObserved(t, zapcore.WarnLevel)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/log_poller_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/log_poller_test.go: `.NewSqlxDB(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewORM(chainID1, db, lggr)`
$DIR/pkg/logpoller/log_poller_test.go: `.MustNewSimTransactor(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewBackend(types.GenesisAlloc{
		owner.From: {
			Balance: big.NewInt(0).Mul(big.NewInt(10), big.NewInt(1e18)),
		},
	}, simulated.WithBlockGasLimit(10e6))`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(0)`
$DIR/pkg/logpoller/log_poller_test.go: `.Mul(big.NewInt(10), big.NewInt(1e18))`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(10)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(1e18)`
$DIR/pkg/logpoller/log_poller_test.go: `.WithBlockGasLimit(10e6)`
$DIR/pkg/logpoller/log_poller_test.go: `.Client()`
$DIR/pkg/logpoller/log_poller_test.go: `.DeployLogEmitter(owner, ec)`
$DIR/pkg/logpoller/log_poller_test.go: `.EmitLog1(owner, []*big.Int{big.NewInt(9)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(9)`
$DIR/pkg/logpoller/log_poller_test.go: `.EmitLog1(owner, []*big.Int{big.NewInt(7)})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(7)`
$DIR/pkg/logpoller/log_poller_test.go: `.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.NewLogPoller(o, client.NewSimulatedBackendClient(t, backend, chainID2), lggr, nil, lpOpts)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewSimulatedBackendClient(t, backend, chainID2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Replay(ctx, 5)`
$DIR/pkg/logpoller/log_poller_test.go: `.Replay(ctx, 2)`
$DIR/pkg/logpoller/log_poller_test.go: `.Sleep(100 * time.Millisecond)`
$DIR/pkg/logpoller/log_poller_test.go: `.RequireEventually(t, func() bool {
		return observedLogs.Len() >= 1
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.Len()`
$DIR/pkg/logpoller/log_poller_test.go: `.All()`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.TestObserved(t, zapcore.DebugLevel)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/log_poller_test.go: `.NewSqlxDB(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewORM(chainID, db, lggr)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewLogPoller(o, ec, lggr, headTracker, lpOpts)`
$DIR/pkg/logpoller/log_poller_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(func(ctx context.Context, blockNumber *big.Int) (*evmtypes.Head, error) {
		if blockNumber == nil {
			require.FailNow(t, "unexpected call to get current head")
		}
		return &evmtypes.Head{Number: blockNumber.Int64(), ParentHash: common.HexToHash(fmt.Sprintf("0x%x", blockNumber.Int64()-1))}, nil
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.Int64()`
$DIR/pkg/logpoller/log_poller_test.go: `.HexToHash(fmt.Sprintf("0x%x", blockNumber.Int64()-1))`
$DIR/pkg/logpoller/log_poller_test.go: `.Sprintf("0x%x", blockNumber.Int64()-1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Int64()`
$DIR/pkg/logpoller/log_poller_test.go: `.Run("halves size until small enough, then succeeds", func(t *testing.T) {
		// Simulate latestBlock = 300
		head.Number = 300
		head.Hash = common.HexToHash("0x1234") // needed to satisfy validation in fetchBlocks()
		finalized.Number = head.Number - lpOpts.FinalityDepth

		headTracker.On("LatestAndFinalizedBlock", mock.Anything).Return(head, finalized, nil).Once()
		headTracker.On("LatestSafeBlock", mock.Anything).Return(finalized, nil).Once()

		headByHash := ec.On("HeadByHash", mock.Anything, mock.Anything).Return(func(ctx context.Context, blockHash common.Hash) (*evmtypes.Head, error) {
			return &evmtypes.Head{Hash: blockHash}, nil
		})

		batchCallContext := ec.On("BatchCallContext", mock.Anything, mock.Anything).Return(
			func(ctx context.Context, calls []rpc.BatchElem) error {
				for i := range calls {
					blockNumberHex := calls[i].Args[0].(string)
					if blockNumberHex == "latest" {
						calls[i].Result = head
						continue
					}
					blockNumber, ok := new(big.Int).SetString(blockNumberHex[2:], 16)
					require.True(t, ok, blockNumberHex)

					calls[i].Result = &evmtypes.Head{
						Number:     blockNumber.Int64(),
						Hash:       common.HexToHash(fmt.Sprintf("0x%x", blockNumber.Int64())),
						ParentHash: common.HexToHash(fmt.Sprintf("0x%x", blockNumber.Int64()-1)),
					}
				}
				return nil
			},
		)

		filterLogsCall = ec.On("FilterLogs", mock.Anything, mock.Anything).Return(func(ctx context.Context, fq ethereum.FilterQuery) (logs []types.Log, err error) {
			if fq.BlockHash != nil {
				return []types.Log{}, nil // succeed when single block requested
			}
			from := fq.FromBlock.Uint64()
			to := fq.ToBlock.Uint64()
			if to-from >= 8 {
				return []types.Log{}, context.DeadlineExceeded // simulate RPC client timeout as a "too many results" scenario
			}
			if to-from >= 4 {
				return []types.Log{}, tooLargeErr // return "too many results" error if block range spans 4 or more blocks
			}
			return logs, err
		})

		addr := testutils.NewAddress()
		err := lp.RegisterFilter(ctx, logpoller.Filter{
			Name:      "Integration test",
			EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
			Addresses: []common.Address{addr},
		})
		require.NoError(t, err)
		lp.PollAndSaveLogs(ctx, 5)
		block, err2 := o.SelectLatestBlock(ctx)
		require.NoError(t, err2)
		assert.Equal(t, int64(298), block.BlockNumber)

		logs := obs.FilterLevelExact(zapcore.WarnLevel).FilterMessageSnippet("halving block range batch size").FilterFieldKey("newBatchSize").All()
		// Should have tried again 3 times--first reducing batch size to 10, then 5, then 2
		require.Len(t, logs, 3)
		for i, s := range expected[:3] {
			assert.Equal(t, s, logs[i].ContextMap()["newBatchSize"])
		}
		filterLogsCall.Unset()
		batchCallContext.Unset()
		headByHash.Unset()
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.HexToHash("0x1234")`
$DIR/pkg/logpoller/log_poller_test.go: `.On("LatestAndFinalizedBlock", mock.Anything)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(head, finalized, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_test.go: `.On("LatestSafeBlock", mock.Anything)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(finalized, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_test.go: `.On("HeadByHash", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(func(ctx context.Context, blockHash common.Hash) (*evmtypes.Head, error) {
			return &evmtypes.Head{Hash: blockHash}, nil
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.On("BatchCallContext", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(
			func(ctx context.Context, calls []rpc.BatchElem) error {
				for i := range calls {
					blockNumberHex := calls[i].Args[0].(string)
					if blockNumberHex == "latest" {
						calls[i].Result = head
						continue
					}
					blockNumber, ok := new(big.Int).SetString(blockNumberHex[2:], 16)
					require.True(t, ok, blockNumberHex)

					calls[i].Result = &evmtypes.Head{
						Number:     blockNumber.Int64(),
						Hash:       common.HexToHash(fmt.Sprintf("0x%x", blockNumber.Int64())),
						ParentHash: common.HexToHash(fmt.Sprintf("0x%x", blockNumber.Int64()-1)),
					}
				}
				return nil
			},
		)`
$DIR/pkg/logpoller/log_poller_test.go: `.SetString(blockNumberHex[2:], 16)`
$DIR/pkg/logpoller/log_poller_test.go: `.Int64()`
$DIR/pkg/logpoller/log_poller_test.go: `.HexToHash(fmt.Sprintf("0x%x", blockNumber.Int64()))`
$DIR/pkg/logpoller/log_poller_test.go: `.Sprintf("0x%x", blockNumber.Int64())`
$DIR/pkg/logpoller/log_poller_test.go: `.Int64()`
$DIR/pkg/logpoller/log_poller_test.go: `.HexToHash(fmt.Sprintf("0x%x", blockNumber.Int64()-1))`
$DIR/pkg/logpoller/log_poller_test.go: `.Sprintf("0x%x", blockNumber.Int64()-1)`
$DIR/pkg/logpoller/log_poller_test.go: `.Int64()`
$DIR/pkg/logpoller/log_poller_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(func(ctx context.Context, fq ethereum.FilterQuery) (logs []types.Log, err error) {
			if fq.BlockHash != nil {
				return []types.Log{}, nil // succeed when single block requested
			}
			from := fq.FromBlock.Uint64()
			to := fq.ToBlock.Uint64()
			if to-from >= 8 {
				return []types.Log{}, context.DeadlineExceeded // simulate RPC client timeout as a "too many results" scenario
			}
			if to-from >= 4 {
				return []types.Log{}, tooLargeErr // return "too many results" error if block range spans 4 or more blocks
			}
			return logs, err
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.FromBlock.Uint64()`
$DIR/pkg/logpoller/log_poller_test.go: `.ToBlock.Uint64()`
$DIR/pkg/logpoller/log_poller_test.go: `.NewAddress()`
$DIR/pkg/logpoller/log_poller_test.go: `.RegisterFilter(ctx, logpoller.Filter{
			Name:      "Integration test",
			EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
			Addresses: []common.Address{addr},
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(ctx, 5)`
$DIR/pkg/logpoller/log_poller_test.go: `.SelectLatestBlock(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.FilterLevelExact(zapcore.WarnLevel)`
$DIR/pkg/logpoller/log_poller_test.go: `.FilterMessageSnippet("halving block range batch size")`
$DIR/pkg/logpoller/log_poller_test.go: `.FilterFieldKey("newBatchSize")`
$DIR/pkg/logpoller/log_poller_test.go: `.All()`
$DIR/pkg/logpoller/log_poller_test.go: `.Unset()`
$DIR/pkg/logpoller/log_poller_test.go: `.Unset()`
$DIR/pkg/logpoller/log_poller_test.go: `.Unset()`
$DIR/pkg/logpoller/log_poller_test.go: `.Run("Halves size until single block, then reports critical error", func(t *testing.T) {
		obs.TakeAll()

		// Now jump to block 500, but return error no matter how small the block range gets.
		//  Should exit the loop with a critical error instead of hanging.
		head.Number = 500
		finalized.Number = head.Number - lpOpts.FinalityDepth
		headTracker.On("LatestAndFinalizedBlock", mock.Anything).Return(head, finalized, nil).Once()
		headTracker.On("LatestSafeBlock", mock.Anything).Return(finalized, nil).Once()
		filterLogsCall = ec.On("FilterLogs", mock.Anything, mock.Anything).Return(func(ctx context.Context, fq ethereum.FilterQuery) (logs []types.Log, err error) {
			if fq.BlockHash != nil {
				return []types.Log{}, nil // succeed when single block requested
			}
			return []types.Log{}, tooLargeErr // return "too many results" error if block range spans 4 or more blocks
		})

		lp.PollAndSaveLogs(ctx, 298)
		block, err := o.SelectLatestBlock(ctx)
		if err != nil {
			require.ErrorContains(t, err, "no rows") // In case this subtest is run by itself
		} else {
			assert.Equal(t, int64(298), block.BlockNumber)
		}
		warns := obs.FilterMessageSnippet("halving block range").FilterLevelExact(zapcore.WarnLevel).All()
		crit := obs.FilterMessageSnippet("failed to retrieve logs").FilterLevelExact(zapcore.DPanicLevel).All()
		require.Len(t, warns, 4)
		for i, s := range expected {
			assert.Equal(t, s, warns[i].ContextMap()["newBatchSize"])
		}

		require.Len(t, crit, 1)
		assert.Contains(t, crit[0].Message, "Too many log results in a single block")
		filterLogsCall.Unset()
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.TakeAll()`
$DIR/pkg/logpoller/log_poller_test.go: `.On("LatestAndFinalizedBlock", mock.Anything)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(head, finalized, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_test.go: `.On("LatestSafeBlock", mock.Anything)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(finalized, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(func(ctx context.Context, fq ethereum.FilterQuery) (logs []types.Log, err error) {
			if fq.BlockHash != nil {
				return []types.Log{}, nil // succeed when single block requested
			}
			return []types.Log{}, tooLargeErr // return "too many results" error if block range spans 4 or more blocks
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(ctx, 298)`
$DIR/pkg/logpoller/log_poller_test.go: `.SelectLatestBlock(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.FilterMessageSnippet("halving block range")`
$DIR/pkg/logpoller/log_poller_test.go: `.FilterLevelExact(zapcore.WarnLevel)`
$DIR/pkg/logpoller/log_poller_test.go: `.All()`
$DIR/pkg/logpoller/log_poller_test.go: `.FilterMessageSnippet("failed to retrieve logs")`
$DIR/pkg/logpoller/log_poller_test.go: `.FilterLevelExact(zapcore.DPanicLevel)`
$DIR/pkg/logpoller/log_poller_test.go: `.All()`
$DIR/pkg/logpoller/log_poller_test.go: `.Unset()`
$DIR/pkg/logpoller/log_poller_test.go: `.New("Unrelated to the size of the request")`
$DIR/pkg/logpoller/log_poller_test.go: `.TakeAll()`
$DIR/pkg/logpoller/log_poller_test.go: `.On("FilterLogs", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(func(ctx context.Context, fq ethereum.FilterQuery) (logs []types.Log, err error) {
			if fq.BlockHash != nil {
				return []types.Log{}, nil // succeed when single block requested
			}
			return []types.Log{}, unrelatedError // return an unrelated error that should just be retried with same size
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.On("LatestAndFinalizedBlock", mock.Anything)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(head, finalized, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_test.go: `.On("LatestSafeBlock", mock.Anything)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(finalized, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(ctx, 298)`
$DIR/pkg/logpoller/log_poller_test.go: `.SelectLatestBlock(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.FilterLevelExact(zapcore.DPanicLevel)`
$DIR/pkg/logpoller/log_poller_test.go: `.All()`
$DIR/pkg/logpoller/log_poller_test.go: `.FilterLevelExact(zapcore.ErrorLevel)`
$DIR/pkg/logpoller/log_poller_test.go: `.All()`
$DIR/pkg/logpoller/log_poller_test.go: `.FilterLevelExact(zapcore.WarnLevel)`
$DIR/pkg/logpoller/log_poller_test.go: `.All()`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(ctx, logpoller.Filter{
		Name:      "GetBlocks Test",
		EventSigs: []common.Hash{eventSig},
		Addresses: []common.Address{th.EmitterAddress1}},
	)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.HeaderByNumber(ctx, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.finalizeThroughBlock(t, h.Number.Int64())`
$DIR/pkg/logpoller/log_poller_test.go: `.Number.Int64()`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(ctx, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.LogsDataWordGreaterThan(
		ctx,
		eventSig,
		th.EmitterAddress1,
		0,
		common.Hash{},
		evmtypes.Finalized,
	)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.LogsDataWordGreaterThan(
		ctx,
		eventSig,
		th.EmitterAddress1,
		0,
		common.Hash{},
		evmtypes.Safe,
	)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.LogsDataWordGreaterThan(
		ctx,
		eventSig,
		th.EmitterAddress1,
		0,
		common.Hash{},
		evmtypes.Confirmations(numberOfConfirmations),
	)`
$DIR/pkg/logpoller/log_poller_test.go: `.Confirmations(numberOfConfirmations)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run(tt.name, func(t *testing.T) {
			lpOpts := logpoller.Opts{
				UseFinalityTag:           tt.useFinalityTag,
				FinalityDepth:            tt.finalityDepth,
				BackfillBatchSize:        3,
				RPCBatchSize:             2,
				KeepFinalizedBlocksDepth: 1000,
			}
			th := SetupTH(t, lpOpts)
			// Should return error before the first poll and save
			_, err := th.LogPoller.LatestBlock(ctx)
			require.Error(t, err)

			// Create a couple of blocks
			for i := 0; i < numberOfBlocks-1; i++ {
				th.Backend.Commit()
			}

			if tt.useFinalityTag {
				th.finalizeThroughBlock(t, tt.expectedFinalizedBlock)
			}

			th.PollAndSaveLogs(ctx, 1)

			latestBlock, err := th.LogPoller.LatestBlock(ctx)
			require.NoError(t, err)
			require.Equal(t, int64(numberOfBlocks), latestBlock.BlockNumber)
			require.Equal(t, tt.expectedFinalizedBlock, latestBlock.FinalizedBlockNumber)
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.LatestBlock(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.finalizeThroughBlock(t, tt.expectedFinalizedBlock)`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(ctx, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.LatestBlock(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run(tt.name, func(t *testing.T) {
			lpOpts := logpoller.Opts{
				UseFinalityTag:           tt.finalityTag,
				FinalityDepth:            tt.finalityDepth,
				BackfillBatchSize:        3,
				RPCBatchSize:             2,
				KeepFinalizedBlocksDepth: 1000,
				BackupPollerBlockDelay:   100,
			}
			th := SetupTH(t, lpOpts)

			header, err := th.Client.HeaderByNumber(ctx, nil)
			require.NoError(t, err)
			require.LessOrEqual(t, header.Time, uint64(math.MaxInt64))
			genesisBlockTime := time.Unix(int64(header.Time), 0) //nolint:gosec // G115 false positive

			// Emit some logs in blocks
			for i := 0; i < emittedLogs; i++ {
				_, err2 := th.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})
				require.NoError(t, err2)
				th.Backend.Commit()
			}

			// First PollAndSave, no filters are registered
			currentBlock := th.PollAndSaveLogs(ctx, 1)

			err = th.LogPoller.RegisterFilter(ctx, logpoller.Filter{
				Name:      "Test Emitter",
				EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
				Addresses: []common.Address{th.EmitterAddress1},
			})
			require.NoError(t, err)

			// Finalize current block, because backup always backfill up to one block before last finalized
			if tt.finalityTag {
				th.finalizeThroughBlock(t, currentBlock)
			} else {
				for i := 0; i < int(tt.finalityDepth)+1; i++ {
					th.Backend.Commit()
				}
			}

			// LogPoller should backfill entire history
			require.NoError(t, th.LogPoller.BackupPollAndSaveLogs(ctx))
			require.NoError(t, err)

			// Make sure that all logs are backfilled
			logs, err := th.LogPoller.Logs(
				ctx,
				0,
				currentBlock,
				EmitterABI.Events["Log1"].ID,
				th.EmitterAddress1,
			)
			require.NoError(t, err)
			require.Len(t, logs, emittedLogs)

			// We should get all the logs by the block_timestamp
			logs, err = th.LogPoller.LogsCreatedAfter(
				ctx,
				EmitterABI.Events["Log1"].ID,
				th.EmitterAddress1,
				genesisBlockTime,
				0,
			)
			require.NoError(t, err)
			require.Len(t, logs, emittedLogs)
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.Client.HeaderByNumber(ctx, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Unix(int64(header.Time), 0)`
$DIR/pkg/logpoller/log_poller_test.go: `.Emitter1.EmitLog1(th.Owner, []*big.Int{big.NewInt(int64(i))})`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.PollAndSaveLogs(ctx, 1)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.RegisterFilter(ctx, logpoller.Filter{
				Name:      "Test Emitter",
				EventSigs: []common.Hash{EmitterABI.Events["Log1"].ID},
				Addresses: []common.Address{th.EmitterAddress1},
			})`
$DIR/pkg/logpoller/log_poller_test.go: `.finalizeThroughBlock(t, currentBlock)`
$DIR/pkg/logpoller/log_poller_test.go: `.Backend.Commit()`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.Logs(
				ctx,
				0,
				currentBlock,
				EmitterABI.Events["Log1"].ID,
				th.EmitterAddress1,
			)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.LogsCreatedAfter(
				ctx,
				EmitterABI.Events["Log1"].ID,
				th.EmitterAddress1,
				genesisBlockTime,
				0,
			)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run(tt.name, func(t *testing.T) {
			lpOpts := logpoller.Opts{
				UseFinalityTag:           true,
				BackfillBatchSize:        3,
				RPCBatchSize:             2,
				KeepFinalizedBlocksDepth: tt.keepFinalizedBlocksDepth,
			}
			th := SetupTH(t, lpOpts)

			for i := 1; i <= tt.blockToCreate; i++ {
				err := th.ORM.InsertBlock(ctx, utils.RandomBytes32(), int64(i+10), time.Now(), int64(i), int64(i))
				require.NoError(t, err)
			}

			if tt.wantErr {
				_, err := th.LogPoller.PruneOldBlocks(ctx)
				require.Error(t, err)
				return
			}

			allDeleted, err := th.LogPoller.PruneOldBlocks(ctx)
			require.NoError(t, err)
			assert.True(t, allDeleted)
			blocks, err := th.ORM.GetBlocksRange(ctx, 0, math.MaxInt64)
			require.NoError(t, err)
			assert.Len(t, blocks, tt.blocksLeft)
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.InsertBlock(ctx, utils.RandomBytes32(), int64(i+10), time.Now(), int64(i), int64(i))`
$DIR/pkg/logpoller/log_poller_test.go: `.RandomBytes32()`
$DIR/pkg/logpoller/log_poller_test.go: `.Now()`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.PruneOldBlocks(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.LogPoller.PruneOldBlocks(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.ORM.GetBlocksRange(ctx, 0, math.MaxInt64)`
$DIR/pkg/logpoller/log_poller_test.go: `.Context(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.Test(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/log_poller_test.go: `.NewSqlxDB(t)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewORM(chainID, db, lggr)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewLogPoller(orm, ec, lggr, nil, lpOpts)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run("Fails, if failed to select oldest block", func(t *testing.T) {
		_, err := lp.FindLCA(ctx)
		require.ErrorContains(t, err, "failed to select the latest block")
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.FindLCA(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.HexToHash("0x124")`
$DIR/pkg/logpoller/log_poller_test.go: `.Run("Fails, if caller's context canceled", func(t *testing.T) {
		lCtx, cancel := context.WithCancel(ctx)
		ec.On("HeadByHash", mock.Anything, latestBlockHash).Return(nil, nil).Run(func(_ mock.Arguments) {
			cancel()
		}).Once()
		_, err := lp.FindLCA(lCtx)
		require.ErrorContains(t, err, "aborted, FindLCA request cancelled")
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.WithCancel(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.On("HeadByHash", mock.Anything, latestBlockHash)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(nil, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run(func(_ mock.Arguments) {
			cancel()
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_test.go: `.FindLCA(lCtx)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run("Fails, if RPC returns an error", func(t *testing.T) {
		expectedError := errors.New("failed to call RPC")
		ec.On("HeadByHash", mock.Anything, latestBlockHash).Return(nil, expectedError).Once()
		_, err := lp.FindLCA(ctx)
		require.ErrorContains(t, err, expectedError.Error())
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.New("failed to call RPC")`
$DIR/pkg/logpoller/log_poller_test.go: `.On("HeadByHash", mock.Anything, latestBlockHash)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(nil, expectedError)`
$DIR/pkg/logpoller/log_poller_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_test.go: `.FindLCA(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run("Fails, if block numbers do not match", func(t *testing.T) {
		ec.On("HeadByHash", mock.Anything, latestBlockHash).Return(&evmtypes.Head{
			Number: 123,
		}, nil).Once()
		_, err := lp.FindLCA(ctx)
		require.ErrorContains(t, err, "expected block numbers to match")
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.On("HeadByHash", mock.Anything, latestBlockHash)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(&evmtypes.Head{
			Number: 123,
		}, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Once()`
$DIR/pkg/logpoller/log_poller_test.go: `.FindLCA(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run("Fails, if none of the blocks in db matches on chain", func(t *testing.T) {
		ec.On("HeadByHash", mock.Anything, mock.Anything).Return(nil, nil).Times(3)
		_, err := lp.FindLCA(ctx)
		require.ErrorContains(t, err, "failed to find LCA, this means that whole database LogPoller state was reorged out of chain or RPC/Core node is misconfigured")
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.On("HeadByHash", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(nil, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Times(3)`
$DIR/pkg/logpoller/log_poller_test.go: `.FindLCA(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.New("failed to find LCA, this means that whole database LogPoller state was reorged out of chain or RPC/Core node is misconfigured")`
$DIR/pkg/logpoller/log_poller_test.go: `.Run(tc.Name, func(t *testing.T) {
			// reset the database
			require.NoError(t, orm.DeleteLogsAndBlocksAfter(ctx, 0))
			for _, b := range tc.Blocks {
				blockHashI++
				hash := common.BigToHash(big.NewInt(blockHashI))
				require.NoError(t, orm.InsertBlock(ctx, hash, int64(b.BN), time.Now(), 0, 0))
				// Hashes are unique for all test cases
				var onChainBlock *evmtypes.Head
				if b.Exists {
					onChainBlock = &evmtypes.Head{Number: int64(b.BN)}
				}
				ec.On("HeadByHash", mock.Anything, hash).Return(onChainBlock, nil).Maybe()
			}

			result, err := lp.FindLCA(ctx)
			if tc.ExpectedError != nil {
				require.ErrorContains(t, err, tc.ExpectedError.Error())
			} else {
				require.NotNil(t, result)
				require.Equal(t, result.BlockNumber, int64(tc.ExpectedBlockNumber), "expected block numbers to match")
			}
		})`
$DIR/pkg/logpoller/log_poller_test.go: `.BigToHash(big.NewInt(blockHashI))`
$DIR/pkg/logpoller/log_poller_test.go: `.NewInt(blockHashI)`
$DIR/pkg/logpoller/log_poller_test.go: `.On("HeadByHash", mock.Anything, hash)`
$DIR/pkg/logpoller/log_poller_test.go: `.Return(onChainBlock, nil)`
$DIR/pkg/logpoller/log_poller_test.go: `.Maybe()`
$DIR/pkg/logpoller/log_poller_test.go: `.FindLCA(ctx)`
$DIR/pkg/logpoller/log_poller_test.go: `.HexToAddress("0x1234567890abcdef1234567890abcdef12345678")`
$DIR/pkg/logpoller/log_poller_test.go: `.HexToHash("0xabcdef1234567890abcdef1234567890abcdef1234")`
$DIR/pkg/logpoller/log_poller_test.go: `.Now()`
$DIR/pkg/logpoller/log_poller_test.go: `.NewAddressFilter(address)`
$DIR/pkg/logpoller/log_poller_test.go: `.NewEventSigFilter(eventSig)`
$DIR/pkg/logpoller/log_poller_test.go: `.Timestamp(uint64(ts.Unix()), primitives.Gte)`
$DIR/pkg/logpoller/log_poller_test.go: `.Unix()`
$DIR/pkg/logpoller/log_poller_test.go: `.NewConfirmationsFilter(evmtypes.Confirmations(0))`
$DIR/pkg/logpoller/log_poller_test.go: `.Confirmations(0)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run("Valid combination of filters", func(t *testing.T) {
		result, err := logpoller.Where(expr1, expr2, expr3, expr4)
		require.NoError(t, err)
		assert.Equal(t, []query.Expression{expr1, expr2, expr3, expr4}, result)
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.Where(expr1, expr2, expr3, expr4)`
$DIR/pkg/logpoller/log_poller_test.go: `.Run("No expressions (should return empty slice)", func(t *testing.T) {
		result, err := logpoller.Where()
		require.NoError(t, err)
		assert.Equal(t, []query.Expression{}, result)
	})`
$DIR/pkg/logpoller/log_poller_test.go: `.Where()`
$DIR/pkg/logpoller/log_poller_test.go: `.Where(invalidExpr)`
$DIR/pkg/logpoller/observability_test.go: `t.Cleanup(func() { resetMetrics(*orm) })`
$DIR/pkg/logpoller/observability_test.go: `resetMetrics(*orm)`
$DIR/pkg/logpoller/observability_test.go: `_, _ = orm.SelectIndexedLogs(ctx, common.Address{}, common.Hash{}, 1, []common.Hash{}, 1)`
$DIR/pkg/logpoller/observability_test.go: `_, _ = orm.SelectIndexedLogsByBlockRange(ctx, 0, 1, common.Address{}, common.Hash{}, 1, []common.Hash{})`
$DIR/pkg/logpoller/observability_test.go: `_, _ = orm.SelectIndexedLogsTopicGreaterThan(ctx, common.Address{}, common.Hash{}, 1, common.Hash{}, 1)`
$DIR/pkg/logpoller/observability_test.go: `_, _ = orm.SelectIndexedLogsTopicRange(ctx, common.Address{}, common.Hash{}, 1, common.Hash{}, common.Hash{}, 1)`
$DIR/pkg/logpoller/observability_test.go: `_, _ = orm.SelectIndexedLogsWithSigsExcluding(ctx, common.Hash{}, common.Hash{}, 1, common.Address{}, 0, 1, 1)`
$DIR/pkg/logpoller/observability_test.go: `_, _ = orm.SelectLogsDataWordRange(ctx, common.Address{}, common.Hash{}, 0, common.Hash{}, common.Hash{}, 1)`
$DIR/pkg/logpoller/observability_test.go: `_, _ = orm.SelectLogsDataWordGreaterThan(ctx, common.Address{}, common.Hash{}, 0, common.Hash{}, 1)`
$DIR/pkg/logpoller/observability_test.go: `_, _ = orm.SelectLogsCreatedAfter(ctx, common.Address{}, common.Hash{}, time.Now(), 0)`
$DIR/pkg/logpoller/observability_test.go: `_, _ = orm.SelectLatestLogByEventSigWithConfs(ctx, common.Hash{}, common.Address{}, 0)`
$DIR/pkg/logpoller/observability_test.go: `_, _ = orm.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0, []common.Address{{}}, []common.Hash{{}}, 1)`
$DIR/pkg/logpoller/observability_test.go: `_, _ = orm.SelectIndexedLogsCreatedAfter(ctx, common.Address{}, common.Hash{}, 1, []common.Hash{}, time.Now(), 0)`
$DIR/pkg/logpoller/observability_test.go: `_ = orm.InsertLogs(ctx, []Log{})`
$DIR/pkg/logpoller/observability_test.go: `_ = orm.InsertLogsWithBlock(ctx, []Log{}, Block{
		BlockNumber:    1,
		BlockTimestamp: time.Now(),
	})`
$DIR/pkg/logpoller/observability_test.go: `t.Cleanup(func() { resetMetrics(*orm) })`
$DIR/pkg/logpoller/observability_test.go: `resetMetrics(*orm)`
$DIR/pkg/logpoller/observability_test.go: `t.Cleanup(func() { resetMetrics(*orm) })`
$DIR/pkg/logpoller/observability_test.go: `resetMetrics(*orm)`
$DIR/pkg/logpoller/observability_test.go: `rowsAffected, err = orm.DeleteBlocksBefore(ctx, 30, 0)`
$DIR/pkg/logpoller/observability_test.go: `.Context(t)`
$DIR/pkg/logpoller/observability_test.go: `.Cleanup(func() { resetMetrics(*orm) })`
$DIR/pkg/logpoller/observability_test.go: `.SelectIndexedLogs(ctx, common.Address{}, common.Hash{}, 1, []common.Hash{}, 1)`
$DIR/pkg/logpoller/observability_test.go: `.SelectIndexedLogsByBlockRange(ctx, 0, 1, common.Address{}, common.Hash{}, 1, []common.Hash{})`
$DIR/pkg/logpoller/observability_test.go: `.SelectIndexedLogsTopicGreaterThan(ctx, common.Address{}, common.Hash{}, 1, common.Hash{}, 1)`
$DIR/pkg/logpoller/observability_test.go: `.SelectIndexedLogsTopicRange(ctx, common.Address{}, common.Hash{}, 1, common.Hash{}, common.Hash{}, 1)`
$DIR/pkg/logpoller/observability_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, common.Hash{}, common.Hash{}, 1, common.Address{}, 0, 1, 1)`
$DIR/pkg/logpoller/observability_test.go: `.SelectLogsDataWordRange(ctx, common.Address{}, common.Hash{}, 0, common.Hash{}, common.Hash{}, 1)`
$DIR/pkg/logpoller/observability_test.go: `.SelectLogsDataWordGreaterThan(ctx, common.Address{}, common.Hash{}, 0, common.Hash{}, 1)`
$DIR/pkg/logpoller/observability_test.go: `.SelectLogsCreatedAfter(ctx, common.Address{}, common.Hash{}, time.Now(), 0)`
$DIR/pkg/logpoller/observability_test.go: `.Now()`
$DIR/pkg/logpoller/observability_test.go: `.SelectLatestLogByEventSigWithConfs(ctx, common.Hash{}, common.Address{}, 0)`
$DIR/pkg/logpoller/observability_test.go: `.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0, []common.Address{{}}, []common.Hash{{}}, 1)`
$DIR/pkg/logpoller/observability_test.go: `.SelectIndexedLogsCreatedAfter(ctx, common.Address{}, common.Hash{}, 1, []common.Hash{}, time.Now(), 0)`
$DIR/pkg/logpoller/observability_test.go: `.Now()`
$DIR/pkg/logpoller/observability_test.go: `.InsertLogs(ctx, []Log{})`
$DIR/pkg/logpoller/observability_test.go: `.InsertLogsWithBlock(ctx, []Log{}, Block{
		BlockNumber:    1,
		BlockTimestamp: time.Now(),
	})`
$DIR/pkg/logpoller/observability_test.go: `.Now()`
$DIR/pkg/logpoller/observability_test.go: `.CollectAndCount(orm.datasetSize)`
$DIR/pkg/logpoller/observability_test.go: `.Context(t)`
$DIR/pkg/logpoller/observability_test.go: `.Cleanup(func() { resetMetrics(*orm) })`
$DIR/pkg/logpoller/observability_test.go: `.SelectLatestLogByEventSigWithConfs(ctx, common.Hash{}, common.Address{}, 0)`
$DIR/pkg/logpoller/observability_test.go: `.Cleanup(func() { resetMetrics(*orm) })`
$DIR/pkg/logpoller/observability_test.go: `.Context()`
$DIR/pkg/logpoller/observability_test.go: `.Context()`
$DIR/pkg/logpoller/observability_test.go: `.New("error")`
$DIR/pkg/logpoller/observability_test.go: `.Context(t)`
$DIR/pkg/logpoller/observability_test.go: `.DeleteExpiredLogs(ctx, 3)`
$DIR/pkg/logpoller/observability_test.go: `.DeleteBlocksBefore(ctx, 30, 0)`
$DIR/pkg/logpoller/observability_test.go: `.ToFloat64(orm.blocksInserted.WithLabelValues(network, "420"))`
$DIR/pkg/logpoller/observability_test.go: `.blocksInserted.WithLabelValues(network, "420")`
$DIR/pkg/logpoller/orm_test.go: `logs = append(logs, GenLog(th.ChainID, int64(i+1), 1, "0x3", EmitterABI.Events["Log1"].ID.Bytes(), th.EmitterAddress1))`
$DIR/pkg/logpoller/orm_test.go: `blockNumbers = append(blockNumbers, b.number)`
$DIR/pkg/logpoller/orm_test.go: `recentBlocks = append(recentBlocks, block{number: int64(i), hash: common.HexToHash(fmt.Sprintf("0x%d", i))})`
$DIR/pkg/logpoller/orm_test.go: `blockNumbers = append(blockNumbers, b.number)`
$DIR/pkg/logpoller/orm_test.go: `latest, err = o2.SelectLatestBlock(ctx)`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.SelectBlockByHash(ctx, common.HexToHash("0x1234"))`
$DIR/pkg/logpoller/orm_test.go: `_, err = o2.SelectBlockByHash(ctx, common.HexToHash("0x1234"))`
$DIR/pkg/logpoller/orm_test.go: `_, err = o2.SelectBlockByHash(ctx, common.HexToHash("0x1235"))`
$DIR/pkg/logpoller/orm_test.go: `logs, err = o1.SelectLogsByBlockRange(ctx, 10, 10)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = o1.SelectLogs(ctx, 1, 1, common.HexToAddress("0x1234"), topic)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = o1.SelectLogs(ctx, 10, 10, common.HexToAddress("0x1234"), topic)`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.SelectLatestLogByEventSigWithConfs(ctx, topic, common.HexToAddress("0x1234"), 0)`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.SelectLatestLogByEventSigWithConfs(ctx, topic, common.HexToAddress("0x1234"), 1)`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.SelectLatestLogByEventSigWithConfs(ctx, topic, common.HexToAddress("0x1234"), 0)`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.SelectLatestLogByEventSigWithConfs(ctx, topic, common.HexToAddress("0x1234"), 1)`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.SelectLatestLogByEventSigWithConfs(ctx, topic, common.HexToAddress("0x1234"), 2)`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.SelectLatestLogByEventSigWithConfs(ctx, topic, common.HexToAddress("0x1234"), 3)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0 /* startBlock */, []common.Address{common.HexToAddress("0x1234"), common.HexToAddress("0x1235")}, []common.Hash{topic}, 0)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0 /* startBlock */, []common.Address{common.HexToAddress("0x1234")}, []common.Hash{topic, topic2}, 0)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0 /* startBlock */, []common.Address{common.HexToAddress("0x1234"), common.HexToAddress("0x1235")}, []common.Hash{topic, topic2}, 0)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0 /* startBlock */, []common.Address{common.HexToAddress("0x1234"), common.HexToAddress("0x1235")}, []common.Hash{topic, topic2}, 1)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0 /* startBlock */, []common.Address{common.HexToAddress("0x1234"), common.HexToAddress("0x1235")}, []common.Hash{topic, topic2}, 2)`
$DIR/pkg/logpoller/orm_test.go: `latest, err = o1.SelectLatestBlock(ctx)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = o1.SelectLogsByBlockRange(ctx, 1, latest.BlockNumber)`
$DIR/pkg/logpoller/orm_test.go: `time.Sleep(2 * time.Millisecond)`
$DIR/pkg/logpoller/orm_test.go: `deleted, err = o1.DeleteExpiredLogs(ctx, 0)`
$DIR/pkg/logpoller/orm_test.go: `ids, err = o1.SelectUnmatchedLogIDs(ctx, 0)`
$DIR/pkg/logpoller/orm_test.go: `deleted, err = o1.DeleteLogsByRowID(ctx, ids)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = o2.SelectLogs(ctx, 0, 100, common.HexToAddress("0x1236"), topic2)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = o2.SelectLogs(ctx, 0, 100, common.HexToAddress("0x5555"), topic)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = o1.SelectLogsByBlockRange(ctx, 1, latest.BlockNumber)`
$DIR/pkg/logpoller/orm_test.go: `err = o1.DeleteLogsAndBlocksAfter(ctx, 1)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = o1.SelectLogsByBlockRange(ctx, 1, latest.BlockNumber)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = o2.SelectLogsByBlockRange(ctx, 1, 17)`
$DIR/pkg/logpoller/orm_test.go: `ids, err = o1.SelectExcessLogIDs(ctx, 2)`
$DIR/pkg/logpoller/orm_test.go: `ids, err = o1.SelectExcessLogIDs(ctx, 4)`
$DIR/pkg/logpoller/orm_test.go: `ids, err = o1.SelectExcessLogIDs(ctx, 10)`
$DIR/pkg/logpoller/orm_test.go: `t.Run("Save filter: "+filter.Name, func(t *testing.T) {
			var count int
			err := orm.InsertFilter(ctx, filter)
			require.NoError(t, err)
			err = dbx.Get(&count, `SELECT COUNT(*) FROM evm.log_poller_filters WHERE evm_chain_id = $1 AND name = $2`, ubig.New(chainID), filter.Name)
			require.NoError(t, err)
			expectedCount := len(filter.Addresses) * len(filter.EventSigs)
			if len(filter.Topic2) > 0 {
				expectedCount *= len(filter.Topic2)
			}
			if len(filter.Topic3) > 0 {
				expectedCount *= len(filter.Topic3)
			}
			if len(filter.Topic4) > 0 {
				expectedCount *= len(filter.Topic4)
			}
			assert.Equal(t, expectedCount, count)
		})`
$DIR/pkg/logpoller/orm_test.go: `err = dbx.Get(&count, `SELECT COUNT(*) FROM evm.log_poller_filters WHERE evm_chain_id = $1 AND name = $2`, ubig.New(chainID), filter.Name)`
$DIR/pkg/logpoller/orm_test.go: `expectedCount *= len(filter.Topic2)`
$DIR/pkg/logpoller/orm_test.go: `expectedCount *= len(filter.Topic3)`
$DIR/pkg/logpoller/orm_test.go: `expectedCount *= len(filter.Topic4)`
$DIR/pkg/logpoller/orm_test.go: `insertLogsTopicValueRange(t, th.ChainID, o1, addr, 1, eventSig, 1, 3)`
$DIR/pkg/logpoller/orm_test.go: `insertLogsTopicValueRange(t, th.ChainID, o1, addr, 2, eventSig, 4, 4)`
$DIR/pkg/logpoller/orm_test.go: `topicFilters.Expressions[idx] = logpoller.NewEventByTopicFilter(topicIdx, []logpoller.HashedValueComparator{
				{Values: []common.Hash{logpoller.EvmWord(value)}, Operator: primitives.Eq},
			})`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, standardFilter(1, []uint64{1}).Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectIndexedLogs(ctx, addr, eventSig, 1, []common.Hash{logpoller.EvmWord(1), logpoller.EvmWord(2)}, 0)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, standardFilter(1, []uint64{1, 2}).Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectIndexedLogsByBlockRange(ctx, 1, 1, addr, eventSig, 1, []common.Hash{logpoller.EvmWord(1)})`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, blockRangeFilter("1", "1", 1, []uint64{1}), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectIndexedLogsByBlockRange(ctx, 1, 2, addr, eventSig, 1, []common.Hash{logpoller.EvmWord(2)})`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, blockRangeFilter("1", "2", 1, []uint64{2}), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectIndexedLogsByBlockRange(ctx, 1, 2, addr, eventSig, 1, []common.Hash{logpoller.EvmWord(1)})`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, blockRangeFilter("1", "2", 1, []uint64{1}), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.SelectIndexedLogsByBlockRange(ctx, 1, 2, addr, eventSig, 0, []common.Hash{logpoller.EvmWord(1)})`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.FilteredLogs(ctx, blockRangeFilter("1", "2", 0, []uint64{1}), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.SelectIndexedLogsByBlockRange(ctx, 1, 2, addr, eventSig, 4, []common.Hash{logpoller.EvmWord(1)})`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.FilteredLogs(ctx, blockRangeFilter("1", "2", 4, []uint64{1}), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectIndexedLogsTopicGreaterThan(ctx, addr, eventSig, 1, logpoller.EvmWord(2), 0)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, filter.Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectIndexedLogsTopicRange(ctx, addr, eventSig, 1, logpoller.EvmWord(3), logpoller.EvmWord(3), 0)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, rangeFilter(1, 3, 3), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectIndexedLogsTopicRange(ctx, addr, eventSig, 1, logpoller.EvmWord(1), logpoller.EvmWord(3), 0)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, rangeFilter(1, 1, 3), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectIndexedLogsTopicRange(ctx, addr, eventSig, 1, logpoller.EvmWord(4), logpoller.EvmWord(4), 1)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectIndexedLogsTopicRange(ctx, addr, eventSig, 1, logpoller.EvmWord(4), logpoller.EvmWord(4), 1)`
$DIR/pkg/logpoller/orm_test.go: `retrievedLogs, err = o1.FilteredLogs(ctx, filter.Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, wordFilter(0, 2, 2), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectLogsDataWordRange(ctx, addr, eventSig, 0, logpoller.EvmWord(1), logpoller.EvmWord(2), 0)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, wordFilter(0, 1, 2), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectLogsDataWordRange(ctx, addr, eventSig, 0, logpoller.EvmWord(1), logpoller.EvmWord(1), 0)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, wordFilter(0, 1, 1), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectLogsDataWordRange(ctx, addr, eventSig, 1, logpoller.EvmWord(3), logpoller.EvmWord(3), 0)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, wordFilter(1, 3, 3), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectLogsDataWordRange(ctx, addr, eventSig, 1, logpoller.EvmWord(3), logpoller.EvmWord(3), 0)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, wordFilter(1, 3, 3), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.SelectLogsDataWordGreaterThan(ctx, addr, eventSig, 0, logpoller.EvmWord(1), 0)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = o1.FilteredLogs(ctx, filter, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `exp[idx] = logpoller.NewEventSigFilter(val)`
$DIR/pkg/logpoller/orm_test.go: `filters = append(filters, query.Expression{
				BoolExpression: query.BoolExpression{
					Expressions:  exp,
					BoolOperator: query.OR,
				},
			})`
$DIR/pkg/logpoller/orm_test.go: `filters = append(filters, query.Expression{
			BoolExpression: query.BoolExpression{
				Expressions: []query.Expression{
					query.Block(startBlock, primitives.Gte),
					query.Block(endBlock, primitives.Lte),
				},
				BoolOperator: query.AND,
			},
		})`
$DIR/pkg/logpoller/orm_test.go: `assertion(t, logs, err, startBlock, endBlock)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = th.ORM.FilteredLogs(ctx, filter([]common.Hash{topic, topic2}, strconv.Itoa(int(startBlock)), strconv.Itoa(int(endBlock))).Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `m.On("Exec", int64(0), int64(0)).Return(0, queryError).Once()`
$DIR/pkg/logpoller/orm_test.go: `m.On("Exec", int64(0), int64(60)).Return(4, nil).Once()`
$DIR/pkg/logpoller/orm_test.go: `_, err = r.ExecPagedQuery(ctx, 300, 1000)`
$DIR/pkg/logpoller/orm_test.go: `m.On("Exec", mock.Anything, mock.Anything).Return(3, nil)`
$DIR/pkg/logpoller/orm_test.go: `numResults, err = r.ExecPagedQuery(ctx, 300, 1000)`
$DIR/pkg/logpoller/orm_test.go: `m.AssertNumberOfCalls(t, "Exec", 6)`
$DIR/pkg/logpoller/orm_test.go: `m.AssertCalled(t, "Exec", expected[0], expected[1])`
$DIR/pkg/logpoller/orm_test.go: `numResults, err = r.ExecPagedQuery(ctx, 15, 1000)`
$DIR/pkg/logpoller/orm_test.go: `m.AssertNumberOfCalls(t, "Exec", 11)`
$DIR/pkg/logpoller/orm_test.go: `expectedLimitBlocks = [][]int64{{42, 56}, {57, 71}, {72, 86}, {87, 101}, {102, 116}}`
$DIR/pkg/logpoller/orm_test.go: `m.AssertCalled(t, "Exec", expected[0], expected[1])`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.SelectBlockByNumber(ctx, 1)`
$DIR/pkg/logpoller/orm_test.go: `deleted, err = o1.DeleteBlocksBefore(ctx, 3, 0)`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.SelectBlockByNumber(ctx, 2)`
$DIR/pkg/logpoller/orm_test.go: `_, err = o1.SelectBlockByNumber(ctx, 3)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = th.ORM.SelectLogs(ctx, 1, 3, address1, event1)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = th.ORM.FilteredLogs(ctx, logFilter("1", "3", address1), query.LimitAndSort{
		SortBy: []query.SortBy{query.NewSortBySequence(query.Asc)},
	}, "")`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = th.ORM.SelectLogs(ctx, 2, 2, address2, event1)`
$DIR/pkg/logpoller/orm_test.go: `lgs, err = th.ORM.FilteredLogs(ctx, logFilter("2", "2", address2), query.LimitAndSort{
		SortBy: []query.SortBy{query.NewSortBySequence(query.Asc)},
	}, "")`
$DIR/pkg/logpoller/orm_test.go: `logs, err = orm.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 1, addressB, 0, 3, 0)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = orm.SelectIndexedLogsWithSigsExcluding(ctx, requestSigA, responseSigA, 1, addressA, 0, 3, 0)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = orm.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 1, addressB, 0, 3, 0)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = orm.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 4, 0)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = orm.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 4, 0)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = orm.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 4, 0)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = orm.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 4, 3)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = orm.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 10, 0)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = orm.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 10, 3)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = orm.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 10, 0)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = orm.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 1, addressB, 0, 3, 0)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = orm.SelectIndexedLogsWithSigsExcluding(ctx, requestSigA, responseSigA, 1, addressA, 0, 1, 10)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = orm.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 1, addressB, 2, 13, 0)`
$DIR/pkg/logpoller/orm_test.go: `t.Run(tt.name, func(t *testing.T) {
			blockNumber, err := th.ORM.SelectLatestBlockByEventSigsAddrsWithConfs(ctx, tt.fromBlock, tt.events, tt.addrs, tt.confs)
			require.NoError(t, err)
			assert.Equal(t, tt.expectedBlockNumber, blockNumber)
		})`
$DIR/pkg/logpoller/orm_test.go: `filters = append(filters, query.Expression{
				BoolExpression: query.BoolExpression{
					Expressions:  exp,
					BoolOperator: query.OR,
				},
			})`
$DIR/pkg/logpoller/orm_test.go: `filters = append(filters, []query.Expression{
			query.Timestamp(uint64(timestamp.Unix()), primitives.Gt),
			logpoller.NewConfirmationsFilter(confs),
		}...)`
$DIR/pkg/logpoller/orm_test.go: `t.Run(tt.name, func(t *testing.T) {
			logs, err := th.ORM.SelectLogsCreatedAfter(ctx, address, event, tt.after, tt.confs)

			assertion(t, logs, err, tt.expectedLogs)

			logs, err = th.ORM.FilteredLogs(ctx, filter(tt.after, tt.confs, 0, nil).Expressions, limiter, "")

			assertion(t, logs, err, tt.expectedLogs)
		})`
$DIR/pkg/logpoller/orm_test.go: `assertion(t, logs, err, tt.expectedLogs)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = th.ORM.FilteredLogs(ctx, filter(tt.after, tt.confs, 0, nil).Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `assertion(t, logs, err, tt.expectedLogs)`
$DIR/pkg/logpoller/orm_test.go: `t.Run(tt.name, func(t *testing.T) {
				logs, err := th.ORM.SelectIndexedLogsCreatedAfter(ctx, address, event, 1, []common.Hash{event}, tt.after, tt.confs)

				assertion(t, logs, err, tt.expectedLogs)

				logs, err = th.ORM.FilteredLogs(ctx, filter(tt.after, tt.confs, 1, []common.Hash{event}).Expressions, limiter, "")

				assertion(t, logs, err, tt.expectedLogs)
			})`
$DIR/pkg/logpoller/orm_test.go: `assertion(t, logs, err, tt.expectedLogs)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = th.ORM.FilteredLogs(ctx, filter(tt.after, tt.confs, 1, []common.Hash{event}).Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `assertion(t, logs, err, tt.expectedLogs)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = th.ORM.SelectIndexedLogs(ctx, address, event, 1, []common.Hash{event}, types.Unconfirmed)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = th.ORM.SelectIndexedLogs(ctx, address, event, 1, []common.Hash{event}, types.Confirmations(4))`
$DIR/pkg/logpoller/orm_test.go: `t.Run(tt.name, func(t *testing.T) {
			// clean all logs and blocks between test cases
			defer func() { _ = o.DeleteLogsAndBlocksAfter(ctx, 0) }()
			insertError := o.InsertLogsWithBlock(ctx, tt.logs, tt.block)

			logs, logsErr := o.SelectLogs(ctx, 0, math.MaxInt, address, event)
			block, blockErr := o.SelectLatestBlock(ctx)

			if tt.shouldRollback {
				assert.Error(t, insertError)

				assert.NoError(t, logsErr)
				assert.Empty(t, logs)

				assert.Error(t, blockErr)
			} else {
				assert.NoError(t, insertError)

				assert.NoError(t, logsErr)
				assert.Len(t, logs, len(tt.logs))

				assert.NoError(t, blockErr)
				assert.Equal(t, block.BlockNumber, tt.block.BlockNumber)
			}
		})`
$DIR/pkg/logpoller/orm_test.go: `_ = o.DeleteLogsAndBlocksAfter(ctx, 0)`
$DIR/pkg/logpoller/orm_test.go: `logs[i] = GenLog(chainID, int64(i+1), int64(i+1), utils.RandomAddress().String(), event[:], address)`
$DIR/pkg/logpoller/orm_test.go: `t.Run(tt.name, func(t *testing.T) {
			// clean all logs and blocks between test cases
			defer func() { _, _ = db.Exec("truncate evm.logs") }()

			insertErr := o.InsertLogs(ctx, tt.logs)
			logsFromDb, err := o.SelectLogs(ctx, 0, math.MaxInt, address, event)
			assert.NoError(t, err)

			if tt.shouldRollback {
				assert.Error(t, insertErr)
				assert.Empty(t, logsFromDb)
			} else {
				assert.NoError(t, insertErr)
				assert.Len(t, logsFromDb, len(tt.logs))
			}
		})`
$DIR/pkg/logpoller/orm_test.go: `_, _ = db.Exec("truncate evm.logs")`
$DIR/pkg/logpoller/orm_test.go: `firstLogData = append(firstLogData, logpoller.EvmWord(1).Bytes()...)`
$DIR/pkg/logpoller/orm_test.go: `firstLogData = append(firstLogData, logpoller.EvmWord(10).Bytes()...)`
$DIR/pkg/logpoller/orm_test.go: `secondLogData = append(secondLogData, logpoller.EvmWord(5).Bytes()...)`
$DIR/pkg/logpoller/orm_test.go: `secondLogData = append(secondLogData, logpoller.EvmWord(20).Bytes()...)`
$DIR/pkg/logpoller/orm_test.go: `t.Run(tt.name, func(t *testing.T) {
			logs, err := th.ORM.SelectLogsDataWordBetween(ctx, address, eventSig, 0, 1, logpoller.EvmWord(tt.wordValue), types.Unconfirmed)

			assertion(t, logs, err, tt.expectedLogs)

			logs, err = th.ORM.FilteredLogs(ctx, wordFilter(tt.wordValue).Expressions, limiter, "")

			assertion(t, logs, err, tt.expectedLogs)
		})`
$DIR/pkg/logpoller/orm_test.go: `assertion(t, logs, err, tt.expectedLogs)`
$DIR/pkg/logpoller/orm_test.go: `logs, err = th.ORM.FilteredLogs(ctx, wordFilter(tt.wordValue).Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `assertion(t, logs, err, tt.expectedLogs)`
$DIR/pkg/logpoller/orm_test.go: `t.Run("Selects oldest within given chain", func(t *testing.T) {
		// insert blocks
		require.NoError(t, o2.InsertBlock(ctx, common.HexToHash("0x1231"), 11, time.Now(), 0, 0))
		require.NoError(t, o2.InsertBlock(ctx, common.HexToHash("0x1232"), 12, time.Now(), 0, 0))
		// insert newer block from different chain
		require.NoError(t, o1.InsertBlock(ctx, common.HexToHash("0x1233"), 13, time.Now(), 0, 0))
		require.NoError(t, o1.InsertBlock(ctx, common.HexToHash("0x1231"), 14, time.Now(), 0, 0))
		block, err := o1.SelectOldestBlock(ctx, 0)
		require.NoError(t, err)
		require.NotNil(t, block)
		require.Equal(t, int64(13), block.BlockNumber)
		require.Equal(t, block.BlockHash, common.HexToHash("0x1233"))
	})`
$DIR/pkg/logpoller/orm_test.go: `t.Run("If finalized block is not present in DB return error", func(t *testing.T) {
		th := SetupTH(t, lpOpts)
		o1 := th.ORM
		o2 := th.ORM2
		ctx := testutils.Context(t)
		// o2's chain does not have finalized block
		require.NoError(t, o2.InsertBlock(ctx, common.HexToHash("0x1231"), 11, time.Now(), 9, 9))
		require.NoError(t, o2.InsertBlock(ctx, common.HexToHash("0x1234"), 10, time.Now(), 8, 8))
		// o1 has finalized blocks
		require.NoError(t, o1.InsertBlock(ctx, common.HexToHash("0x1233"), 11, time.Now(), 10, 10))
		require.NoError(t, o1.InsertBlock(ctx, common.HexToHash("0x1232"), 10, time.Now(), 10, 10))
		result, err := o2.SelectLatestFinalizedBlock(ctx)
		require.ErrorIs(t, err, sql.ErrNoRows)
		require.Nil(t, result)
	})`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.ID.Bytes()`
$DIR/pkg/logpoller/orm_test.go: `.ORM.SelectLogsByBlockRange(ctx, 1, 1)`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x111")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x112")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x113")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x114")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x115")`
$DIR/pkg/logpoller/orm_test.go: `.GetBlocksRange(ctx, blockNumbers[0], blockNumbers[len(blockNumbers)-1])`
$DIR/pkg/logpoller/orm_test.go: `.GetBlocksRange(ctx, blockNumbers[0], 15)`
$DIR/pkg/logpoller/orm_test.go: `.GetBlocksRange(ctx, 15, 15)`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash(fmt.Sprintf("0x%d", i))`
$DIR/pkg/logpoller/orm_test.go: `.Sprintf("0x%d", i)`
$DIR/pkg/logpoller/orm_test.go: `.GetBlocksRange(ctx, blockNumbers[0], blockNumbers[len(blockNumbers)-1])`
$DIR/pkg/logpoller/orm_test.go: `.GetBlocksRange(ctx, blockNumbers[0], 257)`
$DIR/pkg/logpoller/orm_test.go: `.GetBlocksRange(ctx, 257, 257)`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.SelectBlockByHash(ctx, common.HexToHash("0x1234"))`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectBlockByHash(ctx, common.HexToHash("0x1234"))`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestBlock(ctx)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestBlock(ctx)`
$DIR/pkg/logpoller/orm_test.go: `.SelectBlockByHash(ctx, common.HexToHash("0x1234"))`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectBlockByHash(ctx, common.HexToHash("0x1234"))`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectBlockByHash(ctx, common.HexToHash("0x1235"))`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1235")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1599")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1600")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsByBlockRange(ctx, 1, 17)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsByBlockRange(ctx, 10, 10)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogs(ctx, 1, 1, common.HexToAddress("0x1234"), topic)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogs(ctx, 10, 10, common.HexToAddress("0x1234"), topic)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestLogByEventSigWithConfs(ctx, topic, common.HexToAddress("0x1234"), 0)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestLogByEventSigWithConfs(ctx, topic, common.HexToAddress("0x1234"), 0)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestLogByEventSigWithConfs(ctx, topic, common.HexToAddress("0x1234"), 1)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestLogByEventSigWithConfs(ctx, topic, common.HexToAddress("0x1234"), 0)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestLogByEventSigWithConfs(ctx, topic, common.HexToAddress("0x1234"), 1)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestLogByEventSigWithConfs(ctx, topic, common.HexToAddress("0x1234"), 2)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestLogByEventSigWithConfs(ctx, topic, common.HexToAddress("0x1234"), 3)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0 /* startBlock */, []common.Address{common.HexToAddress("0x1234")}, []common.Hash{topic}, 0)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0 /* startBlock */, []common.Address{common.HexToAddress("0x1234"), common.HexToAddress("0x1235")}, []common.Hash{topic}, 0)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1235")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0 /* startBlock */, []common.Address{common.HexToAddress("0x1234")}, []common.Hash{topic, topic2}, 0)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0 /* startBlock */, []common.Address{common.HexToAddress("0x1234"), common.HexToAddress("0x1235")}, []common.Hash{topic, topic2}, 0)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1235")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0 /* startBlock */, []common.Address{common.HexToAddress("0x1234"), common.HexToAddress("0x1235")}, []common.Hash{topic, topic2}, 1)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1235")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestLogEventSigsAddrsWithConfs(ctx, 0 /* startBlock */, []common.Address{common.HexToAddress("0x1234"), common.HexToAddress("0x1235")}, []common.Hash{topic, topic2}, 2)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1235")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1236")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1236")`
$DIR/pkg/logpoller/orm_test.go: `.LoadFilters(ctx)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestBlock(ctx)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsByBlockRange(ctx, 1, latest.BlockNumber)`
$DIR/pkg/logpoller/orm_test.go: `.Sleep(2 * time.Millisecond)`
$DIR/pkg/logpoller/orm_test.go: `.DeleteExpiredLogs(ctx, 1)`
$DIR/pkg/logpoller/orm_test.go: `.DeleteExpiredLogs(ctx, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectUnmatchedLogIDs(ctx, 2)`
$DIR/pkg/logpoller/orm_test.go: `.SelectUnmatchedLogIDs(ctx, 0)`
$DIR/pkg/logpoller/orm_test.go: `.DeleteLogsByRowID(ctx, ids)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogs(ctx, 0, 100, common.HexToAddress("0x1236"), topic2)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1236")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogs(ctx, 0, 100, common.HexToAddress("0x5555"), topic)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x5555")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsByBlockRange(ctx, 1, latest.BlockNumber)`
$DIR/pkg/logpoller/orm_test.go: `.DeleteLogsAndBlocksAfter(ctx, 1)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsByBlockRange(ctx, 1, latest.BlockNumber)`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1599")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1600")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1235")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1236")`
$DIR/pkg/logpoller/orm_test.go: `.SelectBlockByHash(ctx, blockHashes[i])`
$DIR/pkg/logpoller/orm_test.go: `.SelectBlockByHash(ctx, common.HexToHash("0x1234"))`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsByBlockRange(ctx, 1, 12)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsByBlockRange(ctx, 1, 17)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1235")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1235")`
$DIR/pkg/logpoller/orm_test.go: `.LoadFilters(ctx)`
$DIR/pkg/logpoller/orm_test.go: `.SelectUnmatchedLogIDs(ctx, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectExcessLogIDs(ctx, 2)`
$DIR/pkg/logpoller/orm_test.go: `.SelectExcessLogIDs(ctx, 4)`
$DIR/pkg/logpoller/orm_test.go: `.SelectExcessLogIDs(ctx, 10)`
$DIR/pkg/logpoller/orm_test.go: `.DeleteLogsByRowID(ctx, ids)`
$DIR/pkg/logpoller/orm_test.go: `.Test(t)`
$DIR/pkg/logpoller/orm_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/logpoller/orm_test.go: `.NewORM(chainID, dbx, lggr)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1111")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x2222")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x3333")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x4444")`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.Run("Save filter: "+filter.Name, func(t *testing.T) {
			var count int
			err := orm.InsertFilter(ctx, filter)
			require.NoError(t, err)
			err = dbx.Get(&count, `SELECT COUNT(*) FROM evm.log_poller_filters WHERE evm_chain_id = $1 AND name = $2`, ubig.New(chainID), filter.Name)
			require.NoError(t, err)
			expectedCount := len(filter.Addresses) * len(filter.EventSigs)
			if len(filter.Topic2) > 0 {
				expectedCount *= len(filter.Topic2)
			}
			if len(filter.Topic3) > 0 {
				expectedCount *= len(filter.Topic3)
			}
			if len(filter.Topic4) > 0 {
				expectedCount *= len(filter.Topic4)
			}
			assert.Equal(t, expectedCount, count)
		})`
$DIR/pkg/logpoller/orm_test.go: `.InsertFilter(ctx, filter)`
$DIR/pkg/logpoller/orm_test.go: `.Get(&count, `SELECT COUNT(*) FROM evm.log_poller_filters WHERE evm_chain_id = $1 AND name = $2`, ubig.New(chainID), filter.Name)`
$DIR/pkg/logpoller/orm_test.go: `.New(chainID)`
$DIR/pkg/logpoller/orm_test.go: `.LoadFilters(ctx)`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1599")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.NewEventByTopicFilter(topicIdx, []logpoller.HashedValueComparator{
				{Values: []common.Hash{logpoller.EvmWord(value)}, Operator: primitives.Eq},
			})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(value)`
$DIR/pkg/logpoller/orm_test.go: `.NewLimitAndSort(query.Limit{}, query.NewSortBySequence(query.Asc))`
$DIR/pkg/logpoller/orm_test.go: `.NewSortBySequence(query.Asc)`
$DIR/pkg/logpoller/orm_test.go: `.NewAddressFilter(addr)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventSigFilter(eventSig)`
$DIR/pkg/logpoller/orm_test.go: `.Confidence(primitives.Unconfirmed)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogs(ctx, addr, eventSig, 1, []common.Hash{logpoller.EvmWord(1)}, 0)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, standardFilter(1, []uint64{1}).Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogs(ctx, addr, eventSig, 1, []common.Hash{logpoller.EvmWord(1), logpoller.EvmWord(2)}, 0)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(2)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, standardFilter(1, []uint64{1, 2}).Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.NewAddressFilter(addr)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventSigFilter(eventSig)`
$DIR/pkg/logpoller/orm_test.go: `.Block(start, primitives.Gte)`
$DIR/pkg/logpoller/orm_test.go: `.Block(end, primitives.Lte)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsByBlockRange(ctx, 1, 1, addr, eventSig, 1, []common.Hash{logpoller.EvmWord(1)})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, blockRangeFilter("1", "1", 1, []uint64{1}), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsByBlockRange(ctx, 1, 2, addr, eventSig, 1, []common.Hash{logpoller.EvmWord(2)})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(2)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, blockRangeFilter("1", "2", 1, []uint64{2}), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsByBlockRange(ctx, 1, 2, addr, eventSig, 1, []common.Hash{logpoller.EvmWord(1)})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, blockRangeFilter("1", "2", 1, []uint64{1}), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsByBlockRange(ctx, 1, 2, addr, eventSig, 0, []common.Hash{logpoller.EvmWord(1)})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, blockRangeFilter("1", "2", 0, []uint64{1}), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsByBlockRange(ctx, 1, 2, addr, eventSig, 4, []common.Hash{logpoller.EvmWord(1)})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, blockRangeFilter("1", "2", 4, []uint64{1}), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsTopicGreaterThan(ctx, addr, eventSig, 1, logpoller.EvmWord(2), 0)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(2)`
$DIR/pkg/logpoller/orm_test.go: `.NewAddressFilter(addr)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventSigFilter(eventSig)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventByTopicFilter(1, []logpoller.HashedValueComparator{
				{Values: []common.Hash{logpoller.EvmWord(2)}, Operator: primitives.Gte},
			})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(2)`
$DIR/pkg/logpoller/orm_test.go: `.Confidence(primitives.Unconfirmed)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, filter.Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.NewAddressFilter(addr)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventSigFilter(eventSig)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventByTopicFilter(topicIdx, []logpoller.HashedValueComparator{
				{Values: []common.Hash{logpoller.EvmWord(min)}, Operator: primitives.Gte},
			})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(min)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventByTopicFilter(topicIdx, []logpoller.HashedValueComparator{
				{Values: []common.Hash{logpoller.EvmWord(max)}, Operator: primitives.Lte},
			})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(max)`
$DIR/pkg/logpoller/orm_test.go: `.Confidence(primitives.Unconfirmed)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsTopicRange(ctx, addr, eventSig, 1, logpoller.EvmWord(3), logpoller.EvmWord(3), 0)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(3)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(3)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, rangeFilter(1, 3, 3), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsTopicRange(ctx, addr, eventSig, 1, logpoller.EvmWord(1), logpoller.EvmWord(3), 0)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(3)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, rangeFilter(1, 1, 3), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsTopicRange(ctx, addr, eventSig, 1, logpoller.EvmWord(4), logpoller.EvmWord(4), 1)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(4)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(4)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsTopicRange(ctx, addr, eventSig, 1, logpoller.EvmWord(4), logpoller.EvmWord(4), 1)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(4)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(4)`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1599")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1888")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.New(th.ChainID)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1")`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.Bytes()`
$DIR/pkg/logpoller/orm_test.go: `.New(th.ChainID)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1")`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(2)`
$DIR/pkg/logpoller/orm_test.go: `.Bytes()`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(3)`
$DIR/pkg/logpoller/orm_test.go: `.Bytes()`
$DIR/pkg/logpoller/orm_test.go: `.New(th.ChainID)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1889")`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(2)`
$DIR/pkg/logpoller/orm_test.go: `.Bytes()`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(3)`
$DIR/pkg/logpoller/orm_test.go: `.Bytes()`
$DIR/pkg/logpoller/orm_test.go: `.New(th.ChainID)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1600")`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(2)`
$DIR/pkg/logpoller/orm_test.go: `.Bytes()`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(3)`
$DIR/pkg/logpoller/orm_test.go: `.Bytes()`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsByTxHash(ctx, addr, eventSig, txHash)`
$DIR/pkg/logpoller/orm_test.go: `.NewLimitAndSort(query.Limit{}, query.NewSortBySequence(query.Asc))`
$DIR/pkg/logpoller/orm_test.go: `.NewSortBySequence(query.Asc)`
$DIR/pkg/logpoller/orm_test.go: `.NewAddressFilter(addr)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventSigFilter(eventSig)`
$DIR/pkg/logpoller/orm_test.go: `.TxHash(txHash.Hex())`
$DIR/pkg/logpoller/orm_test.go: `.Hex()`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, filter.Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1599")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.NewAddressFilter(addr)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventSigFilter(eventSig)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventByWordFilter(wordIdx, []logpoller.HashedValueComparator{
				{Values: []common.Hash{logpoller.EvmWord(word1)}, Operator: primitives.Gte},
			})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(word1)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventByWordFilter(wordIdx, []logpoller.HashedValueComparator{
				{Values: []common.Hash{logpoller.EvmWord(word2)}, Operator: primitives.Lte},
			})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(word2)`
$DIR/pkg/logpoller/orm_test.go: `.Confidence(primitives.Unconfirmed)`
$DIR/pkg/logpoller/orm_test.go: `.NewLimitAndSort(query.Limit{}, query.NewSortBySequence(query.Asc))`
$DIR/pkg/logpoller/orm_test.go: `.NewSortBySequence(query.Asc)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsDataWordRange(ctx, addr, eventSig, 0, logpoller.EvmWord(2), logpoller.EvmWord(2), 0)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(2)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(2)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, wordFilter(0, 2, 2), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsDataWordRange(ctx, addr, eventSig, 0, logpoller.EvmWord(1), logpoller.EvmWord(2), 0)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(2)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, wordFilter(0, 1, 2), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsDataWordRange(ctx, addr, eventSig, 0, logpoller.EvmWord(1), logpoller.EvmWord(1), 0)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, wordFilter(0, 1, 1), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsDataWordRange(ctx, addr, eventSig, 1, logpoller.EvmWord(3), logpoller.EvmWord(3), 0)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(3)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(3)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, wordFilter(1, 3, 3), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsDataWordRange(ctx, addr, eventSig, 1, logpoller.EvmWord(3), logpoller.EvmWord(3), 0)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(3)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(3)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, wordFilter(1, 3, 3), limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsDataWordGreaterThan(ctx, addr, eventSig, 0, logpoller.EvmWord(1), 0)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.NewAddressFilter(addr)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventSigFilter(eventSig)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventByWordFilter(0, []logpoller.HashedValueComparator{
			{Values: []common.Hash{logpoller.EvmWord(1)}, Operator: primitives.Gte},
		})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.Confidence(primitives.Unconfirmed)`
$DIR/pkg/logpoller/orm_test.go: `.FilteredLogs(ctx, filter, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1599")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1600")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x12345")`
$DIR/pkg/logpoller/orm_test.go: `.New(th.ChainID)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1234")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1888")`
$DIR/pkg/logpoller/orm_test.go: `.New(th.ChainID)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1235")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1888")`
$DIR/pkg/logpoller/orm_test.go: `.New(th.ChainID)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1236")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1235")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1888")`
$DIR/pkg/logpoller/orm_test.go: `.New(th.ChainID)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1237")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x1235")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1888")`
$DIR/pkg/logpoller/orm_test.go: `.New(th.ChainID)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1238")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1888")`
$DIR/pkg/logpoller/orm_test.go: `.New(th.ChainID)`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1239")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x1888")`
$DIR/pkg/logpoller/orm_test.go: `.NewAddressFilter(sourceAddr)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventSigFilter(val)`
$DIR/pkg/logpoller/orm_test.go: `.Block(startBlock, primitives.Gte)`
$DIR/pkg/logpoller/orm_test.go: `.Block(endBlock, primitives.Lte)`
$DIR/pkg/logpoller/orm_test.go: `.NewSortBySequence(query.Asc)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogsWithSigs(ctx, startBlock, endBlock, sourceAddr, []common.Hash{
		topic,
		topic2,
	})`
$DIR/pkg/logpoller/orm_test.go: `.ORM.FilteredLogs(ctx, filter([]common.Hash{topic, topic2}, strconv.Itoa(int(startBlock)), strconv.Itoa(int(endBlock))).Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.Itoa(int(startBlock))`
$DIR/pkg/logpoller/orm_test.go: `.Itoa(int(endBlock))`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.Test(t)`
$DIR/pkg/logpoller/orm_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/orm_test.go: `.NewSqlxDB(t)`
$DIR/pkg/logpoller/orm_test.go: `.NewORM(chainID, db, lggr)`
$DIR/pkg/logpoller/orm_test.go: `.New("some error")`
$DIR/pkg/logpoller/orm_test.go: `.On("Exec", int64(0), int64(0))`
$DIR/pkg/logpoller/orm_test.go: `.Return(0, queryError)`
$DIR/pkg/logpoller/orm_test.go: `.Once()`
$DIR/pkg/logpoller/orm_test.go: `.NewRangeQueryer(chainID, db, m.Exec)`
$DIR/pkg/logpoller/orm_test.go: `.ExecPagedQuery(ctx, 0, 0)`
$DIR/pkg/logpoller/orm_test.go: `.On("Exec", int64(0), int64(60))`
$DIR/pkg/logpoller/orm_test.go: `.Return(4, nil)`
$DIR/pkg/logpoller/orm_test.go: `.Once()`
$DIR/pkg/logpoller/orm_test.go: `.ExecPagedQuery(ctx, 0, 60)`
$DIR/pkg/logpoller/orm_test.go: `.ExecPagedQuery(ctx, 300, 1000)`
$DIR/pkg/logpoller/orm_test.go: `.On("Exec", mock.Anything, mock.Anything)`
$DIR/pkg/logpoller/orm_test.go: `.Return(3, nil)`
$DIR/pkg/logpoller/orm_test.go: `.ExecPagedQuery(ctx, 300, 1000)`
$DIR/pkg/logpoller/orm_test.go: `.AssertNumberOfCalls(t, "Exec", 6)`
$DIR/pkg/logpoller/orm_test.go: `.AssertCalled(t, "Exec", expected[0], expected[1])`
$DIR/pkg/logpoller/orm_test.go: `.ExecPagedQuery(ctx, 15, 1000)`
$DIR/pkg/logpoller/orm_test.go: `.AssertNumberOfCalls(t, "Exec", 11)`
$DIR/pkg/logpoller/orm_test.go: `.AssertCalled(t, "Exec", expected[0], expected[1])`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.DeleteBlocksBefore(ctx, 1, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectBlockByNumber(ctx, 1)`
$DIR/pkg/logpoller/orm_test.go: `.SelectBlockByNumber(ctx, 2)`
$DIR/pkg/logpoller/orm_test.go: `.DeleteBlocksBefore(ctx, 3, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectBlockByNumber(ctx, 2)`
$DIR/pkg/logpoller/orm_test.go: `.SelectBlockByNumber(ctx, 3)`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x2ab9a2Dc53736b361b72d900CdF9F78F9406fbbb")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x6E225058950f237371261C985Db6bDe26df2200E")`
$DIR/pkg/logpoller/orm_test.go: `.ORM.SelectLogsByBlockRange(ctx, 1, 3)`
$DIR/pkg/logpoller/orm_test.go: `.NewAddressFilter(address)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventSigFilter(event1)`
$DIR/pkg/logpoller/orm_test.go: `.Block(start, primitives.Gte)`
$DIR/pkg/logpoller/orm_test.go: `.Block(end, primitives.Lte)`
$DIR/pkg/logpoller/orm_test.go: `.ORM.SelectLogs(ctx, 1, 3, address1, event1)`
$DIR/pkg/logpoller/orm_test.go: `.ORM.FilteredLogs(ctx, logFilter("1", "3", address1), query.LimitAndSort{
		SortBy: []query.SortBy{query.NewSortBySequence(query.Asc)},
	}, "")`
$DIR/pkg/logpoller/orm_test.go: `.NewSortBySequence(query.Asc)`
$DIR/pkg/logpoller/orm_test.go: `.ORM.SelectLogs(ctx, 2, 2, address2, event1)`
$DIR/pkg/logpoller/orm_test.go: `.ORM.FilteredLogs(ctx, logFilter("2", "2", address2), query.LimitAndSort{
		SortBy: []query.SortBy{query.NewSortBySequence(query.Asc)},
	}, "")`
$DIR/pkg/logpoller/orm_test.go: `.NewSortBySequence(query.Asc)`
$DIR/pkg/logpoller/orm_test.go: `.Bytes()`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x11111")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x22222")`
$DIR/pkg/logpoller/orm_test.go: `.HexToAddress("0x33333")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x01")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x02")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x03")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x04")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x000a")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x000b")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x000c")`
$DIR/pkg/logpoller/orm_test.go: `.HexToHash("0x000d")`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigA, responseSigA, 1, addressA, 0, 3, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 1, addressB, 0, 3, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigA, responseSigA, 1, addressA, 0, 3, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 1, addressB, 0, 3, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 4, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 4, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 4, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 4, 3)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 10, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 10, 3)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 3, addressC, 0, 10, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 1, addressB, 0, 3, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigA, responseSigA, 1, addressA, 0, 1, 10)`
$DIR/pkg/logpoller/orm_test.go: `.SelectIndexedLogsWithSigsExcluding(ctx, requestSigB, responseSigB, 1, addressB, 2, 13, 0)`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.RandomAddress()`
$DIR/pkg/logpoller/orm_test.go: `.RandomAddress()`
$DIR/pkg/logpoller/orm_test.go: `.Run(tt.name, func(t *testing.T) {
			blockNumber, err := th.ORM.SelectLatestBlockByEventSigsAddrsWithConfs(ctx, tt.fromBlock, tt.events, tt.addrs, tt.confs)
			require.NoError(t, err)
			assert.Equal(t, tt.expectedBlockNumber, blockNumber)
		})`
$DIR/pkg/logpoller/orm_test.go: `.ORM.SelectLatestBlockByEventSigsAddrsWithConfs(ctx, tt.fromBlock, tt.events, tt.addrs, tt.confs)`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.RandomAddress()`
$DIR/pkg/logpoller/orm_test.go: `.Date(2010, 1, 1, 12, 12, 12, 0, time.UTC)`
$DIR/pkg/logpoller/orm_test.go: `.Date(2020, 1, 1, 12, 12, 12, 0, time.UTC)`
$DIR/pkg/logpoller/orm_test.go: `.Date(2030, 1, 1, 12, 12, 12, 0, time.UTC)`
$DIR/pkg/logpoller/orm_test.go: `.NewAddressFilter(address)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventSigFilter(event)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventByTopicFilter(topicIdx, []logpoller.HashedValueComparator{
					{Values: topicVals, Operator: primitives.Eq},
				})`
$DIR/pkg/logpoller/orm_test.go: `.Timestamp(uint64(timestamp.Unix()), primitives.Gt)`
$DIR/pkg/logpoller/orm_test.go: `.Unix()`
$DIR/pkg/logpoller/orm_test.go: `.NewConfirmationsFilter(confs)`
$DIR/pkg/logpoller/orm_test.go: `.NewSortBySequence(query.Asc)`
$DIR/pkg/logpoller/orm_test.go: `.Run(tt.name, func(t *testing.T) {
			logs, err := th.ORM.SelectLogsCreatedAfter(ctx, address, event, tt.after, tt.confs)

			assertion(t, logs, err, tt.expectedLogs)

			logs, err = th.ORM.FilteredLogs(ctx, filter(tt.after, tt.confs, 0, nil).Expressions, limiter, "")

			assertion(t, logs, err, tt.expectedLogs)
		})`
$DIR/pkg/logpoller/orm_test.go: `.ORM.SelectLogsCreatedAfter(ctx, address, event, tt.after, tt.confs)`
$DIR/pkg/logpoller/orm_test.go: `.ORM.FilteredLogs(ctx, filter(tt.after, tt.confs, 0, nil).Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.Run(tt.name, func(t *testing.T) {
				logs, err := th.ORM.SelectIndexedLogsCreatedAfter(ctx, address, event, 1, []common.Hash{event}, tt.after, tt.confs)

				assertion(t, logs, err, tt.expectedLogs)

				logs, err = th.ORM.FilteredLogs(ctx, filter(tt.after, tt.confs, 1, []common.Hash{event}).Expressions, limiter, "")

				assertion(t, logs, err, tt.expectedLogs)
			})`
$DIR/pkg/logpoller/orm_test.go: `.ORM.SelectIndexedLogsCreatedAfter(ctx, address, event, 1, []common.Hash{event}, tt.after, tt.confs)`
$DIR/pkg/logpoller/orm_test.go: `.ORM.FilteredLogs(ctx, filter(tt.after, tt.confs, 1, []common.Hash{event}).Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.RandomAddress()`
$DIR/pkg/logpoller/orm_test.go: `.ORM.SelectIndexedLogs(ctx, address, event, 1, []common.Hash{event}, types.Unconfirmed)`
$DIR/pkg/logpoller/orm_test.go: `.ORM.SelectIndexedLogs(ctx, address, event, 1, []common.Hash{event}, types.Unconfirmed)`
$DIR/pkg/logpoller/orm_test.go: `.ORM.SelectIndexedLogs(ctx, address, event, 1, []common.Hash{event}, types.Confirmations(4))`
$DIR/pkg/logpoller/orm_test.go: `.Confirmations(4)`
$DIR/pkg/logpoller/orm_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/orm_test.go: `.RandomBytes32()`
$DIR/pkg/logpoller/orm_test.go: `.RandomAddress()`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.NewIndependentSqlxDB(t)`
$DIR/pkg/logpoller/orm_test.go: `.NewORM(chainID, db, logger.Test(t))`
$DIR/pkg/logpoller/orm_test.go: `.Test(t)`
$DIR/pkg/logpoller/orm_test.go: `.RandomAddress()`
$DIR/pkg/logpoller/orm_test.go: `.String()`
$DIR/pkg/logpoller/orm_test.go: `.RandomAddress()`
$DIR/pkg/logpoller/orm_test.go: `.String()`
$DIR/pkg/logpoller/orm_test.go: `.RandomBytes32()`
$DIR/pkg/logpoller/orm_test.go: `.Now()`
$DIR/pkg/logpoller/orm_test.go: `.RandomBytes32()`
$DIR/pkg/logpoller/orm_test.go: `.Now()`
$DIR/pkg/logpoller/orm_test.go: `.Run(tt.name, func(t *testing.T) {
			// clean all logs and blocks between test cases
			defer func() { _ = o.DeleteLogsAndBlocksAfter(ctx, 0) }()
			insertError := o.InsertLogsWithBlock(ctx, tt.logs, tt.block)

			logs, logsErr := o.SelectLogs(ctx, 0, math.MaxInt, address, event)
			block, blockErr := o.SelectLatestBlock(ctx)

			if tt.shouldRollback {
				assert.Error(t, insertError)

				assert.NoError(t, logsErr)
				assert.Empty(t, logs)

				assert.Error(t, blockErr)
			} else {
				assert.NoError(t, insertError)

				assert.NoError(t, logsErr)
				assert.Len(t, logs, len(tt.logs))

				assert.NoError(t, blockErr)
				assert.Equal(t, block.BlockNumber, tt.block.BlockNumber)
			}
		})`
$DIR/pkg/logpoller/orm_test.go: `.DeleteLogsAndBlocksAfter(ctx, 0)`
$DIR/pkg/logpoller/orm_test.go: `.InsertLogsWithBlock(ctx, tt.logs, tt.block)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogs(ctx, 0, math.MaxInt, address, event)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestBlock(ctx)`
$DIR/pkg/logpoller/orm_test.go: `.NewRandomEVMChainID()`
$DIR/pkg/logpoller/orm_test.go: `.RandomBytes32()`
$DIR/pkg/logpoller/orm_test.go: `.RandomAddress()`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.NewIndependentSqlxDB(t)`
$DIR/pkg/logpoller/orm_test.go: `.NewORM(chainID, db, logger.Test(t))`
$DIR/pkg/logpoller/orm_test.go: `.Test(t)`
$DIR/pkg/logpoller/orm_test.go: `.RandomAddress()`
$DIR/pkg/logpoller/orm_test.go: `.String()`
$DIR/pkg/logpoller/orm_test.go: `.RandomAddress()`
$DIR/pkg/logpoller/orm_test.go: `.String()`
$DIR/pkg/logpoller/orm_test.go: `.Run(tt.name, func(t *testing.T) {
			// clean all logs and blocks between test cases
			defer func() { _, _ = db.Exec("truncate evm.logs") }()

			insertErr := o.InsertLogs(ctx, tt.logs)
			logsFromDb, err := o.SelectLogs(ctx, 0, math.MaxInt, address, event)
			assert.NoError(t, err)

			if tt.shouldRollback {
				assert.Error(t, insertErr)
				assert.Empty(t, logsFromDb)
			} else {
				assert.NoError(t, insertErr)
				assert.Len(t, logsFromDb, len(tt.logs))
			}
		})`
$DIR/pkg/logpoller/orm_test.go: `.Exec("truncate evm.logs")`
$DIR/pkg/logpoller/orm_test.go: `.InsertLogs(ctx, tt.logs)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLogs(ctx, 0, math.MaxInt, address, event)`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.RandomAddress()`
$DIR/pkg/logpoller/orm_test.go: `.RandomBytes32()`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(1)`
$DIR/pkg/logpoller/orm_test.go: `.Bytes()`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(10)`
$DIR/pkg/logpoller/orm_test.go: `.Bytes()`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(5)`
$DIR/pkg/logpoller/orm_test.go: `.Bytes()`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(20)`
$DIR/pkg/logpoller/orm_test.go: `.Bytes()`
$DIR/pkg/logpoller/orm_test.go: `.ORM.InsertLogsWithBlock(ctx,
		[]logpoller.Log{
			GenLogWithData(th.ChainID, address, eventSig, 1, 1, firstLogData),
			GenLogWithData(th.ChainID, address, eventSig, 2, 2, secondLogData),
		},
		logpoller.Block{
			BlockHash:            utils.RandomBytes32(),
			BlockNumber:          10,
			BlockTimestamp:       time.Now(),
			FinalizedBlockNumber: 1,
		},
	)`
$DIR/pkg/logpoller/orm_test.go: `.RandomBytes32()`
$DIR/pkg/logpoller/orm_test.go: `.Now()`
$DIR/pkg/logpoller/orm_test.go: `.NewSortByBlock(query.Asc)`
$DIR/pkg/logpoller/orm_test.go: `.NewSortBySequence(query.Asc)`
$DIR/pkg/logpoller/orm_test.go: `.NewAddressFilter(address)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventSigFilter(eventSig)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventByWordFilter(0, []logpoller.HashedValueComparator{
					{Values: []common.Hash{logpoller.EvmWord(word)}, Operator: primitives.Lte},
				})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(word)`
$DIR/pkg/logpoller/orm_test.go: `.NewEventByWordFilter(1, []logpoller.HashedValueComparator{
					{Values: []common.Hash{logpoller.EvmWord(word)}, Operator: primitives.Gte},
				})`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(word)`
$DIR/pkg/logpoller/orm_test.go: `.Confidence(primitives.Unconfirmed)`
$DIR/pkg/logpoller/orm_test.go: `.Run(tt.name, func(t *testing.T) {
			logs, err := th.ORM.SelectLogsDataWordBetween(ctx, address, eventSig, 0, 1, logpoller.EvmWord(tt.wordValue), types.Unconfirmed)

			assertion(t, logs, err, tt.expectedLogs)

			logs, err = th.ORM.FilteredLogs(ctx, wordFilter(tt.wordValue).Expressions, limiter, "")

			assertion(t, logs, err, tt.expectedLogs)
		})`
$DIR/pkg/logpoller/orm_test.go: `.ORM.SelectLogsDataWordBetween(ctx, address, eventSig, 0, 1, logpoller.EvmWord(tt.wordValue), types.Unconfirmed)`
$DIR/pkg/logpoller/orm_test.go: `.EvmWord(tt.wordValue)`
$DIR/pkg/logpoller/orm_test.go: `.ORM.FilteredLogs(ctx, wordFilter(tt.wordValue).Expressions, limiter, "")`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.Run("Selects oldest within given chain", func(t *testing.T) {
		// insert blocks
		require.NoError(t, o2.InsertBlock(ctx, common.HexToHash("0x1231"), 11, time.Now(), 0, 0))
		require.NoError(t, o2.InsertBlock(ctx, common.HexToHash("0x1232"), 12, time.Now(), 0, 0))
		// insert newer block from different chain
		require.NoError(t, o1.InsertBlock(ctx, common.HexToHash("0x1233"), 13, time.Now(), 0, 0))
		require.NoError(t, o1.InsertBlock(ctx, common.HexToHash("0x1231"), 14, time.Now(), 0, 0))
		block, err := o1.SelectOldestBlock(ctx, 0)
		require.NoError(t, err)
		require.NotNil(t, block)
		require.Equal(t, int64(13), block.BlockNumber)
		require.Equal(t, block.BlockHash, common.HexToHash("0x1233"))
	})`
$DIR/pkg/logpoller/orm_test.go: `.SelectOldestBlock(ctx, 0)`
$DIR/pkg/logpoller/orm_test.go: `.SelectOldestBlock(ctx, 12)`
$DIR/pkg/logpoller/orm_test.go: `.Run("If finalized block is not present in DB return error", func(t *testing.T) {
		th := SetupTH(t, lpOpts)
		o1 := th.ORM
		o2 := th.ORM2
		ctx := testutils.Context(t)
		// o2's chain does not have finalized block
		require.NoError(t, o2.InsertBlock(ctx, common.HexToHash("0x1231"), 11, time.Now(), 9, 9))
		require.NoError(t, o2.InsertBlock(ctx, common.HexToHash("0x1234"), 10, time.Now(), 8, 8))
		// o1 has finalized blocks
		require.NoError(t, o1.InsertBlock(ctx, common.HexToHash("0x1233"), 11, time.Now(), 10, 10))
		require.NoError(t, o1.InsertBlock(ctx, common.HexToHash("0x1232"), 10, time.Now(), 10, 10))
		result, err := o2.SelectLatestFinalizedBlock(ctx)
		require.ErrorIs(t, err, sql.ErrNoRows)
		require.Nil(t, result)
	})`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestFinalizedBlock(ctx)`
$DIR/pkg/logpoller/orm_test.go: `.Context(t)`
$DIR/pkg/logpoller/orm_test.go: `.SelectLatestFinalizedBlock(ctx)`
$DIR/pkg/logpoller/parser_test.go: `t.Run("query with no filters no order and no limit", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{}
		limiter := query.LimitAndSort{}

		result, args, err := parser.buildQuery(chainID, expressions, limiter)

		require.NoError(t, err)
		assert.Equal(t, logsQuery(" WHERE evm_chain_id = :evm_chain_id ORDER BY "+defaultSort), result)

		assertArgs(t, args, 1)
	})`
$DIR/pkg/logpoller/parser_test.go: `assertArgs(t, args, 1)`
$DIR/pkg/logpoller/parser_test.go: `t.Run("query with cursor and no order by", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{
			NewAddressFilter(common.HexToAddress("0x42")),
			NewEventSigFilter(common.HexToHash("0x21")),
			NewConfirmationsFilter(types.Finalized),
		}
		limiter := query.NewLimitAndSort(query.CursorLimit("10-5-0x42", query.CursorFollowing, 20))

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"AND (address = :address_0 AND event_sig = :event_sig_0 " +
				"AND block_number <= " +
				"(SELECT finalized_block_number FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1)) " +
				"AND (block_number > :cursor_block_number OR (block_number = :cursor_block_number AND log_index > :cursor_log_index)) " +
				"ORDER BY block_number ASC, log_index ASC, tx_hash ASC " +
				"LIMIT 20")

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 5)
	})`
$DIR/pkg/logpoller/parser_test.go: `assertArgs(t, args, 5)`
$DIR/pkg/logpoller/parser_test.go: `t.Run("query with limit and no order by", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{
			NewAddressFilter(common.HexToAddress("0x42")),
			NewEventSigFilter(common.HexToHash("0x21")),
		}
		limiter := query.NewLimitAndSort(query.CountLimit(20))

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"AND (address = :address_0 AND event_sig = :event_sig_0) " +
				"ORDER BY " + defaultSort + " " +
				"LIMIT 20")

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 3)
	})`
$DIR/pkg/logpoller/parser_test.go: `assertArgs(t, args, 3)`
$DIR/pkg/logpoller/parser_test.go: `t.Run("query with order by sequence no cursor no limit", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{}
		limiter := query.NewLimitAndSort(query.Limit{}, query.NewSortBySequence(query.Desc))

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"ORDER BY block_number DESC, log_index DESC, tx_hash DESC")

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 1)
	})`
$DIR/pkg/logpoller/parser_test.go: `assertArgs(t, args, 1)`
$DIR/pkg/logpoller/parser_test.go: `t.Run("query with multiple order by no limit", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{}
		limiter := query.NewLimitAndSort(query.Limit{}, query.NewSortByBlock(query.Asc), query.NewSortByTimestamp(query.Desc))

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"ORDER BY block_number ASC, block_timestamp DESC")

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 1)
	})`
$DIR/pkg/logpoller/parser_test.go: `assertArgs(t, args, 1)`
$DIR/pkg/logpoller/parser_test.go: `t.Run("basic query with default primitives no order by and cursor", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{
			query.Timestamp(10, primitives.Eq),
			query.TxHash(common.HexToHash("0x84").String()),
			query.Block("99", primitives.Neq),
			query.Confidence(primitives.Finalized),
		}
		limiter := query.NewLimitAndSort(query.CursorLimit("10-20-0x42", query.CursorPrevious, 20))

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"AND (block_timestamp = :block_timestamp_0 " +
				"AND tx_hash = :tx_hash_0 " +
				"AND block_number != :block_number_0 " +
				"AND block_number <= " +
				"(SELECT finalized_block_number FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1)) " +
				"AND (block_number < :cursor_block_number OR (block_number = :cursor_block_number AND log_index < :cursor_log_index)) " +
				"ORDER BY block_number DESC, log_index DESC, tx_hash DESC LIMIT 20")

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 6)
	})`
$DIR/pkg/logpoller/parser_test.go: `assertArgs(t, args, 6)`
$DIR/pkg/logpoller/parser_test.go: `t.Run("query for finality", func(t *testing.T) {
		t.Parallel()

		t.Run("finalized", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{query.Confidence(primitives.Finalized)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT finalized_block_number FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			assertArgs(t, args, 1)
		})

		t.Run("safe", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{query.Confidence(primitives.Safe)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT safe_block_number FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			assertArgs(t, args, 1)
		})

		t.Run("unconfirmed", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{query.Confidence(primitives.Unconfirmed)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT greatest(block_number - :confs_0, 0) FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			assertArgs(t, args, 2)
		})

		t.Run("exact confirmations", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{NewConfirmationsFilter(25)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT greatest(block_number - :confs_0, 0) FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			confirmations, ok := args.args["confs_0"]

			require.True(t, ok)
			require.Equal(t, uint64(25), confirmations)

			assertArgs(t, args, 2)
		})
	})`
$DIR/pkg/logpoller/parser_test.go: `t.Run("finalized", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{query.Confidence(primitives.Finalized)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT finalized_block_number FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			assertArgs(t, args, 1)
		})`
$DIR/pkg/logpoller/parser_test.go: `assertArgs(t, args, 1)`
$DIR/pkg/logpoller/parser_test.go: `t.Run("safe", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{query.Confidence(primitives.Safe)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT safe_block_number FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			assertArgs(t, args, 1)
		})`
$DIR/pkg/logpoller/parser_test.go: `assertArgs(t, args, 1)`
$DIR/pkg/logpoller/parser_test.go: `t.Run("unconfirmed", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{query.Confidence(primitives.Unconfirmed)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT greatest(block_number - :confs_0, 0) FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			assertArgs(t, args, 2)
		})`
$DIR/pkg/logpoller/parser_test.go: `assertArgs(t, args, 2)`
$DIR/pkg/logpoller/parser_test.go: `t.Run("exact confirmations", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{NewConfirmationsFilter(25)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT greatest(block_number - :confs_0, 0) FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			confirmations, ok := args.args["confs_0"]

			require.True(t, ok)
			require.Equal(t, uint64(25), confirmations)

			assertArgs(t, args, 2)
		})`
$DIR/pkg/logpoller/parser_test.go: `assertArgs(t, args, 2)`
$DIR/pkg/logpoller/parser_test.go: `t.Run("query for event by word", func(t *testing.T) {
		t.Parallel()

		wordFilter := NewEventByWordFilter(8, []HashedValueComparator{
			{Values: []common.Hash{common.HexToHash("0x1"), common.HexToHash("0x2")}, Operator: primitives.Gt},
		})

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{wordFilter}
		limiter := query.LimitAndSort{}

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"AND substring(data from 32*8+1 for 32) > ANY(:word_value_0) ORDER BY " + defaultSort)

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		values, err := args.toArgs()
		require.NoError(t, err)
		require.Len(t, values, 2)
		// HashedValueComparator values should be concatenated into single slice
		require.Len(t, values["word_value_0"], 2)
	})`
$DIR/pkg/logpoller/parser_test.go: `t.Run("query for event topic", func(t *testing.T) {
		t.Parallel()

		topicFilter := NewEventByTopicFilter(2, []HashedValueComparator{
			{Values: []common.Hash{common.HexToHash("a")}, Operator: primitives.Gt},
			{Values: []common.Hash{common.HexToHash("b"), common.HexToHash("c")}, Operator: primitives.Lt},
		})

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{topicFilter}
		limiter := query.LimitAndSort{}

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"AND topics[3] > :topic_value_0 AND topics[3] < ANY(:topic_value_1) ORDER BY " + defaultSort)

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 3)
	})`
$DIR/pkg/logpoller/parser_test.go: `assertArgs(t, args, 3)`
$DIR/pkg/logpoller/parser_test.go: `t.Run("nested query", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)

		expressions := []query.Expression{
			{BoolExpression: query.BoolExpression{
				Expressions: []query.Expression{
					query.Timestamp(10, primitives.Gte),
					{BoolExpression: query.BoolExpression{
						Expressions: []query.Expression{
							query.TxHash(common.HexToHash("0x84").Hex()),
							query.Confidence(primitives.Unconfirmed),
						},
						BoolOperator: query.OR,
					}},
				},
				BoolOperator: query.AND,
			}},
		}
		limiter := query.LimitAndSort{}

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"AND (block_timestamp >= :block_timestamp_0 " +
				"AND (tx_hash = :tx_hash_0 " +
				"OR block_number <= (SELECT greatest(block_number - :confs_0, 0) FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1))) ORDER BY " + defaultSort)

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 4)
	})`
$DIR/pkg/logpoller/parser_test.go: `assertArgs(t, args, 4)`
$DIR/pkg/logpoller/parser_test.go: `.Run("query with no filters no order and no limit", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{}
		limiter := query.LimitAndSort{}

		result, args, err := parser.buildQuery(chainID, expressions, limiter)

		require.NoError(t, err)
		assert.Equal(t, logsQuery(" WHERE evm_chain_id = :evm_chain_id ORDER BY "+defaultSort), result)

		assertArgs(t, args, 1)
	})`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.Run("query with cursor and no order by", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{
			NewAddressFilter(common.HexToAddress("0x42")),
			NewEventSigFilter(common.HexToHash("0x21")),
			NewConfirmationsFilter(types.Finalized),
		}
		limiter := query.NewLimitAndSort(query.CursorLimit("10-5-0x42", query.CursorFollowing, 20))

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"AND (address = :address_0 AND event_sig = :event_sig_0 " +
				"AND block_number <= " +
				"(SELECT finalized_block_number FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1)) " +
				"AND (block_number > :cursor_block_number OR (block_number = :cursor_block_number AND log_index > :cursor_log_index)) " +
				"ORDER BY block_number ASC, log_index ASC, tx_hash ASC " +
				"LIMIT 20")

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 5)
	})`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.HexToAddress("0x42")`
$DIR/pkg/logpoller/parser_test.go: `.HexToHash("0x21")`
$DIR/pkg/logpoller/parser_test.go: `.NewLimitAndSort(query.CursorLimit("10-5-0x42", query.CursorFollowing, 20))`
$DIR/pkg/logpoller/parser_test.go: `.CursorLimit("10-5-0x42", query.CursorFollowing, 20)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.Run("query with limit and no order by", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{
			NewAddressFilter(common.HexToAddress("0x42")),
			NewEventSigFilter(common.HexToHash("0x21")),
		}
		limiter := query.NewLimitAndSort(query.CountLimit(20))

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"AND (address = :address_0 AND event_sig = :event_sig_0) " +
				"ORDER BY " + defaultSort + " " +
				"LIMIT 20")

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 3)
	})`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.HexToAddress("0x42")`
$DIR/pkg/logpoller/parser_test.go: `.HexToHash("0x21")`
$DIR/pkg/logpoller/parser_test.go: `.NewLimitAndSort(query.CountLimit(20))`
$DIR/pkg/logpoller/parser_test.go: `.CountLimit(20)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.Run("query with order by sequence no cursor no limit", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{}
		limiter := query.NewLimitAndSort(query.Limit{}, query.NewSortBySequence(query.Desc))

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"ORDER BY block_number DESC, log_index DESC, tx_hash DESC")

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 1)
	})`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.NewLimitAndSort(query.Limit{}, query.NewSortBySequence(query.Desc))`
$DIR/pkg/logpoller/parser_test.go: `.NewSortBySequence(query.Desc)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.Run("query with multiple order by no limit", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{}
		limiter := query.NewLimitAndSort(query.Limit{}, query.NewSortByBlock(query.Asc), query.NewSortByTimestamp(query.Desc))

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"ORDER BY block_number ASC, block_timestamp DESC")

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 1)
	})`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.NewLimitAndSort(query.Limit{}, query.NewSortByBlock(query.Asc), query.NewSortByTimestamp(query.Desc))`
$DIR/pkg/logpoller/parser_test.go: `.NewSortByBlock(query.Asc)`
$DIR/pkg/logpoller/parser_test.go: `.NewSortByTimestamp(query.Desc)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.Run("basic query with default primitives no order by and cursor", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{
			query.Timestamp(10, primitives.Eq),
			query.TxHash(common.HexToHash("0x84").String()),
			query.Block("99", primitives.Neq),
			query.Confidence(primitives.Finalized),
		}
		limiter := query.NewLimitAndSort(query.CursorLimit("10-20-0x42", query.CursorPrevious, 20))

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"AND (block_timestamp = :block_timestamp_0 " +
				"AND tx_hash = :tx_hash_0 " +
				"AND block_number != :block_number_0 " +
				"AND block_number <= " +
				"(SELECT finalized_block_number FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1)) " +
				"AND (block_number < :cursor_block_number OR (block_number = :cursor_block_number AND log_index < :cursor_log_index)) " +
				"ORDER BY block_number DESC, log_index DESC, tx_hash DESC LIMIT 20")

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 6)
	})`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.Timestamp(10, primitives.Eq)`
$DIR/pkg/logpoller/parser_test.go: `.TxHash(common.HexToHash("0x84").String())`
$DIR/pkg/logpoller/parser_test.go: `.HexToHash("0x84")`
$DIR/pkg/logpoller/parser_test.go: `.String()`
$DIR/pkg/logpoller/parser_test.go: `.Block("99", primitives.Neq)`
$DIR/pkg/logpoller/parser_test.go: `.Confidence(primitives.Finalized)`
$DIR/pkg/logpoller/parser_test.go: `.NewLimitAndSort(query.CursorLimit("10-20-0x42", query.CursorPrevious, 20))`
$DIR/pkg/logpoller/parser_test.go: `.CursorLimit("10-20-0x42", query.CursorPrevious, 20)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.Run("query for finality", func(t *testing.T) {
		t.Parallel()

		t.Run("finalized", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{query.Confidence(primitives.Finalized)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT finalized_block_number FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			assertArgs(t, args, 1)
		})

		t.Run("safe", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{query.Confidence(primitives.Safe)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT safe_block_number FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			assertArgs(t, args, 1)
		})

		t.Run("unconfirmed", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{query.Confidence(primitives.Unconfirmed)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT greatest(block_number - :confs_0, 0) FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			assertArgs(t, args, 2)
		})

		t.Run("exact confirmations", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{NewConfirmationsFilter(25)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT greatest(block_number - :confs_0, 0) FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			confirmations, ok := args.args["confs_0"]

			require.True(t, ok)
			require.Equal(t, uint64(25), confirmations)

			assertArgs(t, args, 2)
		})
	})`
$DIR/pkg/logpoller/parser_test.go: `.Run("finalized", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{query.Confidence(primitives.Finalized)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT finalized_block_number FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			assertArgs(t, args, 1)
		})`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.Confidence(primitives.Finalized)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.Run("safe", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{query.Confidence(primitives.Safe)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT safe_block_number FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			assertArgs(t, args, 1)
		})`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.Confidence(primitives.Safe)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.Run("unconfirmed", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{query.Confidence(primitives.Unconfirmed)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT greatest(block_number - :confs_0, 0) FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			assertArgs(t, args, 2)
		})`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.Confidence(primitives.Unconfirmed)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.Run("exact confirmations", func(t *testing.T) {
			parser := &pgDSLParser{}
			chainID := big.NewInt(1)

			expressions := []query.Expression{NewConfirmationsFilter(25)}
			limiter := query.LimitAndSort{}

			result, args, err := parser.buildQuery(chainID, expressions, limiter)
			expected := logsQuery(
				" WHERE evm_chain_id = :evm_chain_id " +
					"AND block_number <= (SELECT greatest(block_number - :confs_0, 0) FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1) ORDER BY " + defaultSort)

			require.NoError(t, err)
			assert.Equal(t, expected, result)

			confirmations, ok := args.args["confs_0"]

			require.True(t, ok)
			require.Equal(t, uint64(25), confirmations)

			assertArgs(t, args, 2)
		})`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.Run("query for event by word", func(t *testing.T) {
		t.Parallel()

		wordFilter := NewEventByWordFilter(8, []HashedValueComparator{
			{Values: []common.Hash{common.HexToHash("0x1"), common.HexToHash("0x2")}, Operator: primitives.Gt},
		})

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{wordFilter}
		limiter := query.LimitAndSort{}

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"AND substring(data from 32*8+1 for 32) > ANY(:word_value_0) ORDER BY " + defaultSort)

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		values, err := args.toArgs()
		require.NoError(t, err)
		require.Len(t, values, 2)
		// HashedValueComparator values should be concatenated into single slice
		require.Len(t, values["word_value_0"], 2)
	})`
$DIR/pkg/logpoller/parser_test.go: `.HexToHash("0x1")`
$DIR/pkg/logpoller/parser_test.go: `.HexToHash("0x2")`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.toArgs()`
$DIR/pkg/logpoller/parser_test.go: `.Run("query for event topic", func(t *testing.T) {
		t.Parallel()

		topicFilter := NewEventByTopicFilter(2, []HashedValueComparator{
			{Values: []common.Hash{common.HexToHash("a")}, Operator: primitives.Gt},
			{Values: []common.Hash{common.HexToHash("b"), common.HexToHash("c")}, Operator: primitives.Lt},
		})

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)
		expressions := []query.Expression{topicFilter}
		limiter := query.LimitAndSort{}

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"AND topics[3] > :topic_value_0 AND topics[3] < ANY(:topic_value_1) ORDER BY " + defaultSort)

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 3)
	})`
$DIR/pkg/logpoller/parser_test.go: `.HexToHash("a")`
$DIR/pkg/logpoller/parser_test.go: `.HexToHash("b")`
$DIR/pkg/logpoller/parser_test.go: `.HexToHash("c")`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.Run("nested query", func(t *testing.T) {
		t.Parallel()

		parser := &pgDSLParser{}
		chainID := big.NewInt(1)

		expressions := []query.Expression{
			{BoolExpression: query.BoolExpression{
				Expressions: []query.Expression{
					query.Timestamp(10, primitives.Gte),
					{BoolExpression: query.BoolExpression{
						Expressions: []query.Expression{
							query.TxHash(common.HexToHash("0x84").Hex()),
							query.Confidence(primitives.Unconfirmed),
						},
						BoolOperator: query.OR,
					}},
				},
				BoolOperator: query.AND,
			}},
		}
		limiter := query.LimitAndSort{}

		result, args, err := parser.buildQuery(chainID, expressions, limiter)
		expected := logsQuery(
			" WHERE evm_chain_id = :evm_chain_id " +
				"AND (block_timestamp >= :block_timestamp_0 " +
				"AND (tx_hash = :tx_hash_0 " +
				"OR block_number <= (SELECT greatest(block_number - :confs_0, 0) FROM evm.log_poller_blocks WHERE evm_chain_id = :evm_chain_id ORDER BY block_number DESC LIMIT 1))) ORDER BY " + defaultSort)

		require.NoError(t, err)
		assert.Equal(t, expected, result)

		assertArgs(t, args, 4)
	})`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.Timestamp(10, primitives.Gte)`
$DIR/pkg/logpoller/parser_test.go: `.TxHash(common.HexToHash("0x84").Hex())`
$DIR/pkg/logpoller/parser_test.go: `.HexToHash("0x84")`
$DIR/pkg/logpoller/parser_test.go: `.Hex()`
$DIR/pkg/logpoller/parser_test.go: `.Confidence(primitives.Unconfirmed)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.HexToHash("a")`
$DIR/pkg/logpoller/parser_test.go: `.HexToHash("b")`
$DIR/pkg/logpoller/parser_test.go: `.HexToHash("c")`
$DIR/pkg/logpoller/parser_test.go: `.NewInt(1)`
$DIR/pkg/logpoller/parser_test.go: `.Timestamp(10, primitives.Eq)`
$DIR/pkg/logpoller/parser_test.go: `.TxHash(common.HexToHash("0x84").Hex())`
$DIR/pkg/logpoller/parser_test.go: `.HexToHash("0x84")`
$DIR/pkg/logpoller/parser_test.go: `.Hex()`
$DIR/pkg/logpoller/parser_test.go: `.Confidence(primitives.Unconfirmed)`
$DIR/pkg/logpoller/parser_test.go: `.buildQuery(chainID, expressions, limiter)`
$DIR/pkg/logpoller/parser_test.go: `.toArgs()`
$DIR/pkg/logpoller/query_test.go: `t.Run(tt.name, func(t *testing.T) {
			args, err := tt.queryArgs.toArgs()
			if tt.wantErr {
				require.Error(t, err)
			} else {
				require.NoError(t, err)
				require.Equal(t, tt.want, args)
			}
		})`
$DIR/pkg/logpoller/query_test.go: `.NewInt(20)`
$DIR/pkg/logpoller/query_test.go: `.withAddress(utils.ZeroAddress)`
$DIR/pkg/logpoller/query_test.go: `.NewI(20)`
$DIR/pkg/logpoller/query_test.go: `.NewInt(20)`
$DIR/pkg/logpoller/query_test.go: `.withTopicIndex(0)`
$DIR/pkg/logpoller/query_test.go: `.withField("arg", "value")`
$DIR/pkg/logpoller/query_test.go: `.withField("hash", common.Hash{})`
$DIR/pkg/logpoller/query_test.go: `.withEventSigArray([]common.Hash{{}, {}})`
$DIR/pkg/logpoller/query_test.go: `.withTopicIndex(2)`
$DIR/pkg/logpoller/query_test.go: `.Run(tt.name, func(t *testing.T) {
			args, err := tt.queryArgs.toArgs()
			if tt.wantErr {
				require.Error(t, err)
			} else {
				require.NoError(t, err)
				require.Equal(t, tt.want, args)
			}
		})`
$DIR/pkg/logpoller/query_test.go: `.queryArgs.toArgs()`
$DIR/pkg/monitor/balance_test.go: `t.Run("updates balance from nil for multiple keys", func(t *testing.T) {
		k0Addr := testutils.NewAddress()
		k1Addr := testutils.NewAddress()
		ethKeyStore := keystest.Addresses{k0Addr, k1Addr}
		ethClient := newEthClientMock(t)

		bm := monitor.NewBalanceMonitor(ethClient, ethKeyStore, logger.Test(t))

		k0bal := big.NewInt(42)
		k1bal := big.NewInt(43)
		assert.Nil(t, bm.GetEthBalance(k0Addr))
		assert.Nil(t, bm.GetEthBalance(k1Addr))

		ethClient.On("BalanceAt", mock.Anything, k0Addr, nilBigInt).Once().Return(k0bal, nil)
		ethClient.On("BalanceAt", mock.Anything, k1Addr, nilBigInt).Once().Return(k1bal, nil)

		servicetest.RunHealthy(t, bm)

		gomega.NewWithT(t).Eventually(func() *big.Int {
			return bm.GetEthBalance(k0Addr).ToInt()
		}).Should(gomega.Equal(k0bal))
		gomega.NewWithT(t).Eventually(func() *big.Int {
			return bm.GetEthBalance(k1Addr).ToInt()
		}).Should(gomega.Equal(k1bal))
	})`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, k0Addr, nilBigInt).Once().Return(k0bal, nil)`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, k1Addr, nilBigInt).Once().Return(k1bal, nil)`
$DIR/pkg/monitor/balance_test.go: `servicetest.RunHealthy(t, bm)`
$DIR/pkg/monitor/balance_test.go: `gomega.NewWithT(t).Eventually(func() *big.Int {
			return bm.GetEthBalance(k0Addr).ToInt()
		}).Should(gomega.Equal(k0bal))`
$DIR/pkg/monitor/balance_test.go: `gomega.NewWithT(t).Eventually(func() *big.Int {
			return bm.GetEthBalance(k1Addr).ToInt()
		}).Should(gomega.Equal(k1bal))`
$DIR/pkg/monitor/balance_test.go: `t.Run("handles nil head", func(t *testing.T) {
		k0Addr := testutils.NewAddress()
		ethKeyStore := keystest.Addresses{k0Addr}
		ethClient := newEthClientMock(t)

		bm := monitor.NewBalanceMonitor(ethClient, ethKeyStore, logger.Test(t))
		k0bal := big.NewInt(42)

		ethClient.On("BalanceAt", mock.Anything, k0Addr, nilBigInt).Once().Return(k0bal, nil)

		servicetest.RunHealthy(t, bm)

		gomega.NewWithT(t).Eventually(func() *big.Int {
			return bm.GetEthBalance(k0Addr).ToInt()
		}).Should(gomega.Equal(k0bal))
	})`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, k0Addr, nilBigInt).Once().Return(k0bal, nil)`
$DIR/pkg/monitor/balance_test.go: `servicetest.RunHealthy(t, bm)`
$DIR/pkg/monitor/balance_test.go: `gomega.NewWithT(t).Eventually(func() *big.Int {
			return bm.GetEthBalance(k0Addr).ToInt()
		}).Should(gomega.Equal(k0bal))`
$DIR/pkg/monitor/balance_test.go: `t.Run("cancelled context", func(t *testing.T) {
		k0Addr := testutils.NewAddress()
		ethKeyStore := keystest.Addresses{k0Addr}
		ethClient := newEthClientMock(t)

		bm := monitor.NewBalanceMonitor(ethClient, ethKeyStore, logger.Test(t))
		ctxCancelledAwaiter := testutils.NewAwaiter()

		ethClient.On("BalanceAt", mock.Anything, k0Addr, nilBigInt).Once().Run(func(args mock.Arguments) {
			ctx := args.Get(0).(context.Context)
			select {
			case <-time.After(tests.WaitTimeout(t)):
			case <-ctx.Done():
				ctxCancelledAwaiter.ItHappened()
			}
		}).Return(nil, nil)

		ctx, cancel := context.WithCancel(tests.Context(t))
		go func() {
			<-time.After(time.Second)
			cancel()
		}()
		assert.NoError(t, bm.Start(ctx))

		ctxCancelledAwaiter.AwaitOrFail(t)
	})`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, k0Addr, nilBigInt).Once().Run(func(args mock.Arguments) {
			ctx := args.Get(0).(context.Context)
			select {
			case <-time.After(tests.WaitTimeout(t)):
			case <-ctx.Done():
				ctxCancelledAwaiter.ItHappened()
			}
		}).Return(nil, nil)`
$DIR/pkg/monitor/balance_test.go: `ctxCancelledAwaiter.ItHappened()`
$DIR/pkg/monitor/balance_test.go: `<-time.After(time.Second)`
$DIR/pkg/monitor/balance_test.go: `cancel()`
$DIR/pkg/monitor/balance_test.go: `ctxCancelledAwaiter.AwaitOrFail(t)`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, k0Addr, nilBigInt).
			Once().
			Return(nil, pkgerrors.New("a little easter egg for the 4chan link marines error"))`
$DIR/pkg/monitor/balance_test.go: `servicetest.RunHealthy(t, bm)`
$DIR/pkg/monitor/balance_test.go: `gomega.NewWithT(t).Consistently(func() *big.Int {
			return bm.GetEthBalance(k0Addr).ToInt()
		}).Should(gomega.BeNil())`
$DIR/pkg/monitor/balance_test.go: `k1bal.SetString("19223372036854776000", 10)`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, k0Addr, nilBigInt).Once().Return(k0bal, nil)`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, k1Addr, nilBigInt).Once().Return(k1bal, nil)`
$DIR/pkg/monitor/balance_test.go: `servicetest.RunHealthy(t, bm)`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, k0Addr, nilBigInt).Once().Return(k0bal, nil)`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, k1Addr, nilBigInt).Once().Return(k1bal, nil)`
$DIR/pkg/monitor/balance_test.go: `bm.OnNewLongestChain(tests.Context(t), head)`
$DIR/pkg/monitor/balance_test.go: `<-bm.WorkDone()`
$DIR/pkg/monitor/balance_test.go: `head = testutils.Head(1)`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, k0Addr, nilBigInt).Once().Return(k0bal2, nil)`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, k1Addr, nilBigInt).Once().Return(k1bal2, nil)`
$DIR/pkg/monitor/balance_test.go: `bm.OnNewLongestChain(tests.Context(t), head)`
$DIR/pkg/monitor/balance_test.go: `<-bm.WorkDone()`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, mock.Anything, mock.Anything).
		Once().
		Return(big.NewInt(1), nil)`
$DIR/pkg/monitor/balance_test.go: `servicetest.RunHealthy(t, bm)`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, mock.Anything, mock.Anything).
		WaitUntil(mockUnblocker).
		Once().
		Return(big.NewInt(42), nil)`
$DIR/pkg/monitor/balance_test.go: `ethClient.On("BalanceAt", mock.Anything, mock.Anything, mock.Anything).
		Run(func(mock.Arguments) { callCount.Add(1) }).
		Maybe().
		Return(big.NewInt(42), nil)`
$DIR/pkg/monitor/balance_test.go: `callCount.Add(1)`
$DIR/pkg/monitor/balance_test.go: `bm.OnNewLongestChain(tests.Context(t), head)`
$DIR/pkg/monitor/balance_test.go: `callbackOrTimeout(t, "FewerRPCCallsWhenBehind unblock BalanceAt", func() {
		mockUnblocker <- time.Time{}
	})`
$DIR/pkg/monitor/balance_test.go: `mockUnblocker <- time.Time{}`
$DIR/pkg/monitor/balance_test.go: `t.Run(test.name, func(t *testing.T) {
			eth := assets.NewEth(0)
			eth.SetString(test.input, 10)
			float, err := monitor.ApproximateFloat64(eth)
			require.NoError(t, err)
			require.Equal(t, test.want, float)
		})`
$DIR/pkg/monitor/balance_test.go: `eth.SetString(test.input, 10)`
$DIR/pkg/monitor/balance_test.go: `.Run("updates balance from nil for multiple keys", func(t *testing.T) {
		k0Addr := testutils.NewAddress()
		k1Addr := testutils.NewAddress()
		ethKeyStore := keystest.Addresses{k0Addr, k1Addr}
		ethClient := newEthClientMock(t)

		bm := monitor.NewBalanceMonitor(ethClient, ethKeyStore, logger.Test(t))

		k0bal := big.NewInt(42)
		k1bal := big.NewInt(43)
		assert.Nil(t, bm.GetEthBalance(k0Addr))
		assert.Nil(t, bm.GetEthBalance(k1Addr))

		ethClient.On("BalanceAt", mock.Anything, k0Addr, nilBigInt).Once().Return(k0bal, nil)
		ethClient.On("BalanceAt", mock.Anything, k1Addr, nilBigInt).Once().Return(k1bal, nil)

		servicetest.RunHealthy(t, bm)

		gomega.NewWithT(t).Eventually(func() *big.Int {
			return bm.GetEthBalance(k0Addr).ToInt()
		}).Should(gomega.Equal(k0bal))
		gomega.NewWithT(t).Eventually(func() *big.Int {
			return bm.GetEthBalance(k1Addr).ToInt()
		}).Should(gomega.Equal(k1bal))
	})`
$DIR/pkg/monitor/balance_test.go: `.NewAddress()`
$DIR/pkg/monitor/balance_test.go: `.NewAddress()`
$DIR/pkg/monitor/balance_test.go: `.NewBalanceMonitor(ethClient, ethKeyStore, logger.Test(t))`
$DIR/pkg/monitor/balance_test.go: `.Test(t)`
$DIR/pkg/monitor/balance_test.go: `.NewInt(42)`
$DIR/pkg/monitor/balance_test.go: `.NewInt(43)`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, k0Addr, nilBigInt)`
$DIR/pkg/monitor/balance_test.go: `.Once()`
$DIR/pkg/monitor/balance_test.go: `.Return(k0bal, nil)`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, k1Addr, nilBigInt)`
$DIR/pkg/monitor/balance_test.go: `.Once()`
$DIR/pkg/monitor/balance_test.go: `.Return(k1bal, nil)`
$DIR/pkg/monitor/balance_test.go: `.RunHealthy(t, bm)`
$DIR/pkg/monitor/balance_test.go: `.NewWithT(t)`
$DIR/pkg/monitor/balance_test.go: `.Eventually(func() *big.Int {
			return bm.GetEthBalance(k0Addr).ToInt()
		})`
$DIR/pkg/monitor/balance_test.go: `.GetEthBalance(k0Addr)`
$DIR/pkg/monitor/balance_test.go: `.ToInt()`
$DIR/pkg/monitor/balance_test.go: `.Should(gomega.Equal(k0bal))`
$DIR/pkg/monitor/balance_test.go: `.Equal(k0bal)`
$DIR/pkg/monitor/balance_test.go: `.NewWithT(t)`
$DIR/pkg/monitor/balance_test.go: `.Eventually(func() *big.Int {
			return bm.GetEthBalance(k1Addr).ToInt()
		})`
$DIR/pkg/monitor/balance_test.go: `.GetEthBalance(k1Addr)`
$DIR/pkg/monitor/balance_test.go: `.ToInt()`
$DIR/pkg/monitor/balance_test.go: `.Should(gomega.Equal(k1bal))`
$DIR/pkg/monitor/balance_test.go: `.Equal(k1bal)`
$DIR/pkg/monitor/balance_test.go: `.Run("handles nil head", func(t *testing.T) {
		k0Addr := testutils.NewAddress()
		ethKeyStore := keystest.Addresses{k0Addr}
		ethClient := newEthClientMock(t)

		bm := monitor.NewBalanceMonitor(ethClient, ethKeyStore, logger.Test(t))
		k0bal := big.NewInt(42)

		ethClient.On("BalanceAt", mock.Anything, k0Addr, nilBigInt).Once().Return(k0bal, nil)

		servicetest.RunHealthy(t, bm)

		gomega.NewWithT(t).Eventually(func() *big.Int {
			return bm.GetEthBalance(k0Addr).ToInt()
		}).Should(gomega.Equal(k0bal))
	})`
$DIR/pkg/monitor/balance_test.go: `.NewAddress()`
$DIR/pkg/monitor/balance_test.go: `.NewBalanceMonitor(ethClient, ethKeyStore, logger.Test(t))`
$DIR/pkg/monitor/balance_test.go: `.Test(t)`
$DIR/pkg/monitor/balance_test.go: `.NewInt(42)`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, k0Addr, nilBigInt)`
$DIR/pkg/monitor/balance_test.go: `.Once()`
$DIR/pkg/monitor/balance_test.go: `.Return(k0bal, nil)`
$DIR/pkg/monitor/balance_test.go: `.RunHealthy(t, bm)`
$DIR/pkg/monitor/balance_test.go: `.NewWithT(t)`
$DIR/pkg/monitor/balance_test.go: `.Eventually(func() *big.Int {
			return bm.GetEthBalance(k0Addr).ToInt()
		})`
$DIR/pkg/monitor/balance_test.go: `.GetEthBalance(k0Addr)`
$DIR/pkg/monitor/balance_test.go: `.ToInt()`
$DIR/pkg/monitor/balance_test.go: `.Should(gomega.Equal(k0bal))`
$DIR/pkg/monitor/balance_test.go: `.Equal(k0bal)`
$DIR/pkg/monitor/balance_test.go: `.Run("cancelled context", func(t *testing.T) {
		k0Addr := testutils.NewAddress()
		ethKeyStore := keystest.Addresses{k0Addr}
		ethClient := newEthClientMock(t)

		bm := monitor.NewBalanceMonitor(ethClient, ethKeyStore, logger.Test(t))
		ctxCancelledAwaiter := testutils.NewAwaiter()

		ethClient.On("BalanceAt", mock.Anything, k0Addr, nilBigInt).Once().Run(func(args mock.Arguments) {
			ctx := args.Get(0).(context.Context)
			select {
			case <-time.After(tests.WaitTimeout(t)):
			case <-ctx.Done():
				ctxCancelledAwaiter.ItHappened()
			}
		}).Return(nil, nil)

		ctx, cancel := context.WithCancel(tests.Context(t))
		go func() {
			<-time.After(time.Second)
			cancel()
		}()
		assert.NoError(t, bm.Start(ctx))

		ctxCancelledAwaiter.AwaitOrFail(t)
	})`
$DIR/pkg/monitor/balance_test.go: `.NewAddress()`
$DIR/pkg/monitor/balance_test.go: `.NewBalanceMonitor(ethClient, ethKeyStore, logger.Test(t))`
$DIR/pkg/monitor/balance_test.go: `.Test(t)`
$DIR/pkg/monitor/balance_test.go: `.NewAwaiter()`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, k0Addr, nilBigInt)`
$DIR/pkg/monitor/balance_test.go: `.Once()`
$DIR/pkg/monitor/balance_test.go: `.Run(func(args mock.Arguments) {
			ctx := args.Get(0).(context.Context)
			select {
			case <-time.After(tests.WaitTimeout(t)):
			case <-ctx.Done():
				ctxCancelledAwaiter.ItHappened()
			}
		})`
$DIR/pkg/monitor/balance_test.go: `.Get(0)`
$DIR/pkg/monitor/balance_test.go: `.After(tests.WaitTimeout(t))`
$DIR/pkg/monitor/balance_test.go: `.WaitTimeout(t)`
$DIR/pkg/monitor/balance_test.go: `.Done()`
$DIR/pkg/monitor/balance_test.go: `.ItHappened()`
$DIR/pkg/monitor/balance_test.go: `.Return(nil, nil)`
$DIR/pkg/monitor/balance_test.go: `.WithCancel(tests.Context(t))`
$DIR/pkg/monitor/balance_test.go: `.Context(t)`
$DIR/pkg/monitor/balance_test.go: `.After(time.Second)`
$DIR/pkg/monitor/balance_test.go: `.AwaitOrFail(t)`
$DIR/pkg/monitor/balance_test.go: `.NewAddress()`
$DIR/pkg/monitor/balance_test.go: `.NewBalanceMonitor(ethClient, ethKeyStore, logger.Test(t))`
$DIR/pkg/monitor/balance_test.go: `.Test(t)`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, k0Addr, nilBigInt)`
$DIR/pkg/monitor/balance_test.go: `.
			Once()`
$DIR/pkg/monitor/balance_test.go: `.
			Return(nil, pkgerrors.New("a little easter egg for the 4chan link marines error"))`
$DIR/pkg/monitor/balance_test.go: `.New("a little easter egg for the 4chan link marines error")`
$DIR/pkg/monitor/balance_test.go: `.RunHealthy(t, bm)`
$DIR/pkg/monitor/balance_test.go: `.NewWithT(t)`
$DIR/pkg/monitor/balance_test.go: `.Consistently(func() *big.Int {
			return bm.GetEthBalance(k0Addr).ToInt()
		})`
$DIR/pkg/monitor/balance_test.go: `.GetEthBalance(k0Addr)`
$DIR/pkg/monitor/balance_test.go: `.ToInt()`
$DIR/pkg/monitor/balance_test.go: `.Should(gomega.BeNil())`
$DIR/pkg/monitor/balance_test.go: `.BeNil()`
$DIR/pkg/monitor/balance_test.go: `.NewAddress()`
$DIR/pkg/monitor/balance_test.go: `.NewAddress()`
$DIR/pkg/monitor/balance_test.go: `.NewBalanceMonitor(ethClient, ethKeyStore, logger.Test(t))`
$DIR/pkg/monitor/balance_test.go: `.Test(t)`
$DIR/pkg/monitor/balance_test.go: `.NewInt(42)`
$DIR/pkg/monitor/balance_test.go: `.NewInt(0)`
$DIR/pkg/monitor/balance_test.go: `.SetString("19223372036854776000", 10)`
$DIR/pkg/monitor/balance_test.go: `.Head(0)`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, k0Addr, nilBigInt)`
$DIR/pkg/monitor/balance_test.go: `.Once()`
$DIR/pkg/monitor/balance_test.go: `.Return(k0bal, nil)`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, k1Addr, nilBigInt)`
$DIR/pkg/monitor/balance_test.go: `.Once()`
$DIR/pkg/monitor/balance_test.go: `.Return(k1bal, nil)`
$DIR/pkg/monitor/balance_test.go: `.RunHealthy(t, bm)`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, k0Addr, nilBigInt)`
$DIR/pkg/monitor/balance_test.go: `.Once()`
$DIR/pkg/monitor/balance_test.go: `.Return(k0bal, nil)`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, k1Addr, nilBigInt)`
$DIR/pkg/monitor/balance_test.go: `.Once()`
$DIR/pkg/monitor/balance_test.go: `.Return(k1bal, nil)`
$DIR/pkg/monitor/balance_test.go: `.OnNewLongestChain(tests.Context(t), head)`
$DIR/pkg/monitor/balance_test.go: `.Context(t)`
$DIR/pkg/monitor/balance_test.go: `.WorkDone()`
$DIR/pkg/monitor/balance_test.go: `.NewInt(142)`
$DIR/pkg/monitor/balance_test.go: `.NewInt(142)`
$DIR/pkg/monitor/balance_test.go: `.Head(1)`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, k0Addr, nilBigInt)`
$DIR/pkg/monitor/balance_test.go: `.Once()`
$DIR/pkg/monitor/balance_test.go: `.Return(k0bal2, nil)`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, k1Addr, nilBigInt)`
$DIR/pkg/monitor/balance_test.go: `.Once()`
$DIR/pkg/monitor/balance_test.go: `.Return(k1bal2, nil)`
$DIR/pkg/monitor/balance_test.go: `.OnNewLongestChain(tests.Context(t), head)`
$DIR/pkg/monitor/balance_test.go: `.Context(t)`
$DIR/pkg/monitor/balance_test.go: `.WorkDone()`
$DIR/pkg/monitor/balance_test.go: `.NewAddress()`
$DIR/pkg/monitor/balance_test.go: `.NewBalanceMonitor(ethClient, ethKeyStore, logger.Test(t))`
$DIR/pkg/monitor/balance_test.go: `.Test(t)`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/monitor/balance_test.go: `.
		Once()`
$DIR/pkg/monitor/balance_test.go: `.
		Return(big.NewInt(1), nil)`
$DIR/pkg/monitor/balance_test.go: `.NewInt(1)`
$DIR/pkg/monitor/balance_test.go: `.RunHealthy(t, bm)`
$DIR/pkg/monitor/balance_test.go: `.Head(0)`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/monitor/balance_test.go: `.
		WaitUntil(mockUnblocker)`
$DIR/pkg/monitor/balance_test.go: `.
		Once()`
$DIR/pkg/monitor/balance_test.go: `.
		Return(big.NewInt(42), nil)`
$DIR/pkg/monitor/balance_test.go: `.NewInt(42)`
$DIR/pkg/monitor/balance_test.go: `.On("BalanceAt", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/monitor/balance_test.go: `.
		Run(func(mock.Arguments) { callCount.Add(1) })`
$DIR/pkg/monitor/balance_test.go: `.Add(1)`
$DIR/pkg/monitor/balance_test.go: `.
		Maybe()`
$DIR/pkg/monitor/balance_test.go: `.
		Return(big.NewInt(42), nil)`
$DIR/pkg/monitor/balance_test.go: `.NewInt(42)`
$DIR/pkg/monitor/balance_test.go: `.OnNewLongestChain(tests.Context(t), head)`
$DIR/pkg/monitor/balance_test.go: `.Context(t)`
$DIR/pkg/monitor/balance_test.go: `.Load()`
$DIR/pkg/monitor/balance_test.go: `.Run(test.name, func(t *testing.T) {
			eth := assets.NewEth(0)
			eth.SetString(test.input, 10)
			float, err := monitor.ApproximateFloat64(eth)
			require.NoError(t, err)
			require.Equal(t, test.want, float)
		})`
$DIR/pkg/monitor/balance_test.go: `.NewEth(0)`
$DIR/pkg/monitor/balance_test.go: `.SetString(test.input, 10)`
$DIR/pkg/monitor/balance_test.go: `.ApproximateFloat64(eth)`
$DIR/pkg/report/datafeeds/decode_test.go: `t.Run(tt.name, func(t *testing.T) {
			feedID, err := datafeeds.NewFeedIDFromHex(tt.feedID)
			require.NoError(t, err)

			decimals, isNumber := datafeeds.GetDecimals(feedID.GetDataType())

			result := datafeeds.ToBenchmarkVal(feedID, tt.val)
			if math.IsNaN(tt.expected) {
				require.False(t, isNumber)
				require.True(t, math.IsNaN(result))
			} else {
				require.True(t, isNumber)
				require.Equal(t, tt.expected, result)
				require.Equal(t, tt.expectedDecimals, decimals)
			}
		})`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewInt(1234567890123456789)`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewInt(300069)`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewDataFeedsProcessor(nil, nil)`
$DIR/pkg/report/datafeeds/decode_test.go: `.GetDataFeedsSchema()`
$DIR/pkg/report/datafeeds/decode_test.go: `.Pack(reports)`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewPORProcessor(nil, nil)`
$DIR/pkg/report/datafeeds/decode_test.go: `.GetPORSchema()`
$DIR/pkg/report/datafeeds/decode_test.go: `.Pack(reports)`
$DIR/pkg/report/datafeeds/decode_test.go: `.SetString(s, 10)`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewInt(1000000000000000000)`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewInt(1000000000000000000)`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewInt(1000000012340000000)`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewInt(1000000000000000000)`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewInt(1000000000000000087)`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewInt(1000000000000000000)`
$DIR/pkg/report/datafeeds/decode_test.go: `.NaN()`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewInt(1000000000000000000)`
$DIR/pkg/report/datafeeds/decode_test.go: `.NaN()`
$DIR/pkg/report/datafeeds/decode_test.go: `.Exp(big.NewInt(10), big.NewInt(400), nil)`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewInt(10)`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewInt(400)`
$DIR/pkg/report/datafeeds/decode_test.go: `.Inf(1)`
$DIR/pkg/report/datafeeds/decode_test.go: `.Run(tt.name, func(t *testing.T) {
			feedID, err := datafeeds.NewFeedIDFromHex(tt.feedID)
			require.NoError(t, err)

			decimals, isNumber := datafeeds.GetDecimals(feedID.GetDataType())

			result := datafeeds.ToBenchmarkVal(feedID, tt.val)
			if math.IsNaN(tt.expected) {
				require.False(t, isNumber)
				require.True(t, math.IsNaN(result))
			} else {
				require.True(t, isNumber)
				require.Equal(t, tt.expected, result)
				require.Equal(t, tt.expectedDecimals, decimals)
			}
		})`
$DIR/pkg/report/datafeeds/decode_test.go: `.NewFeedIDFromHex(tt.feedID)`
$DIR/pkg/report/datafeeds/decode_test.go: `.GetDecimals(feedID.GetDataType())`
$DIR/pkg/report/datafeeds/decode_test.go: `.GetDataType()`
$DIR/pkg/report/datafeeds/decode_test.go: `.ToBenchmarkVal(feedID, tt.val)`
$DIR/pkg/report/datafeeds/decode_test.go: `.IsNaN(tt.expected)`
$DIR/pkg/report/datafeeds/id_test.go: `t.Run(tt.name, func(t *testing.T) {
			decimals, isNumber := GetDecimals(tt.dataType)
			require.Equal(t, tt.expected, decimals)
			require.Equal(t, tt.isNumber, isNumber)
		})`
$DIR/pkg/report/datafeeds/id_test.go: `t.Run(tt.name, func(t *testing.T) {
			feedID, err := NewFeedIDFromHex(tt.feedID)
			require.NoError(t, err)

			dataType := feedID.GetDataType()
			require.Equal(t, tt.expected, dataType)

			decimals, isNumber := GetDecimals(dataType)
			require.Equal(t, tt.isNumber, isNumber)

			if isNumber {
				require.Equal(t, tt.expected-0x20, decimals)
			} else {
				require.Equal(t, uint8(0), decimals)
			}
		})`
$DIR/pkg/report/datafeeds/id_test.go: `.Run(tt.name, func(t *testing.T) {
			decimals, isNumber := GetDecimals(tt.dataType)
			require.Equal(t, tt.expected, decimals)
			require.Equal(t, tt.isNumber, isNumber)
		})`
$DIR/pkg/report/datafeeds/id_test.go: `.Run(tt.name, func(t *testing.T) {
			feedID, err := NewFeedIDFromHex(tt.feedID)
			require.NoError(t, err)

			dataType := feedID.GetDataType()
			require.Equal(t, tt.expected, dataType)

			decimals, isNumber := GetDecimals(dataType)
			require.Equal(t, tt.isNumber, isNumber)

			if isNumber {
				require.Equal(t, tt.expected-0x20, decimals)
			} else {
				require.Equal(t, uint8(0), decimals)
			}
		})`
$DIR/pkg/report/datafeeds/id_test.go: `.GetDataType()`
$DIR/pkg/report/mercury/common/types_test.go: `.DecodeString(encoded)`
$DIR/pkg/report/mercury/v3/types_test.go: `.DecodeString(encoded)`
$DIR/pkg/testutils/config_test.go: `c.FinalityDepth = &finalityDepth`
$DIR/pkg/testutils/config_test.go: `.EVM()`
$DIR/pkg/testutils/config_test.go: `.GasEstimator()`
$DIR/pkg/testutils/config_test.go: `.EIP1559DynamicFees()`
$DIR/pkg/txm/attempt_builder_test.go: `t.Run("fails if GasPrice is nil", func(t *testing.T) {
		tx := &types.Transaction{ID: 10, FromAddress: address}
		_, err := ab.newCustomAttempt(t.Context(), tx, gas.EvmFee{DynamicFee: gas.DynamicFee{GasTipCap: assets.NewWeiI(1), GasFeeCap: assets.NewWeiI(2)}}, gasLimit, evmtypes.LegacyTxType, lggr)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "estimator did not return legacy fee")
	})`
$DIR/pkg/txm/attempt_builder_test.go: `t.Run("fails if tx doesn't have a nonce", func(t *testing.T) {
		tx := &types.Transaction{ID: 10, FromAddress: address}
		_, err := ab.newCustomAttempt(t.Context(), tx, gas.EvmFee{GasPrice: assets.NewWeiI(25)}, gasLimit, evmtypes.LegacyTxType, lggr)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "nonce empty")
	})`
$DIR/pkg/txm/attempt_builder_test.go: `t.Run("fails if DynamicFee is invalid", func(t *testing.T) {
		tx := &types.Transaction{ID: 10, FromAddress: address}
		_, err := ab.newCustomAttempt(t.Context(), tx, gas.EvmFee{GasPrice: assets.NewWeiI(1)}, gasLimit, evmtypes.DynamicFeeTxType, lggr)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "estimator did not return dynamic fee")
	})`
$DIR/pkg/txm/attempt_builder_test.go: `t.Run("fails if tx doesn't have a nonce", func(t *testing.T) {
		tx := &types.Transaction{ID: 10, FromAddress: address}
		_, err := ab.newCustomAttempt(t.Context(), tx, gas.EvmFee{DynamicFee: gas.DynamicFee{GasTipCap: assets.NewWeiI(1), GasFeeCap: assets.NewWeiI(2)}}, gasLimit, evmtypes.DynamicFeeTxType, lggr)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "nonce empty")
	})`
$DIR/pkg/txm/attempt_builder_test.go: `.TxSigner(nil)`
$DIR/pkg/txm/attempt_builder_test.go: `.NewAddress()`
$DIR/pkg/txm/attempt_builder_test.go: `.Test(t)`
$DIR/pkg/txm/attempt_builder_test.go: `.Run("fails if GasPrice is nil", func(t *testing.T) {
		tx := &types.Transaction{ID: 10, FromAddress: address}
		_, err := ab.newCustomAttempt(t.Context(), tx, gas.EvmFee{DynamicFee: gas.DynamicFee{GasTipCap: assets.NewWeiI(1), GasFeeCap: assets.NewWeiI(2)}}, gasLimit, evmtypes.LegacyTxType, lggr)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "estimator did not return legacy fee")
	})`
$DIR/pkg/txm/attempt_builder_test.go: `.newCustomAttempt(t.Context(), tx, gas.EvmFee{DynamicFee: gas.DynamicFee{GasTipCap: assets.NewWeiI(1), GasFeeCap: assets.NewWeiI(2)}}, gasLimit, evmtypes.LegacyTxType, lggr)`
$DIR/pkg/txm/attempt_builder_test.go: `.Context()`
$DIR/pkg/txm/attempt_builder_test.go: `.NewWeiI(1)`
$DIR/pkg/txm/attempt_builder_test.go: `.NewWeiI(2)`
$DIR/pkg/txm/attempt_builder_test.go: `.Run("fails if tx doesn't have a nonce", func(t *testing.T) {
		tx := &types.Transaction{ID: 10, FromAddress: address}
		_, err := ab.newCustomAttempt(t.Context(), tx, gas.EvmFee{GasPrice: assets.NewWeiI(25)}, gasLimit, evmtypes.LegacyTxType, lggr)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "nonce empty")
	})`
$DIR/pkg/txm/attempt_builder_test.go: `.newCustomAttempt(t.Context(), tx, gas.EvmFee{GasPrice: assets.NewWeiI(25)}, gasLimit, evmtypes.LegacyTxType, lggr)`
$DIR/pkg/txm/attempt_builder_test.go: `.Context()`
$DIR/pkg/txm/attempt_builder_test.go: `.NewWeiI(25)`
$DIR/pkg/txm/attempt_builder_test.go: `.newCustomAttempt(t.Context(), tx, gas.EvmFee{GasPrice: assets.NewWeiI(25)}, gasLimit, evmtypes.LegacyTxType, lggr)`
$DIR/pkg/txm/attempt_builder_test.go: `.Context()`
$DIR/pkg/txm/attempt_builder_test.go: `.NewWeiI(25)`
$DIR/pkg/txm/attempt_builder_test.go: `.TxSigner(nil)`
$DIR/pkg/txm/attempt_builder_test.go: `.NewAddress()`
$DIR/pkg/txm/attempt_builder_test.go: `.Test(t)`
$DIR/pkg/txm/attempt_builder_test.go: `.Run("fails if DynamicFee is invalid", func(t *testing.T) {
		tx := &types.Transaction{ID: 10, FromAddress: address}
		_, err := ab.newCustomAttempt(t.Context(), tx, gas.EvmFee{GasPrice: assets.NewWeiI(1)}, gasLimit, evmtypes.DynamicFeeTxType, lggr)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "estimator did not return dynamic fee")
	})`
$DIR/pkg/txm/attempt_builder_test.go: `.newCustomAttempt(t.Context(), tx, gas.EvmFee{GasPrice: assets.NewWeiI(1)}, gasLimit, evmtypes.DynamicFeeTxType, lggr)`
$DIR/pkg/txm/attempt_builder_test.go: `.Context()`
$DIR/pkg/txm/attempt_builder_test.go: `.NewWeiI(1)`
$DIR/pkg/txm/attempt_builder_test.go: `.Run("fails if tx doesn't have a nonce", func(t *testing.T) {
		tx := &types.Transaction{ID: 10, FromAddress: address}
		_, err := ab.newCustomAttempt(t.Context(), tx, gas.EvmFee{DynamicFee: gas.DynamicFee{GasTipCap: assets.NewWeiI(1), GasFeeCap: assets.NewWeiI(2)}}, gasLimit, evmtypes.DynamicFeeTxType, lggr)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "nonce empty")
	})`
$DIR/pkg/txm/attempt_builder_test.go: `.newCustomAttempt(t.Context(), tx, gas.EvmFee{DynamicFee: gas.DynamicFee{GasTipCap: assets.NewWeiI(1), GasFeeCap: assets.NewWeiI(2)}}, gasLimit, evmtypes.DynamicFeeTxType, lggr)`
$DIR/pkg/txm/attempt_builder_test.go: `.Context()`
$DIR/pkg/txm/attempt_builder_test.go: `.NewWeiI(1)`
$DIR/pkg/txm/attempt_builder_test.go: `.NewWeiI(2)`
$DIR/pkg/txm/attempt_builder_test.go: `.newCustomAttempt(t.Context(), tx, gas.EvmFee{DynamicFee: gas.DynamicFee{GasTipCap: assets.NewWeiI(1), GasFeeCap: assets.NewWeiI(2)}}, gasLimit, evmtypes.DynamicFeeTxType, lggr)`
$DIR/pkg/txm/attempt_builder_test.go: `.Context()`
$DIR/pkg/txm/attempt_builder_test.go: `.NewWeiI(1)`
$DIR/pkg/txm/attempt_builder_test.go: `.NewWeiI(2)`
$DIR/pkg/txm/metrics_test.go: `t.Run("overrides 0x0 as ToAddress if tx is purgeable", func(t *testing.T) {
		// GIVEN
		ctx := t.Context()
		beholderTester := beholderTests.Beholder(t)

		toAddress := testutils.NewAddress()
		fromAddress := testutils.NewAddress()

		expectedFromAddress := fromAddress
		expectedToAddress := common.Address{}
		expectedHash := common.Hash{}
		expectedChain := testutils.FixtureChainID
		expectedNonce := uint64(256)
		var actualMessage svrv1.TxMessage

		txmMetrics, err := NewTxmMetrics(expectedChain)
		require.NoError(t, err)

		tx := &types.Transaction{
			IsPurgeable: true,
			FromAddress: fromAddress,
			ToAddress:   toAddress,
			Nonce:       &expectedNonce,
		}

		// WHEN
		err = txmMetrics.EmitTxMessage(
			ctx,
			expectedHash,
			fromAddress,
			tx,
		)
		require.NoError(t, err)

		// THEN
		messages := beholderTester.Messages(t)

		assert.Len(t, messages, 1)
		actualMessageBody := messages[0]
		err = proto.Unmarshal(actualMessageBody.Body, &actualMessage)
		require.NoError(t, err)

		assert.Equal(t, expectedFromAddress.String(), actualMessage.FromAddress)
		assert.Equal(t, expectedToAddress.String(), actualMessage.ToAddress)
		assert.Equal(t, strconv.FormatUint(expectedNonce, 10), actualMessage.Nonce)
		assert.Equal(t, expectedChain.String(), actualMessage.ChainId)
		assert.Equal(t, "", actualMessage.FeedAddress)
	})`
$DIR/pkg/txm/metrics_test.go: `err = txmMetrics.EmitTxMessage(
			ctx,
			expectedHash,
			fromAddress,
			tx,
		)`
$DIR/pkg/txm/metrics_test.go: `err = proto.Unmarshal(actualMessageBody.Body, &actualMessage)`
$DIR/pkg/txm/metrics_test.go: `err = txmMetrics.EmitTxMessage(
			ctx,
			expectedHash,
			fromAddress,
			tx,
		)`
$DIR/pkg/txm/metrics_test.go: `err = proto.Unmarshal(actualMessageBody.Body, &actualMessage)`
$DIR/pkg/txm/metrics_test.go: `.Run("overrides 0x0 as ToAddress if tx is purgeable", func(t *testing.T) {
		// GIVEN
		ctx := t.Context()
		beholderTester := beholderTests.Beholder(t)

		toAddress := testutils.NewAddress()
		fromAddress := testutils.NewAddress()

		expectedFromAddress := fromAddress
		expectedToAddress := common.Address{}
		expectedHash := common.Hash{}
		expectedChain := testutils.FixtureChainID
		expectedNonce := uint64(256)
		var actualMessage svrv1.TxMessage

		txmMetrics, err := NewTxmMetrics(expectedChain)
		require.NoError(t, err)

		tx := &types.Transaction{
			IsPurgeable: true,
			FromAddress: fromAddress,
			ToAddress:   toAddress,
			Nonce:       &expectedNonce,
		}

		// WHEN
		err = txmMetrics.EmitTxMessage(
			ctx,
			expectedHash,
			fromAddress,
			tx,
		)
		require.NoError(t, err)

		// THEN
		messages := beholderTester.Messages(t)

		assert.Len(t, messages, 1)
		actualMessageBody := messages[0]
		err = proto.Unmarshal(actualMessageBody.Body, &actualMessage)
		require.NoError(t, err)

		assert.Equal(t, expectedFromAddress.String(), actualMessage.FromAddress)
		assert.Equal(t, expectedToAddress.String(), actualMessage.ToAddress)
		assert.Equal(t, strconv.FormatUint(expectedNonce, 10), actualMessage.Nonce)
		assert.Equal(t, expectedChain.String(), actualMessage.ChainId)
		assert.Equal(t, "", actualMessage.FeedAddress)
	})`
$DIR/pkg/txm/metrics_test.go: `.Context()`
$DIR/pkg/txm/metrics_test.go: `.Beholder(t)`
$DIR/pkg/txm/metrics_test.go: `.NewAddress()`
$DIR/pkg/txm/metrics_test.go: `.NewAddress()`
$DIR/pkg/txm/metrics_test.go: `.EmitTxMessage(
			ctx,
			expectedHash,
			fromAddress,
			tx,
		)`
$DIR/pkg/txm/metrics_test.go: `.Messages(t)`
$DIR/pkg/txm/metrics_test.go: `.Unmarshal(actualMessageBody.Body, &actualMessage)`
$DIR/pkg/txm/metrics_test.go: `.Context()`
$DIR/pkg/txm/metrics_test.go: `.Beholder(t)`
$DIR/pkg/txm/metrics_test.go: `.NewAddress()`
$DIR/pkg/txm/metrics_test.go: `.NewAddress()`
$DIR/pkg/txm/metrics_test.go: `.EmitTxMessage(
			ctx,
			expectedHash,
			fromAddress,
			tx,
		)`
$DIR/pkg/txm/metrics_test.go: `.Messages(t)`
$DIR/pkg/txm/metrics_test.go: `.Unmarshal(actualMessageBody.Body, &actualMessage)`
$DIR/pkg/txm/storage/inmemory_store_manager_test.go: `err = m.Add(fromAddress)`
$DIR/pkg/txm/storage/inmemory_store_manager_test.go: `err = m.Add(addresses...)`
$DIR/pkg/txm/storage/inmemory_store_manager_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_manager_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_manager_test.go: `.Add(fromAddress)`
$DIR/pkg/txm/storage/inmemory_store_manager_test.go: `.Add(fromAddress)`
$DIR/pkg/txm/storage/inmemory_store_manager_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_manager_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_manager_test.go: `.Add(addresses...)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("abandons unstarted and unconfirmed transactions", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		// Unstarted
		tx1 := insertUnstartedTransaction(m)
		tx2 := insertUnstartedTransaction(m)

		// Unconfirmed
		tx3, err := insertUnconfirmedTransaction(m, 3)
		require.NoError(t, err)
		tx4, err := insertUnconfirmedTransaction(m, 4)
		require.NoError(t, err)

		m.AbandonPendingTransactions()

		assert.Equal(t, txmgr.TxFatalError, tx1.State)
		assert.Equal(t, txmgr.TxFatalError, tx2.State)
		assert.Equal(t, txmgr.TxFatalError, tx3.State)
		assert.Equal(t, txmgr.TxFatalError, tx4.State)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `m.AbandonPendingTransactions()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `m.AbandonPendingTransactions()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `_, err = insertConfirmedTransaction(m, 2)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("fails if corresponding unconfirmed transaction for attempt was not found", func(t *testing.T) {
		var nonce uint64 = 1
		newAttempt := &types.Attempt{}
		err := m.AppendAttemptToTransaction(nonce, newAttempt)
		require.Error(t, err)
		require.ErrorContains(t, err, "unconfirmed tx was not found")
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("fails if unconfirmed transaction was found but doesn't match the txID", func(t *testing.T) {
		var nonce uint64 = 10
		newAttempt := &types.Attempt{
			TxID: 2,
		}
		err := m.AppendAttemptToTransaction(nonce, newAttempt)
		require.Error(t, err)
		require.ErrorContains(t, err, "attempt points to a different txID")
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `insertUnstartedTransaction(m)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `_, err = insertConfirmedTransaction(m, 0)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("fails if unconfirmed transaction with the same nonce exists", func(t *testing.T) {
		_, err := m.CreateEmptyUnconfirmedTransaction(1, 0)
		require.Error(t, err)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("fails if confirmed transaction with the same nonce exists", func(t *testing.T) {
		_, err := m.CreateEmptyUnconfirmedTransaction(0, 0)
		require.Error(t, err)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("creates new transactions", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		now := time.Now()
		txR1 := &types.TxRequest{}
		txR2 := &types.TxRequest{}
		tx1 := m.CreateTransaction(txR1)
		assert.Equal(t, uint64(0), tx1.ID)
		assert.LessOrEqual(t, now, tx1.CreatedAt)

		tx2 := m.CreateTransaction(txR2)
		assert.Equal(t, uint64(1), tx2.ID)
		assert.LessOrEqual(t, now, tx2.CreatedAt)

		assert.Equal(t, 2, m.CountUnstartedTransactions())
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `tx, count = m.FetchUnconfirmedTransactionAtNonceWithCount(0)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("returns 0 if there are no transactions", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		un, cn, err := m.MarkConfirmedAndReorgedTransactions(100)
		require.NoError(t, err)
		assert.Empty(t, un)
		assert.Empty(t, cn)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("confirms transaction with nonce lower than the latest", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		ctx1, err := insertUnconfirmedTransaction(m, 0)
		require.NoError(t, err)

		ctx2, err := insertUnconfirmedTransaction(m, 1)
		require.NoError(t, err)

		ctxs, utxs, err := m.MarkConfirmedAndReorgedTransactions(1)
		require.NoError(t, err)
		assert.Equal(t, txmgr.TxConfirmed, ctx1.State)
		assert.Equal(t, txmgr.TxUnconfirmed, ctx2.State)
		assert.Equal(t, ctxs[0].ID, ctx1.ID) // Ensure order
		assert.Empty(t, utxs)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("state remains the same if nonce didn't change", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		ctx1, err := insertConfirmedTransaction(m, 0)
		require.NoError(t, err)

		ctx2, err := insertUnconfirmedTransaction(m, 1)
		require.NoError(t, err)

		ctxs, utxs, err := m.MarkConfirmedAndReorgedTransactions(1)
		require.NoError(t, err)
		assert.Equal(t, txmgr.TxConfirmed, ctx1.State)
		assert.Equal(t, txmgr.TxUnconfirmed, ctx2.State)
		assert.Empty(t, ctxs)
		assert.Empty(t, utxs)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("unconfirms transaction with nonce equal to or higher than the latest", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		ctx1, err := insertConfirmedTransaction(m, 0)
		require.NoError(t, err)

		ctx2, err := insertConfirmedTransaction(m, 1)
		require.NoError(t, err)

		ctxs, utxs, err := m.MarkConfirmedAndReorgedTransactions(1)
		require.NoError(t, err)
		assert.Equal(t, txmgr.TxConfirmed, ctx1.State)
		assert.Equal(t, txmgr.TxUnconfirmed, ctx2.State)
		assert.Equal(t, utxs[0], ctx2.ID)
		assert.Empty(t, ctxs)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("logs an error during confirmation if a transaction with the same nonce already exists", func(t *testing.T) {
		lggr, observedLogs := logger.TestObserved(t, zap.DebugLevel)
		m := NewInMemoryStore(lggr, fromAddress, testutils.FixtureChainID)
		_, err := insertConfirmedTransaction(m, 0)
		require.NoError(t, err)
		_, err = insertUnconfirmedTransaction(m, 0)
		require.NoError(t, err)

		_, _, err = m.MarkConfirmedAndReorgedTransactions(1)
		require.NoError(t, err)
		tests.AssertLogEventually(t, observedLogs, "Another confirmed transaction with the same nonce exists")
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `_, err = insertUnconfirmedTransaction(m, 0)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `_, _, err = m.MarkConfirmedAndReorgedTransactions(1)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `tests.AssertLogEventually(t, observedLogs, "Another confirmed transaction with the same nonce exists")`
$DIR/pkg/txm/storage/inmemory_store_test.go: `err = m.MarkUnconfirmedTransactionPurgeable(0)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("fails if unconfirmed transaction was not found", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		var nonce uint64
		require.Error(t, m.UpdateTransactionBroadcast(0, nonce, hash))
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("fails if attempt was not found for a given transaction", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		var nonce uint64
		tx, err := insertUnconfirmedTransaction(m, nonce)
		require.NoError(t, err)
		require.Error(t, m.UpdateTransactionBroadcast(0, nonce, hash))

		// Attempt with different hash
		attempt := &types.Attempt{TxID: tx.ID, Hash: testutils.NewHash()}
		tx.Attempts = append(tx.Attempts, attempt)
		require.Error(t, m.UpdateTransactionBroadcast(0, nonce, hash))
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `tx.Attempts = append(tx.Attempts, attempt)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `tx.Attempts = append(tx.Attempts, attempt)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("returns nil if there are no unstarted transactions", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		tx, err := m.UpdateUnstartedTransactionWithNonce(0)
		require.NoError(t, err)
		assert.Nil(t, tx)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("fails if there is already another unconfirmed transaction with the same nonce", func(t *testing.T) {
		var nonce uint64
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		insertUnstartedTransaction(m)
		_, err := insertUnconfirmedTransaction(m, nonce)
		require.NoError(t, err)

		_, err = m.UpdateUnstartedTransactionWithNonce(nonce)
		require.Error(t, err)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `insertUnstartedTransaction(m)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `_, err = m.UpdateUnstartedTransactionWithNonce(nonce)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `insertUnstartedTransaction(m)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("fails if corresponding unconfirmed transaction for attempt was not found", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		var nonce uint64
		tx := &types.Transaction{Nonce: &nonce}
		attempt := &types.Attempt{TxID: 0}
		err := m.DeleteAttemptForUnconfirmedTx(*tx.Nonce, attempt)
		require.Error(t, err)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `t.Run("fails if corresponding unconfirmed attempt for txID was not found", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		_, err := insertUnconfirmedTransaction(m, 0)
		require.NoError(t, err)

		attempt := &types.Attempt{TxID: 2, Hash: testutils.NewHash()}
		err = m.DeleteAttemptForUnconfirmedTx(0, attempt)

		require.Error(t, err)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `err = m.DeleteAttemptForUnconfirmedTx(0, attempt)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `tx.Attempts = append(tx.Attempts, attempt)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `err = m.DeleteAttemptForUnconfirmedTx(nonce, attempt)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `tx.IdempotencyKey = &ik`
$DIR/pkg/txm/storage/inmemory_store_test.go: `itx = m.FindTxWithIdempotencyKey(uik)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("abandons unstarted and unconfirmed transactions", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		// Unstarted
		tx1 := insertUnstartedTransaction(m)
		tx2 := insertUnstartedTransaction(m)

		// Unconfirmed
		tx3, err := insertUnconfirmedTransaction(m, 3)
		require.NoError(t, err)
		tx4, err := insertUnconfirmedTransaction(m, 4)
		require.NoError(t, err)

		m.AbandonPendingTransactions()

		assert.Equal(t, txmgr.TxFatalError, tx1.State)
		assert.Equal(t, txmgr.TxFatalError, tx2.State)
		assert.Equal(t, txmgr.TxFatalError, tx3.State)
		assert.Equal(t, txmgr.TxFatalError, tx4.State)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.AbandonPendingTransactions()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.AbandonPendingTransactions()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("fails if corresponding unconfirmed transaction for attempt was not found", func(t *testing.T) {
		var nonce uint64 = 1
		newAttempt := &types.Attempt{}
		err := m.AppendAttemptToTransaction(nonce, newAttempt)
		require.Error(t, err)
		require.ErrorContains(t, err, "unconfirmed tx was not found")
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.AppendAttemptToTransaction(nonce, newAttempt)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("fails if unconfirmed transaction was found but doesn't match the txID", func(t *testing.T) {
		var nonce uint64 = 10
		newAttempt := &types.Attempt{
			TxID: 2,
		}
		err := m.AppendAttemptToTransaction(nonce, newAttempt)
		require.Error(t, err)
		require.ErrorContains(t, err, "attempt points to a different txID")
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.AppendAttemptToTransaction(nonce, newAttempt)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.FetchUnconfirmedTransactionAtNonceWithCount(10)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.CountUnstartedTransactions()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("fails if unconfirmed transaction with the same nonce exists", func(t *testing.T) {
		_, err := m.CreateEmptyUnconfirmedTransaction(1, 0)
		require.Error(t, err)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.CreateEmptyUnconfirmedTransaction(1, 0)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("fails if confirmed transaction with the same nonce exists", func(t *testing.T) {
		_, err := m.CreateEmptyUnconfirmedTransaction(0, 0)
		require.Error(t, err)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.CreateEmptyUnconfirmedTransaction(0, 0)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.CreateEmptyUnconfirmedTransaction(2, 0)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("creates new transactions", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		now := time.Now()
		txR1 := &types.TxRequest{}
		txR2 := &types.TxRequest{}
		tx1 := m.CreateTransaction(txR1)
		assert.Equal(t, uint64(0), tx1.ID)
		assert.LessOrEqual(t, now, tx1.CreatedAt)

		tx2 := m.CreateTransaction(txR2)
		assert.Equal(t, uint64(1), tx2.ID)
		assert.LessOrEqual(t, now, tx2.CreatedAt)

		assert.Equal(t, 2, m.CountUnstartedTransactions())
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Now()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.CreateTransaction(txR1)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.CreateTransaction(txR2)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.CreateTransaction(r)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.UpdateUnstartedTransactionWithNonce(0)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.FetchUnconfirmedTransactionAtNonceWithCount(0)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.FetchUnconfirmedTransactionAtNonceWithCount(0)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("returns 0 if there are no transactions", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		un, cn, err := m.MarkConfirmedAndReorgedTransactions(100)
		require.NoError(t, err)
		assert.Empty(t, un)
		assert.Empty(t, cn)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.MarkConfirmedAndReorgedTransactions(100)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("confirms transaction with nonce lower than the latest", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		ctx1, err := insertUnconfirmedTransaction(m, 0)
		require.NoError(t, err)

		ctx2, err := insertUnconfirmedTransaction(m, 1)
		require.NoError(t, err)

		ctxs, utxs, err := m.MarkConfirmedAndReorgedTransactions(1)
		require.NoError(t, err)
		assert.Equal(t, txmgr.TxConfirmed, ctx1.State)
		assert.Equal(t, txmgr.TxUnconfirmed, ctx2.State)
		assert.Equal(t, ctxs[0].ID, ctx1.ID) // Ensure order
		assert.Empty(t, utxs)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.MarkConfirmedAndReorgedTransactions(1)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("state remains the same if nonce didn't change", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		ctx1, err := insertConfirmedTransaction(m, 0)
		require.NoError(t, err)

		ctx2, err := insertUnconfirmedTransaction(m, 1)
		require.NoError(t, err)

		ctxs, utxs, err := m.MarkConfirmedAndReorgedTransactions(1)
		require.NoError(t, err)
		assert.Equal(t, txmgr.TxConfirmed, ctx1.State)
		assert.Equal(t, txmgr.TxUnconfirmed, ctx2.State)
		assert.Empty(t, ctxs)
		assert.Empty(t, utxs)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.MarkConfirmedAndReorgedTransactions(1)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("unconfirms transaction with nonce equal to or higher than the latest", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		ctx1, err := insertConfirmedTransaction(m, 0)
		require.NoError(t, err)

		ctx2, err := insertConfirmedTransaction(m, 1)
		require.NoError(t, err)

		ctxs, utxs, err := m.MarkConfirmedAndReorgedTransactions(1)
		require.NoError(t, err)
		assert.Equal(t, txmgr.TxConfirmed, ctx1.State)
		assert.Equal(t, txmgr.TxUnconfirmed, ctx2.State)
		assert.Equal(t, utxs[0], ctx2.ID)
		assert.Empty(t, ctxs)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.MarkConfirmedAndReorgedTransactions(1)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("logs an error during confirmation if a transaction with the same nonce already exists", func(t *testing.T) {
		lggr, observedLogs := logger.TestObserved(t, zap.DebugLevel)
		m := NewInMemoryStore(lggr, fromAddress, testutils.FixtureChainID)
		_, err := insertConfirmedTransaction(m, 0)
		require.NoError(t, err)
		_, err = insertUnconfirmedTransaction(m, 0)
		require.NoError(t, err)

		_, _, err = m.MarkConfirmedAndReorgedTransactions(1)
		require.NoError(t, err)
		tests.AssertLogEventually(t, observedLogs, "Another confirmed transaction with the same nonce exists")
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.TestObserved(t, zap.DebugLevel)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.MarkConfirmedAndReorgedTransactions(1)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.AssertLogEventually(t, observedLogs, "Another confirmed transaction with the same nonce exists")`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.MarkConfirmedAndReorgedTransactions(uint64(maxQueuedTransactions + overshot))`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.MarkUnconfirmedTransactionPurgeable(0)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.MarkUnconfirmedTransactionPurgeable(0)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewHash()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("fails if unconfirmed transaction was not found", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		var nonce uint64
		require.Error(t, m.UpdateTransactionBroadcast(0, nonce, hash))
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("fails if attempt was not found for a given transaction", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		var nonce uint64
		tx, err := insertUnconfirmedTransaction(m, nonce)
		require.NoError(t, err)
		require.Error(t, m.UpdateTransactionBroadcast(0, nonce, hash))

		// Attempt with different hash
		attempt := &types.Attempt{TxID: tx.ID, Hash: testutils.NewHash()}
		tx.Attempts = append(tx.Attempts, attempt)
		require.Error(t, m.UpdateTransactionBroadcast(0, nonce, hash))
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewHash()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("returns nil if there are no unstarted transactions", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		tx, err := m.UpdateUnstartedTransactionWithNonce(0)
		require.NoError(t, err)
		assert.Nil(t, tx)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.UpdateUnstartedTransactionWithNonce(0)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("fails if there is already another unconfirmed transaction with the same nonce", func(t *testing.T) {
		var nonce uint64
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		insertUnstartedTransaction(m)
		_, err := insertUnconfirmedTransaction(m, nonce)
		require.NoError(t, err)

		_, err = m.UpdateUnstartedTransactionWithNonce(nonce)
		require.Error(t, err)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.UpdateUnstartedTransactionWithNonce(nonce)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.UpdateUnstartedTransactionWithNonce(nonce)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("fails if corresponding unconfirmed transaction for attempt was not found", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		var nonce uint64
		tx := &types.Transaction{Nonce: &nonce}
		attempt := &types.Attempt{TxID: 0}
		err := m.DeleteAttemptForUnconfirmedTx(*tx.Nonce, attempt)
		require.Error(t, err)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.DeleteAttemptForUnconfirmedTx(*tx.Nonce, attempt)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Run("fails if corresponding unconfirmed attempt for txID was not found", func(t *testing.T) {
		m := NewInMemoryStore(logger.Test(t), fromAddress, testutils.FixtureChainID)
		_, err := insertUnconfirmedTransaction(m, 0)
		require.NoError(t, err)

		attempt := &types.Attempt{TxID: 2, Hash: testutils.NewHash()}
		err = m.DeleteAttemptForUnconfirmedTx(0, attempt)

		require.Error(t, err)
	})`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewHash()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.DeleteAttemptForUnconfirmedTx(0, attempt)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewHash()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.DeleteAttemptForUnconfirmedTx(nonce, attempt)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.FindTxWithIdempotencyKey(ik)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.FindTxWithIdempotencyKey(uik)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.NewAddress()`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.Test(t)`
$DIR/pkg/txm/storage/inmemory_store_test.go: `.pruneConfirmedTransactions()`
$DIR/pkg/txm/stuck_tx_detector_test.go: `t.Run("returns false if transaction is not stuck", func(t *testing.T) {
		config := StuckTxDetectorConfig{
			BlockTime:             10 * time.Second,
			StuckTxBlockThreshold: 5,
		}
		fromAddress := testutils.NewAddress()
		s := NewStuckTxDetector(logger.Test(t), "", config)

		// No previous broadcast
		tx := &types.Transaction{
			ID:              1,
			LastBroadcastAt: nil,
			FromAddress:     fromAddress,
		}
		assert.False(t, s.timeBasedDetection(tx))
		// Not enough time has passed since last broadcast
		now := time.Now()
		tx.LastBroadcastAt = &now
		assert.False(t, s.timeBasedDetection(tx))
		// Not enough time has passed since last purge
		tx.LastBroadcastAt = &time.Time{}
		s.lastPurgeMap[fromAddress] = now
		assert.False(t, s.timeBasedDetection(tx))
	})`
$DIR/pkg/txm/stuck_tx_detector_test.go: `tx.LastBroadcastAt = &now`
$DIR/pkg/txm/stuck_tx_detector_test.go: `tx.LastBroadcastAt = &time.Time{}`
$DIR/pkg/txm/stuck_tx_detector_test.go: `s.lastPurgeMap[fromAddress] = now`
$DIR/pkg/txm/stuck_tx_detector_test.go: `t.Run("returns true if transaction is stuck", func(t *testing.T) {
		config := StuckTxDetectorConfig{
			BlockTime:             10 * time.Second,
			StuckTxBlockThreshold: 5,
		}
		fromAddress := testutils.NewAddress()
		s := NewStuckTxDetector(logger.Test(t), "", config)

		tx := &types.Transaction{
			ID:              1,
			LastBroadcastAt: &time.Time{},
			FromAddress:     fromAddress,
		}
		assert.True(t, s.timeBasedDetection(tx))
	})`
$DIR/pkg/txm/stuck_tx_detector_test.go: `.Run("returns false if transaction is not stuck", func(t *testing.T) {
		config := StuckTxDetectorConfig{
			BlockTime:             10 * time.Second,
			StuckTxBlockThreshold: 5,
		}
		fromAddress := testutils.NewAddress()
		s := NewStuckTxDetector(logger.Test(t), "", config)

		// No previous broadcast
		tx := &types.Transaction{
			ID:              1,
			LastBroadcastAt: nil,
			FromAddress:     fromAddress,
		}
		assert.False(t, s.timeBasedDetection(tx))
		// Not enough time has passed since last broadcast
		now := time.Now()
		tx.LastBroadcastAt = &now
		assert.False(t, s.timeBasedDetection(tx))
		// Not enough time has passed since last purge
		tx.LastBroadcastAt = &time.Time{}
		s.lastPurgeMap[fromAddress] = now
		assert.False(t, s.timeBasedDetection(tx))
	})`
$DIR/pkg/txm/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txm/stuck_tx_detector_test.go: `.Test(t)`
$DIR/pkg/txm/stuck_tx_detector_test.go: `.Now()`
$DIR/pkg/txm/stuck_tx_detector_test.go: `.Run("returns true if transaction is stuck", func(t *testing.T) {
		config := StuckTxDetectorConfig{
			BlockTime:             10 * time.Second,
			StuckTxBlockThreshold: 5,
		}
		fromAddress := testutils.NewAddress()
		s := NewStuckTxDetector(logger.Test(t), "", config)

		tx := &types.Transaction{
			ID:              1,
			LastBroadcastAt: &time.Time{},
			FromAddress:     fromAddress,
		}
		assert.True(t, s.timeBasedDetection(tx))
	})`
$DIR/pkg/txm/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txm/stuck_tx_detector_test.go: `.Test(t)`
$DIR/pkg/txm/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txm/stuck_tx_detector_test.go: `.Test(t)`
$DIR/pkg/txm/txm_test.go: `t.Run("retries if initial pending nonce call fails", func(t *testing.T) {
		lggr, observedLogs := logger.TestObserved(t, zap.DebugLevel)
		config := Config{BlockTime: 1 * time.Minute}
		txStore := storage.NewInMemoryStoreManager(lggr, testutils.FixtureChainID)
		require.NoError(t, txStore.Add(address1))
		keystore := keystest.Addresses{address1}
		txm := NewTxm(lggr, testutils.FixtureChainID, client, nil, txStore, nil, config, keystore)
		client.On("PendingNonceAt", mock.Anything, address1).Return(uint64(0), errors.New("error")).Once()
		client.On("PendingNonceAt", mock.Anything, address1).Return(uint64(100), nil).Once()
		servicetest.Run(t, txm)
		tests.AssertLogEventually(t, observedLogs, "Error when fetching initial nonce")
		tests.AssertLogEventually(t, observedLogs, fmt.Sprintf("Set initial nonce for address: %v to %d", address1, 100))
	})`
$DIR/pkg/txm/txm_test.go: `client.On("PendingNonceAt", mock.Anything, address1).Return(uint64(0), errors.New("error")).Once()`
$DIR/pkg/txm/txm_test.go: `client.On("PendingNonceAt", mock.Anything, address1).Return(uint64(100), nil).Once()`
$DIR/pkg/txm/txm_test.go: `servicetest.Run(t, txm)`
$DIR/pkg/txm/txm_test.go: `tests.AssertLogEventually(t, observedLogs, "Error when fetching initial nonce")`
$DIR/pkg/txm/txm_test.go: `tests.AssertLogEventually(t, observedLogs, fmt.Sprintf("Set initial nonce for address: %v to %d", address1, 100))`
$DIR/pkg/txm/txm_test.go: `client.On("PendingNonceAt", mock.Anything, address1).Return(nonce, nil).Once()`
$DIR/pkg/txm/txm_test.go: `client.On("PendingNonceAt", mock.Anything, address2).Return(nonce, nil).Once()`
$DIR/pkg/txm/txm_test.go: `client.On("NonceAt", mock.Anything, address1, mock.Anything).Return(nonce, nil).Maybe()`
$DIR/pkg/txm/txm_test.go: `client.On("NonceAt", mock.Anything, address2, mock.Anything).Return(nonce, nil).Maybe()`
$DIR/pkg/txm/txm_test.go: `servicetest.Run(t, txm)`
$DIR/pkg/txm/txm_test.go: `tests.AssertLogEventually(t, observedLogs, "Backfill time elapsed")`
$DIR/pkg/txm/txm_test.go: `t.Run("Trigger fails if Txm is unstarted", func(t *testing.T) {
		lggr, observedLogs := logger.TestObserved(t, zap.ErrorLevel)
		txm := NewTxm(lggr, nil, nil, nil, nil, nil, Config{}, keystest.Addresses{})
		txm.Trigger(address)
		tests.AssertLogEventually(t, observedLogs, "Txm unstarted")
	})`
$DIR/pkg/txm/txm_test.go: `txm.Trigger(address)`
$DIR/pkg/txm/txm_test.go: `tests.AssertLogEventually(t, observedLogs, "Txm unstarted")`
$DIR/pkg/txm/txm_test.go: `client.On("PendingNonceAt", mock.Anything, address).Return(nonce, nil).Maybe()`
$DIR/pkg/txm/txm_test.go: `servicetest.Run(t, txm)`
$DIR/pkg/txm/txm_test.go: `txm.Trigger(address)`
$DIR/pkg/txm/txm_test.go: `t.Run("fails if FetchUnconfirmedTransactionAtNonceWithCount for unconfirmed transactions fails", func(t *testing.T) {
		mTxStore := newMockTxStore(t)
		mTxStore.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything).Return(nil, 0, errors.New("call failed")).Once()
		txm := NewTxm(logger.Test(t), testutils.FixtureChainID, client, ab, mTxStore, nil, config, keystore)
		bo, err := txm.broadcastTransaction(ctx, address)
		require.Error(t, err)
		assert.False(t, bo)
		require.ErrorContains(t, err, "call failed")
	})`
$DIR/pkg/txm/txm_test.go: `mTxStore.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything).Return(nil, 0, errors.New("call failed")).Once()`
$DIR/pkg/txm/txm_test.go: `t.Run("throws a warning and returns if unconfirmed transactions exceed maxInFlightTransactions", func(t *testing.T) {
		lggr, observedLogs := logger.TestObserved(t, zap.DebugLevel)
		mTxStore := newMockTxStore(t)
		mTxStore.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything).Return(nil, maxInFlightTransactions+1, nil).Once()
		txm := NewTxm(lggr, testutils.FixtureChainID, client, ab, mTxStore, nil, config, keystore)
		bo, err := txm.broadcastTransaction(ctx, address)
		assert.True(t, bo)
		require.NoError(t, err)
		tests.AssertLogEventually(t, observedLogs, "Reached transaction limit")
	})`
$DIR/pkg/txm/txm_test.go: `mTxStore.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything).Return(nil, maxInFlightTransactions+1, nil).Once()`
$DIR/pkg/txm/txm_test.go: `tests.AssertLogEventually(t, observedLogs, "Reached transaction limit")`
$DIR/pkg/txm/txm_test.go: `t.Run("checks pending nonce if unconfirmed transactions are equal or more than maxInFlightSubset", func(t *testing.T) {
		lggr, observedLogs := logger.TestObserved(t, zap.DebugLevel)
		mTxStore := newMockTxStore(t)
		txm := NewTxm(lggr, testutils.FixtureChainID, client, ab, mTxStore, nil, config, keystore)
		txm.setNonce(address, 1)
		mTxStore.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything).Return(nil, maxInFlightSubset, nil).Twice()

		client.On("PendingNonceAt", mock.Anything, address).Return(uint64(0), nil).Once() // LocalNonce: 1, PendingNonce: 0
		bo, err := txm.broadcastTransaction(ctx, address)
		assert.True(t, bo)
		require.NoError(t, err)

		client.On("PendingNonceAt", mock.Anything, address).Return(uint64(1), nil).Once() // LocalNonce: 1, PendingNonce: 1
		mTxStore.On("UpdateUnstartedTransactionWithNonce", mock.Anything, mock.Anything, mock.Anything).Return(nil, nil).Once()
		bo, err = txm.broadcastTransaction(ctx, address)
		assert.False(t, bo)
		require.NoError(t, err)
		tests.AssertLogCountEventually(t, observedLogs, "Reached transaction limit.", 1)
	})`
$DIR/pkg/txm/txm_test.go: `txm.setNonce(address, 1)`
$DIR/pkg/txm/txm_test.go: `mTxStore.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything).Return(nil, maxInFlightSubset, nil).Twice()`
$DIR/pkg/txm/txm_test.go: `client.On("PendingNonceAt", mock.Anything, address).Return(uint64(0), nil).Once()`
$DIR/pkg/txm/txm_test.go: `client.On("PendingNonceAt", mock.Anything, address).Return(uint64(1), nil).Once()`
$DIR/pkg/txm/txm_test.go: `mTxStore.On("UpdateUnstartedTransactionWithNonce", mock.Anything, mock.Anything, mock.Anything).Return(nil, nil).Once()`
$DIR/pkg/txm/txm_test.go: `bo, err = txm.broadcastTransaction(ctx, address)`
$DIR/pkg/txm/txm_test.go: `tests.AssertLogCountEventually(t, observedLogs, "Reached transaction limit.", 1)`
$DIR/pkg/txm/txm_test.go: `t.Run("fails if UpdateUnstartedTransactionWithNonce fails", func(t *testing.T) {
		mTxStore := newMockTxStore(t)
		mTxStore.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything).Return(nil, 0, nil).Once()
		txm := NewTxm(logger.Test(t), testutils.FixtureChainID, client, ab, mTxStore, nil, config, keystore)
		mTxStore.On("UpdateUnstartedTransactionWithNonce", mock.Anything, mock.Anything, mock.Anything).Return(nil, errors.New("call failed")).Once()
		bo, err := txm.broadcastTransaction(ctx, address)
		assert.False(t, bo)
		require.Error(t, err)
		require.ErrorContains(t, err, "call failed")
	})`
$DIR/pkg/txm/txm_test.go: `mTxStore.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything).Return(nil, 0, nil).Once()`
$DIR/pkg/txm/txm_test.go: `mTxStore.On("UpdateUnstartedTransactionWithNonce", mock.Anything, mock.Anything, mock.Anything).Return(nil, errors.New("call failed")).Once()`
$DIR/pkg/txm/txm_test.go: `t.Run("returns if there are no unstarted transactions", func(t *testing.T) {
		lggr := logger.Test(t)
		txStore := storage.NewInMemoryStoreManager(lggr, testutils.FixtureChainID)
		require.NoError(t, txStore.Add(address))
		txm := NewTxm(lggr, testutils.FixtureChainID, client, ab, txStore, nil, config, keystore)
		bo, err := txm.broadcastTransaction(ctx, address)
		require.NoError(t, err)
		assert.False(t, bo)
		assert.Equal(t, uint64(0), txm.getNonce(address))
	})`
$DIR/pkg/txm/txm_test.go: `txm.setNonce(address, 8)`
$DIR/pkg/txm/txm_test.go: `txm.metrics = metrics`
$DIR/pkg/txm/txm_test.go: `ab.On("NewAttempt", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(attempt, nil).Once()`
$DIR/pkg/txm/txm_test.go: `client.On("SendTransaction", mock.Anything, mock.Anything, mock.Anything).Return(nil).Once()`
$DIR/pkg/txm/txm_test.go: `tx, err = txStore.FindTxWithIdempotencyKey(t.Context(), IDK)`
$DIR/pkg/txm/txm_test.go: `t.Run("fails if latest nonce fetching fails", func(t *testing.T) {
		txm := NewTxm(logger.Test(t), testutils.FixtureChainID, client, ab, txStore, nil, config, keystore)
		client.On("NonceAt", mock.Anything, address, mock.Anything).Return(uint64(0), errors.New("latest nonce fail")).Once()
		bo, err := txm.backfillTransactions(t.Context(), address)
		require.Error(t, err)
		assert.False(t, bo)
		require.ErrorContains(t, err, "latest nonce fail")
	})`
$DIR/pkg/txm/txm_test.go: `client.On("NonceAt", mock.Anything, address, mock.Anything).Return(uint64(0), errors.New("latest nonce fail")).Once()`
$DIR/pkg/txm/txm_test.go: `t.Run("fails if MarkConfirmedAndReorgedTransactions fails", func(t *testing.T) {
		txm := NewTxm(logger.Test(t), testutils.FixtureChainID, client, ab, txStore, nil, config, keystore)
		client.On("NonceAt", mock.Anything, address, mock.Anything).Return(uint64(0), nil).Once()
		txStore.On("MarkConfirmedAndReorgedTransactions", mock.Anything, mock.Anything, address).
			Return([]*types.Transaction{}, []uint64{}, errors.New("marking transactions confirmed failed")).Once()
		bo, err := txm.backfillTransactions(t.Context(), address)
		require.Error(t, err)
		assert.False(t, bo)
		require.ErrorContains(t, err, "marking transactions confirmed failed")
	})`
$DIR/pkg/txm/txm_test.go: `client.On("NonceAt", mock.Anything, address, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txm/txm_test.go: `txStore.On("MarkConfirmedAndReorgedTransactions", mock.Anything, mock.Anything, address).
			Return([]*types.Transaction{}, []uint64{}, errors.New("marking transactions confirmed failed")).Once()`
$DIR/pkg/txm/txm_test.go: `t.Run("fills nonce gap", func(t *testing.T) {
		lggr, observedLogs := logger.TestObserved(t, zap.DebugLevel)
		txStore := storage.NewInMemoryStoreManager(lggr, testutils.FixtureChainID)
		require.NoError(t, txStore.Add(address))
		ab := newMockAttemptBuilder(t)
		c := Config{EIP1559: false, BlockTime: 10 * time.Minute, RetryBlockThreshold: 10, EmptyTxLimitDefault: 22000}
		txm := NewTxm(lggr, testutils.FixtureChainID, client, ab, txStore, nil, c, keystore)
		emptyMetrics, err := NewTxmMetrics(testutils.FixtureChainID)
		require.NoError(t, err)
		txm.metrics = emptyMetrics

		// Add a new transaction that will be assigned with nonce = 1. Nonce = 0 is not being tracked by the txStore. This will trigger a nonce gap.
		txRequest := &types.TxRequest{
			ChainID:     testutils.FixtureChainID,
			FromAddress: address,
			ToAddress:   testutils.NewAddress(),
		}
		_, err = txm.CreateTransaction(t.Context(), txRequest)
		require.NoError(t, err)
		_, err = txStore.UpdateUnstartedTransactionWithNonce(t.Context(), address, 1) // Create nonce gap
		require.NoError(t, err)

		// During backfill we observe nonce has changed. The transaction with nonce = 1 should be marked unconfirmed.
		// For nonce = 0 there are no transactions stored in txStore, which results in a nonce gap.
		// TXM creates a new empty transaction and fills the gap.
		client.On("NonceAt", mock.Anything, address, mock.Anything).Return(uint64(0), nil).Once()
		attempt := &types.Attempt{
			TxID:     1,
			Fee:      gas.EvmFee{GasPrice: assets.NewWeiI(1)},
			GasLimit: 22000,
		}
		ab.On("NewAttempt", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(attempt, nil).Once()
		client.On("SendTransaction", mock.Anything, mock.Anything, mock.Anything).Return(nil).Once()
		bo, err := txm.backfillTransactions(t.Context(), address)
		require.NoError(t, err)
		assert.False(t, bo)
		tests.AssertLogEventually(t, observedLogs, fmt.Sprintf("Nonce gap at nonce: %d - address: %v. Creating a new transaction", 0, address))
		_, count, err := txStore.FetchUnconfirmedTransactionAtNonceWithCount(t.Context(), 0, address)
		require.NoError(t, err)
		assert.Equal(t, 2, count)
	})`
$DIR/pkg/txm/txm_test.go: `txm.metrics = emptyMetrics`
$DIR/pkg/txm/txm_test.go: `_, err = txm.CreateTransaction(t.Context(), txRequest)`
$DIR/pkg/txm/txm_test.go: `_, err = txStore.UpdateUnstartedTransactionWithNonce(t.Context(), address, 1)`
$DIR/pkg/txm/txm_test.go: `client.On("NonceAt", mock.Anything, address, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txm/txm_test.go: `ab.On("NewAttempt", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(attempt, nil).Once()`
$DIR/pkg/txm/txm_test.go: `client.On("SendTransaction", mock.Anything, mock.Anything, mock.Anything).Return(nil).Once()`
$DIR/pkg/txm/txm_test.go: `tests.AssertLogEventually(t, observedLogs, fmt.Sprintf("Nonce gap at nonce: %d - address: %v. Creating a new transaction", 0, address))`
$DIR/pkg/txm/txm_test.go: `txm.metrics = emptyMetrics`
$DIR/pkg/txm/txm_test.go: `_, err = txStore.UpdateUnstartedTransactionWithNonce(t.Context(), address, 0)`
$DIR/pkg/txm/txm_test.go: `ab.On("NewAttempt", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(attempt, nil).Once()`
$DIR/pkg/txm/txm_test.go: `client.On("NonceAt", mock.Anything, address, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txm/txm_test.go: `client.On("SendTransaction", mock.Anything, mock.Anything, mock.Anything).Return(nil).Once()`
$DIR/pkg/txm/txm_test.go: `_, err = txm.backfillTransactions(t.Context(), address)`
$DIR/pkg/txm/txm_test.go: `tests.AssertLogEventually(t, observedLogs, fmt.Sprintf("Rebroadcasting attempt for txID: %d", attempt.TxID))`
$DIR/pkg/txm/txm_test.go: `.NewAddress()`
$DIR/pkg/txm/txm_test.go: `.NewAddress()`
$DIR/pkg/txm/txm_test.go: `.Run("retries if initial pending nonce call fails", func(t *testing.T) {
		lggr, observedLogs := logger.TestObserved(t, zap.DebugLevel)
		config := Config{BlockTime: 1 * time.Minute}
		txStore := storage.NewInMemoryStoreManager(lggr, testutils.FixtureChainID)
		require.NoError(t, txStore.Add(address1))
		keystore := keystest.Addresses{address1}
		txm := NewTxm(lggr, testutils.FixtureChainID, client, nil, txStore, nil, config, keystore)
		client.On("PendingNonceAt", mock.Anything, address1).Return(uint64(0), errors.New("error")).Once()
		client.On("PendingNonceAt", mock.Anything, address1).Return(uint64(100), nil).Once()
		servicetest.Run(t, txm)
		tests.AssertLogEventually(t, observedLogs, "Error when fetching initial nonce")
		tests.AssertLogEventually(t, observedLogs, fmt.Sprintf("Set initial nonce for address: %v to %d", address1, 100))
	})`
$DIR/pkg/txm/txm_test.go: `.TestObserved(t, zap.DebugLevel)`
$DIR/pkg/txm/txm_test.go: `.NewInMemoryStoreManager(lggr, testutils.FixtureChainID)`
$DIR/pkg/txm/txm_test.go: `.On("PendingNonceAt", mock.Anything, address1)`
$DIR/pkg/txm/txm_test.go: `.Return(uint64(0), errors.New("error"))`
$DIR/pkg/txm/txm_test.go: `.New("error")`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.On("PendingNonceAt", mock.Anything, address1)`
$DIR/pkg/txm/txm_test.go: `.Return(uint64(100), nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.Run(t, txm)`
$DIR/pkg/txm/txm_test.go: `.AssertLogEventually(t, observedLogs, "Error when fetching initial nonce")`
$DIR/pkg/txm/txm_test.go: `.AssertLogEventually(t, observedLogs, fmt.Sprintf("Set initial nonce for address: %v to %d", address1, 100))`
$DIR/pkg/txm/txm_test.go: `.Sprintf("Set initial nonce for address: %v to %d", address1, 100)`
$DIR/pkg/txm/txm_test.go: `.Addresses(addresses)`
$DIR/pkg/txm/txm_test.go: `.TestObserved(t, zap.DebugLevel)`
$DIR/pkg/txm/txm_test.go: `.NewInMemoryStoreManager(lggr, testutils.FixtureChainID)`
$DIR/pkg/txm/txm_test.go: `.On("PendingNonceAt", mock.Anything, address1)`
$DIR/pkg/txm/txm_test.go: `.Return(nonce, nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.On("PendingNonceAt", mock.Anything, address2)`
$DIR/pkg/txm/txm_test.go: `.Return(nonce, nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.On("NonceAt", mock.Anything, address1, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(nonce, nil)`
$DIR/pkg/txm/txm_test.go: `.Maybe()`
$DIR/pkg/txm/txm_test.go: `.On("NonceAt", mock.Anything, address2, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(nonce, nil)`
$DIR/pkg/txm/txm_test.go: `.Maybe()`
$DIR/pkg/txm/txm_test.go: `.Run(t, txm)`
$DIR/pkg/txm/txm_test.go: `.AssertLogEventually(t, observedLogs, "Backfill time elapsed")`
$DIR/pkg/txm/txm_test.go: `.NewAddress()`
$DIR/pkg/txm/txm_test.go: `.Run("Trigger fails if Txm is unstarted", func(t *testing.T) {
		lggr, observedLogs := logger.TestObserved(t, zap.ErrorLevel)
		txm := NewTxm(lggr, nil, nil, nil, nil, nil, Config{}, keystest.Addresses{})
		txm.Trigger(address)
		tests.AssertLogEventually(t, observedLogs, "Txm unstarted")
	})`
$DIR/pkg/txm/txm_test.go: `.TestObserved(t, zap.ErrorLevel)`
$DIR/pkg/txm/txm_test.go: `.Trigger(address)`
$DIR/pkg/txm/txm_test.go: `.AssertLogEventually(t, observedLogs, "Txm unstarted")`
$DIR/pkg/txm/txm_test.go: `.Test(t)`
$DIR/pkg/txm/txm_test.go: `.NewInMemoryStoreManager(lggr, testutils.FixtureChainID)`
$DIR/pkg/txm/txm_test.go: `.On("PendingNonceAt", mock.Anything, address)`
$DIR/pkg/txm/txm_test.go: `.Return(nonce, nil)`
$DIR/pkg/txm/txm_test.go: `.Maybe()`
$DIR/pkg/txm/txm_test.go: `.Run(t, txm)`
$DIR/pkg/txm/txm_test.go: `.Trigger(address)`
$DIR/pkg/txm/txm_test.go: `.Context()`
$DIR/pkg/txm/txm_test.go: `.NewAddress()`
$DIR/pkg/txm/txm_test.go: `.Run("fails if FetchUnconfirmedTransactionAtNonceWithCount for unconfirmed transactions fails", func(t *testing.T) {
		mTxStore := newMockTxStore(t)
		mTxStore.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything).Return(nil, 0, errors.New("call failed")).Once()
		txm := NewTxm(logger.Test(t), testutils.FixtureChainID, client, ab, mTxStore, nil, config, keystore)
		bo, err := txm.broadcastTransaction(ctx, address)
		require.Error(t, err)
		assert.False(t, bo)
		require.ErrorContains(t, err, "call failed")
	})`
$DIR/pkg/txm/txm_test.go: `.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(nil, 0, errors.New("call failed"))`
$DIR/pkg/txm/txm_test.go: `.New("call failed")`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.Test(t)`
$DIR/pkg/txm/txm_test.go: `.broadcastTransaction(ctx, address)`
$DIR/pkg/txm/txm_test.go: `.Run("throws a warning and returns if unconfirmed transactions exceed maxInFlightTransactions", func(t *testing.T) {
		lggr, observedLogs := logger.TestObserved(t, zap.DebugLevel)
		mTxStore := newMockTxStore(t)
		mTxStore.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything).Return(nil, maxInFlightTransactions+1, nil).Once()
		txm := NewTxm(lggr, testutils.FixtureChainID, client, ab, mTxStore, nil, config, keystore)
		bo, err := txm.broadcastTransaction(ctx, address)
		assert.True(t, bo)
		require.NoError(t, err)
		tests.AssertLogEventually(t, observedLogs, "Reached transaction limit")
	})`
$DIR/pkg/txm/txm_test.go: `.TestObserved(t, zap.DebugLevel)`
$DIR/pkg/txm/txm_test.go: `.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(nil, maxInFlightTransactions+1, nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.broadcastTransaction(ctx, address)`
$DIR/pkg/txm/txm_test.go: `.AssertLogEventually(t, observedLogs, "Reached transaction limit")`
$DIR/pkg/txm/txm_test.go: `.Run("checks pending nonce if unconfirmed transactions are equal or more than maxInFlightSubset", func(t *testing.T) {
		lggr, observedLogs := logger.TestObserved(t, zap.DebugLevel)
		mTxStore := newMockTxStore(t)
		txm := NewTxm(lggr, testutils.FixtureChainID, client, ab, mTxStore, nil, config, keystore)
		txm.setNonce(address, 1)
		mTxStore.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything).Return(nil, maxInFlightSubset, nil).Twice()

		client.On("PendingNonceAt", mock.Anything, address).Return(uint64(0), nil).Once() // LocalNonce: 1, PendingNonce: 0
		bo, err := txm.broadcastTransaction(ctx, address)
		assert.True(t, bo)
		require.NoError(t, err)

		client.On("PendingNonceAt", mock.Anything, address).Return(uint64(1), nil).Once() // LocalNonce: 1, PendingNonce: 1
		mTxStore.On("UpdateUnstartedTransactionWithNonce", mock.Anything, mock.Anything, mock.Anything).Return(nil, nil).Once()
		bo, err = txm.broadcastTransaction(ctx, address)
		assert.False(t, bo)
		require.NoError(t, err)
		tests.AssertLogCountEventually(t, observedLogs, "Reached transaction limit.", 1)
	})`
$DIR/pkg/txm/txm_test.go: `.TestObserved(t, zap.DebugLevel)`
$DIR/pkg/txm/txm_test.go: `.setNonce(address, 1)`
$DIR/pkg/txm/txm_test.go: `.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(nil, maxInFlightSubset, nil)`
$DIR/pkg/txm/txm_test.go: `.Twice()`
$DIR/pkg/txm/txm_test.go: `.On("PendingNonceAt", mock.Anything, address)`
$DIR/pkg/txm/txm_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.broadcastTransaction(ctx, address)`
$DIR/pkg/txm/txm_test.go: `.On("PendingNonceAt", mock.Anything, address)`
$DIR/pkg/txm/txm_test.go: `.Return(uint64(1), nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.On("UpdateUnstartedTransactionWithNonce", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(nil, nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.broadcastTransaction(ctx, address)`
$DIR/pkg/txm/txm_test.go: `.AssertLogCountEventually(t, observedLogs, "Reached transaction limit.", 1)`
$DIR/pkg/txm/txm_test.go: `.Run("fails if UpdateUnstartedTransactionWithNonce fails", func(t *testing.T) {
		mTxStore := newMockTxStore(t)
		mTxStore.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything).Return(nil, 0, nil).Once()
		txm := NewTxm(logger.Test(t), testutils.FixtureChainID, client, ab, mTxStore, nil, config, keystore)
		mTxStore.On("UpdateUnstartedTransactionWithNonce", mock.Anything, mock.Anything, mock.Anything).Return(nil, errors.New("call failed")).Once()
		bo, err := txm.broadcastTransaction(ctx, address)
		assert.False(t, bo)
		require.Error(t, err)
		require.ErrorContains(t, err, "call failed")
	})`
$DIR/pkg/txm/txm_test.go: `.On("FetchUnconfirmedTransactionAtNonceWithCount", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(nil, 0, nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.Test(t)`
$DIR/pkg/txm/txm_test.go: `.On("UpdateUnstartedTransactionWithNonce", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(nil, errors.New("call failed"))`
$DIR/pkg/txm/txm_test.go: `.New("call failed")`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.broadcastTransaction(ctx, address)`
$DIR/pkg/txm/txm_test.go: `.Run("returns if there are no unstarted transactions", func(t *testing.T) {
		lggr := logger.Test(t)
		txStore := storage.NewInMemoryStoreManager(lggr, testutils.FixtureChainID)
		require.NoError(t, txStore.Add(address))
		txm := NewTxm(lggr, testutils.FixtureChainID, client, ab, txStore, nil, config, keystore)
		bo, err := txm.broadcastTransaction(ctx, address)
		require.NoError(t, err)
		assert.False(t, bo)
		assert.Equal(t, uint64(0), txm.getNonce(address))
	})`
$DIR/pkg/txm/txm_test.go: `.Test(t)`
$DIR/pkg/txm/txm_test.go: `.NewInMemoryStoreManager(lggr, testutils.FixtureChainID)`
$DIR/pkg/txm/txm_test.go: `.broadcastTransaction(ctx, address)`
$DIR/pkg/txm/txm_test.go: `.Test(t)`
$DIR/pkg/txm/txm_test.go: `.NewInMemoryStoreManager(lggr, testutils.FixtureChainID)`
$DIR/pkg/txm/txm_test.go: `.setNonce(address, 8)`
$DIR/pkg/txm/txm_test.go: `.NewAddress()`
$DIR/pkg/txm/txm_test.go: `.CreateTransaction(t.Context(), txRequest)`
$DIR/pkg/txm/txm_test.go: `.Context()`
$DIR/pkg/txm/txm_test.go: `.NewWeiI(1)`
$DIR/pkg/txm/txm_test.go: `.On("NewAttempt", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(attempt, nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.On("SendTransaction", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.broadcastTransaction(ctx, address)`
$DIR/pkg/txm/txm_test.go: `.FindTxWithIdempotencyKey(t.Context(), IDK)`
$DIR/pkg/txm/txm_test.go: `.Context()`
$DIR/pkg/txm/txm_test.go: `.NewAddress()`
$DIR/pkg/txm/txm_test.go: `.Run("fails if latest nonce fetching fails", func(t *testing.T) {
		txm := NewTxm(logger.Test(t), testutils.FixtureChainID, client, ab, txStore, nil, config, keystore)
		client.On("NonceAt", mock.Anything, address, mock.Anything).Return(uint64(0), errors.New("latest nonce fail")).Once()
		bo, err := txm.backfillTransactions(t.Context(), address)
		require.Error(t, err)
		assert.False(t, bo)
		require.ErrorContains(t, err, "latest nonce fail")
	})`
$DIR/pkg/txm/txm_test.go: `.Test(t)`
$DIR/pkg/txm/txm_test.go: `.On("NonceAt", mock.Anything, address, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(uint64(0), errors.New("latest nonce fail"))`
$DIR/pkg/txm/txm_test.go: `.New("latest nonce fail")`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.backfillTransactions(t.Context(), address)`
$DIR/pkg/txm/txm_test.go: `.Context()`
$DIR/pkg/txm/txm_test.go: `.Run("fails if MarkConfirmedAndReorgedTransactions fails", func(t *testing.T) {
		txm := NewTxm(logger.Test(t), testutils.FixtureChainID, client, ab, txStore, nil, config, keystore)
		client.On("NonceAt", mock.Anything, address, mock.Anything).Return(uint64(0), nil).Once()
		txStore.On("MarkConfirmedAndReorgedTransactions", mock.Anything, mock.Anything, address).
			Return([]*types.Transaction{}, []uint64{}, errors.New("marking transactions confirmed failed")).Once()
		bo, err := txm.backfillTransactions(t.Context(), address)
		require.Error(t, err)
		assert.False(t, bo)
		require.ErrorContains(t, err, "marking transactions confirmed failed")
	})`
$DIR/pkg/txm/txm_test.go: `.Test(t)`
$DIR/pkg/txm/txm_test.go: `.On("NonceAt", mock.Anything, address, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.On("MarkConfirmedAndReorgedTransactions", mock.Anything, mock.Anything, address)`
$DIR/pkg/txm/txm_test.go: `.
			Return([]*types.Transaction{}, []uint64{}, errors.New("marking transactions confirmed failed"))`
$DIR/pkg/txm/txm_test.go: `.New("marking transactions confirmed failed")`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.backfillTransactions(t.Context(), address)`
$DIR/pkg/txm/txm_test.go: `.Context()`
$DIR/pkg/txm/txm_test.go: `.Run("fills nonce gap", func(t *testing.T) {
		lggr, observedLogs := logger.TestObserved(t, zap.DebugLevel)
		txStore := storage.NewInMemoryStoreManager(lggr, testutils.FixtureChainID)
		require.NoError(t, txStore.Add(address))
		ab := newMockAttemptBuilder(t)
		c := Config{EIP1559: false, BlockTime: 10 * time.Minute, RetryBlockThreshold: 10, EmptyTxLimitDefault: 22000}
		txm := NewTxm(lggr, testutils.FixtureChainID, client, ab, txStore, nil, c, keystore)
		emptyMetrics, err := NewTxmMetrics(testutils.FixtureChainID)
		require.NoError(t, err)
		txm.metrics = emptyMetrics

		// Add a new transaction that will be assigned with nonce = 1. Nonce = 0 is not being tracked by the txStore. This will trigger a nonce gap.
		txRequest := &types.TxRequest{
			ChainID:     testutils.FixtureChainID,
			FromAddress: address,
			ToAddress:   testutils.NewAddress(),
		}
		_, err = txm.CreateTransaction(t.Context(), txRequest)
		require.NoError(t, err)
		_, err = txStore.UpdateUnstartedTransactionWithNonce(t.Context(), address, 1) // Create nonce gap
		require.NoError(t, err)

		// During backfill we observe nonce has changed. The transaction with nonce = 1 should be marked unconfirmed.
		// For nonce = 0 there are no transactions stored in txStore, which results in a nonce gap.
		// TXM creates a new empty transaction and fills the gap.
		client.On("NonceAt", mock.Anything, address, mock.Anything).Return(uint64(0), nil).Once()
		attempt := &types.Attempt{
			TxID:     1,
			Fee:      gas.EvmFee{GasPrice: assets.NewWeiI(1)},
			GasLimit: 22000,
		}
		ab.On("NewAttempt", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(attempt, nil).Once()
		client.On("SendTransaction", mock.Anything, mock.Anything, mock.Anything).Return(nil).Once()
		bo, err := txm.backfillTransactions(t.Context(), address)
		require.NoError(t, err)
		assert.False(t, bo)
		tests.AssertLogEventually(t, observedLogs, fmt.Sprintf("Nonce gap at nonce: %d - address: %v. Creating a new transaction", 0, address))
		_, count, err := txStore.FetchUnconfirmedTransactionAtNonceWithCount(t.Context(), 0, address)
		require.NoError(t, err)
		assert.Equal(t, 2, count)
	})`
$DIR/pkg/txm/txm_test.go: `.TestObserved(t, zap.DebugLevel)`
$DIR/pkg/txm/txm_test.go: `.NewInMemoryStoreManager(lggr, testutils.FixtureChainID)`
$DIR/pkg/txm/txm_test.go: `.NewAddress()`
$DIR/pkg/txm/txm_test.go: `.CreateTransaction(t.Context(), txRequest)`
$DIR/pkg/txm/txm_test.go: `.Context()`
$DIR/pkg/txm/txm_test.go: `.UpdateUnstartedTransactionWithNonce(t.Context(), address, 1)`
$DIR/pkg/txm/txm_test.go: `.Context()`
$DIR/pkg/txm/txm_test.go: `.On("NonceAt", mock.Anything, address, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.NewWeiI(1)`
$DIR/pkg/txm/txm_test.go: `.On("NewAttempt", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(attempt, nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.On("SendTransaction", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.backfillTransactions(t.Context(), address)`
$DIR/pkg/txm/txm_test.go: `.Context()`
$DIR/pkg/txm/txm_test.go: `.AssertLogEventually(t, observedLogs, fmt.Sprintf("Nonce gap at nonce: %d - address: %v. Creating a new transaction", 0, address))`
$DIR/pkg/txm/txm_test.go: `.Sprintf("Nonce gap at nonce: %d - address: %v. Creating a new transaction", 0, address)`
$DIR/pkg/txm/txm_test.go: `.FetchUnconfirmedTransactionAtNonceWithCount(t.Context(), 0, address)`
$DIR/pkg/txm/txm_test.go: `.Context()`
$DIR/pkg/txm/txm_test.go: `.TestObserved(t, zap.DebugLevel)`
$DIR/pkg/txm/txm_test.go: `.NewInMemoryStoreManager(lggr, testutils.FixtureChainID)`
$DIR/pkg/txm/txm_test.go: `.NewAddress()`
$DIR/pkg/txm/txm_test.go: `.CreateTransaction(t.Context(), txRequest)`
$DIR/pkg/txm/txm_test.go: `.Context()`
$DIR/pkg/txm/txm_test.go: `.UpdateUnstartedTransactionWithNonce(t.Context(), address, 0)`
$DIR/pkg/txm/txm_test.go: `.Context()`
$DIR/pkg/txm/txm_test.go: `.NewWeiI(1)`
$DIR/pkg/txm/txm_test.go: `.On("NewAttempt", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(attempt, nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.On("NonceAt", mock.Anything, address, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.On("SendTransaction", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txm/txm_test.go: `.Return(nil)`
$DIR/pkg/txm/txm_test.go: `.Once()`
$DIR/pkg/txm/txm_test.go: `.backfillTransactions(t.Context(), address)`
$DIR/pkg/txm/txm_test.go: `.Context()`
$DIR/pkg/txm/txm_test.go: `.AssertLogEventually(t, observedLogs, fmt.Sprintf("Rebroadcasting attempt for txID: %d", attempt.TxID))`
$DIR/pkg/txm/txm_test.go: `.Sprintf("Rebroadcasting attempt for txID: %d", attempt.TxID)`
$DIR/pkg/txm/types/transaction_test.go: `t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			tx := Transaction{
				Meta: tt.meta,
			}

			got, err := tx.GetMeta()
			if tt.wantErr {
				assert.Error(t, err)
				return
			}

			require.NoError(t, err)
			assert.Equal(t, tt.expected, got)
		})`
$DIR/pkg/txm/types/transaction_test.go: `.BoolFrom(true)`
$DIR/pkg/txm/types/transaction_test.go: `.Marshal(meta)`
$DIR/pkg/txm/types/transaction_test.go: `.JSON(b)`
$DIR/pkg/txm/types/transaction_test.go: `.BoolFrom(true)`
$DIR/pkg/txm/types/transaction_test.go: `.JSON([]byte(`{invalid json`))`
$DIR/pkg/txm/types/transaction_test.go: `.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			tx := Transaction{
				Meta: tt.meta,
			}

			got, err := tx.GetMeta()
			if tt.wantErr {
				assert.Error(t, err)
				return
			}

			require.NoError(t, err)
			assert.Equal(t, tt.expected, got)
		})`
$DIR/pkg/txm/types/transaction_test.go: `.GetMeta()`
$DIR/pkg/txmgr/attempts_test.go: `t.Run("returns correct hash for non-okex chains", func(t *testing.T) {
		chainID := big.NewInt(1)
		kst := keystest.TxSigner(nil)
		cks := txmgr.NewEvmTxAttemptBuilder(*chainID, newFeeConfig(), kst, nil)
		hash, rawBytes, err := cks.SignTx(t.Context(), addr, tx)
		require.NoError(t, err)
		require.NotNil(t, rawBytes)
		require.Equal(t, "0xdd68f554373fdea7ec6713a6e437e7646465d553a6aa0b43233093366cc87ef0", hash.String())
	})`
$DIR/pkg/txmgr/attempts_test.go: `t.Run("returns correct hash for okex chains", func(t *testing.T) {
		chainID := big.NewInt(1)
		kst := keystest.TxSigner(nil)
		cks := txmgr.NewEvmTxAttemptBuilder(*chainID, newFeeConfig(), kst, nil)
		hash, rawBytes, err := cks.SignTx(t.Context(), addr, tx)
		require.NoError(t, err)
		require.NotNil(t, rawBytes)
		require.Equal(t, "0xdd68f554373fdea7ec6713a6e437e7646465d553a6aa0b43233093366cc87ef0", hash.String())
	})`
$DIR/pkg/txmgr/attempts_test.go: `t.Run("can properly encoded and decode raw transaction for LegacyTx", func(t *testing.T) {
		chainID := big.NewInt(1)
		kst := keystest.TxSigner(nil)
		cks := txmgr.NewEvmTxAttemptBuilder(*chainID, newFeeConfig(), kst, nil)

		_, rawBytes, err := cks.SignTx(t.Context(), addr, tx)
		require.NoError(t, err)
		require.NotNil(t, rawBytes)
		require.Equal(t, "0xe42a82015681f294b921f7763960b296b9cbad586ff066a18d749724818e83010203808080", hexutil.Encode(rawBytes))

		var decodedTx *gethtypes.Transaction
		decodedTx, err = txmgr.GetGethSignedTx(rawBytes)
		require.NoError(t, err)
		require.Equal(t, tx.Hash(), decodedTx.Hash())
	})`
$DIR/pkg/txmgr/attempts_test.go: `decodedTx, err = txmgr.GetGethSignedTx(rawBytes)`
$DIR/pkg/txmgr/attempts_test.go: `decodedTx, err = txmgr.GetGethSignedTx(rawBytes)`
$DIR/pkg/txmgr/attempts_test.go: `t.Run("creates attempt with fields", func(t *testing.T) {
		feeCfg := newFeeConfig()
		feeCfg.priceMax = assets.GWei(200)
		cks := txmgr.NewEvmTxAttemptBuilder(*big.NewInt(1), feeCfg, kst, nil)
		dynamicFee := gas.DynamicFee{GasTipCap: assets.GWei(100), GasFeeCap: assets.GWei(200)}
		a, _, err := cks.NewCustomTxAttempt(t.Context(), txmgr.Tx{Sequence: &n, FromAddress: addr}, gas.EvmFee{
			DynamicFee: gas.DynamicFee{GasTipCap: dynamicFee.GasTipCap, GasFeeCap: dynamicFee.GasFeeCap},
		}, 100, 0x2, lggr)
		require.NoError(t, err)
		assert.Equal(t, 100, int(a.ChainSpecificFeeLimit))
		assert.Nil(t, a.TxFee.GasPrice)
		assert.NotNil(t, a.TxFee.GasTipCap)
		assert.Equal(t, assets.GWei(100).String(), a.TxFee.GasTipCap.String())
		assert.NotNil(t, a.TxFee.GasFeeCap)
		assert.Equal(t, assets.GWei(200).String(), a.TxFee.GasFeeCap.String())
	})`
$DIR/pkg/txmgr/attempts_test.go: `feeCfg.priceMax = assets.GWei(200)`
$DIR/pkg/txmgr/attempts_test.go: `c.GasEstimator.PriceMax = assets.GWei(4)`
$DIR/pkg/txmgr/attempts_test.go: `c.GasEstimator.PriceMin = assets.GWei(6)`
$DIR/pkg/txmgr/attempts_test.go: `t.Run(test.name, func(t *testing.T) {
				cfg := testutils.NewTestChainScopedConfig(t, test.setCfg)
				cks := txmgr.NewEvmTxAttemptBuilder(*big.NewInt(1), cfg.EVM().GasEstimator(), kst, nil)
				dynamicFee := gas.DynamicFee{GasTipCap: test.tipcap, GasFeeCap: test.feecap}
				_, _, err := cks.NewCustomTxAttempt(t.Context(), txmgr.Tx{Sequence: &n, FromAddress: addr}, gas.EvmFee{
					DynamicFee: gas.DynamicFee{GasTipCap: dynamicFee.GasTipCap, GasFeeCap: dynamicFee.GasFeeCap},
				}, 100, 0x2, lggr)
				if test.expectError == "" {
					require.NoError(t, err)
				} else {
					require.ErrorContains(t, err, test.expectError)
				}
			})`
$DIR/pkg/txmgr/attempts_test.go: `gc.priceMin = assets.NewWeiI(10)`
$DIR/pkg/txmgr/attempts_test.go: `gc.priceMax = assets.NewWeiI(50)`
$DIR/pkg/txmgr/attempts_test.go: `t.Run("creates attempt with fields", func(t *testing.T) {
		var n evmtypes.Nonce
		a, _, err := cks.NewCustomTxAttempt(t.Context(), txmgr.Tx{Sequence: &n, FromAddress: addr}, gas.EvmFee{GasPrice: assets.NewWeiI(25)}, 100, 0x0, lggr)
		require.NoError(t, err)
		assert.Equal(t, 100, int(a.ChainSpecificFeeLimit))
		assert.NotNil(t, a.TxFee.GasPrice)
		assert.Equal(t, "25 wei", a.TxFee.GasPrice.String())
		assert.Nil(t, a.TxFee.GasTipCap)
		assert.Nil(t, a.TxFee.GasFeeCap)
	})`
$DIR/pkg/txmgr/attempts_test.go: `gc.priceMin = assets.GWei(10)`
$DIR/pkg/txmgr/attempts_test.go: `gc.priceMax = assets.GWei(50)`
$DIR/pkg/txmgr/attempts_test.go: `gc.limitDefault = uint64(10)`
$DIR/pkg/txmgr/attempts_test.go: `est.On("BumpFee", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(bumpedFee, uint64(10_000), nil)`
$DIR/pkg/txmgr/attempts_test.go: `t.Run("creates legacy purge attempt with fields if previous attempt is legacy", func(t *testing.T) {
		n := evmtypes.Nonce(0)
		etx := txmgr.Tx{Sequence: &n, FromAddress: addr, EncodedPayload: []byte{1, 2, 3}}
		prevAttempt, _, err := cks.NewCustomTxAttempt(t.Context(), etx, gas.EvmFee{GasPrice: bumpedLegacy.Sub(assets.GWei(1))}, 100, 0x0, lggr)
		require.NoError(t, err)
		etx.TxAttempts = append(etx.TxAttempts, prevAttempt)
		a, err := cks.NewPurgeTxAttempt(t.Context(), etx, lggr)
		require.NoError(t, err)
		// The fee limit is overridden with LimitDefault since purge attempts are just empty attempts
		require.Equal(t, gc.limitDefault, a.ChainSpecificFeeLimit)
		require.NotNil(t, a.TxFee.GasPrice)
		require.Equal(t, bumpedLegacy.String(), a.TxFee.GasPrice.String())
		require.Nil(t, a.TxFee.GasTipCap)
		require.Nil(t, a.TxFee.GasFeeCap)
		require.Equal(t, true, a.IsPurgeAttempt)
		require.Equal(t, []byte{}, a.Tx.EncodedPayload)
		require.Equal(t, *big.NewInt(0), a.Tx.Value)
	})`
$DIR/pkg/txmgr/attempts_test.go: `etx.TxAttempts = append(etx.TxAttempts, prevAttempt)`
$DIR/pkg/txmgr/attempts_test.go: `t.Run("creates dynamic purge attempt with fields if previous attempt is dynamic", func(t *testing.T) {
		n := evmtypes.Nonce(0)
		etx := txmgr.Tx{Sequence: &n, FromAddress: addr, EncodedPayload: []byte{1, 2, 3}}
		prevAttempt, _, err := cks.NewCustomTxAttempt(t.Context(), etx, gas.EvmFee{DynamicFee: gas.DynamicFee{GasTipCap: bumpedDynamicTip.Sub(assets.GWei(1)), GasFeeCap: bumpedDynamicFee.Sub(assets.GWei(1))}}, 100, 0x2, lggr)
		require.NoError(t, err)
		etx.TxAttempts = append(etx.TxAttempts, prevAttempt)
		a, err := cks.NewPurgeTxAttempt(t.Context(), etx, lggr)
		require.NoError(t, err)
		// The fee limit is overridden with LimitDefault since purge attempts are just empty attempts
		require.Equal(t, gc.limitDefault, a.ChainSpecificFeeLimit)
		require.Nil(t, a.TxFee.GasPrice)
		require.NotNil(t, a.TxFee.GasTipCap)
		require.NotNil(t, a.TxFee.GasFeeCap)
		require.Equal(t, bumpedDynamicTip.String(), a.TxFee.GasTipCap.String())
		require.Equal(t, bumpedDynamicFee.String(), a.TxFee.GasFeeCap.String())
		require.Equal(t, true, a.IsPurgeAttempt)
		require.Equal(t, []byte{}, a.Tx.EncodedPayload)
		require.Equal(t, *big.NewInt(0), a.Tx.Value)
	})`
$DIR/pkg/txmgr/attempts_test.go: `etx.TxAttempts = append(etx.TxAttempts, prevAttempt)`
$DIR/pkg/txmgr/attempts_test.go: `etx.TxAttempts = append(etx.TxAttempts, prevAttempt)`
$DIR/pkg/txmgr/attempts_test.go: `etx.TxAttempts = append(etx.TxAttempts, purgeAttempt)`
$DIR/pkg/txmgr/attempts_test.go: `t.Run("dynamic fee with legacy tx type", func(t *testing.T) {
		_, retryable, err := cks.NewCustomTxAttempt(t.Context(), txmgr.Tx{}, gas.EvmFee{
			DynamicFee: dynamicFee,
		}, 100, 0x0, lggr)
		require.Error(t, err)
		assert.False(t, retryable)
	})`
$DIR/pkg/txmgr/attempts_test.go: `t.Run("legacy fee with dynamic tx type", func(t *testing.T) {
		_, retryable, err := cks.NewCustomTxAttempt(t.Context(), txmgr.Tx{}, gas.EvmFee{GasPrice: legacyFee}, 100, 0x2, lggr)
		require.Error(t, err)
		assert.False(t, retryable)
	})`
$DIR/pkg/txmgr/attempts_test.go: `est.On("GetFee", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(gas.EvmFee{}, uint64(0), pkgerrors.New("fail"))`
$DIR/pkg/txmgr/attempts_test.go: `est.On("BumpFee", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(gas.EvmFee{}, uint64(0), pkgerrors.New("fail"))`
$DIR/pkg/txmgr/attempts_test.go: `t.Run("NewAttempt", func(t *testing.T) {
		_, _, _, retryable, err := cks.NewTxAttempt(ctx, txmgr.Tx{}, lggr)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "failed to get fee")
		assert.True(t, retryable)
	})`
$DIR/pkg/txmgr/attempts_test.go: `t.Run("NewAttemptWithType", func(t *testing.T) {
		_, _, _, retryable, err := cks.NewTxAttemptWithType(ctx, txmgr.Tx{}, lggr, 0x0)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "failed to get fee")
		assert.True(t, retryable)
	})`
$DIR/pkg/txmgr/attempts_test.go: `.HexToAddress("0xb921F7763960b296B9cbAD586ff066A18D749724")`
$DIR/pkg/txmgr/attempts_test.go: `.HexToAddress("0xb921F7763960b296B9cbAD586ff066A18D749724")`
$DIR/pkg/txmgr/attempts_test.go: `.NewTx(&gethtypes.LegacyTx{
		Nonce:    42,
		To:       &to,
		Value:    big.NewInt(142),
		Gas:      242,
		GasPrice: big.NewInt(342),
		Data:     []byte{1, 2, 3},
	})`
$DIR/pkg/txmgr/attempts_test.go: `.NewInt(142)`
$DIR/pkg/txmgr/attempts_test.go: `.NewInt(342)`
$DIR/pkg/txmgr/attempts_test.go: `.Run("returns correct hash for non-okex chains", func(t *testing.T) {
		chainID := big.NewInt(1)
		kst := keystest.TxSigner(nil)
		cks := txmgr.NewEvmTxAttemptBuilder(*chainID, newFeeConfig(), kst, nil)
		hash, rawBytes, err := cks.SignTx(t.Context(), addr, tx)
		require.NoError(t, err)
		require.NotNil(t, rawBytes)
		require.Equal(t, "0xdd68f554373fdea7ec6713a6e437e7646465d553a6aa0b43233093366cc87ef0", hash.String())
	})`
$DIR/pkg/txmgr/attempts_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/attempts_test.go: `.TxSigner(nil)`
$DIR/pkg/txmgr/attempts_test.go: `.NewEvmTxAttemptBuilder(*chainID, newFeeConfig(), kst, nil)`
$DIR/pkg/txmgr/attempts_test.go: `.SignTx(t.Context(), addr, tx)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.Run("returns correct hash for okex chains", func(t *testing.T) {
		chainID := big.NewInt(1)
		kst := keystest.TxSigner(nil)
		cks := txmgr.NewEvmTxAttemptBuilder(*chainID, newFeeConfig(), kst, nil)
		hash, rawBytes, err := cks.SignTx(t.Context(), addr, tx)
		require.NoError(t, err)
		require.NotNil(t, rawBytes)
		require.Equal(t, "0xdd68f554373fdea7ec6713a6e437e7646465d553a6aa0b43233093366cc87ef0", hash.String())
	})`
$DIR/pkg/txmgr/attempts_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/attempts_test.go: `.TxSigner(nil)`
$DIR/pkg/txmgr/attempts_test.go: `.NewEvmTxAttemptBuilder(*chainID, newFeeConfig(), kst, nil)`
$DIR/pkg/txmgr/attempts_test.go: `.SignTx(t.Context(), addr, tx)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.Run("can properly encoded and decode raw transaction for LegacyTx", func(t *testing.T) {
		chainID := big.NewInt(1)
		kst := keystest.TxSigner(nil)
		cks := txmgr.NewEvmTxAttemptBuilder(*chainID, newFeeConfig(), kst, nil)

		_, rawBytes, err := cks.SignTx(t.Context(), addr, tx)
		require.NoError(t, err)
		require.NotNil(t, rawBytes)
		require.Equal(t, "0xe42a82015681f294b921f7763960b296b9cbad586ff066a18d749724818e83010203808080", hexutil.Encode(rawBytes))

		var decodedTx *gethtypes.Transaction
		decodedTx, err = txmgr.GetGethSignedTx(rawBytes)
		require.NoError(t, err)
		require.Equal(t, tx.Hash(), decodedTx.Hash())
	})`
$DIR/pkg/txmgr/attempts_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/attempts_test.go: `.TxSigner(nil)`
$DIR/pkg/txmgr/attempts_test.go: `.NewEvmTxAttemptBuilder(*chainID, newFeeConfig(), kst, nil)`
$DIR/pkg/txmgr/attempts_test.go: `.SignTx(t.Context(), addr, tx)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.GetGethSignedTx(rawBytes)`
$DIR/pkg/txmgr/attempts_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/attempts_test.go: `.TxSigner(nil)`
$DIR/pkg/txmgr/attempts_test.go: `.NewTx(&gethtypes.DynamicFeeTx{
			Nonce: 42,
			To:    &to,
			Value: big.NewInt(142),
			Gas:   242,
			Data:  []byte{1, 2, 3},
		})`
$DIR/pkg/txmgr/attempts_test.go: `.NewInt(142)`
$DIR/pkg/txmgr/attempts_test.go: `.NewEvmTxAttemptBuilder(*chainID, newFeeConfig(), kst, nil)`
$DIR/pkg/txmgr/attempts_test.go: `.SignTx(t.Context(), addr, typedTx)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.GetGethSignedTx(rawBytes)`
$DIR/pkg/txmgr/attempts_test.go: `.TxSigner(nil)`
$DIR/pkg/txmgr/attempts_test.go: `.Test(t)`
$DIR/pkg/txmgr/attempts_test.go: `.Run("creates attempt with fields", func(t *testing.T) {
		feeCfg := newFeeConfig()
		feeCfg.priceMax = assets.GWei(200)
		cks := txmgr.NewEvmTxAttemptBuilder(*big.NewInt(1), feeCfg, kst, nil)
		dynamicFee := gas.DynamicFee{GasTipCap: assets.GWei(100), GasFeeCap: assets.GWei(200)}
		a, _, err := cks.NewCustomTxAttempt(t.Context(), txmgr.Tx{Sequence: &n, FromAddress: addr}, gas.EvmFee{
			DynamicFee: gas.DynamicFee{GasTipCap: dynamicFee.GasTipCap, GasFeeCap: dynamicFee.GasFeeCap},
		}, 100, 0x2, lggr)
		require.NoError(t, err)
		assert.Equal(t, 100, int(a.ChainSpecificFeeLimit))
		assert.Nil(t, a.TxFee.GasPrice)
		assert.NotNil(t, a.TxFee.GasTipCap)
		assert.Equal(t, assets.GWei(100).String(), a.TxFee.GasTipCap.String())
		assert.NotNil(t, a.TxFee.GasFeeCap)
		assert.Equal(t, assets.GWei(200).String(), a.TxFee.GasFeeCap.String())
	})`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(200)`
$DIR/pkg/txmgr/attempts_test.go: `.NewEvmTxAttemptBuilder(*big.NewInt(1), feeCfg, kst, nil)`
$DIR/pkg/txmgr/attempts_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(100)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(200)`
$DIR/pkg/txmgr/attempts_test.go: `.NewCustomTxAttempt(t.Context(), txmgr.Tx{Sequence: &n, FromAddress: addr}, gas.EvmFee{
			DynamicFee: gas.DynamicFee{GasTipCap: dynamicFee.GasTipCap, GasFeeCap: dynamicFee.GasFeeCap},
		}, 100, 0x2, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(5)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(5)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(4)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(5)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(6)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(5)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(5)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(5)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(4)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(5)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(5)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(6)`
$DIR/pkg/txmgr/attempts_test.go: `.Run(test.name, func(t *testing.T) {
				cfg := testutils.NewTestChainScopedConfig(t, test.setCfg)
				cks := txmgr.NewEvmTxAttemptBuilder(*big.NewInt(1), cfg.EVM().GasEstimator(), kst, nil)
				dynamicFee := gas.DynamicFee{GasTipCap: test.tipcap, GasFeeCap: test.feecap}
				_, _, err := cks.NewCustomTxAttempt(t.Context(), txmgr.Tx{Sequence: &n, FromAddress: addr}, gas.EvmFee{
					DynamicFee: gas.DynamicFee{GasTipCap: dynamicFee.GasTipCap, GasFeeCap: dynamicFee.GasFeeCap},
				}, 100, 0x2, lggr)
				if test.expectError == "" {
					require.NoError(t, err)
				} else {
					require.ErrorContains(t, err, test.expectError)
				}
			})`
$DIR/pkg/txmgr/attempts_test.go: `.NewTestChainScopedConfig(t, test.setCfg)`
$DIR/pkg/txmgr/attempts_test.go: `.NewEvmTxAttemptBuilder(*big.NewInt(1), cfg.EVM().GasEstimator(), kst, nil)`
$DIR/pkg/txmgr/attempts_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/attempts_test.go: `.EVM()`
$DIR/pkg/txmgr/attempts_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/attempts_test.go: `.NewCustomTxAttempt(t.Context(), txmgr.Tx{Sequence: &n, FromAddress: addr}, gas.EvmFee{
					DynamicFee: gas.DynamicFee{GasTipCap: dynamicFee.GasTipCap, GasFeeCap: dynamicFee.GasFeeCap},
				}, 100, 0x2, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.TxSigner(nil)`
$DIR/pkg/txmgr/attempts_test.go: `.NewWeiI(10)`
$DIR/pkg/txmgr/attempts_test.go: `.NewWeiI(50)`
$DIR/pkg/txmgr/attempts_test.go: `.NewEvmTxAttemptBuilder(*big.NewInt(1), gc, kst, nil)`
$DIR/pkg/txmgr/attempts_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/attempts_test.go: `.Test(t)`
$DIR/pkg/txmgr/attempts_test.go: `.Run("creates attempt with fields", func(t *testing.T) {
		var n evmtypes.Nonce
		a, _, err := cks.NewCustomTxAttempt(t.Context(), txmgr.Tx{Sequence: &n, FromAddress: addr}, gas.EvmFee{GasPrice: assets.NewWeiI(25)}, 100, 0x0, lggr)
		require.NoError(t, err)
		assert.Equal(t, 100, int(a.ChainSpecificFeeLimit))
		assert.NotNil(t, a.TxFee.GasPrice)
		assert.Equal(t, "25 wei", a.TxFee.GasPrice.String())
		assert.Nil(t, a.TxFee.GasTipCap)
		assert.Nil(t, a.TxFee.GasFeeCap)
	})`
$DIR/pkg/txmgr/attempts_test.go: `.NewCustomTxAttempt(t.Context(), txmgr.Tx{Sequence: &n, FromAddress: addr}, gas.EvmFee{GasPrice: assets.NewWeiI(25)}, 100, 0x0, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.NewWeiI(25)`
$DIR/pkg/txmgr/attempts_test.go: `.NewCustomTxAttempt(t.Context(), txmgr.Tx{FromAddress: addr}, gas.EvmFee{GasPrice: assets.NewWeiI(100)}, 100, 0x0, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.NewWeiI(100)`
$DIR/pkg/txmgr/attempts_test.go: `.TxSigner(nil)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(10)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(50)`
$DIR/pkg/txmgr/attempts_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(30)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(15)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(10)`
$DIR/pkg/txmgr/attempts_test.go: `.On("BumpFee", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/attempts_test.go: `.Return(bumpedFee, uint64(10_000), nil)`
$DIR/pkg/txmgr/attempts_test.go: `.NewEvmTxAttemptBuilder(*big.NewInt(1), gc, kst, est)`
$DIR/pkg/txmgr/attempts_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/attempts_test.go: `.Test(t)`
$DIR/pkg/txmgr/attempts_test.go: `.Run("creates legacy purge attempt with fields if previous attempt is legacy", func(t *testing.T) {
		n := evmtypes.Nonce(0)
		etx := txmgr.Tx{Sequence: &n, FromAddress: addr, EncodedPayload: []byte{1, 2, 3}}
		prevAttempt, _, err := cks.NewCustomTxAttempt(t.Context(), etx, gas.EvmFee{GasPrice: bumpedLegacy.Sub(assets.GWei(1))}, 100, 0x0, lggr)
		require.NoError(t, err)
		etx.TxAttempts = append(etx.TxAttempts, prevAttempt)
		a, err := cks.NewPurgeTxAttempt(t.Context(), etx, lggr)
		require.NoError(t, err)
		// The fee limit is overridden with LimitDefault since purge attempts are just empty attempts
		require.Equal(t, gc.limitDefault, a.ChainSpecificFeeLimit)
		require.NotNil(t, a.TxFee.GasPrice)
		require.Equal(t, bumpedLegacy.String(), a.TxFee.GasPrice.String())
		require.Nil(t, a.TxFee.GasTipCap)
		require.Nil(t, a.TxFee.GasFeeCap)
		require.Equal(t, true, a.IsPurgeAttempt)
		require.Equal(t, []byte{}, a.Tx.EncodedPayload)
		require.Equal(t, *big.NewInt(0), a.Tx.Value)
	})`
$DIR/pkg/txmgr/attempts_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/attempts_test.go: `.NewCustomTxAttempt(t.Context(), etx, gas.EvmFee{GasPrice: bumpedLegacy.Sub(assets.GWei(1))}, 100, 0x0, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.Sub(assets.GWei(1))`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(1)`
$DIR/pkg/txmgr/attempts_test.go: `.NewPurgeTxAttempt(t.Context(), etx, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.Run("creates dynamic purge attempt with fields if previous attempt is dynamic", func(t *testing.T) {
		n := evmtypes.Nonce(0)
		etx := txmgr.Tx{Sequence: &n, FromAddress: addr, EncodedPayload: []byte{1, 2, 3}}
		prevAttempt, _, err := cks.NewCustomTxAttempt(t.Context(), etx, gas.EvmFee{DynamicFee: gas.DynamicFee{GasTipCap: bumpedDynamicTip.Sub(assets.GWei(1)), GasFeeCap: bumpedDynamicFee.Sub(assets.GWei(1))}}, 100, 0x2, lggr)
		require.NoError(t, err)
		etx.TxAttempts = append(etx.TxAttempts, prevAttempt)
		a, err := cks.NewPurgeTxAttempt(t.Context(), etx, lggr)
		require.NoError(t, err)
		// The fee limit is overridden with LimitDefault since purge attempts are just empty attempts
		require.Equal(t, gc.limitDefault, a.ChainSpecificFeeLimit)
		require.Nil(t, a.TxFee.GasPrice)
		require.NotNil(t, a.TxFee.GasTipCap)
		require.NotNil(t, a.TxFee.GasFeeCap)
		require.Equal(t, bumpedDynamicTip.String(), a.TxFee.GasTipCap.String())
		require.Equal(t, bumpedDynamicFee.String(), a.TxFee.GasFeeCap.String())
		require.Equal(t, true, a.IsPurgeAttempt)
		require.Equal(t, []byte{}, a.Tx.EncodedPayload)
		require.Equal(t, *big.NewInt(0), a.Tx.Value)
	})`
$DIR/pkg/txmgr/attempts_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/attempts_test.go: `.NewCustomTxAttempt(t.Context(), etx, gas.EvmFee{DynamicFee: gas.DynamicFee{GasTipCap: bumpedDynamicTip.Sub(assets.GWei(1)), GasFeeCap: bumpedDynamicFee.Sub(assets.GWei(1))}}, 100, 0x2, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.Sub(assets.GWei(1))`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(1)`
$DIR/pkg/txmgr/attempts_test.go: `.Sub(assets.GWei(1))`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(1)`
$DIR/pkg/txmgr/attempts_test.go: `.NewPurgeTxAttempt(t.Context(), etx, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/attempts_test.go: `.NewCustomTxAttempt(t.Context(), etx, gas.EvmFee{GasPrice: bumpedLegacy.Sub(assets.GWei(1))}, 100, 0x0, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.Sub(assets.GWei(1))`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(1)`
$DIR/pkg/txmgr/attempts_test.go: `.NewPurgeTxAttempt(t.Context(), etx, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.NewBumpTxAttempt(t.Context(), etx, purgeAttempt, etx.TxAttempts, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.TxSigner(nil)`
$DIR/pkg/txmgr/attempts_test.go: `.Test(t)`
$DIR/pkg/txmgr/attempts_test.go: `.NewEvmTxAttemptBuilder(*big.NewInt(1), newFeeConfig(), kst, nil)`
$DIR/pkg/txmgr/attempts_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(100)`
$DIR/pkg/txmgr/attempts_test.go: `.GWei(200)`
$DIR/pkg/txmgr/attempts_test.go: `.NewWeiI(100)`
$DIR/pkg/txmgr/attempts_test.go: `.Run("dynamic fee with legacy tx type", func(t *testing.T) {
		_, retryable, err := cks.NewCustomTxAttempt(t.Context(), txmgr.Tx{}, gas.EvmFee{
			DynamicFee: dynamicFee,
		}, 100, 0x0, lggr)
		require.Error(t, err)
		assert.False(t, retryable)
	})`
$DIR/pkg/txmgr/attempts_test.go: `.NewCustomTxAttempt(t.Context(), txmgr.Tx{}, gas.EvmFee{
			DynamicFee: dynamicFee,
		}, 100, 0x0, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.Run("legacy fee with dynamic tx type", func(t *testing.T) {
		_, retryable, err := cks.NewCustomTxAttempt(t.Context(), txmgr.Tx{}, gas.EvmFee{GasPrice: legacyFee}, 100, 0x2, lggr)
		require.Error(t, err)
		assert.False(t, retryable)
	})`
$DIR/pkg/txmgr/attempts_test.go: `.NewCustomTxAttempt(t.Context(), txmgr.Tx{}, gas.EvmFee{GasPrice: legacyFee}, 100, 0x2, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.NewCustomTxAttempt(t.Context(), txmgr.Tx{}, gas.EvmFee{}, 100, 0xA, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/attempts_test.go: `.On("GetFee", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/attempts_test.go: `.Return(gas.EvmFee{}, uint64(0), pkgerrors.New("fail"))`
$DIR/pkg/txmgr/attempts_test.go: `.New("fail")`
$DIR/pkg/txmgr/attempts_test.go: `.On("BumpFee", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/attempts_test.go: `.Return(gas.EvmFee{}, uint64(0), pkgerrors.New("fail"))`
$DIR/pkg/txmgr/attempts_test.go: `.New("fail")`
$DIR/pkg/txmgr/attempts_test.go: `.TxSigner(nil)`
$DIR/pkg/txmgr/attempts_test.go: `.Test(t)`
$DIR/pkg/txmgr/attempts_test.go: `.Context()`
$DIR/pkg/txmgr/attempts_test.go: `.NewEvmTxAttemptBuilder(*big.NewInt(1), &feeConfig{eip1559DynamicFees: true}, kst, est)`
$DIR/pkg/txmgr/attempts_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/attempts_test.go: `.Run("NewAttempt", func(t *testing.T) {
		_, _, _, retryable, err := cks.NewTxAttempt(ctx, txmgr.Tx{}, lggr)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "failed to get fee")
		assert.True(t, retryable)
	})`
$DIR/pkg/txmgr/attempts_test.go: `.NewTxAttempt(ctx, txmgr.Tx{}, lggr)`
$DIR/pkg/txmgr/attempts_test.go: `.Run("NewAttemptWithType", func(t *testing.T) {
		_, _, _, retryable, err := cks.NewTxAttemptWithType(ctx, txmgr.Tx{}, lggr, 0x0)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "failed to get fee")
		assert.True(t, retryable)
	})`
$DIR/pkg/txmgr/attempts_test.go: `.NewTxAttemptWithType(ctx, txmgr.Tx{}, lggr, 0x0)`
$DIR/pkg/txmgr/attempts_test.go: `.NewBumpTxAttempt(ctx, txmgr.Tx{}, txmgr.TxAttempt{}, nil, lggr)`
$DIR/pkg/txmgr/broadcaster_test.go: `memKS.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, mock.Anything, mock.Anything).Return(uint64(0), nil).Twice()`
$DIR/pkg/txmgr/broadcaster_test.go: `err = eb.Close()`
$DIR/pkg/txmgr/broadcaster_test.go: `err = eb.Start(ctx)`
$DIR/pkg/txmgr/broadcaster_test.go: `err = eb.Close()`
$DIR/pkg/txmgr/broadcaster_test.go: `err = eb.Start(ctx)`
$DIR/pkg/txmgr/broadcaster_test.go: `err = eb.Close()`
$DIR/pkg/txmgr/broadcaster_test.go: `memKS.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, mock.Anything, mock.Anything).Return(uint64(0), errors.New("Getting on-chain nonce failed")).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `err = eb.Start(t.Context())`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, otherAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("no eth_txes at all", func(t *testing.T) {
		retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("eth_txes exist for a different from address", func(t *testing.T) {
		mustCreateUnstartedTx(t, txStore, otherAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `mustCreateUnstartedTx(t, txStore, otherAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("existing eth_txes with broadcast_at or error", func(t *testing.T) {
		nonce := evmtypes.Nonce(342)
		errStr := "some error"

		etxUnconfirmed := txmgr.Tx{
			Sequence:           &nonce,
			FromAddress:        fromAddress,
			ToAddress:          toAddress,
			EncodedPayload:     encodedPayload,
			Value:              value,
			FeeLimit:           gasLimit,
			BroadcastAt:        &timeNow,
			InitialBroadcastAt: &timeNow,
			Error:              null.String{},
			State:              txmgrcommon.TxUnconfirmed,
		}
		etxWithError := txmgr.Tx{
			Sequence:       nil,
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: encodedPayload,
			Value:          value,
			FeeLimit:       gasLimit,
			Error:          null.StringFrom(errStr),
			State:          txmgrcommon.TxFatalError,
		}

		require.NoError(t, txStore.InsertTx(ctx, &etxUnconfirmed))
		require.NoError(t, txStore.InsertTx(ctx, &etxWithError))

		retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("sends 3 EthTxs in order with higher value last, and lower values starting from the earliest", func(t *testing.T) {
		// Higher value
		expensiveEthTx := txmgr.Tx{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: []byte{42, 42, 0},
			Value:          big.Int(assets.NewEthValue(242)),
			FeeLimit:       gasLimit,
			CreatedAt:      time.Unix(0, 0),
			State:          txmgrcommon.TxUnstarted,
		}
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(2) && tx.Value().Cmp(big.NewInt(242)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Earlier
		tr := int32(99)
		b, err := json.Marshal(txmgr.TxMeta{JobID: &tr})
		require.NoError(t, err)
		meta := sqlutil.JSON(b)
		earlierEthTx := txmgr.Tx{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: []byte{42, 42, 0},
			Value:          value,
			FeeLimit:       gasLimit,
			CreatedAt:      time.Unix(0, 1),
			State:          txmgrcommon.TxUnstarted,
			Meta:           &meta,
		}
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			if tx.Nonce() != uint64(0) {
				return false
			}
			require.Equal(t, evmcfg.EVM().ChainID(), tx.ChainId())
			require.Equal(t, gasLimit, tx.Gas())
			require.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault().ToInt(), tx.GasPrice())
			require.Equal(t, toAddress, *tx.To())
			require.Equal(t, value.String(), tx.Value().String())
			require.Equal(t, earlierEthTx.EncodedPayload, tx.Data())
			return true
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Later
		laterEthTx := txmgr.Tx{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: []byte{42, 42, 1},
			Value:          value,
			FeeLimit:       gasLimit,
			CreatedAt:      time.Unix(1, 0),
			State:          txmgrcommon.TxUnstarted,
		}
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			if tx.Nonce() != uint64(1) {
				return false
			}
			require.Equal(t, evmcfg.EVM().ChainID(), tx.ChainId())
			require.Equal(t, gasLimit, tx.Gas())
			require.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault().ToInt(), tx.GasPrice())
			require.Equal(t, toAddress, *tx.To())
			require.Equal(t, value.String(), tx.Value().String())
			require.Equal(t, laterEthTx.EncodedPayload, tx.Data())
			return true
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Insertion order deliberately reversed to test ordering
		require.NoError(t, txStore.InsertTx(ctx, &expensiveEthTx))
		require.NoError(t, txStore.InsertTx(ctx, &laterEthTx))
		require.NoError(t, txStore.InsertTx(ctx, &earlierEthTx))

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		// Check earlierEthTx and it's attempt
		// This was the earlier one sent so it has the lower nonce
		earlierTransaction, err := txStore.FindTxWithAttempts(ctx, earlierEthTx.ID)
		require.NoError(t, err)
		assert.False(t, earlierTransaction.Error.Valid)
		require.NotNil(t, earlierTransaction.FromAddress)
		assert.Equal(t, fromAddress, earlierTransaction.FromAddress)
		require.NotNil(t, earlierTransaction.Sequence)
		assert.Equal(t, evmtypes.Nonce(0), *earlierTransaction.Sequence)
		assert.NotNil(t, earlierTransaction.BroadcastAt)
		assert.NotNil(t, earlierTransaction.InitialBroadcastAt)
		assert.Len(t, earlierTransaction.TxAttempts, 1)
		var m txmgr.TxMeta
		err = json.Unmarshal(*earlierEthTx.Meta, &m)
		require.NoError(t, err)
		assert.NotNil(t, m.JobID)
		assert.Equal(t, tr, *m.JobID)

		attempt := earlierTransaction.TxAttempts[0]

		assert.Equal(t, earlierTransaction.ID, attempt.TxID)
		assert.NotNil(t, attempt.TxFee.GasPrice)
		assert.Nil(t, attempt.TxFee.GasTipCap)
		assert.Nil(t, attempt.TxFee.GasFeeCap)
		assert.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault(), attempt.TxFee.GasPrice)

		_, err = txmgr.GetGethSignedTx(attempt.SignedRawTx)
		require.NoError(t, err)
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
		require.Len(t, attempt.Receipts, 0)

		// Check laterEthTx and it's attempt
		// This was the later one sent so it has the higher nonce
		laterTransaction, err := txStore.FindTxWithAttempts(ctx, laterEthTx.ID)
		require.NoError(t, err)
		assert.False(t, earlierTransaction.Error.Valid)
		require.NotNil(t, laterTransaction.FromAddress)
		assert.Equal(t, fromAddress, laterTransaction.FromAddress)
		require.NotNil(t, laterTransaction.Sequence)
		assert.Equal(t, evmtypes.Nonce(1), *laterTransaction.Sequence)
		assert.NotNil(t, laterTransaction.BroadcastAt)
		assert.NotNil(t, earlierTransaction.InitialBroadcastAt)
		assert.Len(t, laterTransaction.TxAttempts, 1)

		attempt = laterTransaction.TxAttempts[0]

		assert.Equal(t, laterTransaction.ID, attempt.TxID)
		assert.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault(), attempt.TxFee.GasPrice)

		_, err = txmgr.GetGethSignedTx(attempt.SignedRawTx)
		require.NoError(t, err)
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
		require.Len(t, attempt.Receipts, 0)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(2) && tx.Value().Cmp(big.NewInt(242)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			if tx.Nonce() != uint64(0) {
				return false
			}
			require.Equal(t, evmcfg.EVM().ChainID(), tx.ChainId())
			require.Equal(t, gasLimit, tx.Gas())
			require.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault().ToInt(), tx.GasPrice())
			require.Equal(t, toAddress, *tx.To())
			require.Equal(t, value.String(), tx.Value().String())
			require.Equal(t, earlierEthTx.EncodedPayload, tx.Data())
			return true
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			if tx.Nonce() != uint64(1) {
				return false
			}
			require.Equal(t, evmcfg.EVM().ChainID(), tx.ChainId())
			require.Equal(t, gasLimit, tx.Gas())
			require.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault().ToInt(), tx.GasPrice())
			require.Equal(t, toAddress, *tx.To())
			require.Equal(t, value.String(), tx.Value().String())
			require.Equal(t, laterEthTx.EncodedPayload, tx.Data())
			return true
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `err = json.Unmarshal(*earlierEthTx.Meta, &m)`
$DIR/pkg/txmgr/broadcaster_test.go: `_, err = txmgr.GetGethSignedTx(attempt.SignedRawTx)`
$DIR/pkg/txmgr/broadcaster_test.go: `attempt = laterTransaction.TxAttempts[0]`
$DIR/pkg/txmgr/broadcaster_test.go: `_, err = txmgr.GetGethSignedTx(attempt.SignedRawTx)`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.EIP1559DynamicFees = ptr(true)`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.TipCapDefault = assets.NewWeiI(rnd)`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.FeeCapDefault = assets.NewWeiI(rnd + 1)`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.PriceMax = assets.NewWeiI(rnd + 2)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, otherAddress, mock.Anything).Return(uint64(1), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `nonceTracker = txmgr.NewNonceTracker(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `eb = NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), checkerFactory, false, nonceTracker)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("sends transactions with type 0x2 in EIP-1559 mode", func(t *testing.T) {
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(343) && tx.Value().Cmp(big.NewInt(242)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()

		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, []byte{42, 42, 0}, gasLimit, big.Int(assets.NewEthValue(242)), testutils.FixtureChainID)
		// Do the thing
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check eipTxWithAl and it's attempt
		// This was the earlier one sent so it has the lower nonce
		etx, err := txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		assert.False(t, etx.Error.Valid)
		require.NotNil(t, etx.FromAddress)
		assert.Equal(t, fromAddress, etx.FromAddress)
		require.NotNil(t, etx.Sequence)
		assert.Equal(t, evmtypes.Nonce(343), *etx.Sequence)
		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		assert.Len(t, etx.TxAttempts, 1)

		attempt := etx.TxAttempts[0]

		assert.Equal(t, etx.ID, attempt.TxID)
		assert.Nil(t, attempt.TxFee.GasPrice)
		assert.Equal(t, rnd, attempt.TxFee.GasTipCap.ToInt().Int64())
		assert.Equal(t, rnd+1, attempt.TxFee.GasFeeCap.ToInt().Int64())

		_, err = txmgr.GetGethSignedTx(attempt.SignedRawTx)
		require.NoError(t, err)
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
		require.Len(t, attempt.Receipts, 0)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(343) && tx.Value().Cmp(big.NewInt(242)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `_, err = txmgr.GetGethSignedTx(attempt.SignedRawTx)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("when simulation succeeds, sends tx as normal", func(t *testing.T) {
			txRequest := txmgr.TxRequest{
				FromAddress:    fromAddress,
				ToAddress:      toAddress,
				EncodedPayload: []byte{42, 0, 0},
				Value:          big.Int(assets.NewEthValue(442)),
				FeeLimit:       gasLimit,
				Strategy:       txmgrcommon.NewSendEveryStrategy(),
				Checker: txmgr.TransmitCheckerSpec{
					CheckerType: txmgr.TransmitCheckerTypeSimulate,
				},
			}
			ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(344) && tx.Value().Cmp(big.NewInt(442)) == 0
			}), fromAddress).Return(multinode.Successful, nil).Once()
			ethClient.On("CallContext", mock.Anything, mock.AnythingOfType("*hexutil.Bytes"), "eth_call", mock.MatchedBy(func(callarg map[string]interface{}) bool {
				if fmt.Sprintf("%s", callarg["value"]) == "0x1ba" { // 442
					assert.Equal(t, txRequest.FromAddress, callarg["from"])
					assert.Equal(t, &txRequest.ToAddress, callarg["to"])
					assert.Equal(t, hexutil.Uint64(txRequest.FeeLimit), callarg["gas"])
					assert.Nil(t, callarg["gasPrice"])
					assert.Nil(t, callarg["maxFeePerGas"])
					assert.Nil(t, callarg["maxPriorityFeePerGas"])
					assert.Equal(t, (*hexutil.Big)(&txRequest.Value), callarg["value"])
					assert.Equal(t, hexutil.Bytes(txRequest.EncodedPayload), callarg["data"])
					return true
				}
				return false
			}), "latest").Return(nil).Once()

			ethTx := mustCreateUnstartedTxFromEvmTxRequest(t, txStore, txRequest, testutils.FixtureChainID)

			{
				retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
				assert.NoError(t, err)
				assert.False(t, retryable)
			}

			// Check ethtx was sent
			ethTx, err := txStore.FindTxWithAttempts(ctx, ethTx.ID)
			require.NoError(t, err)
			assert.Equal(t, txmgrcommon.TxUnconfirmed, ethTx.State)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(344) && tx.Value().Cmp(big.NewInt(442)) == 0
			}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("CallContext", mock.Anything, mock.AnythingOfType("*hexutil.Bytes"), "eth_call", mock.MatchedBy(func(callarg map[string]interface{}) bool {
				if fmt.Sprintf("%s", callarg["value"]) == "0x1ba" { // 442
					assert.Equal(t, txRequest.FromAddress, callarg["from"])
					assert.Equal(t, &txRequest.ToAddress, callarg["to"])
					assert.Equal(t, hexutil.Uint64(txRequest.FeeLimit), callarg["gas"])
					assert.Nil(t, callarg["gasPrice"])
					assert.Nil(t, callarg["maxFeePerGas"])
					assert.Nil(t, callarg["maxPriorityFeePerGas"])
					assert.Equal(t, (*hexutil.Big)(&txRequest.Value), callarg["value"])
					assert.Equal(t, hexutil.Bytes(txRequest.EncodedPayload), callarg["data"])
					return true
				}
				return false
			}), "latest").Return(nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("with unknown error, sends tx as normal", func(t *testing.T) {
			ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(345) && tx.Value().Cmp(big.NewInt(542)) == 0
			}), fromAddress).Return(multinode.Successful, nil).Once()
			ethClient.On("CallContext", mock.Anything, mock.AnythingOfType("*hexutil.Bytes"), "eth_call", mock.MatchedBy(func(callarg map[string]interface{}) bool {
				return fmt.Sprintf("%s", callarg["value"]) == "0x21e" // 542
			}), "latest").Return(errors.New("this is not a revert, something unexpected went wrong")).Once()

			ethTx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID,
				txRequestWithChecker(checker),
				txRequestWithValue(big.Int(assets.NewEthValue(542))))

			{
				retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
				assert.NoError(t, err)
				assert.False(t, retryable)
			}

			ethTx, err := txStore.FindTxWithAttempts(ctx, ethTx.ID)
			require.NoError(t, err)
			assert.Equal(t, txmgrcommon.TxUnconfirmed, ethTx.State)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(345) && tx.Value().Cmp(big.NewInt(542)) == 0
			}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("CallContext", mock.Anything, mock.AnythingOfType("*hexutil.Bytes"), "eth_call", mock.MatchedBy(func(callarg map[string]interface{}) bool {
				return fmt.Sprintf("%s", callarg["value"]) == "0x21e" // 542
			}), "latest").Return(errors.New("this is not a revert, something unexpected went wrong")).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("on revert, marks tx as fatally errored and does not send", func(t *testing.T) {
			jerr := client.JsonError{
				Code:    42,
				Message: "oh no, it reverted",
				Data:    []byte{42, 166, 34},
			}
			ethClient.On("CallContext", mock.Anything, mock.AnythingOfType("*hexutil.Bytes"), "eth_call", mock.MatchedBy(func(callarg map[string]interface{}) bool {
				return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
			}), "latest").Return(&jerr).Once()

			ethTx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID,
				txRequestWithChecker(checker),
				txRequestWithValue(big.Int(assets.NewEthValue(642))))
			{
				retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
				assert.NoError(t, err)
				assert.False(t, retryable)
			}

			ethTx, err := txStore.FindTxWithAttempts(ctx, ethTx.ID)
			require.NoError(t, err)
			assert.Equal(t, txmgrcommon.TxFatalError, ethTx.State)
			assert.True(t, ethTx.Error.Valid)
			assert.Equal(t, "transaction reverted during simulation: json-rpc error { Code = 42, Message = 'oh no, it reverted', Data = 'KqYi' }", ethTx.Error.String)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("CallContext", mock.Anything, mock.AnythingOfType("*hexutil.Bytes"), "eth_call", mock.MatchedBy(func(callarg map[string]interface{}) bool {
				return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
			}), "latest").Return(&jerr).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("terminally stuck transaction is marked as fatal", func(t *testing.T) {
			terminallyStuckError := "failed to add tx to the pool: not enough step counters to continue the execution"
			etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, []byte{42, 42, 0}, gasLimit, big.Int(assets.NewEthValue(243)), testutils.FixtureChainID)
			ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(346) && tx.Value().Cmp(big.NewInt(243)) == 0
			}), fromAddress).Return(multinode.Fatal, errors.New(terminallyStuckError)).Once()

			// Start processing unstarted transactions
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)

			dbTx, err := txStore.FindTxWithAttempts(ctx, etx.ID)
			require.NoError(t, err)
			assert.Equal(t, txmgrcommon.TxFatalError, dbTx.State)
			assert.True(t, dbTx.Error.Valid)
			assert.Equal(t, terminallyStuckError, dbTx.Error.String)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(346) && tx.Value().Cmp(big.NewInt(243)) == 0
			}), fromAddress).Return(multinode.Fatal, errors.New(terminallyStuckError)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("when transmit checking times out, sends tx as normal", func(t *testing.T) {
		// Checker will return a canceled error
		checkerFactory.err = context.Canceled

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == 0 && tx.Value().Cmp(big.NewInt(442)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()

		ethTx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID,
			txRequestWithValue(big.Int(assets.NewEthValue(442))),
			txRequestWithChecker(checker))
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check ethtx was sent
		ethTx, err := txStore.FindTxWithAttempts(ctx, ethTx.ID)
		require.NoError(t, err)
		assert.Equal(t, txmgrcommon.TxUnconfirmed, ethTx.State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `checkerFactory.err = context.Canceled`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == 0 && tx.Value().Cmp(big.NewInt(442)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("when transmit checking succeeds, sends tx as normal", func(t *testing.T) {
		// Checker will return no error
		checkerFactory.err = nil

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == 1 && tx.Value().Cmp(big.NewInt(442)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()

		ethTx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID,
			txRequestWithValue(big.Int(assets.NewEthValue(442))),
			txRequestWithChecker(checker))
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check ethtx was sent
		ethTx, err := txStore.FindTxWithAttempts(ctx, ethTx.ID)
		require.NoError(t, err)
		assert.Equal(t, txmgrcommon.TxUnconfirmed, ethTx.State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `checkerFactory.err = nil`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == 1 && tx.Value().Cmp(big.NewInt(442)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `checkerFactory.err = errors.New("fatal checker error")`
$DIR/pkg/txmgr/broadcaster_test.go: `estimator.On("GetFee", mock.Anything, mock.Anything, mock.Anything, ccfg.EVM().GasEstimator().PriceMaxKey(fromAddress), mock.Anything, mock.Anything).Return(gas.EvmFee{GasPrice: assets.GWei(1)}, uint64(500), nil).Run(func(_ mock.Arguments) {
		close(chStartEstimate)
		<-chBlock
	}).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `close(chStartEstimate)`
$DIR/pkg/txmgr/broadcaster_test.go: `<-chBlock`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `eb.XXXTestDisableUnstartedTxAutoProcessing()`
$DIR/pkg/txmgr/broadcaster_test.go: `servicetest.Run(t, eb)`
$DIR/pkg/txmgr/broadcaster_test.go: `mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID)`
$DIR/pkg/txmgr/broadcaster_test.go: `close(chBlock)`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.LimitMultiplier = &lm`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
		assert.Equal(t, int(1600), int(tx.Gas()))
		return true
	}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `mustCreateUnstartedTxFromEvmTxRequest(t, txStore, txRequest, testutils.FixtureChainID)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("cannot be more than one transaction per address in an unfinished state", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()

		firstInProgress := txmgr.Tx{
			FromAddress:    fromAddress,
			Sequence:       &firstNonce,
			ToAddress:      toAddress,
			EncodedPayload: encodedPayload,
			Value:          value,
			FeeLimit:       gasLimit,
			Error:          null.String{},
			State:          txmgrcommon.TxInProgress,
		}

		secondInProgress := txmgr.Tx{
			FromAddress:    fromAddress,
			Sequence:       &secondNonce,
			ToAddress:      toAddress,
			EncodedPayload: encodedPayload,
			Value:          value,
			FeeLimit:       gasLimit,
			Error:          null.String{},
			State:          txmgrcommon.TxInProgress,
		}

		require.NoError(t, txStore.InsertTx(ctx, &firstInProgress))
		err := txStore.InsertTx(ctx, &secondInProgress)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "ERROR: duplicate key value violates unique constraint \"idx_only_one_in_progress_tx_per_account_id_per_evm_chain_id\" (SQLSTATE 23505)")
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("previous run assigned nonce but never broadcast", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		evmcfg := configtest.NewChainScopedConfig(t, nil)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()
		nonceTracker := txmgr.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		eb := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)

		// Crashed right after we commit the database transaction that saved
		// the nonce to the eth_tx so evm.key_states.next_nonce has not been
		// incremented yet
		inProgressEthTx := mustInsertInProgressEthTxWithAttempt(t, txStore, firstNonce, fromAddress)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Do the thing
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check it was saved correctly with its attempt
		etx, err := txStore.FindTxWithAttempts(ctx, inProgressEthTx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, etx.TxAttempts[0].State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("previous run assigned nonce and broadcast but it fatally errored before we could save", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		evmcfg := configtest.NewChainScopedConfig(t, nil)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()
		nonceTracker := txmgr.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		eb := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)

		// Crashed right after we commit the database transaction that saved the nonce to the eth_tx
		inProgressEthTx := mustInsertInProgressEthTxWithAttempt(t, txStore, firstNonce, fromAddress)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.Fatal, errors.New("exceeds block gas limit")).Once()

		// Do the thing
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check it was saved correctly with its attempt
		etx, err := txStore.FindTxWithAttempts(ctx, inProgressEthTx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		assert.True(t, etx.Error.Valid)
		assert.Equal(t, "exceeds block gas limit", etx.Error.String)
		assert.Len(t, etx.TxAttempts, 0)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.Fatal, errors.New("exceeds block gas limit")).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("previous run assigned nonce and broadcast and is now in mempool", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		evmcfg := configtest.NewChainScopedConfig(t, nil)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()
		nonceTracker := txmgr.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		eb := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)

		// Crashed right after we commit the database transaction that saved the nonce to the eth_tx
		inProgressEthTx := mustInsertInProgressEthTxWithAttempt(t, txStore, firstNonce, fromAddress)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.Successful, errors.New("known transaction: a1313bd99a81fb4d8ad1d2e90b67c6b3fa77545c990d6251444b83b70b6f8980")).Once()

		// Do the thing
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check it was saved correctly with its attempt
		etx, err := txStore.FindTxWithAttempts(ctx, inProgressEthTx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.Successful, errors.New("known transaction: a1313bd99a81fb4d8ad1d2e90b67c6b3fa77545c990d6251444b83b70b6f8980")).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("previous run assigned nonce and broadcast and now the transaction has been confirmed", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		evmcfg := configtest.NewChainScopedConfig(t, nil)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()
		nonceTracker := txmgr.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		eb := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)

		// Crashed right after we commit the database transaction that saved the nonce to the eth_tx
		inProgressEthTx := mustInsertInProgressEthTxWithAttempt(t, txStore, firstNonce, fromAddress)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.TransactionAlreadyKnown, errors.New("nonce too low")).Once()

		// Do the thing
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check it was saved correctly with its attempt
		etx, err := txStore.FindTxWithAttempts(ctx, inProgressEthTx.ID)
		require.NoError(t, err)

		require.NotNil(t, etx.BroadcastAt)
		assert.Equal(t, *etx.BroadcastAt, etx.CreatedAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.TransactionAlreadyKnown, errors.New("nonce too low")).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("previous run assigned nonce and then failed to reach node for some reason and node is still down", func(t *testing.T) {
		failedToReachNodeError := context.DeadlineExceeded
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		evmcfg := configtest.NewChainScopedConfig(t, nil)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()
		nonceTracker := txmgr.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		eb := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)

		// Crashed right after we commit the database transaction that saved the nonce to the eth_tx
		inProgressEthTx := mustInsertInProgressEthTxWithAttempt(t, txStore, firstNonce, fromAddress)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.Retryable, failedToReachNodeError).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
		require.Error(t, err)
		assert.Contains(t, err.Error(), failedToReachNodeError.Error())
		assert.True(t, retryable)

		// Check it was left in the unfinished state
		etx, err := txStore.FindTxWithAttempts(ctx, inProgressEthTx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		assert.Equal(t, nextNonce, *etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.Retryable, failedToReachNodeError).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.PriceDefault = assets.NewWeiI(500000000000)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			// Ensure that the gas price is the same as the original attempt
			s, e := txmgr.GetGethSignedTx(attempt.SignedRawTx)
			require.NoError(t, e)
			return tx.Nonce() == uint64(firstNonce) && tx.GasPrice().Int64() == s.GasPrice().Int64()
		}), fromAddress).Return(multinode.Successful, errors.New("known transaction: a1313bd99a81fb4d8ad1d2e90b67c6b3fa77545c990d6251444b83b70b6f8980")).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `attempt = etx.TxAttempts[0]`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("if external wallet sent a transaction from the account and now the nonce is one higher than it should be and we got replacement underpriced then we assume a previous transaction of ours was the one that succeeded, and hand off to EthConfirmer", func(t *testing.T) {
		mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		// First send, replacement underpriced
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(0)
		}), fromAddress).Return(multinode.Successful, errors.New("replacement transaction underpriced")).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		// Check that the transaction was saved correctly with its attempt
		// We assume success and hand off to eth confirmer to eventually mark it as failed
		var latestID int64
		var etx1 txmgr.Tx
		require.NoError(t, db.Get(&latestID, "SELECT max(id) FROM evm.txes"))
		etx1, err = txStore.FindTxWithAttempts(ctx, latestID)
		require.NoError(t, err)
		require.NotNil(t, etx1.BroadcastAt)
		assert.NotEqual(t, etx1.CreatedAt, *etx1.BroadcastAt)
		assert.NotNil(t, etx1.InitialBroadcastAt)
		require.NotNil(t, etx1.Sequence)
		assert.Equal(t, evmtypes.Nonce(0), *etx1.Sequence)
		assert.False(t, etx1.Error.Valid)
		assert.Len(t, etx1.TxAttempts, 1)

		// Check that the local nonce was incremented by one
		finalNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		require.NoError(t, err)
		require.NotNil(t, finalNextNonce)
		require.Equal(t, int64(1), int64(finalNextNonce))
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(0)
		}), fromAddress).Return(multinode.Successful, errors.New("replacement transaction underpriced")).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `etx1, err = txStore.FindTxWithAttempts(ctx, latestID)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("geth Client returns an error in the fatal errors category", func(t *testing.T) {
		fatalErrorExample := "exceeds block gas limit"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)

		t.Run("without callback", func(t *testing.T) {
			etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
			ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == localNextNonce
			}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

			retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)

			// Check it was saved correctly with its attempt
			etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
			require.NoError(t, err)

			assert.Nil(t, etx.BroadcastAt)
			assert.Nil(t, etx.InitialBroadcastAt)
			require.Nil(t, etx.Sequence)
			assert.True(t, etx.Error.Valid)
			assert.Contains(t, etx.Error.String, "exceeds block gas limit")
			assert.Len(t, etx.TxAttempts, 0)

			// Check that the key had its nonce reset
			var nonce evmtypes.Nonce
			nonce, err = nonceTracker.GetNextSequence(ctx, fromAddress)
			require.NoError(t, err)
			// Saved NextNonce must be the same as before because this transaction
			// was not accepted by the eth node and never can be
			require.Equal(t, int64(localNextNonce), int64(nonce))
		})

		t.Run("with callback", func(t *testing.T) {
			runID := testutils.MustInsertPipelineRun(t, db)
			trID := testutils.MustInsertUnfinishedPipelineTaskRun(t, db, runID)
			etx := txmgr.Tx{
				FromAddress:       fromAddress,
				ToAddress:         toAddress,
				EncodedPayload:    encodedPayload,
				Value:             value,
				FeeLimit:          gasLimit,
				State:             txmgrcommon.TxUnstarted,
				PipelineTaskRunID: uuid.NullUUID{UUID: trID, Valid: true},
				SignalCallback:    true,
			}

			t.Run("with erroring callback bails out", func(t *testing.T) {
				require.NoError(t, txStore.InsertTx(t.Context(), &etx))
				fn := func(ctx context.Context, id uuid.UUID, result interface{}, err error) error {
					return errors.New("something exploded in the callback")
				}

				eb.SetResumeCallback(fn)

				ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

				retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
				require.Error(t, err)
				require.Contains(t, err.Error(), "something exploded in the callback")
				assert.True(t, retryable)
			})

			t.Run("calls resume with error", func(t *testing.T) {
				fn := func(ctx context.Context, id uuid.UUID, result interface{}, err error) error {
					require.Equal(t, id, trID)
					require.Nil(t, result)
					require.Error(t, err)
					require.Contains(t, err.Error(), "fatal error while sending transaction: exceeds block gas limit")
					return nil
				}

				eb.SetResumeCallback(fn)

				ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

				{
					retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				}

				// same as the parent test, but callback is set by ctor
				t.Run("callback set by ctor", func(t *testing.T) {
					evmcfg := configtest.NewChainScopedConfig(t, nil)
					estimator := gas.NewEvmFeeEstimator(lggr, func(lggr logger.Logger) gas.EvmEstimator {
						return gas.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, evmcfg.EVM().GasEstimator().BlockHistory(), lggr, nil)
					}, evmcfg.EVM().GasEstimator().EIP1559DynamicFees(), evmcfg.EVM().GasEstimator(), ethClient)
					txBuilder := txmgr.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), evmcfg.EVM().GasEstimator(), ethKeyStore, estimator)
					localNextNonce = getLocalNextNonce(t, nonceTracker, fromAddress)
					metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
					require.NoError(t, err)
					eb2 := txmgr.NewEvmBroadcaster(txStore, txmClient, txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, lggr, &testCheckerFactory{}, false, "", metrics)
					retryable, err := eb2.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				})
			})
		})
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("without callback", func(t *testing.T) {
			etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
			ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == localNextNonce
			}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

			retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)

			// Check it was saved correctly with its attempt
			etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
			require.NoError(t, err)

			assert.Nil(t, etx.BroadcastAt)
			assert.Nil(t, etx.InitialBroadcastAt)
			require.Nil(t, etx.Sequence)
			assert.True(t, etx.Error.Valid)
			assert.Contains(t, etx.Error.String, "exceeds block gas limit")
			assert.Len(t, etx.TxAttempts, 0)

			// Check that the key had its nonce reset
			var nonce evmtypes.Nonce
			nonce, err = nonceTracker.GetNextSequence(ctx, fromAddress)
			require.NoError(t, err)
			// Saved NextNonce must be the same as before because this transaction
			// was not accepted by the eth node and never can be
			require.Equal(t, int64(localNextNonce), int64(nonce))
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == localNextNonce
			}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `nonce, err = nonceTracker.GetNextSequence(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("with callback", func(t *testing.T) {
			runID := testutils.MustInsertPipelineRun(t, db)
			trID := testutils.MustInsertUnfinishedPipelineTaskRun(t, db, runID)
			etx := txmgr.Tx{
				FromAddress:       fromAddress,
				ToAddress:         toAddress,
				EncodedPayload:    encodedPayload,
				Value:             value,
				FeeLimit:          gasLimit,
				State:             txmgrcommon.TxUnstarted,
				PipelineTaskRunID: uuid.NullUUID{UUID: trID, Valid: true},
				SignalCallback:    true,
			}

			t.Run("with erroring callback bails out", func(t *testing.T) {
				require.NoError(t, txStore.InsertTx(t.Context(), &etx))
				fn := func(ctx context.Context, id uuid.UUID, result interface{}, err error) error {
					return errors.New("something exploded in the callback")
				}

				eb.SetResumeCallback(fn)

				ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

				retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
				require.Error(t, err)
				require.Contains(t, err.Error(), "something exploded in the callback")
				assert.True(t, retryable)
			})

			t.Run("calls resume with error", func(t *testing.T) {
				fn := func(ctx context.Context, id uuid.UUID, result interface{}, err error) error {
					require.Equal(t, id, trID)
					require.Nil(t, result)
					require.Error(t, err)
					require.Contains(t, err.Error(), "fatal error while sending transaction: exceeds block gas limit")
					return nil
				}

				eb.SetResumeCallback(fn)

				ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

				{
					retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				}

				// same as the parent test, but callback is set by ctor
				t.Run("callback set by ctor", func(t *testing.T) {
					evmcfg := configtest.NewChainScopedConfig(t, nil)
					estimator := gas.NewEvmFeeEstimator(lggr, func(lggr logger.Logger) gas.EvmEstimator {
						return gas.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, evmcfg.EVM().GasEstimator().BlockHistory(), lggr, nil)
					}, evmcfg.EVM().GasEstimator().EIP1559DynamicFees(), evmcfg.EVM().GasEstimator(), ethClient)
					txBuilder := txmgr.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), evmcfg.EVM().GasEstimator(), ethKeyStore, estimator)
					localNextNonce = getLocalNextNonce(t, nonceTracker, fromAddress)
					metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
					require.NoError(t, err)
					eb2 := txmgr.NewEvmBroadcaster(txStore, txmClient, txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, lggr, &testCheckerFactory{}, false, "", metrics)
					retryable, err := eb2.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				})
			})
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("with erroring callback bails out", func(t *testing.T) {
				require.NoError(t, txStore.InsertTx(t.Context(), &etx))
				fn := func(ctx context.Context, id uuid.UUID, result interface{}, err error) error {
					return errors.New("something exploded in the callback")
				}

				eb.SetResumeCallback(fn)

				ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

				retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
				require.Error(t, err)
				require.Contains(t, err.Error(), "something exploded in the callback")
				assert.True(t, retryable)
			})`
$DIR/pkg/txmgr/broadcaster_test.go: `eb.SetResumeCallback(fn)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("calls resume with error", func(t *testing.T) {
				fn := func(ctx context.Context, id uuid.UUID, result interface{}, err error) error {
					require.Equal(t, id, trID)
					require.Nil(t, result)
					require.Error(t, err)
					require.Contains(t, err.Error(), "fatal error while sending transaction: exceeds block gas limit")
					return nil
				}

				eb.SetResumeCallback(fn)

				ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

				{
					retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				}

				// same as the parent test, but callback is set by ctor
				t.Run("callback set by ctor", func(t *testing.T) {
					evmcfg := configtest.NewChainScopedConfig(t, nil)
					estimator := gas.NewEvmFeeEstimator(lggr, func(lggr logger.Logger) gas.EvmEstimator {
						return gas.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, evmcfg.EVM().GasEstimator().BlockHistory(), lggr, nil)
					}, evmcfg.EVM().GasEstimator().EIP1559DynamicFees(), evmcfg.EVM().GasEstimator(), ethClient)
					txBuilder := txmgr.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), evmcfg.EVM().GasEstimator(), ethKeyStore, estimator)
					localNextNonce = getLocalNextNonce(t, nonceTracker, fromAddress)
					metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
					require.NoError(t, err)
					eb2 := txmgr.NewEvmBroadcaster(txStore, txmClient, txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, lggr, &testCheckerFactory{}, false, "", metrics)
					retryable, err := eb2.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				})
			})`
$DIR/pkg/txmgr/broadcaster_test.go: `eb.SetResumeCallback(fn)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("callback set by ctor", func(t *testing.T) {
					evmcfg := configtest.NewChainScopedConfig(t, nil)
					estimator := gas.NewEvmFeeEstimator(lggr, func(lggr logger.Logger) gas.EvmEstimator {
						return gas.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, evmcfg.EVM().GasEstimator().BlockHistory(), lggr, nil)
					}, evmcfg.EVM().GasEstimator().EIP1559DynamicFees(), evmcfg.EVM().GasEstimator(), ethClient)
					txBuilder := txmgr.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), evmcfg.EVM().GasEstimator(), ethKeyStore, estimator)
					localNextNonce = getLocalNextNonce(t, nonceTracker, fromAddress)
					metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
					require.NoError(t, err)
					eb2 := txmgr.NewEvmBroadcaster(txStore, txmClient, txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, lggr, &testCheckerFactory{}, false, "", metrics)
					retryable, err := eb2.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				})`
$DIR/pkg/txmgr/broadcaster_test.go: `localNextNonce = getLocalNextNonce(t, nonceTracker, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `eb.SetResumeCallback(nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("geth Client fails with error indicating that the transaction was too expensive", func(t *testing.T) {
		TxFeeExceedsCapError := "tx fee (1.10 ether) exceeds the configured cap (1.00 ether)"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(localNextNonce, nil).Once()
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.ExceedsMaxFee, errors.New(TxFeeExceedsCapError)).Twice()
		// In the first case, the tx was NOT accepted into the mempool. In the case
		// of multiple RPC nodes, it is possible that it can be accepted by
		// another node even if the primary one returns "exceeds the configured
		// cap"

		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "tx fee (1.10 ether) exceeds the configured cap (1.00 ether)")
		assert.Contains(t, err.Error(), "error while sending transaction")
		assert.True(t, retryable)

		// Check it was saved with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt) // Note that InitialBroadcastAt really means "InitialDefinitelySuccessfulBroadcastAt"
		assert.Equal(t, evmtypes.Nonce(localNextNonce), *etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)

		// Check that the key had its nonce reset
		var nonce evmtypes.Nonce
		nonce, err = nonceTracker.GetNextSequence(ctx, fromAddress)
		require.NoError(t, err)
		// Saved NextNonce must be the same as before because this transaction
		// was not accepted by the eth node and never can be
		require.Equal(t, int64(localNextNonce), int64(nonce))

		// On the second try, the tx has been accepted into the mempool
		ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(localNextNonce+1, nil).Once()

		retryable, err = eb.ProcessUnstartedTxs(ctx, fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		// Check it was saved with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt) // Note that InitialBroadcastAt really means "InitialDefinitelySuccessfulBroadcastAt"
		assert.Equal(t, evmtypes.Nonce(localNextNonce), *etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
		attempt = etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(localNextNonce, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.ExceedsMaxFee, errors.New(TxFeeExceedsCapError)).Twice()`
$DIR/pkg/txmgr/broadcaster_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `nonce, err = nonceTracker.GetNextSequence(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(localNextNonce+1, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `retryable, err = eb.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `attempt = etx.TxAttempts[0]`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("eth Client call fails with an unexpected random error, and transaction was not accepted into mempool", func(t *testing.T) {
		retryableErrorExample := "some unknown error"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Unknown, errors.New(retryableErrorExample)).Once()
		// Nonce is the same as localNextNonce, implying that this sent transaction has not been accepted
		ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(localNextNonce, nil).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		require.Contains(t, err.Error(), retryableErrorExample)
		assert.True(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxInProgress, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)

		// Now on the second run, it is successful
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Successful, nil).Once()

		retryable, err = eb.ProcessUnstartedTxs(ctx, fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
		attempt = etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Unknown, errors.New(retryableErrorExample)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(localNextNonce, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `retryable, err = eb.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `attempt = etx.TxAttempts[0]`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("eth client call fails with an unexpected random error, and the nonce check also subsequently fails", func(t *testing.T) {
		retryableErrorExample := "some unknown error"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Unknown, errors.New(retryableErrorExample)).Once()
		ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(uint64(0), errors.New("pending nonce fetch failed")).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		require.Contains(t, err.Error(), retryableErrorExample)
		require.Contains(t, err.Error(), "pending nonce fetch failed")
		assert.True(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxInProgress, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)

		// Now on the second run, it is successful
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Successful, nil).Once()

		retryable, err = eb.ProcessUnstartedTxs(ctx, fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
		attempt = etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Unknown, errors.New(retryableErrorExample)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(uint64(0), errors.New("pending nonce fetch failed")).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `retryable, err = eb.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `attempt = etx.TxAttempts[0]`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("eth Client call fails with an unexpected random error, and transaction was accepted into mempool", func(t *testing.T) {
		retryableErrorExample := "some strange RPC returns an unexpected thing"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Unknown, errors.New(retryableErrorExample)).Once()
		// Nonce is one higher than localNextNonce, implying that despite the error, this sent transaction has been accepted into the mempool
		ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(localNextNonce+1, nil).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.NoError(t, err)
		assert.False(t, retryable)

		// Check it was saved correctly with its attempt, in a broadcast state
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Unknown, errors.New(retryableErrorExample)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(localNextNonce+1, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("eth node returns underpriced transaction", func(t *testing.T) {
		// This happens if a transaction's gas price is below the minimum
		// configured for the transaction pool.
		// This is a configuration error by the node operator, since it means they set the base gas level too low.
		underpricedError := "transaction underpriced"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		evmcfg := configtest.NewChainScopedConfig(t, nil)
		// First was underpriced
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(evmcfg.EVM().GasEstimator().PriceDefault().ToInt()) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()

		// Second with gas bump was still underpriced
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(big.NewInt(25000000000)) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()

		// Third succeeded
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(big.NewInt(30000000000)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.NoError(t, err)
		assert.False(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, "30 gwei", attempt.TxFee.GasPrice.String())
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(evmcfg.EVM().GasEstimator().PriceDefault().ToInt()) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(big.NewInt(25000000000)) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(big.NewInt(30000000000)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("failed to reach node for some reason", func(t *testing.T) {
		failedToReachNodeError := context.DeadlineExceeded
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Retryable, failedToReachNodeError).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "context deadline exceeded")
		assert.True(t, retryable)

		// Check it was left in the unfinished state
		etx, err := txStore.FindTxWithAttempts(ctx, etxUnfinished.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		assert.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxInProgress, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, etx.TxAttempts[0].State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Retryable, failedToReachNodeError).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("eth node returns temporarily underpriced transaction", func(t *testing.T) {
		// This happens if parity is rejecting transactions that are not priced high enough to even get into the mempool at all
		// It should pretend it was accepted into the mempool and hand off to ethConfirmer to bump gas as normal
		temporarilyUnderpricedError := "There are too many transactions in the queue. Your transaction was dropped due to limit. Try increasing the fee."
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)

		// Re-use the previously unfinished transaction, no need to insert new

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Successful, errors.New(temporarilyUnderpricedError)).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err := txStore.FindTxWithAttempts(ctx, etxUnfinished.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, "20 gwei", attempt.TxFee.GasPrice.String())
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Successful, errors.New(temporarilyUnderpricedError)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("eth node returns underpriced transaction and bumping gas doesn't increase it", func(t *testing.T) {
		// This happens if a transaction's gas price is below the minimum
		// configured for the transaction pool.
		// This is a configuration error by the node operator, since it means they set the base gas level too low.
		underpricedError := "transaction underpriced"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		// In this scenario the node operator REALLY fucked up and set the bump
		// to zero (even though that should not be possible due to config
		// validation)
		evmcfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.BumpMin = assets.NewWeiI(0)
			c.GasEstimator.BumpPercent = ptr[uint16](0)
		})
		eb2 := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)
		mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)

		// First was underpriced
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(evmcfg.EVM().GasEstimator().PriceDefault().ToInt()) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()

		// Do the thing
		retryable, err := eb2.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		require.Contains(t, err.Error(), "bumped fee price of 20 gwei is equal to original fee price of 20 gwei. ACTION REQUIRED: This is a configuration error, you must increase either FeeEstimator.BumpPercent or FeeEstimator.BumpMin")
		assert.True(t, retryable)

		// TEARDOWN: Clear out the unsent tx before the next test
		testutils.MustExec(t, db, `DELETE FROM evm.txes WHERE nonce = $1`, localNextNonce)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.BumpMin = assets.NewWeiI(0)`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.BumpPercent = ptr[uint16](0)`
$DIR/pkg/txmgr/broadcaster_test.go: `mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(evmcfg.EVM().GasEstimator().PriceDefault().ToInt()) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `testutils.MustExec(t, db, `DELETE FROM evm.txes WHERE nonce = $1`, localNextNonce)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("tx is left in progress and its attempt gets replaced with a new re-estimated attempt if node returns insufficient eth", func(t *testing.T) {
		insufficientEthError := "insufficient funds for transfer"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.InsufficientFunds, errors.New(insufficientEthError)).Once()

		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "insufficient funds for transfer")
		assert.True(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxInProgress, etx.State)
		require.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)
		assert.Nil(t, attempt.BroadcastBeforeBlockNum)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.InsufficientFunds, errors.New(insufficientEthError)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `testutils.MustExec(t, db, `DELETE FROM evm.txes`)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("eth tx is left in progress if nonce is too high", func(t *testing.T) {
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		nonceGapError := "NonceGap, Future nonce. Expected nonce: " + strconv.FormatUint(localNextNonce, 10)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Retryable, errors.New(nonceGapError)).Once()

		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		assert.Contains(t, err.Error(), nonceGapError)
		assert.True(t, retryable)

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxInProgress, etx.State)
		require.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)
		assert.Nil(t, attempt.BroadcastBeforeBlockNum)

		testutils.MustExec(t, db, `DELETE FROM evm.txes`)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Retryable, errors.New(nonceGapError)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `testutils.MustExec(t, db, `DELETE FROM evm.txes`)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("eth node returns underpriced transaction and bumping gas doesn't increase it in EIP-1559 mode", func(t *testing.T) {
		// This happens if a transaction's gas price is below the minimum
		// configured for the transaction pool.
		// This is a configuration error by the node operator, since it means they set the base gas level too low.

		// In this scenario the node operator REALLY fucked up and set the bump
		// to zero (even though that should not be possible due to config
		// validation)
		evmcfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.EIP1559DynamicFees = ptr(true)
			c.GasEstimator.BumpMin = assets.NewWeiI(0)
			c.GasEstimator.BumpPercent = ptr[uint16](0)
		})
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(localNextNonce, nil).Once()
		eb2 := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)
		mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		underpricedError := "transaction underpriced"
		localNextNonce = getLocalNextNonce(t, nonceTracker, fromAddress)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(big.NewInt(1)) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()

		// Check gas tip cap verification
		retryable, err := eb2.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		require.Contains(t, err.Error(), "bumped gas tip cap of 1 wei is less than or equal to original gas tip cap of 1 wei")
		assert.True(t, retryable)

		testutils.MustExec(t, db, `DELETE FROM evm.txes`)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.EIP1559DynamicFees = ptr(true)`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.BumpMin = assets.NewWeiI(0)`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.BumpPercent = ptr[uint16](0)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(localNextNonce, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)`
$DIR/pkg/txmgr/broadcaster_test.go: `localNextNonce = getLocalNextNonce(t, nonceTracker, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(big.NewInt(1)) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `testutils.MustExec(t, db, `DELETE FROM evm.txes`)`
$DIR/pkg/txmgr/broadcaster_test.go: `mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.EIP1559DynamicFees = ptr(true)`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.TipCapDefault = gasTipCapDefault`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(localNextNonce, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(gasTipCapDefault.ToInt()) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(big.NewInt(0).Add(gasTipCapDefault.ToInt(), evmcfg.EVM().GasEstimator().BumpMin().ToInt())) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(big.NewInt(0).Add(gasTipCapDefault.ToInt(), big.NewInt(0).Mul(evmcfg.EVM().GasEstimator().BumpMin().ToInt(), big.NewInt(2)))) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `testutils.MustExec(t, db, `DELETE FROM evm.txes WHERE nonce = $1`, localNextNonce)`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.EstimateLimit = ptr(true)`
$DIR/pkg/txmgr/broadcaster_test.go: `c.GasEstimator.LimitMultiplier = ptr(decimal.NewFromFloat32(limitMultiplier))`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `eb.XXXTestDisableUnstartedTxAutoProcessing()`
$DIR/pkg/txmgr/broadcaster_test.go: `servicetest.Run(t, eb)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("gas limit lowered after estimation", func(t *testing.T) {
		estimatedGasLimit := uint64(100)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Once()
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(0)
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		dbEtx, err := txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		attempt := dbEtx.TxAttempts[0]
		require.Equal(t, uint64(float32(estimatedGasLimit)*gas.EstimateGasBuffer), attempt.ChainSpecificFeeLimit)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(0)
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(uint64(float32(gasLimit)*limitMultiplier)+1, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `nonce, err = nonceTracker.GetNextSequence(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `eb.Trigger(testutils.NewAddress())`
$DIR/pkg/txmgr/broadcaster_test.go: `eb.Trigger(testutils.NewAddress())`
$DIR/pkg/txmgr/broadcaster_test.go: `c.NonceAutoSync = ptr(true)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `err = eb.Start(ctx)`
$DIR/pkg/txmgr/broadcaster_test.go: `tests.AssertLogEventually(t, observed, "Skipping sequence auto-sync")`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == inProgressTxNonce
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `mustInsertInProgressEthTxWithAttempt(t, txStore, evmtypes.Nonce(inProgressTxNonce), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `nonce = getLocalNextNonce(t, nonceTracker, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("transaction successfully broadcasted and increments on-chain nonce", func(t *testing.T) {
		fromAddress := memKS.MustCreate(t)
		localNonce := uint64(0)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNonce
		}), fromAddress).Return(multinode.Successful, nil).Once()
		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Once()

		mustInsertInProgressEthTxWithAttempt(t, txStore, evmtypes.Nonce(localNonce), fromAddress)
		nonceTracker := txmgr.NewNonceTracker(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
		require.NoError(t, err)
		eb := txmgrcommon.NewBroadcaster(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, nonceTracker, lggr, checkerFactory, false, string(chaintype.ChainHedera), metrics)
		// Mark instance as test
		eb.XXXTestDisableUnstartedTxAutoProcessing()
		servicetest.Run(t, eb)

		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.NoError(t, err)
		require.False(t, retryable)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNonce
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `mustInsertInProgressEthTxWithAttempt(t, txStore, evmtypes.Nonce(localNonce), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `eb.XXXTestDisableUnstartedTxAutoProcessing()`
$DIR/pkg/txmgr/broadcaster_test.go: `servicetest.Run(t, eb)`
$DIR/pkg/txmgr/broadcaster_test.go: `t.Run("transaction successfully broadcasted, failed to increment on-chain nonce, succeeded on bumped retry attempt", func(t *testing.T) {
		fromAddress := memKS.MustCreate(t)
		localNonce := uint64(0)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNonce
		}), fromAddress).Return(multinode.Successful, nil).Twice()
		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()
		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Once()

		mustInsertInProgressEthTxWithAttempt(t, txStore, evmtypes.Nonce(localNonce), fromAddress)
		nonceTracker := txmgr.NewNonceTracker(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
		require.NoError(t, err)
		eb := txmgrcommon.NewBroadcaster(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, nonceTracker, lggr, checkerFactory, false, string(chaintype.ChainHedera), metrics)
		// Mark instance as test
		eb.XXXTestDisableUnstartedTxAutoProcessing()
		servicetest.Run(t, eb)

		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		tests.AssertLogEventually(t, observed, "Bumped fee on initial send")
		require.NoError(t, err)
		require.False(t, retryable)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNonce
		}), fromAddress).Return(multinode.Successful, nil).Twice()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `mustInsertInProgressEthTxWithAttempt(t, txStore, evmtypes.Nonce(localNonce), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `eb.XXXTestDisableUnstartedTxAutoProcessing()`
$DIR/pkg/txmgr/broadcaster_test.go: `servicetest.Run(t, eb)`
$DIR/pkg/txmgr/broadcaster_test.go: `tests.AssertLogEventually(t, observed, "Bumped fee on initial send")`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNonce
		}), fromAddress).Return(multinode.Successful, nil).Times(4)`
$DIR/pkg/txmgr/broadcaster_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Times(4)`
$DIR/pkg/txmgr/broadcaster_test.go: `eb.XXXTestDisableUnstartedTxAutoProcessing()`
$DIR/pkg/txmgr/broadcaster_test.go: `servicetest.Run(t, eb)`
$DIR/pkg/txmgr/broadcaster_test.go: `tests.AssertLogEventually(t, observed, "Bumped fee on initial send")`
$DIR/pkg/txmgr/broadcaster_test.go: `tests.AssertLogEventually(t, observed, "failed to broadcast transaction on hedera after 3 retries")`
$DIR/pkg/txmgr/broadcaster_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewIndependentSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), evmcfg.EVM().GasEstimator(), ethKeyStore, estimator)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Twice()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.String()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmBroadcaster(
		txStore,
		txmClient,
		txmgr.NewEvmTxmConfig(evmcfg.EVM()),
		txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()),
		evmcfg.EVM().Transactions(),
		dbListenerCfg,
		ethKeyStore,
		txBuilder,
		logger.Test(t),
		&testCheckerFactory{},
		false,
		"",
		metrics,
	)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmConfig(evmcfg.EVM())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Transactions()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Start(ctx)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Start(ctx)`
$DIR/pkg/txmgr/broadcaster_test.go: `.XXXTestCloseInternal()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), evmcfg.EVM().GasEstimator(), ethKeyStore, estimator)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), errors.New("Getting on-chain nonce failed"))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New("Getting on-chain nonce failed")`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.String()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmBroadcaster(
		txStore,
		txmClient,
		txmgr.NewEvmTxmConfig(evmcfg.EVM()),
		txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()),
		evmcfg.EVM().Transactions(),
		dbListenerCfg,
		ethKeyStore,
		txBuilder,
		logger.Test(t),
		&testCheckerFactory{},
		false,
		"",
		metrics,
	)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmConfig(evmcfg.EVM())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Transactions()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Start(t.Context())`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, otherAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.HexToAddress("0x6C03DDA95a2AEd917EeCc6eddD4b9D16E6380411")`
$DIR/pkg/txmgr/broadcaster_test.go: `.Now()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(142))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(142)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("no eth_txes at all", func(t *testing.T) {
		retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("eth_txes exist for a different from address", func(t *testing.T) {
		mustCreateUnstartedTx(t, txStore, otherAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("existing eth_txes with broadcast_at or error", func(t *testing.T) {
		nonce := evmtypes.Nonce(342)
		errStr := "some error"

		etxUnconfirmed := txmgr.Tx{
			Sequence:           &nonce,
			FromAddress:        fromAddress,
			ToAddress:          toAddress,
			EncodedPayload:     encodedPayload,
			Value:              value,
			FeeLimit:           gasLimit,
			BroadcastAt:        &timeNow,
			InitialBroadcastAt: &timeNow,
			Error:              null.String{},
			State:              txmgrcommon.TxUnconfirmed,
		}
		etxWithError := txmgr.Tx{
			Sequence:       nil,
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: encodedPayload,
			Value:          value,
			FeeLimit:       gasLimit,
			Error:          null.StringFrom(errStr),
			State:          txmgrcommon.TxFatalError,
		}

		require.NoError(t, txStore.InsertTx(ctx, &etxUnconfirmed))
		require.NoError(t, txStore.InsertTx(ctx, &etxWithError))

		retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce(342)`
$DIR/pkg/txmgr/broadcaster_test.go: `.StringFrom(errStr)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("sends 3 EthTxs in order with higher value last, and lower values starting from the earliest", func(t *testing.T) {
		// Higher value
		expensiveEthTx := txmgr.Tx{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: []byte{42, 42, 0},
			Value:          big.Int(assets.NewEthValue(242)),
			FeeLimit:       gasLimit,
			CreatedAt:      time.Unix(0, 0),
			State:          txmgrcommon.TxUnstarted,
		}
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(2) && tx.Value().Cmp(big.NewInt(242)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Earlier
		tr := int32(99)
		b, err := json.Marshal(txmgr.TxMeta{JobID: &tr})
		require.NoError(t, err)
		meta := sqlutil.JSON(b)
		earlierEthTx := txmgr.Tx{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: []byte{42, 42, 0},
			Value:          value,
			FeeLimit:       gasLimit,
			CreatedAt:      time.Unix(0, 1),
			State:          txmgrcommon.TxUnstarted,
			Meta:           &meta,
		}
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			if tx.Nonce() != uint64(0) {
				return false
			}
			require.Equal(t, evmcfg.EVM().ChainID(), tx.ChainId())
			require.Equal(t, gasLimit, tx.Gas())
			require.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault().ToInt(), tx.GasPrice())
			require.Equal(t, toAddress, *tx.To())
			require.Equal(t, value.String(), tx.Value().String())
			require.Equal(t, earlierEthTx.EncodedPayload, tx.Data())
			return true
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Later
		laterEthTx := txmgr.Tx{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: []byte{42, 42, 1},
			Value:          value,
			FeeLimit:       gasLimit,
			CreatedAt:      time.Unix(1, 0),
			State:          txmgrcommon.TxUnstarted,
		}
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			if tx.Nonce() != uint64(1) {
				return false
			}
			require.Equal(t, evmcfg.EVM().ChainID(), tx.ChainId())
			require.Equal(t, gasLimit, tx.Gas())
			require.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault().ToInt(), tx.GasPrice())
			require.Equal(t, toAddress, *tx.To())
			require.Equal(t, value.String(), tx.Value().String())
			require.Equal(t, laterEthTx.EncodedPayload, tx.Data())
			return true
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Insertion order deliberately reversed to test ordering
		require.NoError(t, txStore.InsertTx(ctx, &expensiveEthTx))
		require.NoError(t, txStore.InsertTx(ctx, &laterEthTx))
		require.NoError(t, txStore.InsertTx(ctx, &earlierEthTx))

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		// Check earlierEthTx and it's attempt
		// This was the earlier one sent so it has the lower nonce
		earlierTransaction, err := txStore.FindTxWithAttempts(ctx, earlierEthTx.ID)
		require.NoError(t, err)
		assert.False(t, earlierTransaction.Error.Valid)
		require.NotNil(t, earlierTransaction.FromAddress)
		assert.Equal(t, fromAddress, earlierTransaction.FromAddress)
		require.NotNil(t, earlierTransaction.Sequence)
		assert.Equal(t, evmtypes.Nonce(0), *earlierTransaction.Sequence)
		assert.NotNil(t, earlierTransaction.BroadcastAt)
		assert.NotNil(t, earlierTransaction.InitialBroadcastAt)
		assert.Len(t, earlierTransaction.TxAttempts, 1)
		var m txmgr.TxMeta
		err = json.Unmarshal(*earlierEthTx.Meta, &m)
		require.NoError(t, err)
		assert.NotNil(t, m.JobID)
		assert.Equal(t, tr, *m.JobID)

		attempt := earlierTransaction.TxAttempts[0]

		assert.Equal(t, earlierTransaction.ID, attempt.TxID)
		assert.NotNil(t, attempt.TxFee.GasPrice)
		assert.Nil(t, attempt.TxFee.GasTipCap)
		assert.Nil(t, attempt.TxFee.GasFeeCap)
		assert.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault(), attempt.TxFee.GasPrice)

		_, err = txmgr.GetGethSignedTx(attempt.SignedRawTx)
		require.NoError(t, err)
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
		require.Len(t, attempt.Receipts, 0)

		// Check laterEthTx and it's attempt
		// This was the later one sent so it has the higher nonce
		laterTransaction, err := txStore.FindTxWithAttempts(ctx, laterEthTx.ID)
		require.NoError(t, err)
		assert.False(t, earlierTransaction.Error.Valid)
		require.NotNil(t, laterTransaction.FromAddress)
		assert.Equal(t, fromAddress, laterTransaction.FromAddress)
		require.NotNil(t, laterTransaction.Sequence)
		assert.Equal(t, evmtypes.Nonce(1), *laterTransaction.Sequence)
		assert.NotNil(t, laterTransaction.BroadcastAt)
		assert.NotNil(t, earlierTransaction.InitialBroadcastAt)
		assert.Len(t, laterTransaction.TxAttempts, 1)

		attempt = laterTransaction.TxAttempts[0]

		assert.Equal(t, laterTransaction.ID, attempt.TxID)
		assert.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault(), attempt.TxFee.GasPrice)

		_, err = txmgr.GetGethSignedTx(attempt.SignedRawTx)
		require.NoError(t, err)
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
		require.Len(t, attempt.Receipts, 0)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(242))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(242)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Unix(0, 0)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(2) && tx.Value().Cmp(big.NewInt(242)) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(2) && tx.Value().Cmp(big.NewInt(242)) == 0
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Value()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(big.NewInt(242))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(242)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Marshal(txmgr.TxMeta{JobID: &tr})`
$DIR/pkg/txmgr/broadcaster_test.go: `.JSON(b)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Unix(0, 1)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			if tx.Nonce() != uint64(0) {
				return false
			}
			require.Equal(t, evmcfg.EVM().ChainID(), tx.ChainId())
			require.Equal(t, gasLimit, tx.Gas())
			require.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault().ToInt(), tx.GasPrice())
			require.Equal(t, toAddress, *tx.To())
			require.Equal(t, value.String(), tx.Value().String())
			require.Equal(t, earlierEthTx.EncodedPayload, tx.Data())
			return true
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			if tx.Nonce() != uint64(0) {
				return false
			}
			require.Equal(t, evmcfg.EVM().ChainID(), tx.ChainId())
			require.Equal(t, gasLimit, tx.Gas())
			require.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault().ToInt(), tx.GasPrice())
			require.Equal(t, toAddress, *tx.To())
			require.Equal(t, value.String(), tx.Value().String())
			require.Equal(t, earlierEthTx.EncodedPayload, tx.Data())
			return true
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Unix(1, 0)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			if tx.Nonce() != uint64(1) {
				return false
			}
			require.Equal(t, evmcfg.EVM().ChainID(), tx.ChainId())
			require.Equal(t, gasLimit, tx.Gas())
			require.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault().ToInt(), tx.GasPrice())
			require.Equal(t, toAddress, *tx.To())
			require.Equal(t, value.String(), tx.Value().String())
			require.Equal(t, laterEthTx.EncodedPayload, tx.Data())
			return true
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			if tx.Nonce() != uint64(1) {
				return false
			}
			require.Equal(t, evmcfg.EVM().ChainID(), tx.ChainId())
			require.Equal(t, gasLimit, tx.Gas())
			require.Equal(t, evmcfg.EVM().GasEstimator().PriceDefault().ToInt(), tx.GasPrice())
			require.Equal(t, toAddress, *tx.To())
			require.Equal(t, value.String(), tx.Value().String())
			require.Equal(t, laterEthTx.EncodedPayload, tx.Data())
			return true
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, earlierEthTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Unmarshal(*earlierEthTx.Meta, &m)`
$DIR/pkg/txmgr/broadcaster_test.go: `.GetGethSignedTx(attempt.SignedRawTx)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, laterEthTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.GetGethSignedTx(attempt.SignedRawTx)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Intn(5000)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.GasEstimator.EIP1559DynamicFees = ptr(true)
		c.GasEstimator.TipCapDefault = assets.NewWeiI(rnd)
		c.GasEstimator.FeeCapDefault = assets.NewWeiI(rnd + 1)
		c.GasEstimator.PriceMax = assets.NewWeiI(rnd + 2)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewWeiI(rnd)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewWeiI(rnd + 1)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewWeiI(rnd + 2)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, otherAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(1), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("sends transactions with type 0x2 in EIP-1559 mode", func(t *testing.T) {
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(343) && tx.Value().Cmp(big.NewInt(242)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()

		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, []byte{42, 42, 0}, gasLimit, big.Int(assets.NewEthValue(242)), testutils.FixtureChainID)
		// Do the thing
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check eipTxWithAl and it's attempt
		// This was the earlier one sent so it has the lower nonce
		etx, err := txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		assert.False(t, etx.Error.Valid)
		require.NotNil(t, etx.FromAddress)
		assert.Equal(t, fromAddress, etx.FromAddress)
		require.NotNil(t, etx.Sequence)
		assert.Equal(t, evmtypes.Nonce(343), *etx.Sequence)
		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		assert.Len(t, etx.TxAttempts, 1)

		attempt := etx.TxAttempts[0]

		assert.Equal(t, etx.ID, attempt.TxID)
		assert.Nil(t, attempt.TxFee.GasPrice)
		assert.Equal(t, rnd, attempt.TxFee.GasTipCap.ToInt().Int64())
		assert.Equal(t, rnd+1, attempt.TxFee.GasFeeCap.ToInt().Int64())

		_, err = txmgr.GetGethSignedTx(attempt.SignedRawTx)
		require.NoError(t, err)
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
		require.Len(t, attempt.Receipts, 0)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(343) && tx.Value().Cmp(big.NewInt(242)) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(343) && tx.Value().Cmp(big.NewInt(242)) == 0
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Value()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(big.NewInt(242))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(242)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(242))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(242)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.GetGethSignedTx(attempt.SignedRawTx)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("when simulation succeeds, sends tx as normal", func(t *testing.T) {
			txRequest := txmgr.TxRequest{
				FromAddress:    fromAddress,
				ToAddress:      toAddress,
				EncodedPayload: []byte{42, 0, 0},
				Value:          big.Int(assets.NewEthValue(442)),
				FeeLimit:       gasLimit,
				Strategy:       txmgrcommon.NewSendEveryStrategy(),
				Checker: txmgr.TransmitCheckerSpec{
					CheckerType: txmgr.TransmitCheckerTypeSimulate,
				},
			}
			ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(344) && tx.Value().Cmp(big.NewInt(442)) == 0
			}), fromAddress).Return(multinode.Successful, nil).Once()
			ethClient.On("CallContext", mock.Anything, mock.AnythingOfType("*hexutil.Bytes"), "eth_call", mock.MatchedBy(func(callarg map[string]interface{}) bool {
				if fmt.Sprintf("%s", callarg["value"]) == "0x1ba" { // 442
					assert.Equal(t, txRequest.FromAddress, callarg["from"])
					assert.Equal(t, &txRequest.ToAddress, callarg["to"])
					assert.Equal(t, hexutil.Uint64(txRequest.FeeLimit), callarg["gas"])
					assert.Nil(t, callarg["gasPrice"])
					assert.Nil(t, callarg["maxFeePerGas"])
					assert.Nil(t, callarg["maxPriorityFeePerGas"])
					assert.Equal(t, (*hexutil.Big)(&txRequest.Value), callarg["value"])
					assert.Equal(t, hexutil.Bytes(txRequest.EncodedPayload), callarg["data"])
					return true
				}
				return false
			}), "latest").Return(nil).Once()

			ethTx := mustCreateUnstartedTxFromEvmTxRequest(t, txStore, txRequest, testutils.FixtureChainID)

			{
				retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
				assert.NoError(t, err)
				assert.False(t, retryable)
			}

			// Check ethtx was sent
			ethTx, err := txStore.FindTxWithAttempts(ctx, ethTx.ID)
			require.NoError(t, err)
			assert.Equal(t, txmgrcommon.TxUnconfirmed, ethTx.State)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(442))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(442)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSendEveryStrategy()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(344) && tx.Value().Cmp(big.NewInt(442)) == 0
			}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(344) && tx.Value().Cmp(big.NewInt(442)) == 0
			})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Value()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(big.NewInt(442))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(442)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("CallContext", mock.Anything, mock.AnythingOfType("*hexutil.Bytes"), "eth_call", mock.MatchedBy(func(callarg map[string]interface{}) bool {
				if fmt.Sprintf("%s", callarg["value"]) == "0x1ba" { // 442
					assert.Equal(t, txRequest.FromAddress, callarg["from"])
					assert.Equal(t, &txRequest.ToAddress, callarg["to"])
					assert.Equal(t, hexutil.Uint64(txRequest.FeeLimit), callarg["gas"])
					assert.Nil(t, callarg["gasPrice"])
					assert.Nil(t, callarg["maxFeePerGas"])
					assert.Nil(t, callarg["maxPriorityFeePerGas"])
					assert.Equal(t, (*hexutil.Big)(&txRequest.Value), callarg["value"])
					assert.Equal(t, hexutil.Bytes(txRequest.EncodedPayload), callarg["data"])
					return true
				}
				return false
			}), "latest")`
$DIR/pkg/txmgr/broadcaster_test.go: `.AnythingOfType("*hexutil.Bytes")`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(callarg map[string]interface{}) bool {
				if fmt.Sprintf("%s", callarg["value"]) == "0x1ba" { // 442
					assert.Equal(t, txRequest.FromAddress, callarg["from"])
					assert.Equal(t, &txRequest.ToAddress, callarg["to"])
					assert.Equal(t, hexutil.Uint64(txRequest.FeeLimit), callarg["gas"])
					assert.Nil(t, callarg["gasPrice"])
					assert.Nil(t, callarg["maxFeePerGas"])
					assert.Nil(t, callarg["maxPriorityFeePerGas"])
					assert.Equal(t, (*hexutil.Big)(&txRequest.Value), callarg["value"])
					assert.Equal(t, hexutil.Bytes(txRequest.EncodedPayload), callarg["data"])
					return true
				}
				return false
			})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Sprintf("%s", callarg["value"])`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, ethTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("with unknown error, sends tx as normal", func(t *testing.T) {
			ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(345) && tx.Value().Cmp(big.NewInt(542)) == 0
			}), fromAddress).Return(multinode.Successful, nil).Once()
			ethClient.On("CallContext", mock.Anything, mock.AnythingOfType("*hexutil.Bytes"), "eth_call", mock.MatchedBy(func(callarg map[string]interface{}) bool {
				return fmt.Sprintf("%s", callarg["value"]) == "0x21e" // 542
			}), "latest").Return(errors.New("this is not a revert, something unexpected went wrong")).Once()

			ethTx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID,
				txRequestWithChecker(checker),
				txRequestWithValue(big.Int(assets.NewEthValue(542))))

			{
				retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
				assert.NoError(t, err)
				assert.False(t, retryable)
			}

			ethTx, err := txStore.FindTxWithAttempts(ctx, ethTx.ID)
			require.NoError(t, err)
			assert.Equal(t, txmgrcommon.TxUnconfirmed, ethTx.State)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(345) && tx.Value().Cmp(big.NewInt(542)) == 0
			}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(345) && tx.Value().Cmp(big.NewInt(542)) == 0
			})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Value()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(big.NewInt(542))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(542)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("CallContext", mock.Anything, mock.AnythingOfType("*hexutil.Bytes"), "eth_call", mock.MatchedBy(func(callarg map[string]interface{}) bool {
				return fmt.Sprintf("%s", callarg["value"]) == "0x21e" // 542
			}), "latest")`
$DIR/pkg/txmgr/broadcaster_test.go: `.AnythingOfType("*hexutil.Bytes")`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(callarg map[string]interface{}) bool {
				return fmt.Sprintf("%s", callarg["value"]) == "0x21e" // 542
			})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Sprintf("%s", callarg["value"])`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(errors.New("this is not a revert, something unexpected went wrong"))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New("this is not a revert, something unexpected went wrong")`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(542))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(542)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, ethTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("on revert, marks tx as fatally errored and does not send", func(t *testing.T) {
			jerr := client.JsonError{
				Code:    42,
				Message: "oh no, it reverted",
				Data:    []byte{42, 166, 34},
			}
			ethClient.On("CallContext", mock.Anything, mock.AnythingOfType("*hexutil.Bytes"), "eth_call", mock.MatchedBy(func(callarg map[string]interface{}) bool {
				return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
			}), "latest").Return(&jerr).Once()

			ethTx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID,
				txRequestWithChecker(checker),
				txRequestWithValue(big.Int(assets.NewEthValue(642))))
			{
				retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
				assert.NoError(t, err)
				assert.False(t, retryable)
			}

			ethTx, err := txStore.FindTxWithAttempts(ctx, ethTx.ID)
			require.NoError(t, err)
			assert.Equal(t, txmgrcommon.TxFatalError, ethTx.State)
			assert.True(t, ethTx.Error.Valid)
			assert.Equal(t, "transaction reverted during simulation: json-rpc error { Code = 42, Message = 'oh no, it reverted', Data = 'KqYi' }", ethTx.Error.String)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("CallContext", mock.Anything, mock.AnythingOfType("*hexutil.Bytes"), "eth_call", mock.MatchedBy(func(callarg map[string]interface{}) bool {
				return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
			}), "latest")`
$DIR/pkg/txmgr/broadcaster_test.go: `.AnythingOfType("*hexutil.Bytes")`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(callarg map[string]interface{}) bool {
				return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
			})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Sprintf("%s", callarg["value"])`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(&jerr)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(642))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(642)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, ethTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("terminally stuck transaction is marked as fatal", func(t *testing.T) {
			terminallyStuckError := "failed to add tx to the pool: not enough step counters to continue the execution"
			etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, []byte{42, 42, 0}, gasLimit, big.Int(assets.NewEthValue(243)), testutils.FixtureChainID)
			ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(346) && tx.Value().Cmp(big.NewInt(243)) == 0
			}), fromAddress).Return(multinode.Fatal, errors.New(terminallyStuckError)).Once()

			// Start processing unstarted transactions
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)

			dbTx, err := txStore.FindTxWithAttempts(ctx, etx.ID)
			require.NoError(t, err)
			assert.Equal(t, txmgrcommon.TxFatalError, dbTx.State)
			assert.True(t, dbTx.Error.Valid)
			assert.Equal(t, terminallyStuckError, dbTx.Error.String)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(243))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(243)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(346) && tx.Value().Cmp(big.NewInt(243)) == 0
			}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == uint64(346) && tx.Value().Cmp(big.NewInt(243)) == 0
			})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Value()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(big.NewInt(243))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(243)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Fatal, errors.New(terminallyStuckError))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(terminallyStuckError)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("when transmit checking times out, sends tx as normal", func(t *testing.T) {
		// Checker will return a canceled error
		checkerFactory.err = context.Canceled

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == 0 && tx.Value().Cmp(big.NewInt(442)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()

		ethTx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID,
			txRequestWithValue(big.Int(assets.NewEthValue(442))),
			txRequestWithChecker(checker))
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check ethtx was sent
		ethTx, err := txStore.FindTxWithAttempts(ctx, ethTx.ID)
		require.NoError(t, err)
		assert.Equal(t, txmgrcommon.TxUnconfirmed, ethTx.State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == 0 && tx.Value().Cmp(big.NewInt(442)) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == 0 && tx.Value().Cmp(big.NewInt(442)) == 0
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Value()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(big.NewInt(442))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(442)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(442))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(442)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, ethTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("when transmit checking succeeds, sends tx as normal", func(t *testing.T) {
		// Checker will return no error
		checkerFactory.err = nil

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == 1 && tx.Value().Cmp(big.NewInt(442)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()

		ethTx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID,
			txRequestWithValue(big.Int(assets.NewEthValue(442))),
			txRequestWithChecker(checker))
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check ethtx was sent
		ethTx, err := txStore.FindTxWithAttempts(ctx, ethTx.ID)
		require.NoError(t, err)
		assert.Equal(t, txmgrcommon.TxUnconfirmed, ethTx.State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == 1 && tx.Value().Cmp(big.NewInt(442)) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == 1 && tx.Value().Cmp(big.NewInt(442)) == 0
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Value()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(big.NewInt(442))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(442)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(442))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(442)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, ethTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.New("fatal checker error")`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, ethTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewIndependentSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmConfig(ccfg.EVM())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), ccfg.EVM().GasEstimator(), ethKeyStore, estimator)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("GetFee", mock.Anything, mock.Anything, mock.Anything, ccfg.EVM().GasEstimator().PriceMaxKey(fromAddress), mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.PriceMaxKey(fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(gas.EvmFee{GasPrice: assets.GWei(1)}, uint64(500), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.GWei(1)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run(func(_ mock.Arguments) {
		close(chStartEstimate)
		<-chBlock
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.String()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmBroadcaster(
		txStore,
		txmClient,
		evmcfg,
		txmgr.NewEvmTxmFeeConfig(ccfg.EVM().GasEstimator()),
		ccfg.EVM().Transactions(),
		dbListenerCfg,
		ethKeyStore,
		txBuilder,
		logger.Test(t),
		&testCheckerFactory{},
		false,
		"",
		metrics,
	)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmFeeConfig(ccfg.EVM().GasEstimator())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Transactions()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.XXXTestDisableUnstartedTxAutoProcessing()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run(t, eb)`
$DIR/pkg/txmgr/broadcaster_test.go: `.After(5 * time.Second)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		// Configured gas price changed
		lm := decimal.RequireFromString("1.3")
		c.GasEstimator.LimitMultiplier = &lm
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.RequireFromString("1.3")`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
		assert.Equal(t, int(1600), int(tx.Gas()))
		return true
	}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
		assert.Equal(t, int(1600), int(tx.Gas()))
		return true
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.HexToAddress("0x6C03DDA95a2AEd917EeCc6eddD4b9D16E6380411")`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(242))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(242)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSendEveryStrategy()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.HexToAddress("0x6C03DDA95a2AEd917EeCc6eddD4b9D16E6380411")`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(142))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(142)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce(916714082576372851)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("cannot be more than one transaction per address in an unfinished state", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()

		firstInProgress := txmgr.Tx{
			FromAddress:    fromAddress,
			Sequence:       &firstNonce,
			ToAddress:      toAddress,
			EncodedPayload: encodedPayload,
			Value:          value,
			FeeLimit:       gasLimit,
			Error:          null.String{},
			State:          txmgrcommon.TxInProgress,
		}

		secondInProgress := txmgr.Tx{
			FromAddress:    fromAddress,
			Sequence:       &secondNonce,
			ToAddress:      toAddress,
			EncodedPayload: encodedPayload,
			Value:          value,
			FeeLimit:       gasLimit,
			Error:          null.String{},
			State:          txmgrcommon.TxInProgress,
		}

		require.NoError(t, txStore.InsertTx(ctx, &firstInProgress))
		err := txStore.InsertTx(ctx, &secondInProgress)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "ERROR: duplicate key value violates unique constraint \"idx_only_one_in_progress_tx_per_account_id_per_evm_chain_id\" (SQLSTATE 23505)")
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewAddress()`
$DIR/pkg/txmgr/broadcaster_test.go: `.InsertTx(ctx, &secondInProgress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("previous run assigned nonce but never broadcast", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		evmcfg := configtest.NewChainScopedConfig(t, nil)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()
		nonceTracker := txmgr.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		eb := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)

		// Crashed right after we commit the database transaction that saved
		// the nonce to the eth_tx so evm.key_states.next_nonce has not been
		// incremented yet
		inProgressEthTx := mustInsertInProgressEthTxWithAttempt(t, txStore, firstNonce, fromAddress)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Do the thing
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check it was saved correctly with its attempt
		etx, err := txStore.FindTxWithAttempts(ctx, inProgressEthTx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, etx.TxAttempts[0].State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, inProgressEthTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("previous run assigned nonce and broadcast but it fatally errored before we could save", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		evmcfg := configtest.NewChainScopedConfig(t, nil)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()
		nonceTracker := txmgr.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		eb := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)

		// Crashed right after we commit the database transaction that saved the nonce to the eth_tx
		inProgressEthTx := mustInsertInProgressEthTxWithAttempt(t, txStore, firstNonce, fromAddress)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.Fatal, errors.New("exceeds block gas limit")).Once()

		// Do the thing
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check it was saved correctly with its attempt
		etx, err := txStore.FindTxWithAttempts(ctx, inProgressEthTx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		assert.True(t, etx.Error.Valid)
		assert.Equal(t, "exceeds block gas limit", etx.Error.String)
		assert.Len(t, etx.TxAttempts, 0)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Fatal, errors.New("exceeds block gas limit"))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New("exceeds block gas limit")`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, inProgressEthTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("previous run assigned nonce and broadcast and is now in mempool", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		evmcfg := configtest.NewChainScopedConfig(t, nil)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()
		nonceTracker := txmgr.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		eb := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)

		// Crashed right after we commit the database transaction that saved the nonce to the eth_tx
		inProgressEthTx := mustInsertInProgressEthTxWithAttempt(t, txStore, firstNonce, fromAddress)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.Successful, errors.New("known transaction: a1313bd99a81fb4d8ad1d2e90b67c6b3fa77545c990d6251444b83b70b6f8980")).Once()

		// Do the thing
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check it was saved correctly with its attempt
		etx, err := txStore.FindTxWithAttempts(ctx, inProgressEthTx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, errors.New("known transaction: a1313bd99a81fb4d8ad1d2e90b67c6b3fa77545c990d6251444b83b70b6f8980"))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New("known transaction: a1313bd99a81fb4d8ad1d2e90b67c6b3fa77545c990d6251444b83b70b6f8980")`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, inProgressEthTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("previous run assigned nonce and broadcast and now the transaction has been confirmed", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		evmcfg := configtest.NewChainScopedConfig(t, nil)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()
		nonceTracker := txmgr.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		eb := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)

		// Crashed right after we commit the database transaction that saved the nonce to the eth_tx
		inProgressEthTx := mustInsertInProgressEthTxWithAttempt(t, txStore, firstNonce, fromAddress)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.TransactionAlreadyKnown, errors.New("nonce too low")).Once()

		// Do the thing
		{
			retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)
		}

		// Check it was saved correctly with its attempt
		etx, err := txStore.FindTxWithAttempts(ctx, inProgressEthTx.ID)
		require.NoError(t, err)

		require.NotNil(t, etx.BroadcastAt)
		assert.Equal(t, *etx.BroadcastAt, etx.CreatedAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.TransactionAlreadyKnown, errors.New("nonce too low"))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New("nonce too low")`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, inProgressEthTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("previous run assigned nonce and then failed to reach node for some reason and node is still down", func(t *testing.T) {
		failedToReachNodeError := context.DeadlineExceeded
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		evmcfg := configtest.NewChainScopedConfig(t, nil)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()
		nonceTracker := txmgr.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		eb := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)

		// Crashed right after we commit the database transaction that saved the nonce to the eth_tx
		inProgressEthTx := mustInsertInProgressEthTxWithAttempt(t, txStore, firstNonce, fromAddress)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress).Return(multinode.Retryable, failedToReachNodeError).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(t.Context(), fromAddress)
		require.Error(t, err)
		assert.Contains(t, err.Error(), failedToReachNodeError.Error())
		assert.True(t, retryable)

		// Check it was left in the unfinished state
		etx, err := txStore.FindTxWithAttempts(ctx, inProgressEthTx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		assert.Equal(t, nextNonce, *etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(firstNonce)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Retryable, failedToReachNodeError)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, inProgressEthTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			// Configured gas price changed
			c.GasEstimator.PriceDefault = assets.NewWeiI(500000000000)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewWeiI(500000000000)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			// Ensure that the gas price is the same as the original attempt
			s, e := txmgr.GetGethSignedTx(attempt.SignedRawTx)
			require.NoError(t, e)
			return tx.Nonce() == uint64(firstNonce) && tx.GasPrice().Int64() == s.GasPrice().Int64()
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			// Ensure that the gas price is the same as the original attempt
			s, e := txmgr.GetGethSignedTx(attempt.SignedRawTx)
			require.NoError(t, e)
			return tx.Nonce() == uint64(firstNonce) && tx.GasPrice().Int64() == s.GasPrice().Int64()
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.GetGethSignedTx(attempt.SignedRawTx)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasPrice()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int64()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasPrice()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int64()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, errors.New("known transaction: a1313bd99a81fb4d8ad1d2e90b67c6b3fa77545c990d6251444b83b70b6f8980"))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New("known transaction: a1313bd99a81fb4d8ad1d2e90b67c6b3fa77545c990d6251444b83b70b6f8980")`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(t.Context(), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, inProgressEthTx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.GetGethSignedTx(attempt.SignedRawTx)`
$DIR/pkg/txmgr/broadcaster_test.go: `.HexToAddress("0x6C03DDA95a2AEd917EeCc6eddD4b9D16E6380411")`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(142))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(142)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(lggr, txStore, txmClient)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("if external wallet sent a transaction from the account and now the nonce is one higher than it should be and we got replacement underpriced then we assume a previous transaction of ours was the one that succeeded, and hand off to EthConfirmer", func(t *testing.T) {
		mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		// First send, replacement underpriced
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(0)
		}), fromAddress).Return(multinode.Successful, errors.New("replacement transaction underpriced")).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		// Check that the transaction was saved correctly with its attempt
		// We assume success and hand off to eth confirmer to eventually mark it as failed
		var latestID int64
		var etx1 txmgr.Tx
		require.NoError(t, db.Get(&latestID, "SELECT max(id) FROM evm.txes"))
		etx1, err = txStore.FindTxWithAttempts(ctx, latestID)
		require.NoError(t, err)
		require.NotNil(t, etx1.BroadcastAt)
		assert.NotEqual(t, etx1.CreatedAt, *etx1.BroadcastAt)
		assert.NotNil(t, etx1.InitialBroadcastAt)
		require.NotNil(t, etx1.Sequence)
		assert.Equal(t, evmtypes.Nonce(0), *etx1.Sequence)
		assert.False(t, etx1.Error.Valid)
		assert.Len(t, etx1.TxAttempts, 1)

		// Check that the local nonce was incremented by one
		finalNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		require.NoError(t, err)
		require.NotNil(t, finalNextNonce)
		require.Equal(t, int64(1), int64(finalNextNonce))
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(0)
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(0)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, errors.New("replacement transaction underpriced"))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New("replacement transaction underpriced")`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, latestID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("geth Client returns an error in the fatal errors category", func(t *testing.T) {
		fatalErrorExample := "exceeds block gas limit"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)

		t.Run("without callback", func(t *testing.T) {
			etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
			ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == localNextNonce
			}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

			retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)

			// Check it was saved correctly with its attempt
			etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
			require.NoError(t, err)

			assert.Nil(t, etx.BroadcastAt)
			assert.Nil(t, etx.InitialBroadcastAt)
			require.Nil(t, etx.Sequence)
			assert.True(t, etx.Error.Valid)
			assert.Contains(t, etx.Error.String, "exceeds block gas limit")
			assert.Len(t, etx.TxAttempts, 0)

			// Check that the key had its nonce reset
			var nonce evmtypes.Nonce
			nonce, err = nonceTracker.GetNextSequence(ctx, fromAddress)
			require.NoError(t, err)
			// Saved NextNonce must be the same as before because this transaction
			// was not accepted by the eth node and never can be
			require.Equal(t, int64(localNextNonce), int64(nonce))
		})

		t.Run("with callback", func(t *testing.T) {
			runID := testutils.MustInsertPipelineRun(t, db)
			trID := testutils.MustInsertUnfinishedPipelineTaskRun(t, db, runID)
			etx := txmgr.Tx{
				FromAddress:       fromAddress,
				ToAddress:         toAddress,
				EncodedPayload:    encodedPayload,
				Value:             value,
				FeeLimit:          gasLimit,
				State:             txmgrcommon.TxUnstarted,
				PipelineTaskRunID: uuid.NullUUID{UUID: trID, Valid: true},
				SignalCallback:    true,
			}

			t.Run("with erroring callback bails out", func(t *testing.T) {
				require.NoError(t, txStore.InsertTx(t.Context(), &etx))
				fn := func(ctx context.Context, id uuid.UUID, result interface{}, err error) error {
					return errors.New("something exploded in the callback")
				}

				eb.SetResumeCallback(fn)

				ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

				retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
				require.Error(t, err)
				require.Contains(t, err.Error(), "something exploded in the callback")
				assert.True(t, retryable)
			})

			t.Run("calls resume with error", func(t *testing.T) {
				fn := func(ctx context.Context, id uuid.UUID, result interface{}, err error) error {
					require.Equal(t, id, trID)
					require.Nil(t, result)
					require.Error(t, err)
					require.Contains(t, err.Error(), "fatal error while sending transaction: exceeds block gas limit")
					return nil
				}

				eb.SetResumeCallback(fn)

				ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

				{
					retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				}

				// same as the parent test, but callback is set by ctor
				t.Run("callback set by ctor", func(t *testing.T) {
					evmcfg := configtest.NewChainScopedConfig(t, nil)
					estimator := gas.NewEvmFeeEstimator(lggr, func(lggr logger.Logger) gas.EvmEstimator {
						return gas.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, evmcfg.EVM().GasEstimator().BlockHistory(), lggr, nil)
					}, evmcfg.EVM().GasEstimator().EIP1559DynamicFees(), evmcfg.EVM().GasEstimator(), ethClient)
					txBuilder := txmgr.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), evmcfg.EVM().GasEstimator(), ethKeyStore, estimator)
					localNextNonce = getLocalNextNonce(t, nonceTracker, fromAddress)
					metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
					require.NoError(t, err)
					eb2 := txmgr.NewEvmBroadcaster(txStore, txmClient, txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, lggr, &testCheckerFactory{}, false, "", metrics)
					retryable, err := eb2.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				})
			})
		})
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("without callback", func(t *testing.T) {
			etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
			ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == localNextNonce
			}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

			retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
			assert.NoError(t, err)
			assert.False(t, retryable)

			// Check it was saved correctly with its attempt
			etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
			require.NoError(t, err)

			assert.Nil(t, etx.BroadcastAt)
			assert.Nil(t, etx.InitialBroadcastAt)
			require.Nil(t, etx.Sequence)
			assert.True(t, etx.Error.Valid)
			assert.Contains(t, etx.Error.String, "exceeds block gas limit")
			assert.Len(t, etx.TxAttempts, 0)

			// Check that the key had its nonce reset
			var nonce evmtypes.Nonce
			nonce, err = nonceTracker.GetNextSequence(ctx, fromAddress)
			require.NoError(t, err)
			// Saved NextNonce must be the same as before because this transaction
			// was not accepted by the eth node and never can be
			require.Equal(t, int64(localNextNonce), int64(nonce))
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == localNextNonce
			}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
				return tx.Nonce() == localNextNonce
			})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Fatal, errors.New(fatalErrorExample))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(fatalErrorExample)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.GetNextSequence(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("with callback", func(t *testing.T) {
			runID := testutils.MustInsertPipelineRun(t, db)
			trID := testutils.MustInsertUnfinishedPipelineTaskRun(t, db, runID)
			etx := txmgr.Tx{
				FromAddress:       fromAddress,
				ToAddress:         toAddress,
				EncodedPayload:    encodedPayload,
				Value:             value,
				FeeLimit:          gasLimit,
				State:             txmgrcommon.TxUnstarted,
				PipelineTaskRunID: uuid.NullUUID{UUID: trID, Valid: true},
				SignalCallback:    true,
			}

			t.Run("with erroring callback bails out", func(t *testing.T) {
				require.NoError(t, txStore.InsertTx(t.Context(), &etx))
				fn := func(ctx context.Context, id uuid.UUID, result interface{}, err error) error {
					return errors.New("something exploded in the callback")
				}

				eb.SetResumeCallback(fn)

				ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

				retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
				require.Error(t, err)
				require.Contains(t, err.Error(), "something exploded in the callback")
				assert.True(t, retryable)
			})

			t.Run("calls resume with error", func(t *testing.T) {
				fn := func(ctx context.Context, id uuid.UUID, result interface{}, err error) error {
					require.Equal(t, id, trID)
					require.Nil(t, result)
					require.Error(t, err)
					require.Contains(t, err.Error(), "fatal error while sending transaction: exceeds block gas limit")
					return nil
				}

				eb.SetResumeCallback(fn)

				ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

				{
					retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				}

				// same as the parent test, but callback is set by ctor
				t.Run("callback set by ctor", func(t *testing.T) {
					evmcfg := configtest.NewChainScopedConfig(t, nil)
					estimator := gas.NewEvmFeeEstimator(lggr, func(lggr logger.Logger) gas.EvmEstimator {
						return gas.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, evmcfg.EVM().GasEstimator().BlockHistory(), lggr, nil)
					}, evmcfg.EVM().GasEstimator().EIP1559DynamicFees(), evmcfg.EVM().GasEstimator(), ethClient)
					txBuilder := txmgr.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), evmcfg.EVM().GasEstimator(), ethKeyStore, estimator)
					localNextNonce = getLocalNextNonce(t, nonceTracker, fromAddress)
					metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
					require.NoError(t, err)
					eb2 := txmgr.NewEvmBroadcaster(txStore, txmClient, txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, lggr, &testCheckerFactory{}, false, "", metrics)
					retryable, err := eb2.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				})
			})
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustInsertPipelineRun(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustInsertUnfinishedPipelineTaskRun(t, db, runID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("with erroring callback bails out", func(t *testing.T) {
				require.NoError(t, txStore.InsertTx(t.Context(), &etx))
				fn := func(ctx context.Context, id uuid.UUID, result interface{}, err error) error {
					return errors.New("something exploded in the callback")
				}

				eb.SetResumeCallback(fn)

				ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

				retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
				require.Error(t, err)
				require.Contains(t, err.Error(), "something exploded in the callback")
				assert.True(t, retryable)
			})`
$DIR/pkg/txmgr/broadcaster_test.go: `.New("something exploded in the callback")`
$DIR/pkg/txmgr/broadcaster_test.go: `.SetResumeCallback(fn)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Fatal, errors.New(fatalErrorExample))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(fatalErrorExample)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("calls resume with error", func(t *testing.T) {
				fn := func(ctx context.Context, id uuid.UUID, result interface{}, err error) error {
					require.Equal(t, id, trID)
					require.Nil(t, result)
					require.Error(t, err)
					require.Contains(t, err.Error(), "fatal error while sending transaction: exceeds block gas limit")
					return nil
				}

				eb.SetResumeCallback(fn)

				ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress).Return(multinode.Fatal, errors.New(fatalErrorExample)).Once()

				{
					retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				}

				// same as the parent test, but callback is set by ctor
				t.Run("callback set by ctor", func(t *testing.T) {
					evmcfg := configtest.NewChainScopedConfig(t, nil)
					estimator := gas.NewEvmFeeEstimator(lggr, func(lggr logger.Logger) gas.EvmEstimator {
						return gas.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, evmcfg.EVM().GasEstimator().BlockHistory(), lggr, nil)
					}, evmcfg.EVM().GasEstimator().EIP1559DynamicFees(), evmcfg.EVM().GasEstimator(), ethClient)
					txBuilder := txmgr.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), evmcfg.EVM().GasEstimator(), ethKeyStore, estimator)
					localNextNonce = getLocalNextNonce(t, nonceTracker, fromAddress)
					metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
					require.NoError(t, err)
					eb2 := txmgr.NewEvmBroadcaster(txStore, txmClient, txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, lggr, &testCheckerFactory{}, false, "", metrics)
					retryable, err := eb2.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				})
			})`
$DIR/pkg/txmgr/broadcaster_test.go: `.SetResumeCallback(fn)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
					return tx.Nonce() == localNextNonce
				})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Fatal, errors.New(fatalErrorExample))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(fatalErrorExample)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("callback set by ctor", func(t *testing.T) {
					evmcfg := configtest.NewChainScopedConfig(t, nil)
					estimator := gas.NewEvmFeeEstimator(lggr, func(lggr logger.Logger) gas.EvmEstimator {
						return gas.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, evmcfg.EVM().GasEstimator().BlockHistory(), lggr, nil)
					}, evmcfg.EVM().GasEstimator().EIP1559DynamicFees(), evmcfg.EVM().GasEstimator(), ethClient)
					txBuilder := txmgr.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), evmcfg.EVM().GasEstimator(), ethKeyStore, estimator)
					localNextNonce = getLocalNextNonce(t, nonceTracker, fromAddress)
					metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
					require.NoError(t, err)
					eb2 := txmgr.NewEvmBroadcaster(txStore, txmClient, txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, lggr, &testCheckerFactory{}, false, "", metrics)
					retryable, err := eb2.ProcessUnstartedTxs(ctx, fromAddress)
					assert.NoError(t, err)
					assert.False(t, retryable)
				})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmFeeEstimator(lggr, func(lggr logger.Logger) gas.EvmEstimator {
						return gas.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, evmcfg.EVM().GasEstimator().BlockHistory(), lggr, nil)
					}, evmcfg.EVM().GasEstimator().EIP1559DynamicFees(), evmcfg.EVM().GasEstimator(), ethClient)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, evmcfg.EVM().GasEstimator().BlockHistory(), lggr, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.BlockHistory()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EIP1559DynamicFees()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), evmcfg.EVM().GasEstimator(), ethKeyStore, estimator)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.String()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmBroadcaster(txStore, txmClient, txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, lggr, &testCheckerFactory{}, false, "", metrics)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmConfig(evmcfg.EVM())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Transactions()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.SetResumeCallback(nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("geth Client fails with error indicating that the transaction was too expensive", func(t *testing.T) {
		TxFeeExceedsCapError := "tx fee (1.10 ether) exceeds the configured cap (1.00 ether)"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(localNextNonce, nil).Once()
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.ExceedsMaxFee, errors.New(TxFeeExceedsCapError)).Twice()
		// In the first case, the tx was NOT accepted into the mempool. In the case
		// of multiple RPC nodes, it is possible that it can be accepted by
		// another node even if the primary one returns "exceeds the configured
		// cap"

		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "tx fee (1.10 ether) exceeds the configured cap (1.00 ether)")
		assert.Contains(t, err.Error(), "error while sending transaction")
		assert.True(t, retryable)

		// Check it was saved with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt) // Note that InitialBroadcastAt really means "InitialDefinitelySuccessfulBroadcastAt"
		assert.Equal(t, evmtypes.Nonce(localNextNonce), *etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)

		// Check that the key had its nonce reset
		var nonce evmtypes.Nonce
		nonce, err = nonceTracker.GetNextSequence(ctx, fromAddress)
		require.NoError(t, err)
		// Saved NextNonce must be the same as before because this transaction
		// was not accepted by the eth node and never can be
		require.Equal(t, int64(localNextNonce), int64(nonce))

		// On the second try, the tx has been accepted into the mempool
		ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(localNextNonce+1, nil).Once()

		retryable, err = eb.ProcessUnstartedTxs(ctx, fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		// Check it was saved with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt) // Note that InitialBroadcastAt really means "InitialDefinitelySuccessfulBroadcastAt"
		assert.Equal(t, evmtypes.Nonce(localNextNonce), *etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
		attempt = etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("PendingNonceAt", mock.Anything, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(localNextNonce, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.ExceedsMaxFee, errors.New(TxFeeExceedsCapError))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(TxFeeExceedsCapError)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Twice()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.GetNextSequence(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("PendingNonceAt", mock.Anything, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(localNextNonce+1, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("eth Client call fails with an unexpected random error, and transaction was not accepted into mempool", func(t *testing.T) {
		retryableErrorExample := "some unknown error"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Unknown, errors.New(retryableErrorExample)).Once()
		// Nonce is the same as localNextNonce, implying that this sent transaction has not been accepted
		ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(localNextNonce, nil).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		require.Contains(t, err.Error(), retryableErrorExample)
		assert.True(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxInProgress, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)

		// Now on the second run, it is successful
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Successful, nil).Once()

		retryable, err = eb.ProcessUnstartedTxs(ctx, fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
		attempt = etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Unknown, errors.New(retryableErrorExample))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(retryableErrorExample)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("PendingNonceAt", mock.Anything, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(localNextNonce, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("eth client call fails with an unexpected random error, and the nonce check also subsequently fails", func(t *testing.T) {
		retryableErrorExample := "some unknown error"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Unknown, errors.New(retryableErrorExample)).Once()
		ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(uint64(0), errors.New("pending nonce fetch failed")).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		require.Contains(t, err.Error(), retryableErrorExample)
		require.Contains(t, err.Error(), "pending nonce fetch failed")
		assert.True(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxInProgress, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)

		// Now on the second run, it is successful
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Successful, nil).Once()

		retryable, err = eb.ProcessUnstartedTxs(ctx, fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
		attempt = etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Unknown, errors.New(retryableErrorExample))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(retryableErrorExample)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("PendingNonceAt", mock.Anything, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), errors.New("pending nonce fetch failed"))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New("pending nonce fetch failed")`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("eth Client call fails with an unexpected random error, and transaction was accepted into mempool", func(t *testing.T) {
		retryableErrorExample := "some strange RPC returns an unexpected thing"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Unknown, errors.New(retryableErrorExample)).Once()
		// Nonce is one higher than localNextNonce, implying that despite the error, this sent transaction has been accepted into the mempool
		ethClient.On("PendingNonceAt", mock.Anything, fromAddress).Return(localNextNonce+1, nil).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.NoError(t, err)
		assert.False(t, retryable)

		// Check it was saved correctly with its attempt, in a broadcast state
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Unknown, errors.New(retryableErrorExample))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(retryableErrorExample)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("PendingNonceAt", mock.Anything, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(localNextNonce+1, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("eth node returns underpriced transaction", func(t *testing.T) {
		// This happens if a transaction's gas price is below the minimum
		// configured for the transaction pool.
		// This is a configuration error by the node operator, since it means they set the base gas level too low.
		underpricedError := "transaction underpriced"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		evmcfg := configtest.NewChainScopedConfig(t, nil)
		// First was underpriced
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(evmcfg.EVM().GasEstimator().PriceDefault().ToInt()) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()

		// Second with gas bump was still underpriced
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(big.NewInt(25000000000)) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()

		// Third succeeded
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(big.NewInt(30000000000)) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.NoError(t, err)
		assert.False(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, "30 gwei", attempt.TxFee.GasPrice.String())
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(evmcfg.EVM().GasEstimator().PriceDefault().ToInt()) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(evmcfg.EVM().GasEstimator().PriceDefault().ToInt()) == 0
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasPrice()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(evmcfg.EVM().GasEstimator().PriceDefault().ToInt())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.PriceDefault()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ToInt()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Underpriced, errors.New(underpricedError))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(underpricedError)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(big.NewInt(25000000000)) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(big.NewInt(25000000000)) == 0
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasPrice()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(big.NewInt(25000000000))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(25000000000)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Underpriced, errors.New(underpricedError))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(underpricedError)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(big.NewInt(30000000000)) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(big.NewInt(30000000000)) == 0
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasPrice()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(big.NewInt(30000000000))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(30000000000)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("failed to reach node for some reason", func(t *testing.T) {
		failedToReachNodeError := context.DeadlineExceeded
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Retryable, failedToReachNodeError).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "context deadline exceeded")
		assert.True(t, retryable)

		// Check it was left in the unfinished state
		etx, err := txStore.FindTxWithAttempts(ctx, etxUnfinished.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		assert.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxInProgress, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, etx.TxAttempts[0].State)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Retryable, failedToReachNodeError)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etxUnfinished.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("eth node returns temporarily underpriced transaction", func(t *testing.T) {
		// This happens if parity is rejecting transactions that are not priced high enough to even get into the mempool at all
		// It should pretend it was accepted into the mempool and hand off to ethConfirmer to bump gas as normal
		temporarilyUnderpricedError := "There are too many transactions in the queue. Your transaction was dropped due to limit. Try increasing the fee."
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)

		// Re-use the previously unfinished transaction, no need to insert new

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Successful, errors.New(temporarilyUnderpricedError)).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err := txStore.FindTxWithAttempts(ctx, etxUnfinished.ID)
		require.NoError(t, err)

		assert.NotNil(t, etx.BroadcastAt)
		assert.NotNil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, "20 gwei", attempt.TxFee.GasPrice.String())
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, errors.New(temporarilyUnderpricedError))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(temporarilyUnderpricedError)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etxUnfinished.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("eth node returns underpriced transaction and bumping gas doesn't increase it", func(t *testing.T) {
		// This happens if a transaction's gas price is below the minimum
		// configured for the transaction pool.
		// This is a configuration error by the node operator, since it means they set the base gas level too low.
		underpricedError := "transaction underpriced"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		// In this scenario the node operator REALLY fucked up and set the bump
		// to zero (even though that should not be possible due to config
		// validation)
		evmcfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.BumpMin = assets.NewWeiI(0)
			c.GasEstimator.BumpPercent = ptr[uint16](0)
		})
		eb2 := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)
		mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)

		// First was underpriced
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(evmcfg.EVM().GasEstimator().PriceDefault().ToInt()) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()

		// Do the thing
		retryable, err := eb2.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		require.Contains(t, err.Error(), "bumped fee price of 20 gwei is equal to original fee price of 20 gwei. ACTION REQUIRED: This is a configuration error, you must increase either FeeEstimator.BumpPercent or FeeEstimator.BumpMin")
		assert.True(t, retryable)

		// TEARDOWN: Clear out the unsent tx before the next test
		testutils.MustExec(t, db, `DELETE FROM evm.txes WHERE nonce = $1`, localNextNonce)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.BumpMin = assets.NewWeiI(0)
			c.GasEstimator.BumpPercent = ptr[uint16](0)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewWeiI(0)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(evmcfg.EVM().GasEstimator().PriceDefault().ToInt()) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasPrice().Cmp(evmcfg.EVM().GasEstimator().PriceDefault().ToInt()) == 0
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasPrice()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(evmcfg.EVM().GasEstimator().PriceDefault().ToInt())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.PriceDefault()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ToInt()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Underpriced, errors.New(underpricedError))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(underpricedError)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustExec(t, db, `DELETE FROM evm.txes WHERE nonce = $1`, localNextNonce)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("tx is left in progress and its attempt gets replaced with a new re-estimated attempt if node returns insufficient eth", func(t *testing.T) {
		insufficientEthError := "insufficient funds for transfer"
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.InsufficientFunds, errors.New(insufficientEthError)).Once()

		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "insufficient funds for transfer")
		assert.True(t, retryable)

		// Check it was saved correctly with its attempt
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxInProgress, etx.State)
		require.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)
		assert.Nil(t, attempt.BroadcastBeforeBlockNum)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.InsufficientFunds, errors.New(insufficientEthError))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(insufficientEthError)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustExec(t, db, `DELETE FROM evm.txes`)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("eth tx is left in progress if nonce is too high", func(t *testing.T) {
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		nonceGapError := "NonceGap, Future nonce. Expected nonce: " + strconv.FormatUint(localNextNonce, 10)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress).Return(multinode.Retryable, errors.New(nonceGapError)).Once()

		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		assert.Contains(t, err.Error(), nonceGapError)
		assert.True(t, retryable)

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		assert.Nil(t, etx.BroadcastAt)
		assert.Nil(t, etx.InitialBroadcastAt)
		require.NotNil(t, etx.Sequence)
		assert.False(t, etx.Error.Valid)
		assert.Equal(t, txmgrcommon.TxInProgress, etx.State)
		require.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)
		assert.Nil(t, attempt.BroadcastBeforeBlockNum)

		testutils.MustExec(t, db, `DELETE FROM evm.txes`)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.FormatUint(localNextNonce, 10)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Retryable, errors.New(nonceGapError))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(nonceGapError)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustExec(t, db, `DELETE FROM evm.txes`)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("eth node returns underpriced transaction and bumping gas doesn't increase it in EIP-1559 mode", func(t *testing.T) {
		// This happens if a transaction's gas price is below the minimum
		// configured for the transaction pool.
		// This is a configuration error by the node operator, since it means they set the base gas level too low.

		// In this scenario the node operator REALLY fucked up and set the bump
		// to zero (even though that should not be possible due to config
		// validation)
		evmcfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.EIP1559DynamicFees = ptr(true)
			c.GasEstimator.BumpMin = assets.NewWeiI(0)
			c.GasEstimator.BumpPercent = ptr[uint16](0)
		})
		localNextNonce := getLocalNextNonce(t, nonceTracker, fromAddress)
		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(localNextNonce, nil).Once()
		eb2 := NewTestEthBroadcaster(t, txStore, ethClient, ethKeyStore, dbListenerCfg, evmcfg.EVM(), &testCheckerFactory{}, false, nonceTracker)
		mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		underpricedError := "transaction underpriced"
		localNextNonce = getLocalNextNonce(t, nonceTracker, fromAddress)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(big.NewInt(1)) == 0
		}), fromAddress).Return(multinode.Underpriced, errors.New(underpricedError)).Once()

		// Check gas tip cap verification
		retryable, err := eb2.ProcessUnstartedTxs(ctx, fromAddress)
		require.Error(t, err)
		require.Contains(t, err.Error(), "bumped gas tip cap of 1 wei is less than or equal to original gas tip cap of 1 wei")
		assert.True(t, retryable)

		testutils.MustExec(t, db, `DELETE FROM evm.txes`)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.EIP1559DynamicFees = ptr(true)
			c.GasEstimator.BumpMin = assets.NewWeiI(0)
			c.GasEstimator.BumpPercent = ptr[uint16](0)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewWeiI(0)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(localNextNonce, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(big.NewInt(1)) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(big.NewInt(1)) == 0
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasTipCap()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(big.NewInt(1))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Underpriced, errors.New(underpricedError))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(underpricedError)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustExec(t, db, `DELETE FROM evm.txes`)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewWeiI(42)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.EIP1559DynamicFees = ptr(true)
			c.GasEstimator.TipCapDefault = gasTipCapDefault
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(localNextNonce, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(gasTipCapDefault.ToInt()) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(gasTipCapDefault.ToInt()) == 0
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasTipCap()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(gasTipCapDefault.ToInt())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ToInt()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Underpriced, errors.New(underpricedError))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(underpricedError)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(big.NewInt(0).Add(gasTipCapDefault.ToInt(), evmcfg.EVM().GasEstimator().BumpMin().ToInt())) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(big.NewInt(0).Add(gasTipCapDefault.ToInt(), evmcfg.EVM().GasEstimator().BumpMin().ToInt())) == 0
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasTipCap()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(big.NewInt(0).Add(gasTipCapDefault.ToInt(), evmcfg.EVM().GasEstimator().BumpMin().ToInt()))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Add(gasTipCapDefault.ToInt(), evmcfg.EVM().GasEstimator().BumpMin().ToInt())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ToInt()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.BumpMin()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ToInt()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Underpriced, errors.New(underpricedError))`
$DIR/pkg/txmgr/broadcaster_test.go: `.New(underpricedError)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(big.NewInt(0).Add(gasTipCapDefault.ToInt(), big.NewInt(0).Mul(evmcfg.EVM().GasEstimator().BumpMin().ToInt(), big.NewInt(2)))) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNextNonce && tx.GasTipCap().Cmp(big.NewInt(0).Add(gasTipCapDefault.ToInt(), big.NewInt(0).Mul(evmcfg.EVM().GasEstimator().BumpMin().ToInt(), big.NewInt(2)))) == 0
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasTipCap()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Cmp(big.NewInt(0).Add(gasTipCapDefault.ToInt(), big.NewInt(0).Mul(evmcfg.EVM().GasEstimator().BumpMin().ToInt(), big.NewInt(2))))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Add(gasTipCapDefault.ToInt(), big.NewInt(0).Mul(evmcfg.EVM().GasEstimator().BumpMin().ToInt(), big.NewInt(2)))`
$DIR/pkg/txmgr/broadcaster_test.go: `.ToInt()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Mul(evmcfg.EVM().GasEstimator().BumpMin().ToInt(), big.NewInt(2))`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.BumpMin()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ToInt()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(2)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustExec(t, db, `DELETE FROM evm.txes WHERE nonce = $1`, localNextNonce)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewAddress()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(142))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(142)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.GasEstimator.EstimateLimit = ptr(true)                                      // Enabled gas limit estimation
		c.GasEstimator.LimitMultiplier = ptr(decimal.NewFromFloat32(limitMultiplier)) // Set LimitMultiplier for the buffer
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewFromFloat32(limitMultiplier)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(lggr, txStore, txmClient)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmFeeEstimator(lggr, func(lggr logger.Logger) gas.EvmEstimator {
		return gas.NewFixedPriceEstimator(ge, nil, ge.BlockHistory(), lggr, nil)
	}, ge.EIP1559DynamicFees(), ge, ethClient)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewFixedPriceEstimator(ge, nil, ge.BlockHistory(), lggr, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.BlockHistory()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EIP1559DynamicFees()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), ge, ethKeyStore, estimator)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.String()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewBroadcaster(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmConfig(config.EVM()), txmgr.NewEvmTxmFeeConfig(config.EVM().GasEstimator()), config.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, nonceTracker, lggr, &testCheckerFactory{}, false, "", metrics)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmConfig(config.EVM())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmFeeConfig(config.EVM().GasEstimator())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Transactions()`
$DIR/pkg/txmgr/broadcaster_test.go: `.XXXTestDisableUnstartedTxAutoProcessing()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run(t, eb)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("gas limit lowered after estimation", func(t *testing.T) {
		estimatedGasLimit := uint64(100)
		etx := mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, gasLimit, value, testutils.FixtureChainID)
		ethClient.On("EstimateGas", mock.Anything, mock.Anything).Return(estimatedGasLimit, nil).Once()
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(0)
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Do the thing
		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		assert.NoError(t, err)
		assert.False(t, retryable)

		dbEtx, err := txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		attempt := dbEtx.TxAttempts[0]
		require.Equal(t, uint64(float32(estimatedGasLimit)*gas.EstimateGasBuffer), attempt.ChainSpecificFeeLimit)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("EstimateGas", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(estimatedGasLimit, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(0)
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == uint64(0)
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("EstimateGas", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(float32(gasLimit)*limitMultiplier)+1, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.HexToAddress("0x6C03DDA95a2AEd917EeCc6eddD4b9D16E6380411")`
$DIR/pkg/txmgr/broadcaster_test.go: `.Int(assets.NewEthValue(142))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEthValue(142)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.New("could not sign transaction")`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GetNextSequence(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/broadcaster_test.go: `.GetNextSequence(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Trigger(testutils.NewAddress())`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewAddress()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Trigger(testutils.NewAddress())`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewAddress()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewAddress()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.TestObserved(t, zapcore.DebugLevel)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.NonceAutoSync = ptr(true)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmConfig(evmcfg.EVM())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmFeeEstimator(lggr, func(lggr logger.Logger) gas.EvmEstimator {
		return gas.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, evmcfg.EVM().GasEstimator().BlockHistory(), lggr, nil)
	}, evmcfg.EVM().GasEstimator().EIP1559DynamicFees(), evmcfg.EVM().GasEstimator(), ethClient)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, evmcfg.EVM().GasEstimator().BlockHistory(), lggr, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.BlockHistory()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EIP1559DynamicFees()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), ge, kst, estimator)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.String()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmBroadcaster(txStore, txmClient, evmTxmCfg, txmgr.NewEvmTxmFeeConfig(ge), evmcfg.EVM().Transactions(), dbListenerCfg, kst, txBuilder, lggr, checkerFactory, false, "", metrics)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmFeeConfig(ge)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Transactions()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Start(ctx)`
$DIR/pkg/txmgr/broadcaster_test.go: `.AssertLogEventually(t, observed, "Skipping sequence auto-sync")`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, big.NewInt(0))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Test(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == inProgressTxNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == inProgressTxNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce(inProgressTxNonce)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainStore(memKS, big.NewInt(0))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.TestObserved(t, zapcore.DebugLevel)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmFeeEstimator(lggr, func(lggr logger.Logger) gas.EvmEstimator {
		return gas.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, ge.BlockHistory(), lggr, nil)
	}, ge.EIP1559DynamicFees(), ge, ethClient)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewFixedPriceEstimator(evmcfg.EVM().GasEstimator(), nil, ge.BlockHistory(), lggr, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.BlockHistory()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EIP1559DynamicFees()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), ge, ethKeyStore, estimator)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Context()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("transaction successfully broadcasted and increments on-chain nonce", func(t *testing.T) {
		fromAddress := memKS.MustCreate(t)
		localNonce := uint64(0)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNonce
		}), fromAddress).Return(multinode.Successful, nil).Once()
		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Once()

		mustInsertInProgressEthTxWithAttempt(t, txStore, evmtypes.Nonce(localNonce), fromAddress)
		nonceTracker := txmgr.NewNonceTracker(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
		require.NoError(t, err)
		eb := txmgrcommon.NewBroadcaster(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, nonceTracker, lggr, checkerFactory, false, string(chaintype.ChainHedera), metrics)
		// Mark instance as test
		eb.XXXTestDisableUnstartedTxAutoProcessing()
		servicetest.Run(t, eb)

		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		require.NoError(t, err)
		require.False(t, retryable)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(1), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce(localNonce)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.String()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewBroadcaster(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, nonceTracker, lggr, checkerFactory, false, string(chaintype.ChainHedera), metrics)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmConfig(evmcfg.EVM())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Transactions()`
$DIR/pkg/txmgr/broadcaster_test.go: `.XXXTestDisableUnstartedTxAutoProcessing()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run(t, eb)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run("transaction successfully broadcasted, failed to increment on-chain nonce, succeeded on bumped retry attempt", func(t *testing.T) {
		fromAddress := memKS.MustCreate(t)
		localNonce := uint64(0)
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNonce
		}), fromAddress).Return(multinode.Successful, nil).Twice()
		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Once()
		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Once()

		mustInsertInProgressEthTxWithAttempt(t, txStore, evmtypes.Nonce(localNonce), fromAddress)
		nonceTracker := txmgr.NewNonceTracker(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil))
		metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
		require.NoError(t, err)
		eb := txmgrcommon.NewBroadcaster(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, nonceTracker, lggr, checkerFactory, false, string(chaintype.ChainHedera), metrics)
		// Mark instance as test
		eb.XXXTestDisableUnstartedTxAutoProcessing()
		servicetest.Run(t, eb)

		retryable, err := eb.ProcessUnstartedTxs(ctx, fromAddress)
		tests.AssertLogEventually(t, observed, "Bumped fee on initial send")
		require.NoError(t, err)
		require.False(t, retryable)
	})`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Twice()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(1), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Once()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce(localNonce)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.String()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewBroadcaster(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, nonceTracker, lggr, checkerFactory, false, string(chaintype.ChainHedera), metrics)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmConfig(evmcfg.EVM())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Transactions()`
$DIR/pkg/txmgr/broadcaster_test.go: `.XXXTestDisableUnstartedTxAutoProcessing()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run(t, eb)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.AssertLogEventually(t, observed, "Bumped fee on initial send")`
$DIR/pkg/txmgr/broadcaster_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNonce
		}), fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.MatchedBy(func(tx *gethTypes.Transaction) bool {
			return tx.Nonce() == localNonce
		})`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Times(4)`
$DIR/pkg/txmgr/broadcaster_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Times(4)`
$DIR/pkg/txmgr/broadcaster_test.go: `.Nonce(localNonce)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewNonceTracker(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil))`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/broadcaster_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/broadcaster_test.go: `.String()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewBroadcaster(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmConfig(evmcfg.EVM()), txmgr.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator()), evmcfg.EVM().Transactions(), dbListenerCfg, ethKeyStore, txBuilder, nonceTracker, lggr, checkerFactory, false, string(chaintype.ChainHedera), metrics)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmConfig(evmcfg.EVM())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.NewEvmTxmFeeConfig(evmcfg.EVM().GasEstimator())`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/broadcaster_test.go: `.EVM()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Transactions()`
$DIR/pkg/txmgr/broadcaster_test.go: `.XXXTestDisableUnstartedTxAutoProcessing()`
$DIR/pkg/txmgr/broadcaster_test.go: `.Run(t, eb)`
$DIR/pkg/txmgr/broadcaster_test.go: `.ProcessUnstartedTxs(ctx, fromAddress)`
$DIR/pkg/txmgr/broadcaster_test.go: `.AssertLogEventually(t, observed, "Bumped fee on initial send")`
$DIR/pkg/txmgr/broadcaster_test.go: `.AssertLogEventually(t, observed, "failed to broadcast transaction on hedera after 3 retries")`
$DIR/pkg/txmgr/broadcaster_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `memKS.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `memKS.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `err = ec.Close()`
$DIR/pkg/txmgr/confirmer_test.go: `err = ec.Start(ctx)`
$DIR/pkg/txmgr/confirmer_test.go: `err = ec.Start(ctx)`
$DIR/pkg/txmgr/confirmer_test.go: `latestFinalizedHead.IsFinalized.Store(true)`
$DIR/pkg/txmgr/confirmer_test.go: `h9.Parent.Store(latestFinalizedHead)`
$DIR/pkg/txmgr/confirmer_test.go: `head.Parent.Store(h9)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("NonceAt", mock.Anything, mock.Anything, mock.Anything).Return(uint64(0), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `err = ec.ProcessHead(ctx, head)`
$DIR/pkg/txmgr/confirmer_test.go: `err = ec.Close()`
$DIR/pkg/txmgr/confirmer_test.go: `err = ec.Start(ctx)`
$DIR/pkg/txmgr/confirmer_test.go: `err = ec.Close()`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.PriceMax = assets.GWei(500)`
$DIR/pkg/txmgr/confirmer_test.go: `head.IsFinalized.Store(true)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("does nothing if no re-org'd or included transactions found", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		ethKeyStore := &keystest.FakeChainStore{Addresses: keystest.Addresses{fromAddress}}
		etx1 := mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 0, blockNum)
		etx2 := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 4, fromAddress, 1, blockNum, assets.NewWeiI(1))
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Maybe()
		require.NoError(t, ec.CheckForConfirmation(ctx, &head))

		var err error
		etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, etx1.State)

		etx2, err = txStore.FindTxWithAttempts(ctx, etx2.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx2.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `etx2, err = txStore.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("marks re-org'd confirmed transaction as unconfirmed, marks latest attempt as in-progress, deletes receipt", func(t *testing.T) {
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		// Insert confirmed transaction that stays confirmed
		etx := mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 0, blockNum)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Maybe()
		require.NoError(t, ec.CheckForConfirmation(ctx, &head))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)
		attempt := etx.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)
		require.Empty(t, attempt.Receipts)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("marks re-org'd terminally stuck transaction as unconfirmed, marks latest attempt as in-progress, deletes receipt, removed error", func(t *testing.T) {
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		// Insert terminally stuck transaction that stays fatal error
		etx := mustInsertTerminallyStuckTxWithAttempt(t, txStore, fromAddress, 0, blockNum)
		mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), etx.TxAttempts[0].Hash)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Maybe()
		require.NoError(t, ec.CheckForConfirmation(ctx, &head))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)
		require.Equal(t, "", etx.Error.String)
		attempt := etx.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)
		require.Empty(t, attempt.Receipts)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), etx.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("handles multiple re-org transactions at a time", func(t *testing.T) {
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		// Insert confirmed transaction that stays confirmed
		etx1 := mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 0, blockNum)
		// Insert terminally stuck transaction that stays fatal error
		etx2 := mustInsertTerminallyStuckTxWithAttempt(t, txStore, fromAddress, 1, blockNum)
		mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), etx2.TxAttempts[0].Hash)
		// Insert confirmed transaction that gets re-org'd
		etx3 := mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 2, blockNum)
		// Insert terminally stuck transaction that gets re-org'd
		etx4 := mustInsertTerminallyStuckTxWithAttempt(t, txStore, fromAddress, 3, blockNum)
		mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), etx4.TxAttempts[0].Hash)
		// Insert unconfirmed transaction that is untouched
		etx5 := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 4, fromAddress, 1, blockNum, assets.NewWeiI(1))
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(2), nil).Maybe()
		require.NoError(t, ec.CheckForConfirmation(ctx, &head))

		var err error
		etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, etx1.State)
		attempt1 := etx1.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt1.State)
		require.Len(t, attempt1.Receipts, 1)

		etx2, err = txStore.FindTxWithAttempts(ctx, etx2.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFatalError, etx2.State)
		require.Equal(t, client.TerminallyStuckMsg, etx2.Error.String)
		attempt2 := etx2.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt2.State)
		require.Len(t, attempt2.Receipts, 1)

		etx3, err = txStore.FindTxWithAttempts(ctx, etx3.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx3.State)
		attempt3 := etx3.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptInProgress, attempt3.State)
		require.Empty(t, attempt3.Receipts)

		etx4, err = txStore.FindTxWithAttempts(ctx, etx4.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx4.State)
		require.Equal(t, "", etx4.Error.String)
		attempt4 := etx4.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptInProgress, attempt4.State)
		require.True(t, attempt4.IsPurgeAttempt)
		require.Empty(t, attempt4.Receipts)

		etx5, err = txStore.FindTxWithAttempts(ctx, etx5.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx5.State)
		attempt5 := etx5.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt5.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), etx2.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/confirmer_test.go: `mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), etx4.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(2), nil).Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `etx2, err = txStore.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `etx3, err = txStore.FindTxWithAttempts(ctx, etx3.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `etx4, err = txStore.FindTxWithAttempts(ctx, etx4.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `etx5, err = txStore.FindTxWithAttempts(ctx, etx5.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("marks valid transaction as confirmed if nonce less than mined tx count", func(t *testing.T) {
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, blockNum, assets.NewWeiI(1))
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Maybe()
		require.NoError(t, ec.CheckForConfirmation(ctx, &head))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, etx.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("marks purge transaction as terminally stuck if nonce less than mined tx count", func(t *testing.T) {
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		etx := mustInsertUnconfirmedEthTxWithBroadcastPurgeAttempt(t, txStore, 0, fromAddress)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Maybe()
		require.NoError(t, ec.CheckForConfirmation(ctx, &head))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFatalError, etx.State)
		require.Equal(t, client.TerminallyStuckMsg, etx.Error.String)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), etx2.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(4), nil).Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `etx2, err = txStore.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `etx3, err = txStore.FindTxWithAttempts(ctx, etx3.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `etx4, err = txStore.FindTxWithAttempts(ctx, etx4.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `etx5, err = txStore.FindTxWithAttempts(ctx, etx5.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `mustInsertConfirmedEthTx(t, txStore, nonce, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("returns nothing when there are no transactions", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `mustInsertInProgressEthTx(t, txStore, nonce, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("returns nothing when the transaction is in_progress", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("ignores unconfirmed transactions with nil BroadcastBeforeBlockNum", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt.FromTxAttempt(&attempt1_1)`
$DIR/pkg/txmgr/confirmer_test.go: `attempt1_2.BroadcastBeforeBlockNum = &onTheMoney`
$DIR/pkg/txmgr/confirmer_test.go: `attempt1_2.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(30000)}`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("returns nothing when the transaction is unconfirmed with an attempt that is recent", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		assert.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt = txmgr.DbEthTxAttempt{}`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt.FromTxAttempt(&attempt2_1)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("returns nothing when the transaction has attempts that are too new", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		assert.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `etxWithoutAttempts.Sequence = &n`
$DIR/pkg/txmgr/confirmer_test.go: `etxWithoutAttempts.BroadcastAt = &now`
$DIR/pkg/txmgr/confirmer_test.go: `etxWithoutAttempts.InitialBroadcastAt = &now`
$DIR/pkg/txmgr/confirmer_test.go: `etxWithoutAttempts.State = txmgrcommon.TxUnconfirmed`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("does nothing if the transaction is from a different address than the one given", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmOtherAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		assert.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("returns the transaction if it is unconfirmed and has no attempts (note that this is an invariant violation, but we handle it anyway)", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 1)
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("returns nothing for different chain id", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, big.NewInt(42))
		require.NoError(t, err)

		require.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt = txmgr.DbEthTxAttempt{}`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt.FromTxAttempt(&attempt3_1)`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt = txmgr.DbEthTxAttempt{}`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt.FromTxAttempt(&attemptOther1)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("returns the transaction if it is unconfirmed with an attempt that is older than gasBumpThreshold blocks", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 2)
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
		assert.Equal(t, etx3.ID, etxs[1].ID)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("returns nothing if threshold is zero", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, 0, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("does not return more transactions for gas bumping than gasBumpThreshold", func(t *testing.T) {
		// Unconfirmed txes in DB are:
		// (unnamed) (nonce 2)
		// etx1 (nonce 3)
		// etx2 (nonce 4)
		// etxWithoutAttempts (nonce 5)
		// etx3 (nonce 6) - ready for bump
		// etx4 (nonce 7) - ready for bump
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 4, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 1) // returns etxWithoutAttempts only - eligible for gas bumping because it technically doesn't have any attempts within gasBumpThreshold blocks
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)

		etxs, err = ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 5, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 2) // includes etxWithoutAttempts, etx3 and etx4
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
		assert.Equal(t, etx3.ID, etxs[1].ID)

		// Zero limit disables it
		etxs, err = ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 0, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 2) // includes etxWithoutAttempts, etx3 and etx4
	})`
$DIR/pkg/txmgr/confirmer_test.go: `etxs, err = ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 5, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `etxs, err = ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 0, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt = txmgr.DbEthTxAttempt{}`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt.FromTxAttempt(&attempt4_1)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("ignores pending transactions for another key", func(t *testing.T) {
		// Re-use etx3 nonce for another key, it should not affect the results for this key
		etxOther := txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, (*etx3.Sequence).Int64(), evmOtherAddress)
		aOther := etxOther.TxAttempts[0]
		dbAttempt = txmgr.DbEthTxAttempt{}
		dbAttempt.FromTxAttempt(&aOther)
		require.NoError(t, db.Get(&dbAttempt, `UPDATE evm.tx_attempts SET broadcast_before_block_num=$1 WHERE id=$2 RETURNING *`, oldEnough, aOther.ID))

		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 6, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 3) // includes etxWithoutAttempts, etx3 and etx4
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
		assert.Equal(t, etx3.ID, etxs[1].ID)
		assert.Equal(t, etx4.ID, etxs[2].ID)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt = txmgr.DbEthTxAttempt{}`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt.FromTxAttempt(&aOther)`
$DIR/pkg/txmgr/confirmer_test.go: `attempt3_2.BroadcastBeforeBlockNum = &oldEnough`
$DIR/pkg/txmgr/confirmer_test.go: `attempt3_2.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(30000)}`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("returns the transaction if it is unconfirmed with two attempts that are older than gasBumpThreshold blocks", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 3)
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
		assert.Equal(t, etx3.ID, etxs[1].ID)
		assert.Equal(t, etx4.ID, etxs[2].ID)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `attempt3_3.BroadcastBeforeBlockNum = &tooNew`
$DIR/pkg/txmgr/confirmer_test.go: `attempt3_3.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(40000)}`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("does not return the transaction if it has some older but one newer attempt", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 2)
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
		assert.Equal(t, *etxWithoutAttempts.Sequence, *(etxs[0].Sequence))
		require.Equal(t, evmtypes.Nonce(5), *etxWithoutAttempts.Sequence)
		assert.Equal(t, etx4.ID, etxs[1].ID)
		assert.Equal(t, *etx4.Sequence, *(etxs[1].Sequence))
		require.Equal(t, evmtypes.Nonce(7), *etx4.Sequence)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `attempt0_1.State = txmgrtypes.TxAttemptInsufficientFunds`
$DIR/pkg/txmgr/confirmer_test.go: `attempt4_2.State = txmgrtypes.TxAttemptInsufficientFunds`
$DIR/pkg/txmgr/confirmer_test.go: `attempt4_2.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(40000)}`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `attempt6_2.BroadcastBeforeBlockNum = &tooNew`
$DIR/pkg/txmgr/confirmer_test.go: `attempt6_2.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(30001)}`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("returns unique attempts requiring resubmission due to insufficient eth, ordered by nonce asc", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 4)
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
		assert.Equal(t, *etxWithoutAttempts.Sequence, *(etxs[0].Sequence))
		assert.Equal(t, etx4.ID, etxs[1].ID)
		assert.Equal(t, *etx4.Sequence, *(etxs[1].Sequence))
		assert.Equal(t, etx5.ID, etxs[2].ID)
		assert.Equal(t, *etx5.Sequence, *(etxs[2].Sequence))
		assert.Equal(t, etx6.ID, etxs[3].ID)
		assert.Equal(t, *etx6.Sequence, *(etxs[3].Sequence))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("should retry previous attempt if connectivity check failed for legacy transactions", func(t *testing.T) {
		ccfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.EIP1559DynamicFees = ptr(false)
			c.GasEstimator.BlockHistory.BlockHistorySize = ptr[uint16](2)
			c.GasEstimator.BlockHistory.CheckInclusionBlocks = ptr[uint16](4)
		})

		ctx := t.Context()
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()

		estimator := gasmocks.NewEvmEstimator(t)
		newEst := func(logger.Logger) gas.EvmEstimator { return estimator }
		estimator.On("BumpLegacyGas", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(nil, uint64(0), pkgerrors.Wrapf(fees.ErrConnectivity, "transaction..."))
		ge := ccfg.EVM().GasEstimator()
		feeEstimator := gas.NewEvmFeeEstimator(lggr, newEst, ge.EIP1559DynamicFees(), ge, ethClient)
		kst := keystest.Addresses{fromAddress}
		txBuilder := txmgr.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), ge, keystest.TxSigner(nil), feeEstimator)
		stuckTxDetector := txmgr.NewStuckTxDetector(lggr, testutils.FixtureChainID, "", assets.NewWei(assets.NewEth(100).ToInt()), ccfg.EVM().Transactions().AutoPurge(), feeEstimator, txStore, ethClient)
		metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
		require.NoError(t, err)
		// Create confirmer with necessary state
		ec := txmgr.NewEvmConfirmer(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmFeeConfig(ccfg.EVM().GasEstimator()), ccfg.EVM().Transactions(), confirmerConfig{}, kst, txBuilder, lggr, stuckTxDetector, metrics)
		servicetest.Run(t, ec)
		currentHead := int64(30)
		oldEnough := int64(15)
		nonce := int64(0)
		originalBroadcastAt := time.Unix(1616509100, 0)

		etx := txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress, originalBroadcastAt)
		attempt1 := etx.TxAttempts[0]
		var dbAttempt txmgr.DbEthTxAttempt
		dbAttempt.FromTxAttempt(&attempt1)
		require.NoError(t, db.Get(&dbAttempt, `UPDATE evm.tx_attempts SET broadcast_before_block_num=$1 WHERE id=$2 RETURNING *`, oldEnough, attempt1.ID))

		// Send transaction and assume success.
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(multinode.Successful, nil).Once()

		err = ec.RebroadcastWhereNecessary(t.Context(), currentHead)
		require.NoError(t, err)

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.EIP1559DynamicFees = ptr(false)`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.BlockHistory.BlockHistorySize = ptr[uint16](2)`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.BlockHistory.CheckInclusionBlocks = ptr[uint16](4)`
$DIR/pkg/txmgr/confirmer_test.go: `estimator.On("BumpLegacyGas", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(nil, uint64(0), pkgerrors.Wrapf(fees.ErrConnectivity, "transaction..."))`
$DIR/pkg/txmgr/confirmer_test.go: `servicetest.Run(t, ec)`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt.FromTxAttempt(&attempt1)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `err = ec.RebroadcastWhereNecessary(t.Context(), currentHead)`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.EIP1559DynamicFees = ptr(true)`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.BlockHistory.BlockHistorySize = ptr[uint16](2)`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.BlockHistory.CheckInclusionBlocks = ptr[uint16](4)`
$DIR/pkg/txmgr/confirmer_test.go: `estimator.On("BumpDynamicFee", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(gas.DynamicFee{}, pkgerrors.Wrapf(fees.ErrConnectivity, "transaction..."))`
$DIR/pkg/txmgr/confirmer_test.go: `servicetest.Run(t, ec)`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt.FromTxAttempt(&attempt1)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `err = ec.RebroadcastWhereNecessary(t.Context(), currentHead)`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.PriceMax = assets.GWei(500)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.GasPrice().Int64() == int64(20000000000) && tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.ExceedsMaxFee, errors.New("tx fee (1.10 ether) exceeds the configured cap (1.00 ether)")).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.PriceMax = assets.GWei(500)`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.BumpMin = assets.NewWeiI(0)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("does nothing if no transactions require bumping", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())

		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)
		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `memKS.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("re-sends previous transaction on keystore error", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := keystest.NewMemoryChainStore().MustCreate(t)
		kst := &keystest.FakeChainStore{
			Addresses: keystest.Addresses{fromAddress},
			TxSigner: func(ctx context.Context, from common.Address, tx *types.Transaction) (*types.Transaction, error) {
				if from == fromAddress {
					return nil, errors.New("signing error")
				}
				return tx, nil
			},
		}

		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, 25, assets.NewWeiI(100))

		// Use a mock keystore for this test
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, kst, nil)

		err := ec.RebroadcastWhereNecessary(ctx, currentHead)
		require.Error(t, err)
		require.Contains(t, err.Error(), "signing error")

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		require.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("does nothing and continues on fatal error", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, 25, assets.NewWeiI(100))
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Fatal, errors.New("exceeds block gas limit")).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Fatal, errors.New("exceeds block gas limit")).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("creates new attempt with higher gas price if transaction has an attempt older than threshold", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		latestGasPrice := assets.GWei(20)
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, 25, latestGasPrice)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Len(t, etx.TxAttempts, 2)

		// Got the new attempt
		bumpAttempt := etx.TxAttempts[0]
		expectedBumpedGas := latestGasPrice.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())
		require.Equal(t, expectedBumpedGas.Int64(), bumpAttempt.TxFee.GasPrice.Int64())
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, bumpAttempt.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("does nothing if there is an attempt without BroadcastBeforeBlockNum set", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		etx := mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, 0, fromAddress, txmgrtypes.TxAttemptBroadcast)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("creates new attempt with higher gas price if transaction is already in mempool (e.g. due to previous crash before we could save the new attempt)", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		latestGasPrice := assets.GWei(20)
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, 25, latestGasPrice)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, fmt.Errorf("known transaction: %s", etx.TxAttempts[0].Hash.Hex())).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Len(t, etx.TxAttempts, 2)

		// Got the new attempt
		bumpAttempt := etx.TxAttempts[0]
		expectedBumpedGas := latestGasPrice.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())
		require.Equal(t, expectedBumpedGas.Int64(), bumpAttempt.TxFee.GasPrice.Int64())
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, bumpAttempt.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, fmt.Errorf("known transaction: %s", etx.TxAttempts[0].Hash.Hex())).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("saves new attempt even for transaction that has already been confirmed (nonce already used)", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		latestGasPrice := assets.GWei(20)
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, 25, latestGasPrice)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.TransactionAlreadyKnown, errors.New("nonce too low")).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, etx.State)

		// Got the new attempt
		// Got the new attempt
		bumpedAttempt := etx.TxAttempts[0]
		expectedBumpedGas := latestGasPrice.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())
		require.Equal(t, expectedBumpedGas.Int64(), bumpedAttempt.TxFee.GasPrice.Int64())

		require.Len(t, etx.TxAttempts, 2)
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, etx.TxAttempts[0].State)
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, etx.TxAttempts[1].State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.TransactionAlreadyKnown, errors.New("nonce too low")).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("saves in-progress attempt on temporary error and returns error", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		latestGasPrice := assets.GWei(20)
		broadcastBlockNum := int64(25)
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, broadcastBlockNum, latestGasPrice)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Unknown, errors.New("some network error")).Once()

		err := ec.RebroadcastWhereNecessary(ctx, currentHead)
		require.Error(t, err)
		require.Contains(t, err.Error(), "some network error")

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		// Old attempt is untouched
		require.Len(t, etx.TxAttempts, 2)
		originalAttempt := etx.TxAttempts[1]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, originalAttempt.State)
		require.Equal(t, broadcastBlockNum, *originalAttempt.BroadcastBeforeBlockNum)

		// New in_progress attempt saved
		bumpedAttempt := etx.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptInProgress, bumpedAttempt.State)
		require.Nil(t, bumpedAttempt.BroadcastBeforeBlockNum)

		// Try again and move the attempt into "broadcast"
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		// New in_progress attempt saved and marked "broadcast"
		require.Len(t, etx.TxAttempts, 2)
		bumpedAttempt = etx.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, bumpedAttempt.State)
		require.Nil(t, bumpedAttempt.BroadcastBeforeBlockNum)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Unknown, errors.New("some network error")).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `bumpedAttempt = etx.TxAttempts[0]`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("re-bumps attempt if initial bump is underpriced because the bumped gas price is insufficiently higher than the previous one", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		latestGasPrice := assets.GWei(20)
		broadcastBlockNum := int64(25)
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, broadcastBlockNum, latestGasPrice)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Underpriced, errors.New("replacement transaction underpriced")).Once()
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Do the thing
		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		require.Len(t, etx.TxAttempts, 2)
		bumpedAttempt := etx.TxAttempts[0]
		expectedBumpedGas := latestGasPrice.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())
		expectedBumpedGas = expectedBumpedGas.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())
		require.Equal(t, expectedBumpedGas.Int64(), bumpedAttempt.TxFee.GasPrice.Int64())
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Underpriced, errors.New("replacement transaction underpriced")).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `expectedBumpedGas = expectedBumpedGas.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("resubmits at the old price and does not create a new attempt if one of the bumped transactions would exceed EVM.GasEstimator.PriceMax", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		priceMax := assets.GWei(30)
		newCfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.PriceMax = priceMax
		})
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		broadcastBlockNum := int64(25)
		currentAttemptPrice := priceMax.Sub(assets.GWei(1))
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, broadcastBlockNum, currentAttemptPrice)
		ec := newEthConfirmer(t, txStore, ethClient, newCfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Underpriced, errors.New("underpriced")).Once() // we already submitted at this price, now it's time to bump and submit again but since we simply resubmitted rather than increasing gas price, geth already knows about this tx

		// Do the thing
		require.Error(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		// No new tx attempts
		require.Len(t, etx.TxAttempts, 1)
		bumpedAttempt := etx.TxAttempts[0]
		require.Equal(t, currentAttemptPrice.Int64(), bumpedAttempt.TxFee.GasPrice.Int64())
	})`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.PriceMax = priceMax`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Underpriced, errors.New("underpriced")).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("resubmits at the old price and does not create a new attempt if the current price is exactly EVM.GasEstimator.PriceMax", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		priceMax := assets.GWei(30)
		newCfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.PriceMax = priceMax
		})
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		broadcastBlockNum := int64(25)
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, broadcastBlockNum, priceMax)
		ec := newEthConfirmer(t, txStore, ethClient, newCfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Underpriced, errors.New("underpriced")).Once() // we already submitted at this price, now it's time to bump and submit again but since we simply resubmitted rather than increasing gas price, geth already knows about this tx

		// Do the thing
		require.Error(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		// No new tx attempts
		require.Len(t, etx.TxAttempts, 1)
		bumpedAttempt := etx.TxAttempts[0]
		require.Equal(t, priceMax.Int64(), bumpedAttempt.TxFee.GasPrice.Int64())
	})`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.PriceMax = priceMax`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Underpriced, errors.New("underpriced")).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("EIP-1559: bumps using EIP-1559 rules when existing attempts are of type 0x2", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		newCfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.BumpMin = assets.GWei(1)
		})
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		etx := mustInsertUnconfirmedEthTxWithBroadcastDynamicFeeAttempt(t, txStore, 0, fromAddress)
		err := txStore.UpdateTxAttemptBroadcastBeforeBlockNum(ctx, etx.ID, uint(25))
		require.NoError(t, err)
		ec := newEthConfirmer(t, txStore, ethClient, newCfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()
		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		// A new, bumped attempt
		require.Len(t, etx.TxAttempts, 2)
		bumpAttempt := etx.TxAttempts[0]
		require.Nil(t, bumpAttempt.TxFee.GasPrice)
		bumpedGas := assets.NewWeiI(1).Add(newCfg.EVM().GasEstimator().BumpMin())
		require.Equal(t, bumpedGas.Int64(), bumpAttempt.TxFee.GasTipCap.Int64())
		require.Equal(t, bumpedGas.Int64(), bumpAttempt.TxFee.GasFeeCap.Int64())
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, bumpAttempt.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.BumpMin = assets.GWei(1)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("EIP-1559: resubmits at the old price and does not create a new attempt if one of the bumped EIP-1559 transactions would have its tip cap exceed EVM.GasEstimator.PriceMax", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		newCfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.PriceMax = assets.NewWeiI(1)
		})
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		etx := mustInsertUnconfirmedEthTxWithBroadcastDynamicFeeAttempt(t, txStore, 0, fromAddress)
		err := txStore.UpdateTxAttemptBroadcastBeforeBlockNum(ctx, etx.ID, uint(25))
		require.NoError(t, err)
		ec := newEthConfirmer(t, txStore, ethClient, newCfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Underpriced, errors.New("underpriced")).Once()

		require.Error(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		assert.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		// No new tx attempts
		require.Len(t, etx.TxAttempts, 1)
		bumpedAttempt := etx.TxAttempts[0]
		assert.Equal(t, assets.NewWeiI(1).Int64(), bumpedAttempt.TxFee.GasTipCap.Int64())
		assert.Equal(t, assets.NewWeiI(1).Int64(), bumpedAttempt.TxFee.GasFeeCap.Int64())
	})`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.PriceMax = assets.NewWeiI(1)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Underpriced, errors.New("underpriced")).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.BumpMin = assets.GWei(1)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Underpriced, errors.New("replacement transaction underpriced")).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `bumpedGas = bumpedGas.Add(newCfg.EVM().GasEstimator().BumpMin())`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.PriceMax = assets.GWei(500)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("terminally underpriced transaction with in_progress attempt is retried with more gas", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, kst, nil)

		originalBroadcastAt := time.Unix(1616509100, 0)
		etx := mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, nonce, fromAddress, txmgrtypes.TxAttemptInProgress, originalBroadcastAt)
		require.Equal(t, originalBroadcastAt, *etx.BroadcastAt)
		nonce++

		// Fail the first time with terminally underpriced.
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Underpriced, errors.New("Transaction gas price is too low. It does not satisfy your node's minimal gas price")).Once()
		// Succeed the second time after bumping gas.
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Successful, nil).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(t.Context(), currentHead))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Underpriced, errors.New("Transaction gas price is too low. It does not satisfy your node's minimal gas price")).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("multiple gas bumps with existing broadcast attempts are retried with more gas until success in legacy mode", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, kst, nil)

		etx := txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress)
		nonce++
		legacyAttempt := etx.TxAttempts[0]
		var dbAttempt txmgr.DbEthTxAttempt
		dbAttempt.FromTxAttempt(&legacyAttempt)
		require.NoError(t, db.Get(&dbAttempt, `UPDATE evm.tx_attempts SET broadcast_before_block_num=$1 WHERE id=$2 RETURNING *`, oldEnough, legacyAttempt.ID))

		// Fail a few times with terminally underpriced
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Underpriced, errors.New("Transaction gas price is too low. It does not satisfy your node's minimal gas price")).Times(3)
		// Succeed the second time after bumping gas.
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Successful, nil).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(t.Context(), currentHead))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt.FromTxAttempt(&legacyAttempt)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Underpriced, errors.New("Transaction gas price is too low. It does not satisfy your node's minimal gas price")).Times(3)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt.FromTxAttempt(&dxFeeAttempt)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Underpriced, errors.New("transaction underpriced")).Times(3)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `dbAttempt.FromTxAttempt(&attempt1_1)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("saves attempt with state 'insufficient_eth' if eth node returns this error", func(t *testing.T) {
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		expectedBumpedGasPrice := big.NewInt(20000000000)
		require.Greater(t, expectedBumpedGasPrice.Int64(), attempt1_1.TxFee.GasPrice.ToInt().Int64())

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		}), fromAddress).Return(multinode.InsufficientFunds, insufficientEthError).Once()

		// Do the thing
		require.NoError(t, ec.RebroadcastWhereNecessary(t.Context(), currentHead))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Len(t, etx.TxAttempts, 2)
		require.Equal(t, attempt1_1.ID, etx.TxAttempts[1].ID)

		// Got the new attempt
		attempt1_2 = etx.TxAttempts[0]
		assert.Equal(t, expectedBumpedGasPrice.Int64(), attempt1_2.TxFee.GasPrice.ToInt().Int64())
		assert.Equal(t, txmgrtypes.TxAttemptInsufficientFunds, attempt1_2.State)
		assert.Nil(t, attempt1_2.BroadcastBeforeBlockNum)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		}), fromAddress).Return(multinode.InsufficientFunds, insufficientEthError).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `attempt1_2 = etx.TxAttempts[0]`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("does not bump gas when previous error was 'out of eth', instead resubmits existing transaction", func(t *testing.T) {
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		expectedBumpedGasPrice := big.NewInt(20000000000)
		require.Greater(t, expectedBumpedGasPrice.Int64(), attempt1_1.TxFee.GasPrice.ToInt().Int64())

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		}), fromAddress).Return(multinode.InsufficientFunds, insufficientEthError).Once()

		// Do the thing
		require.NoError(t, ec.RebroadcastWhereNecessary(t.Context(), currentHead))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		// New attempt was NOT created
		require.Len(t, etx.TxAttempts, 2)

		// The attempt is still "out of eth"
		attempt1_2 = etx.TxAttempts[0]
		assert.Equal(t, expectedBumpedGasPrice.Int64(), attempt1_2.TxFee.GasPrice.ToInt().Int64())
		assert.Equal(t, txmgrtypes.TxAttemptInsufficientFunds, attempt1_2.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		}), fromAddress).Return(multinode.InsufficientFunds, insufficientEthError).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `attempt1_2 = etx.TxAttempts[0]`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("saves the attempt as broadcast after node wallet has been topped up with sufficient balance", func(t *testing.T) {
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		expectedBumpedGasPrice := big.NewInt(20000000000)
		require.Greater(t, expectedBumpedGasPrice.Int64(), attempt1_1.TxFee.GasPrice.ToInt().Int64())

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Do the thing
		require.NoError(t, ec.RebroadcastWhereNecessary(t.Context(), currentHead))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		// New attempt was NOT created
		require.Len(t, etx.TxAttempts, 2)

		// Attempt is now 'broadcast'
		attempt1_2 = etx.TxAttempts[0]
		assert.Equal(t, expectedBumpedGasPrice.Int64(), attempt1_2.TxFee.GasPrice.ToInt().Int64())
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt1_2.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `attempt1_2 = etx.TxAttempts[0]`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.BumpTxDepth = ptr(uint32(depth))`
$DIR/pkg/txmgr/confirmer_test.go: `mustInsertUnconfirmedEthTxWithInsufficientEthAttempt(t, txStore, nonce, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
				return tx.Nonce() == uint64(n)
			}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.PriceMax = assets.GWei(500)`
$DIR/pkg/txmgr/confirmer_test.go: `nonce++`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.TerminallyStuck, errors.New(terminallyStuckError)).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, config.EVM().ChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `mustInsertInProgressEthTx(t, txStore, 0, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("rebroadcasts one eth_tx if it falls within in nonce range", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) &&
				tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
				tx.Gas() == overrideGasLimit &&
				reflect.DeepEqual(tx.Data(), etx1.EncodedPayload) &&
				tx.To().String() == etx1.ToAddress.String()
		}), mock.Anything).Return(multinode.Successful, nil).Once()

		require.NoError(t, ec.ForceRebroadcast(t.Context(), []evmtypes.Nonce{1}, gasPriceWei, fromAddress, overrideGasLimit))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) &&
				tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
				tx.Gas() == overrideGasLimit &&
				reflect.DeepEqual(tx.Data(), etx1.EncodedPayload) &&
				tx.To().String() == etx1.ToAddress.String()
		}), mock.Anything).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("uses default gas limit if overrideGasLimit is 0", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) &&
				tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
				tx.Gas() == etx1.FeeLimit &&
				reflect.DeepEqual(tx.Data(), etx1.EncodedPayload) &&
				tx.To().String() == etx1.ToAddress.String()
		}), mock.Anything).Return(multinode.Successful, nil).Once()

		require.NoError(t, ec.ForceRebroadcast(t.Context(), []evmtypes.Nonce{(1)}, gasPriceWei, fromAddress, 0))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) &&
				tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
				tx.Gas() == etx1.FeeLimit &&
				reflect.DeepEqual(tx.Data(), etx1.EncodedPayload) &&
				tx.To().String() == etx1.ToAddress.String()
		}), mock.Anything).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("rebroadcasts several eth_txes in nonce range", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) && tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() && tx.Gas() == overrideGasLimit
		}), mock.Anything).Return(multinode.Successful, nil).Once()
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx2.Sequence) && tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() && tx.Gas() == overrideGasLimit
		}), mock.Anything).Return(multinode.Successful, nil).Once()

		require.NoError(t, ec.ForceRebroadcast(t.Context(), []evmtypes.Nonce{(1), (2)}, gasPriceWei, fromAddress, overrideGasLimit))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) && tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() && tx.Gas() == overrideGasLimit
		}), mock.Anything).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx2.Sequence) && tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() && tx.Gas() == overrideGasLimit
		}), mock.Anything).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `t.Run("broadcasts zero transactions if eth_tx doesn't exist for that nonce", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(1)
		}), mock.Anything).Return(multinode.Successful, nil).Once()
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(2)
		}), mock.Anything).Return(multinode.Successful, nil).Once()
		for i := 3; i <= 5; i++ {
			nonce := i
			ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
				return tx.Nonce() == uint64(nonce) &&
					tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
					tx.Gas() == overrideGasLimit &&
					*tx.To() == fromAddress &&
					tx.Value().Cmp(big.NewInt(0)) == 0 &&
					len(tx.Data()) == 0
			}), mock.Anything).Return(multinode.Successful, nil).Once()
		}
		nonces := []evmtypes.Nonce{(1), (2), (3), (4), (5)}

		require.NoError(t, ec.ForceRebroadcast(t.Context(), nonces, gasPriceWei, fromAddress, overrideGasLimit))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(1)
		}), mock.Anything).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(2)
		}), mock.Anything).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
				return tx.Nonce() == uint64(nonce) &&
					tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
					tx.Gas() == overrideGasLimit &&
					*tx.To() == fromAddress &&
					tx.Value().Cmp(big.NewInt(0)) == 0 &&
					len(tx.Data()) == 0
			}), mock.Anything).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(0) && tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() && tx.Gas() == config.EVM().GasEstimator().LimitDefault()
		}), mock.Anything).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(multinode.Successful, nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `feeEstimator.On("GetFee", mock.Anything, []byte{}, uint64(0), mock.Anything, mock.Anything, mock.Anything).Return(fee, uint64(0), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `feeEstimator.On("BumpFee", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(bumpedFee, uint64(10_000), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `c.GasEstimator.LimitDefault = ptr(limitDefault)`
$DIR/pkg/txmgr/confirmer_test.go: `c.Transactions.AutoPurge.Enabled = ptr(true)`
$DIR/pkg/txmgr/confirmer_test.go: `c.Transactions.AutoPurge.Threshold = ptr(autoPurgeThreshold)`
$DIR/pkg/txmgr/confirmer_test.go: `c.Transactions.AutoPurge.MinAttempts = ptr(autoPurgeMinAttempts)`
$DIR/pkg/txmgr/confirmer_test.go: `ec.SetResumeCallback(fn)`
$DIR/pkg/txmgr/confirmer_test.go: `servicetest.Run(t, ec)`
$DIR/pkg/txmgr/confirmer_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, signal_callback = TRUE WHERE id = $2`, uuid.New(), tx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `head.IsFinalized.Store(true)`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("NonceAt", mock.Anything, mock.Anything, mock.Anything).Return(uint64(0), nil).Once()`
$DIR/pkg/txmgr/confirmer_test.go: `head = evmtypes.Head{
			Hash:   testutils.NewHash(),
			Number: blockNum + 1,
		}`
$DIR/pkg/txmgr/confirmer_test.go: `ethClient.On("NonceAt", mock.Anything, mock.Anything, mock.Anything).Return(uint64(1), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `err = ec.ProcessHead(ctx, &head)`
$DIR/pkg/txmgr/confirmer_test.go: `dbTx, err = txStore.FindTxWithAttempts(ctx, tx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmEstimator(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.Test(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmFeeEstimator(lggr, newEst, ge.EIP1559DynamicFees(), ge, ethClient)`
$DIR/pkg/txmgr/confirmer_test.go: `.EIP1559DynamicFees()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), ge, ethKeyStore, feeEstimator)`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewStuckTxDetector(lggr, testutils.FixtureChainID, "", assets.NewWei(assets.NewEth(100).ToInt()), config.EVM().Transactions().AutoPurge(), feeEstimator, txStore, ethClient)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWei(assets.NewEth(100).ToInt())`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEth(100)`
$DIR/pkg/txmgr/confirmer_test.go: `.ToInt()`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.Transactions()`
$DIR/pkg/txmgr/confirmer_test.go: `.AutoPurge()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.String()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmConfirmer(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmFeeConfig(ge), config.EVM().Transactions(), confirmerConfig{}, ethKeyStore, txBuilder, lggr, stuckTxDetector, metrics)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmTxmFeeConfig(ge)`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.Transactions()`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.Start(ctx)`
$DIR/pkg/txmgr/confirmer_test.go: `.Start(ctx)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewHash()`
$DIR/pkg/txmgr/confirmer_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewHash()`
$DIR/pkg/txmgr/confirmer_test.go: `.Parent.Store(latestFinalizedHead)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewHash()`
$DIR/pkg/txmgr/confirmer_test.go: `.Parent.Store(h9)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("NonceAt", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.ProcessHead(ctx, head)`
$DIR/pkg/txmgr/confirmer_test.go: `.Start(ctx)`
$DIR/pkg/txmgr/confirmer_test.go: `.XXXTestCloseInternal()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.GasEstimator.PriceMax = assets.GWei(500)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(500)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewHash()`
$DIR/pkg/txmgr/confirmer_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("does nothing if no re-org'd or included transactions found", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		ethKeyStore := &keystest.FakeChainStore{Addresses: keystest.Addresses{fromAddress}}
		etx1 := mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 0, blockNum)
		etx2 := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 4, fromAddress, 1, blockNum, assets.NewWeiI(1))
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Maybe()
		require.NoError(t, ec.CheckForConfirmation(ctx, &head))

		var err error
		etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, etx1.State)

		etx2, err = txStore.FindTxWithAttempts(ctx, etx2.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx2.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(1)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(uint64(1), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("marks re-org'd confirmed transaction as unconfirmed, marks latest attempt as in-progress, deletes receipt", func(t *testing.T) {
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		// Insert confirmed transaction that stays confirmed
		etx := mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 0, blockNum)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Maybe()
		require.NoError(t, ec.CheckForConfirmation(ctx, &head))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)
		attempt := etx.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)
		require.Empty(t, attempt.Receipts)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("marks re-org'd terminally stuck transaction as unconfirmed, marks latest attempt as in-progress, deletes receipt, removed error", func(t *testing.T) {
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		// Insert terminally stuck transaction that stays fatal error
		etx := mustInsertTerminallyStuckTxWithAttempt(t, txStore, fromAddress, 0, blockNum)
		mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), etx.TxAttempts[0].Hash)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(0), nil).Maybe()
		require.NoError(t, ec.CheckForConfirmation(ctx, &head))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)
		require.Equal(t, "", etx.Error.String)
		attempt := etx.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptInProgress, attempt.State)
		require.Empty(t, attempt.Receipts)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewHash()`
$DIR/pkg/txmgr/confirmer_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("handles multiple re-org transactions at a time", func(t *testing.T) {
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		// Insert confirmed transaction that stays confirmed
		etx1 := mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 0, blockNum)
		// Insert terminally stuck transaction that stays fatal error
		etx2 := mustInsertTerminallyStuckTxWithAttempt(t, txStore, fromAddress, 1, blockNum)
		mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), etx2.TxAttempts[0].Hash)
		// Insert confirmed transaction that gets re-org'd
		etx3 := mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 2, blockNum)
		// Insert terminally stuck transaction that gets re-org'd
		etx4 := mustInsertTerminallyStuckTxWithAttempt(t, txStore, fromAddress, 3, blockNum)
		mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), etx4.TxAttempts[0].Hash)
		// Insert unconfirmed transaction that is untouched
		etx5 := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 4, fromAddress, 1, blockNum, assets.NewWeiI(1))
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(2), nil).Maybe()
		require.NoError(t, ec.CheckForConfirmation(ctx, &head))

		var err error
		etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, etx1.State)
		attempt1 := etx1.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt1.State)
		require.Len(t, attempt1.Receipts, 1)

		etx2, err = txStore.FindTxWithAttempts(ctx, etx2.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFatalError, etx2.State)
		require.Equal(t, client.TerminallyStuckMsg, etx2.Error.String)
		attempt2 := etx2.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt2.State)
		require.Len(t, attempt2.Receipts, 1)

		etx3, err = txStore.FindTxWithAttempts(ctx, etx3.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx3.State)
		attempt3 := etx3.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptInProgress, attempt3.State)
		require.Empty(t, attempt3.Receipts)

		etx4, err = txStore.FindTxWithAttempts(ctx, etx4.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx4.State)
		require.Equal(t, "", etx4.Error.String)
		attempt4 := etx4.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptInProgress, attempt4.State)
		require.True(t, attempt4.IsPurgeAttempt)
		require.Empty(t, attempt4.Receipts)

		etx5, err = txStore.FindTxWithAttempts(ctx, etx5.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx5.State)
		attempt5 := etx5.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt5.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewHash()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewHash()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(1)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(uint64(2), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx3.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx4.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx5.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("marks valid transaction as confirmed if nonce less than mined tx count", func(t *testing.T) {
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, blockNum, assets.NewWeiI(1))
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Maybe()
		require.NoError(t, ec.CheckForConfirmation(ctx, &head))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, etx.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(1)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(uint64(1), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("marks purge transaction as terminally stuck if nonce less than mined tx count", func(t *testing.T) {
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		etx := mustInsertUnconfirmedEthTxWithBroadcastPurgeAttempt(t, txStore, 0, fromAddress)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("NonceAt", mock.Anything, fromAddress, mock.Anything).Return(uint64(1), nil).Maybe()
		require.NoError(t, ec.CheckForConfirmation(ctx, &head))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFatalError, etx.State)
		require.Equal(t, client.TerminallyStuckMsg, etx.Error.String)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(uint64(1), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewHash()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(1)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(1)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("NonceAt", mock.Anything, fromAddress, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(uint64(4), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Maybe()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx3.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx4.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx5.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.Test(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("returns nothing when there are no transactions", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("returns nothing when the transaction is in_progress", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("ignores unconfirmed transactions with nil BroadcastBeforeBlockNum", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.FromTxAttempt(&attempt1_1)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(30000)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("returns nothing when the transaction is unconfirmed with an attempt that is recent", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		assert.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.FromTxAttempt(&attempt2_1)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("returns nothing when the transaction has attempts that are too new", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		assert.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEthTx(fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce(nonce)`
$DIR/pkg/txmgr/confirmer_test.go: `.Now()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("does nothing if the transaction is from a different address than the one given", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmOtherAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		assert.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmOtherAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("returns the transaction if it is unconfirmed and has no attempts (note that this is an invariant violation, but we handle it anyway)", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 1)
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("returns nothing for different chain id", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, big.NewInt(42))
		require.NoError(t, err)

		require.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, big.NewInt(42))`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.FromTxAttempt(&attempt3_1)`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, evmOtherAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.FromTxAttempt(&attemptOther1)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("returns the transaction if it is unconfirmed with an attempt that is older than gasBumpThreshold blocks", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 2)
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
		assert.Equal(t, etx3.ID, etxs[1].ID)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("returns nothing if threshold is zero", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, 0, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, 0, 10, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("does not return more transactions for gas bumping than gasBumpThreshold", func(t *testing.T) {
		// Unconfirmed txes in DB are:
		// (unnamed) (nonce 2)
		// etx1 (nonce 3)
		// etx2 (nonce 4)
		// etxWithoutAttempts (nonce 5)
		// etx3 (nonce 6) - ready for bump
		// etx4 (nonce 7) - ready for bump
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 4, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 1) // returns etxWithoutAttempts only - eligible for gas bumping because it technically doesn't have any attempts within gasBumpThreshold blocks
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)

		etxs, err = ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 5, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 2) // includes etxWithoutAttempts, etx3 and etx4
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
		assert.Equal(t, etx3.ID, etxs[1].ID)

		// Zero limit disables it
		etxs, err = ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 0, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 2) // includes etxWithoutAttempts, etx3 and etx4
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 4, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 5, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 0, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.FromTxAttempt(&attempt4_1)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("ignores pending transactions for another key", func(t *testing.T) {
		// Re-use etx3 nonce for another key, it should not affect the results for this key
		etxOther := txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, (*etx3.Sequence).Int64(), evmOtherAddress)
		aOther := etxOther.TxAttempts[0]
		dbAttempt = txmgr.DbEthTxAttempt{}
		dbAttempt.FromTxAttempt(&aOther)
		require.NoError(t, db.Get(&dbAttempt, `UPDATE evm.tx_attempts SET broadcast_before_block_num=$1 WHERE id=$2 RETURNING *`, oldEnough, aOther.ID))

		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 6, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 3) // includes etxWithoutAttempts, etx3 and etx4
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
		assert.Equal(t, etx3.ID, etxs[1].ID)
		assert.Equal(t, etx4.ID, etxs[2].ID)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, (*etx3.Sequence).Int64(), evmOtherAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.FromTxAttempt(&aOther)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 6, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(30000)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("returns the transaction if it is unconfirmed with two attempts that are older than gasBumpThreshold blocks", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 3)
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
		assert.Equal(t, etx3.ID, etxs[1].ID)
		assert.Equal(t, etx4.ID, etxs[2].ID)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(40000)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("does not return the transaction if it has some older but one newer attempt", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 2)
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
		assert.Equal(t, *etxWithoutAttempts.Sequence, *(etxs[0].Sequence))
		require.Equal(t, evmtypes.Nonce(5), *etxWithoutAttempts.Sequence)
		assert.Equal(t, etx4.ID, etxs[1].ID)
		assert.Equal(t, *etx4.Sequence, *(etxs[1].Sequence))
		require.Equal(t, evmtypes.Nonce(7), *etx4.Sequence)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewLegacyEthTxAttempt(t, etx4.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(40000)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(30001)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("returns unique attempts requiring resubmission due to insufficient eth, ordered by nonce asc", func(t *testing.T) {
		etxs, err := ec.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)
		require.NoError(t, err)

		require.Len(t, etxs, 4)
		assert.Equal(t, etxWithoutAttempts.ID, etxs[0].ID)
		assert.Equal(t, *etxWithoutAttempts.Sequence, *(etxs[0].Sequence))
		assert.Equal(t, etx4.ID, etxs[1].ID)
		assert.Equal(t, *etx4.Sequence, *(etxs[1].Sequence))
		assert.Equal(t, etx5.ID, etxs[2].ID)
		assert.Equal(t, *etx5.Sequence, *(etxs[2].Sequence))
		assert.Equal(t, etx6.ID, etxs[3].ID)
		assert.Equal(t, *etx6.Sequence, *(etxs[3].Sequence))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxsRequiringRebroadcast(t.Context(), lggr, evmFromAddress, currentHead, gasBumpThreshold, 10, 2, testutils.FixtureChainID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.Test(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("should retry previous attempt if connectivity check failed for legacy transactions", func(t *testing.T) {
		ccfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.EIP1559DynamicFees = ptr(false)
			c.GasEstimator.BlockHistory.BlockHistorySize = ptr[uint16](2)
			c.GasEstimator.BlockHistory.CheckInclusionBlocks = ptr[uint16](4)
		})

		ctx := t.Context()
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()

		estimator := gasmocks.NewEvmEstimator(t)
		newEst := func(logger.Logger) gas.EvmEstimator { return estimator }
		estimator.On("BumpLegacyGas", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(nil, uint64(0), pkgerrors.Wrapf(fees.ErrConnectivity, "transaction..."))
		ge := ccfg.EVM().GasEstimator()
		feeEstimator := gas.NewEvmFeeEstimator(lggr, newEst, ge.EIP1559DynamicFees(), ge, ethClient)
		kst := keystest.Addresses{fromAddress}
		txBuilder := txmgr.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), ge, keystest.TxSigner(nil), feeEstimator)
		stuckTxDetector := txmgr.NewStuckTxDetector(lggr, testutils.FixtureChainID, "", assets.NewWei(assets.NewEth(100).ToInt()), ccfg.EVM().Transactions().AutoPurge(), feeEstimator, txStore, ethClient)
		metrics, err := txmgr.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())
		require.NoError(t, err)
		// Create confirmer with necessary state
		ec := txmgr.NewEvmConfirmer(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmFeeConfig(ccfg.EVM().GasEstimator()), ccfg.EVM().Transactions(), confirmerConfig{}, kst, txBuilder, lggr, stuckTxDetector, metrics)
		servicetest.Run(t, ec)
		currentHead := int64(30)
		oldEnough := int64(15)
		nonce := int64(0)
		originalBroadcastAt := time.Unix(1616509100, 0)

		etx := txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress, originalBroadcastAt)
		attempt1 := etx.TxAttempts[0]
		var dbAttempt txmgr.DbEthTxAttempt
		dbAttempt.FromTxAttempt(&attempt1)
		require.NoError(t, db.Get(&dbAttempt, `UPDATE evm.tx_attempts SET broadcast_before_block_num=$1 WHERE id=$2 RETURNING *`, oldEnough, attempt1.ID))

		// Send transaction and assume success.
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(multinode.Successful, nil).Once()

		err = ec.RebroadcastWhereNecessary(t.Context(), currentHead)
		require.NoError(t, err)

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.EIP1559DynamicFees = ptr(false)
			c.GasEstimator.BlockHistory.BlockHistorySize = ptr[uint16](2)
			c.GasEstimator.BlockHistory.CheckInclusionBlocks = ptr[uint16](4)
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmEstimator(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("BumpLegacyGas", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(nil, uint64(0), pkgerrors.Wrapf(fees.ErrConnectivity, "transaction..."))`
$DIR/pkg/txmgr/confirmer_test.go: `.Wrapf(fees.ErrConnectivity, "transaction...")`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmFeeEstimator(lggr, newEst, ge.EIP1559DynamicFees(), ge, ethClient)`
$DIR/pkg/txmgr/confirmer_test.go: `.EIP1559DynamicFees()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), ge, keystest.TxSigner(nil), feeEstimator)`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.TxSigner(nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewStuckTxDetector(lggr, testutils.FixtureChainID, "", assets.NewWei(assets.NewEth(100).ToInt()), ccfg.EVM().Transactions().AutoPurge(), feeEstimator, txStore, ethClient)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWei(assets.NewEth(100).ToInt())`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEth(100)`
$DIR/pkg/txmgr/confirmer_test.go: `.ToInt()`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.Transactions()`
$DIR/pkg/txmgr/confirmer_test.go: `.AutoPurge()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.String()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmConfirmer(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmFeeConfig(ccfg.EVM().GasEstimator()), ccfg.EVM().Transactions(), confirmerConfig{}, kst, txBuilder, lggr, stuckTxDetector, metrics)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmTxmFeeConfig(ccfg.EVM().GasEstimator())`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.Transactions()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run(t, ec)`
$DIR/pkg/txmgr/confirmer_test.go: `.Unix(1616509100, 0)`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress, originalBroadcastAt)`
$DIR/pkg/txmgr/confirmer_test.go: `.FromTxAttempt(&attempt1)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.RebroadcastWhereNecessary(t.Context(), currentHead)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.EIP1559DynamicFees = ptr(true)
			c.GasEstimator.BlockHistory.BlockHistorySize = ptr[uint16](2)
			c.GasEstimator.BlockHistory.CheckInclusionBlocks = ptr[uint16](4)
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmEstimator(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("BumpDynamicFee", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(gas.DynamicFee{}, pkgerrors.Wrapf(fees.ErrConnectivity, "transaction..."))`
$DIR/pkg/txmgr/confirmer_test.go: `.Wrapf(fees.ErrConnectivity, "transaction...")`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmFeeEstimator(lggr, newEst, ge.EIP1559DynamicFees(), ge, ethClient)`
$DIR/pkg/txmgr/confirmer_test.go: `.EIP1559DynamicFees()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), ge, keystest.TxSigner(nil), feeEstimator)`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.TxSigner(nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewStuckTxDetector(lggr, testutils.FixtureChainID, "", assets.NewWei(assets.NewEth(100).ToInt()), ccfg.EVM().Transactions().AutoPurge(), feeEstimator, txStore, ethClient)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWei(assets.NewEth(100).ToInt())`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEth(100)`
$DIR/pkg/txmgr/confirmer_test.go: `.ToInt()`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.Transactions()`
$DIR/pkg/txmgr/confirmer_test.go: `.AutoPurge()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.String()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmConfirmer(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmFeeConfig(ccfg.EVM().GasEstimator()), ccfg.EVM().Transactions(), confirmerConfig{}, kst, txBuilder, lggr, stuckTxDetector, metrics)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmTxmFeeConfig(ccfg.EVM().GasEstimator())`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.Transactions()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run(t, ec)`
$DIR/pkg/txmgr/confirmer_test.go: `.Unix(1616509100, 0)`
$DIR/pkg/txmgr/confirmer_test.go: `.FromTxAttempt(&attempt1)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.RebroadcastWhereNecessary(t.Context(), currentHead)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.GasEstimator.PriceMax = assets.GWei(500)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(500)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/confirmer_test.go: `.Unix(1616509100, 0)`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress, originalBroadcastAt)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.GasPrice().Int64() == int64(20000000000) && tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.GasPrice().Int64() == int64(20000000000) && tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice()`
$DIR/pkg/txmgr/confirmer_test.go: `.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.ExceedsMaxFee, errors.New("tx fee (1.10 ether) exceeds the configured cap (1.00 ether)"))`
$DIR/pkg/txmgr/confirmer_test.go: `.New("tx fee (1.10 ether) exceeds the configured cap (1.00 ether)")`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.GasEstimator.PriceMax = assets.GWei(500)
		c.GasEstimator.BumpMin = assets.NewWeiI(0)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(500)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(0)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("does nothing if no transactions require bumping", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())

		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)
		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("re-sends previous transaction on keystore error", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := keystest.NewMemoryChainStore().MustCreate(t)
		kst := &keystest.FakeChainStore{
			Addresses: keystest.Addresses{fromAddress},
			TxSigner: func(ctx context.Context, from common.Address, tx *types.Transaction) (*types.Transaction, error) {
				if from == fromAddress {
					return nil, errors.New("signing error")
				}
				return tx, nil
			},
		}

		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, 25, assets.NewWeiI(100))

		// Use a mock keystore for this test
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, kst, nil)

		err := ec.RebroadcastWhereNecessary(ctx, currentHead)
		require.Error(t, err)
		require.Contains(t, err.Error(), "signing error")

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		require.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.New("signing error")`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(100)`
$DIR/pkg/txmgr/confirmer_test.go: `.RebroadcastWhereNecessary(ctx, currentHead)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("does nothing and continues on fatal error", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, 25, assets.NewWeiI(100))
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Fatal, errors.New("exceeds block gas limit")).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(100)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Fatal, errors.New("exceeds block gas limit"))`
$DIR/pkg/txmgr/confirmer_test.go: `.New("exceeds block gas limit")`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("creates new attempt with higher gas price if transaction has an attempt older than threshold", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		latestGasPrice := assets.GWei(20)
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, 25, latestGasPrice)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Len(t, etx.TxAttempts, 2)

		// Got the new attempt
		bumpAttempt := etx.TxAttempts[0]
		expectedBumpedGas := latestGasPrice.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())
		require.Equal(t, expectedBumpedGas.Int64(), bumpAttempt.TxFee.GasPrice.Int64())
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, bumpAttempt.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(20)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.BumpPercent()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("does nothing if there is an attempt without BroadcastBeforeBlockNum set", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		etx := mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, 0, fromAddress, txmgrtypes.TxAttemptBroadcast)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("creates new attempt with higher gas price if transaction is already in mempool (e.g. due to previous crash before we could save the new attempt)", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		latestGasPrice := assets.GWei(20)
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, 25, latestGasPrice)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, fmt.Errorf("known transaction: %s", etx.TxAttempts[0].Hash.Hex())).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Len(t, etx.TxAttempts, 2)

		// Got the new attempt
		bumpAttempt := etx.TxAttempts[0]
		expectedBumpedGas := latestGasPrice.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())
		require.Equal(t, expectedBumpedGas.Int64(), bumpAttempt.TxFee.GasPrice.Int64())
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, bumpAttempt.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(20)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, fmt.Errorf("known transaction: %s", etx.TxAttempts[0].Hash.Hex()))`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.BumpPercent()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("saves new attempt even for transaction that has already been confirmed (nonce already used)", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		latestGasPrice := assets.GWei(20)
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, 25, latestGasPrice)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.TransactionAlreadyKnown, errors.New("nonce too low")).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, etx.State)

		// Got the new attempt
		// Got the new attempt
		bumpedAttempt := etx.TxAttempts[0]
		expectedBumpedGas := latestGasPrice.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())
		require.Equal(t, expectedBumpedGas.Int64(), bumpedAttempt.TxFee.GasPrice.Int64())

		require.Len(t, etx.TxAttempts, 2)
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, etx.TxAttempts[0].State)
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, etx.TxAttempts[1].State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(20)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.TransactionAlreadyKnown, errors.New("nonce too low"))`
$DIR/pkg/txmgr/confirmer_test.go: `.New("nonce too low")`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.BumpPercent()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("saves in-progress attempt on temporary error and returns error", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		latestGasPrice := assets.GWei(20)
		broadcastBlockNum := int64(25)
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, broadcastBlockNum, latestGasPrice)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Unknown, errors.New("some network error")).Once()

		err := ec.RebroadcastWhereNecessary(ctx, currentHead)
		require.Error(t, err)
		require.Contains(t, err.Error(), "some network error")

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		// Old attempt is untouched
		require.Len(t, etx.TxAttempts, 2)
		originalAttempt := etx.TxAttempts[1]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, originalAttempt.State)
		require.Equal(t, broadcastBlockNum, *originalAttempt.BroadcastBeforeBlockNum)

		// New in_progress attempt saved
		bumpedAttempt := etx.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptInProgress, bumpedAttempt.State)
		require.Nil(t, bumpedAttempt.BroadcastBeforeBlockNum)

		// Try again and move the attempt into "broadcast"
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		// New in_progress attempt saved and marked "broadcast"
		require.Len(t, etx.TxAttempts, 2)
		bumpedAttempt = etx.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, bumpedAttempt.State)
		require.Nil(t, bumpedAttempt.BroadcastBeforeBlockNum)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(20)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Unknown, errors.New("some network error"))`
$DIR/pkg/txmgr/confirmer_test.go: `.New("some network error")`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.RebroadcastWhereNecessary(ctx, currentHead)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("re-bumps attempt if initial bump is underpriced because the bumped gas price is insufficiently higher than the previous one", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		latestGasPrice := assets.GWei(20)
		broadcastBlockNum := int64(25)
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, broadcastBlockNum, latestGasPrice)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Underpriced, errors.New("replacement transaction underpriced")).Once()
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Do the thing
		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		require.Len(t, etx.TxAttempts, 2)
		bumpedAttempt := etx.TxAttempts[0]
		expectedBumpedGas := latestGasPrice.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())
		expectedBumpedGas = expectedBumpedGas.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())
		require.Equal(t, expectedBumpedGas.Int64(), bumpedAttempt.TxFee.GasPrice.Int64())
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(20)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Underpriced, errors.New("replacement transaction underpriced"))`
$DIR/pkg/txmgr/confirmer_test.go: `.New("replacement transaction underpriced")`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.BumpPercent()`
$DIR/pkg/txmgr/confirmer_test.go: `.AddPercentage(evmcfg.EVM().GasEstimator().BumpPercent())`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.BumpPercent()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("resubmits at the old price and does not create a new attempt if one of the bumped transactions would exceed EVM.GasEstimator.PriceMax", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		priceMax := assets.GWei(30)
		newCfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.PriceMax = priceMax
		})
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		broadcastBlockNum := int64(25)
		currentAttemptPrice := priceMax.Sub(assets.GWei(1))
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, broadcastBlockNum, currentAttemptPrice)
		ec := newEthConfirmer(t, txStore, ethClient, newCfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Underpriced, errors.New("underpriced")).Once() // we already submitted at this price, now it's time to bump and submit again but since we simply resubmitted rather than increasing gas price, geth already knows about this tx

		// Do the thing
		require.Error(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		// No new tx attempts
		require.Len(t, etx.TxAttempts, 1)
		bumpedAttempt := etx.TxAttempts[0]
		require.Equal(t, currentAttemptPrice.Int64(), bumpedAttempt.TxFee.GasPrice.Int64())
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(30)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.PriceMax = priceMax
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.Sub(assets.GWei(1))`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(1)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Underpriced, errors.New("underpriced"))`
$DIR/pkg/txmgr/confirmer_test.go: `.New("underpriced")`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("resubmits at the old price and does not create a new attempt if the current price is exactly EVM.GasEstimator.PriceMax", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		priceMax := assets.GWei(30)
		newCfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.PriceMax = priceMax
		})
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		broadcastBlockNum := int64(25)
		etx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, broadcastBlockNum, priceMax)
		ec := newEthConfirmer(t, txStore, ethClient, newCfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Underpriced, errors.New("underpriced")).Once() // we already submitted at this price, now it's time to bump and submit again but since we simply resubmitted rather than increasing gas price, geth already knows about this tx

		// Do the thing
		require.Error(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		// No new tx attempts
		require.Len(t, etx.TxAttempts, 1)
		bumpedAttempt := etx.TxAttempts[0]
		require.Equal(t, priceMax.Int64(), bumpedAttempt.TxFee.GasPrice.Int64())
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(30)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.PriceMax = priceMax
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Underpriced, errors.New("underpriced"))`
$DIR/pkg/txmgr/confirmer_test.go: `.New("underpriced")`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("EIP-1559: bumps using EIP-1559 rules when existing attempts are of type 0x2", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		newCfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.BumpMin = assets.GWei(1)
		})
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		etx := mustInsertUnconfirmedEthTxWithBroadcastDynamicFeeAttempt(t, txStore, 0, fromAddress)
		err := txStore.UpdateTxAttemptBroadcastBeforeBlockNum(ctx, etx.ID, uint(25))
		require.NoError(t, err)
		ec := newEthConfirmer(t, txStore, ethClient, newCfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Successful, nil).Once()
		require.NoError(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		// A new, bumped attempt
		require.Len(t, etx.TxAttempts, 2)
		bumpAttempt := etx.TxAttempts[0]
		require.Nil(t, bumpAttempt.TxFee.GasPrice)
		bumpedGas := assets.NewWeiI(1).Add(newCfg.EVM().GasEstimator().BumpMin())
		require.Equal(t, bumpedGas.Int64(), bumpAttempt.TxFee.GasTipCap.Int64())
		require.Equal(t, bumpedGas.Int64(), bumpAttempt.TxFee.GasFeeCap.Int64())
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, bumpAttempt.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.BumpMin = assets.GWei(1)
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(1)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.UpdateTxAttemptBroadcastBeforeBlockNum(ctx, etx.ID, uint(25))`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(1)`
$DIR/pkg/txmgr/confirmer_test.go: `.Add(newCfg.EVM().GasEstimator().BumpMin())`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.BumpMin()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("EIP-1559: resubmits at the old price and does not create a new attempt if one of the bumped EIP-1559 transactions would have its tip cap exceed EVM.GasEstimator.PriceMax", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		newCfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.PriceMax = assets.NewWeiI(1)
		})
		memKS := keystest.NewMemoryChainStore()
		fromAddress := memKS.MustCreate(t)
		ethKeyStore := keys.NewChainStore(memKS, ethClient.ConfiguredChainID())
		etx := mustInsertUnconfirmedEthTxWithBroadcastDynamicFeeAttempt(t, txStore, 0, fromAddress)
		err := txStore.UpdateTxAttemptBroadcastBeforeBlockNum(ctx, etx.ID, uint(25))
		require.NoError(t, err)
		ec := newEthConfirmer(t, txStore, ethClient, newCfg, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress).Return(multinode.Underpriced, errors.New("underpriced")).Once()

		require.Error(t, ec.RebroadcastWhereNecessary(ctx, currentHead))
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		assert.Equal(t, txmgrcommon.TxUnconfirmed, etx.State)

		// No new tx attempts
		require.Len(t, etx.TxAttempts, 1)
		bumpedAttempt := etx.TxAttempts[0]
		assert.Equal(t, assets.NewWeiI(1).Int64(), bumpedAttempt.TxFee.GasTipCap.Int64())
		assert.Equal(t, assets.NewWeiI(1).Int64(), bumpedAttempt.TxFee.GasFeeCap.Int64())
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.PriceMax = assets.NewWeiI(1)
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(1)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.UpdateTxAttemptBroadcastBeforeBlockNum(ctx, etx.ID, uint(25))`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Underpriced, errors.New("underpriced"))`
$DIR/pkg/txmgr/confirmer_test.go: `.New("underpriced")`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.BumpMin = assets.GWei(1)
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(1)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.UpdateTxAttemptBroadcastBeforeBlockNum(ctx, etx.ID, uint(25))`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Underpriced, errors.New("replacement transaction underpriced"))`
$DIR/pkg/txmgr/confirmer_test.go: `.New("replacement transaction underpriced")`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWeiI(1)`
$DIR/pkg/txmgr/confirmer_test.go: `.Add(newCfg.EVM().GasEstimator().BumpMin())`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.BumpMin()`
$DIR/pkg/txmgr/confirmer_test.go: `.Add(newCfg.EVM().GasEstimator().BumpMin())`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.BumpMin()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, big.NewInt(0))`
$DIR/pkg/txmgr/confirmer_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.GasEstimator.PriceMax = assets.GWei(500)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(500)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("terminally underpriced transaction with in_progress attempt is retried with more gas", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, kst, nil)

		originalBroadcastAt := time.Unix(1616509100, 0)
		etx := mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, nonce, fromAddress, txmgrtypes.TxAttemptInProgress, originalBroadcastAt)
		require.Equal(t, originalBroadcastAt, *etx.BroadcastAt)
		nonce++

		// Fail the first time with terminally underpriced.
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Underpriced, errors.New("Transaction gas price is too low. It does not satisfy your node's minimal gas price")).Once()
		// Succeed the second time after bumping gas.
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Successful, nil).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(t.Context(), currentHead))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.Unix(1616509100, 0)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(
			multinode.Underpriced, errors.New("Transaction gas price is too low. It does not satisfy your node's minimal gas price"))`
$DIR/pkg/txmgr/confirmer_test.go: `.New("Transaction gas price is too low. It does not satisfy your node's minimal gas price")`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(
			multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("multiple gas bumps with existing broadcast attempts are retried with more gas until success in legacy mode", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ec := newEthConfirmer(t, txStore, ethClient, evmcfg, kst, nil)

		etx := txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress)
		nonce++
		legacyAttempt := etx.TxAttempts[0]
		var dbAttempt txmgr.DbEthTxAttempt
		dbAttempt.FromTxAttempt(&legacyAttempt)
		require.NoError(t, db.Get(&dbAttempt, `UPDATE evm.tx_attempts SET broadcast_before_block_num=$1 WHERE id=$2 RETURNING *`, oldEnough, legacyAttempt.ID))

		// Fail a few times with terminally underpriced
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Underpriced, errors.New("Transaction gas price is too low. It does not satisfy your node's minimal gas price")).Times(3)
		// Succeed the second time after bumping gas.
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress).Return(
			multinode.Successful, nil).Once()

		require.NoError(t, ec.RebroadcastWhereNecessary(t.Context(), currentHead))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.FromTxAttempt(&legacyAttempt)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(
			multinode.Underpriced, errors.New("Transaction gas price is too low. It does not satisfy your node's minimal gas price"))`
$DIR/pkg/txmgr/confirmer_test.go: `.New("Transaction gas price is too low. It does not satisfy your node's minimal gas price")`
$DIR/pkg/txmgr/confirmer_test.go: `.Times(3)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(
			multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.FromTxAttempt(&dxFeeAttempt)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(
			multinode.Underpriced, errors.New("transaction underpriced"))`
$DIR/pkg/txmgr/confirmer_test.go: `.New("transaction underpriced")`
$DIR/pkg/txmgr/confirmer_test.go: `.Times(3)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(
			multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.FromTxAttempt(&attempt1_1)`
$DIR/pkg/txmgr/confirmer_test.go: `.New("insufficient funds for gas * price + value")`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("saves attempt with state 'insufficient_eth' if eth node returns this error", func(t *testing.T) {
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		expectedBumpedGasPrice := big.NewInt(20000000000)
		require.Greater(t, expectedBumpedGasPrice.Int64(), attempt1_1.TxFee.GasPrice.ToInt().Int64())

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		}), fromAddress).Return(multinode.InsufficientFunds, insufficientEthError).Once()

		// Do the thing
		require.NoError(t, ec.RebroadcastWhereNecessary(t.Context(), currentHead))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Len(t, etx.TxAttempts, 2)
		require.Equal(t, attempt1_1.ID, etx.TxAttempts[1].ID)

		// Got the new attempt
		attempt1_2 = etx.TxAttempts[0]
		assert.Equal(t, expectedBumpedGasPrice.Int64(), attempt1_2.TxFee.GasPrice.ToInt().Int64())
		assert.Equal(t, txmgrtypes.TxAttemptInsufficientFunds, attempt1_2.State)
		assert.Nil(t, attempt1_2.BroadcastBeforeBlockNum)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewInt(20000000000)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Cmp(tx.GasPrice())`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.InsufficientFunds, insufficientEthError)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("does not bump gas when previous error was 'out of eth', instead resubmits existing transaction", func(t *testing.T) {
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		expectedBumpedGasPrice := big.NewInt(20000000000)
		require.Greater(t, expectedBumpedGasPrice.Int64(), attempt1_1.TxFee.GasPrice.ToInt().Int64())

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		}), fromAddress).Return(multinode.InsufficientFunds, insufficientEthError).Once()

		// Do the thing
		require.NoError(t, ec.RebroadcastWhereNecessary(t.Context(), currentHead))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		// New attempt was NOT created
		require.Len(t, etx.TxAttempts, 2)

		// The attempt is still "out of eth"
		attempt1_2 = etx.TxAttempts[0]
		assert.Equal(t, expectedBumpedGasPrice.Int64(), attempt1_2.TxFee.GasPrice.ToInt().Int64())
		assert.Equal(t, txmgrtypes.TxAttemptInsufficientFunds, attempt1_2.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewInt(20000000000)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Cmp(tx.GasPrice())`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.InsufficientFunds, insufficientEthError)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("saves the attempt as broadcast after node wallet has been topped up with sufficient balance", func(t *testing.T) {
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		expectedBumpedGasPrice := big.NewInt(20000000000)
		require.Greater(t, expectedBumpedGasPrice.Int64(), attempt1_1.TxFee.GasPrice.ToInt().Int64())

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		}), fromAddress).Return(multinode.Successful, nil).Once()

		// Do the thing
		require.NoError(t, ec.RebroadcastWhereNecessary(t.Context(), currentHead))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		// New attempt was NOT created
		require.Len(t, etx.TxAttempts, 2)

		// Attempt is now 'broadcast'
		attempt1_2 = etx.TxAttempts[0]
		assert.Equal(t, expectedBumpedGasPrice.Int64(), attempt1_2.TxFee.GasPrice.ToInt().Int64())
		assert.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt1_2.State)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewInt(20000000000)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return expectedBumpedGasPrice.Cmp(tx.GasPrice()) == 0
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Cmp(tx.GasPrice())`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.GasEstimator.BumpTxDepth = ptr(uint32(depth))
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
				return tx.Nonce() == uint64(n)
			}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
				return tx.Nonce() == uint64(n)
			})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.GasEstimator.PriceMax = assets.GWei(500)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(500)`
$DIR/pkg/txmgr/confirmer_test.go: `.Unix(1616509100, 0)`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, nonce, fromAddress, originalBroadcastAt)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.TerminallyStuck, errors.New(terminallyStuckError))`
$DIR/pkg/txmgr/confirmer_test.go: `.New(terminallyStuckError)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		}), fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx.Sequence) //nolint:gosec // disable G115
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainStore(memKS, big.NewInt(0))`
$DIR/pkg/txmgr/confirmer_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.ChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 1, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 2, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(52)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("rebroadcasts one eth_tx if it falls within in nonce range", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) &&
				tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
				tx.Gas() == overrideGasLimit &&
				reflect.DeepEqual(tx.Data(), etx1.EncodedPayload) &&
				tx.To().String() == etx1.ToAddress.String()
		}), mock.Anything).Return(multinode.Successful, nil).Once()

		require.NoError(t, ec.ForceRebroadcast(t.Context(), []evmtypes.Nonce{1}, gasPriceWei, fromAddress, overrideGasLimit))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) &&
				tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
				tx.Gas() == overrideGasLimit &&
				reflect.DeepEqual(tx.Data(), etx1.EncodedPayload) &&
				tx.To().String() == etx1.ToAddress.String()
		}), mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) &&
				tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
				tx.Gas() == overrideGasLimit &&
				reflect.DeepEqual(tx.Data(), etx1.EncodedPayload) &&
				tx.To().String() == etx1.ToAddress.String()
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice()`
$DIR/pkg/txmgr/confirmer_test.go: `.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.Gas()`
$DIR/pkg/txmgr/confirmer_test.go: `.DeepEqual(tx.Data(), etx1.EncodedPayload)`
$DIR/pkg/txmgr/confirmer_test.go: `.Data()`
$DIR/pkg/txmgr/confirmer_test.go: `.To()`
$DIR/pkg/txmgr/confirmer_test.go: `.String()`
$DIR/pkg/txmgr/confirmer_test.go: `.ToAddress.String()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("uses default gas limit if overrideGasLimit is 0", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) &&
				tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
				tx.Gas() == etx1.FeeLimit &&
				reflect.DeepEqual(tx.Data(), etx1.EncodedPayload) &&
				tx.To().String() == etx1.ToAddress.String()
		}), mock.Anything).Return(multinode.Successful, nil).Once()

		require.NoError(t, ec.ForceRebroadcast(t.Context(), []evmtypes.Nonce{(1)}, gasPriceWei, fromAddress, 0))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) &&
				tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
				tx.Gas() == etx1.FeeLimit &&
				reflect.DeepEqual(tx.Data(), etx1.EncodedPayload) &&
				tx.To().String() == etx1.ToAddress.String()
		}), mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) &&
				tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
				tx.Gas() == etx1.FeeLimit &&
				reflect.DeepEqual(tx.Data(), etx1.EncodedPayload) &&
				tx.To().String() == etx1.ToAddress.String()
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice()`
$DIR/pkg/txmgr/confirmer_test.go: `.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.Gas()`
$DIR/pkg/txmgr/confirmer_test.go: `.DeepEqual(tx.Data(), etx1.EncodedPayload)`
$DIR/pkg/txmgr/confirmer_test.go: `.Data()`
$DIR/pkg/txmgr/confirmer_test.go: `.To()`
$DIR/pkg/txmgr/confirmer_test.go: `.String()`
$DIR/pkg/txmgr/confirmer_test.go: `.ToAddress.String()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("rebroadcasts several eth_txes in nonce range", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) && tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() && tx.Gas() == overrideGasLimit
		}), mock.Anything).Return(multinode.Successful, nil).Once()
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx2.Sequence) && tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() && tx.Gas() == overrideGasLimit
		}), mock.Anything).Return(multinode.Successful, nil).Once()

		require.NoError(t, ec.ForceRebroadcast(t.Context(), []evmtypes.Nonce{(1), (2)}, gasPriceWei, fromAddress, overrideGasLimit))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) && tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() && tx.Gas() == overrideGasLimit
		}), mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx1.Sequence) && tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() && tx.Gas() == overrideGasLimit
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice()`
$DIR/pkg/txmgr/confirmer_test.go: `.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.Gas()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx2.Sequence) && tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() && tx.Gas() == overrideGasLimit
		}), mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(*etx2.Sequence) && tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() && tx.Gas() == overrideGasLimit
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice()`
$DIR/pkg/txmgr/confirmer_test.go: `.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.Gas()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.Run("broadcasts zero transactions if eth_tx doesn't exist for that nonce", func(t *testing.T) {
		ethClient := clienttest.NewClientWithDefaultChainID(t)
		ec := newEthConfirmer(t, txStore, ethClient, config, ethKeyStore, nil)

		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(1)
		}), mock.Anything).Return(multinode.Successful, nil).Once()
		ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(2)
		}), mock.Anything).Return(multinode.Successful, nil).Once()
		for i := 3; i <= 5; i++ {
			nonce := i
			ethClient.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
				return tx.Nonce() == uint64(nonce) &&
					tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
					tx.Gas() == overrideGasLimit &&
					*tx.To() == fromAddress &&
					tx.Value().Cmp(big.NewInt(0)) == 0 &&
					len(tx.Data()) == 0
			}), mock.Anything).Return(multinode.Successful, nil).Once()
		}
		nonces := []evmtypes.Nonce{(1), (2), (3), (4), (5)}

		require.NoError(t, ec.ForceRebroadcast(t.Context(), nonces, gasPriceWei, fromAddress, overrideGasLimit))
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(1)
		}), mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(1)
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(2)
		}), mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(2)
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
				return tx.Nonce() == uint64(nonce) &&
					tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
					tx.Gas() == overrideGasLimit &&
					*tx.To() == fromAddress &&
					tx.Value().Cmp(big.NewInt(0)) == 0 &&
					len(tx.Data()) == 0
			}), mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
				return tx.Nonce() == uint64(nonce) &&
					tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() &&
					tx.Gas() == overrideGasLimit &&
					*tx.To() == fromAddress &&
					tx.Value().Cmp(big.NewInt(0)) == 0 &&
					len(tx.Data()) == 0
			})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice()`
$DIR/pkg/txmgr/confirmer_test.go: `.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.Gas()`
$DIR/pkg/txmgr/confirmer_test.go: `.To()`
$DIR/pkg/txmgr/confirmer_test.go: `.Value()`
$DIR/pkg/txmgr/confirmer_test.go: `.Cmp(big.NewInt(0))`
$DIR/pkg/txmgr/confirmer_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/confirmer_test.go: `.Data()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(0) && tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() && tx.Gas() == config.EVM().GasEstimator().LimitDefault()
		}), mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.MatchedBy(func(tx *types.Transaction) bool {
			return tx.Nonce() == uint64(0) && tx.GasPrice().Int64() == gasPriceWei.GasPrice.Int64() && tx.Gas() == config.EVM().GasEstimator().LimitDefault()
		})`
$DIR/pkg/txmgr/confirmer_test.go: `.Nonce()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice()`
$DIR/pkg/txmgr/confirmer_test.go: `.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasPrice.Int64()`
$DIR/pkg/txmgr/confirmer_test.go: `.Gas()`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.LimitDefault()`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("SendTransactionReturnCode", mock.Anything, mock.Anything, fromAddress)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(multinode.Successful, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.Test(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/confirmer_test.go: `.GWei(30)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("GetFee", mock.Anything, []byte{}, uint64(0), mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(fee, uint64(0), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("BumpFee", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(bumpedFee, uint64(10_000), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.GasEstimator.LimitDefault = ptr(limitDefault)
		c.Transactions.AutoPurge.Enabled = ptr(true)
		c.Transactions.AutoPurge.Threshold = ptr(autoPurgeThreshold)
		c.Transactions.AutoPurge.MinAttempts = ptr(autoPurgeMinAttempts)
	})`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmTxAttemptBuilder(*ethClient.ConfiguredChainID(), ge, ethKeyStore, feeEstimator)`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewStuckTxDetector(lggr, testutils.FixtureChainID, "", assets.NewWei(assets.NewEth(100).ToInt()), evmcfg.EVM().Transactions().AutoPurge(), feeEstimator, txStore, ethClient)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewWei(assets.NewEth(100).ToInt())`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEth(100)`
$DIR/pkg/txmgr/confirmer_test.go: `.ToInt()`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.Transactions()`
$DIR/pkg/txmgr/confirmer_test.go: `.AutoPurge()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/confirmer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/confirmer_test.go: `.String()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmConfirmer(txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTxmFeeConfig(ge), evmcfg.EVM().Transactions(), confirmerConfig{}, ethKeyStore, txBuilder, lggr, stuckTxDetector, metrics)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewEvmTxmFeeConfig(ge)`
$DIR/pkg/txmgr/confirmer_test.go: `.EVM()`
$DIR/pkg/txmgr/confirmer_test.go: `.Transactions()`
$DIR/pkg/txmgr/confirmer_test.go: `.SetResumeCallback(fn)`
$DIR/pkg/txmgr/confirmer_test.go: `.Run(t, ec)`
$DIR/pkg/txmgr/confirmer_test.go: `.Context()`
$DIR/pkg/txmgr/confirmer_test.go: `.Add(oneGwei)`
$DIR/pkg/txmgr/confirmer_test.go: `.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, signal_callback = TRUE WHERE id = $2`, uuid.New(), tx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.New()`
$DIR/pkg/txmgr/confirmer_test.go: `.NewHash()`
$DIR/pkg/txmgr/confirmer_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/txmgr/confirmer_test.go: `.On("NonceAt", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.Once()`
$DIR/pkg/txmgr/confirmer_test.go: `.ProcessHead(ctx, &head)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, tx.ID)`
$DIR/pkg/txmgr/confirmer_test.go: `.NewHash()`
$DIR/pkg/txmgr/confirmer_test.go: `.On("NonceAt", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/confirmer_test.go: `.Return(uint64(1), nil)`
$DIR/pkg/txmgr/confirmer_test.go: `.ProcessHead(ctx, &head)`
$DIR/pkg/txmgr/confirmer_test.go: `.FindTxWithAttempts(ctx, tx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt.State = txmgrtypes.TxAttemptBroadcast`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(3)}`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt.BroadcastBeforeBlockNum = &blockNum`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txs, count, err = txStore.TransactionsWithAttempts(ctx, 0, 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt.State = txmgrtypes.TxAttemptBroadcast`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(3)}`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt.BroadcastBeforeBlockNum = &blockNum`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("InsertTx", func(t *testing.T) {
		etx = txmgrtest.NewEthTx(fromAddress)
		require.NoError(t, orm.InsertTx(ctx, &etx))
		assert.Greater(t, int(etx.ID), 0)
		txmgrtest.AssertCount(t, db, "evm.txes", 1)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx = txmgrtest.NewEthTx(fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("InsertTxAttempt", func(t *testing.T) {
		attemptD = txmgrtest.NewDynamicFeeEthTxAttempt(t, etx.ID)
		require.NoError(t, orm.InsertTxAttempt(ctx, &attemptD))
		assert.Greater(t, int(attemptD.ID), 0)
		txmgrtest.AssertCount(t, db, "evm.tx_attempts", 1)

		attemptL = txmgrtest.NewLegacyEthTxAttempt(t, etx.ID)
		attemptL.State = txmgrtypes.TxAttemptBroadcast
		attemptL.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(42)}
		require.NoError(t, orm.InsertTxAttempt(ctx, &attemptL))
		assert.Greater(t, int(attemptL.ID), 0)
		txmgrtest.AssertCount(t, db, "evm.tx_attempts", 2)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attemptD = txmgrtest.NewDynamicFeeEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.AssertCount(t, db, "evm.tx_attempts", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attemptL = txmgrtest.NewLegacyEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attemptL.State = txmgrtypes.TxAttemptBroadcast`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attemptL.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(42)}`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.AssertCount(t, db, "evm.tx_attempts", 2)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("InsertReceipt", func(t *testing.T) {
		r = newEthReceipt(42, utils.NewHash(), attemptD.Hash, 0x1)
		id, err := orm.InsertReceipt(ctx, &r.Receipt)
		r.ID = id
		require.NoError(t, err)
		assert.Greater(t, int(r.ID), 0)
		txmgrtest.AssertCount(t, db, "evm.receipts", 1)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `r = newEthReceipt(42, utils.NewHash(), attemptD.Hash, 0x1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `r.ID = id`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.AssertCount(t, db, "evm.receipts", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("FindTxWithAttempts", func(t *testing.T) {
		var err error
		etx, err = orm.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 2)
		assert.Equal(t, etx.TxAttempts[0].ID, attemptD.ID)
		assert.Equal(t, etx.TxAttempts[1].ID, attemptL.ID)
		require.Len(t, etx.TxAttempts[0].Receipts, 1)
		require.Empty(t, etx.TxAttempts[1].Receipts)
		assert.Equal(t, r.BlockHash, etx.TxAttempts[0].Receipts[0].GetBlockHash())
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx, err = orm.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("FindTxByHash", func(t *testing.T) {
		foundEtx, err := orm.FindTxByHash(ctx, attemptD.Hash)
		require.NoError(t, err)
		assert.Equal(t, etx.ID, foundEtx.ID)
		assert.Equal(t, etx.ChainID, foundEtx.ChainID)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt.State = txmgrtypes.TxAttemptBroadcast`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(3)}`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt.BroadcastBeforeBlockNum = &blockNum`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustCreateUnstartedGeneratedTx(t, orm, fromAddress, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertUnconfirmedEthTx(t, orm, 3, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, orm, 4, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = db.Get(&count, `SELECT count(*) FROM evm.txes`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = db.Get(&count, `SELECT count(*) FROM evm.tx_attempts`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("returns nothing if there are no transactions", func(t *testing.T) {
		olderThan := time.Now()
		attempts, err := txStore.FindTxAttemptsRequiringResend(tests.Context(t), olderThan, 10, testutils.FixtureChainID, fromAddress)
		require.NoError(t, err)
		assert.Empty(t, attempts)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt1_2.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(10)}`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt3_2.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(10)}`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt4_2.TxFee.GasTipCap = assets.NewWeiI(10)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt4_2.TxFee.GasFeeCap = assets.NewWeiI(20)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt4_2.State = txmgrtypes.TxAttemptBroadcast`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt4_4.TxFee.GasTipCap = assets.NewWeiI(30)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt4_4.TxFee.GasFeeCap = assets.NewWeiI(40)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt4_4.State = txmgrtypes.TxAttemptBroadcast`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt4_3.TxFee.GasTipCap = assets.NewWeiI(20)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt4_3.TxFee.GasFeeCap = assets.NewWeiI(30)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt4_3.State = txmgrtypes.TxAttemptBroadcast`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("returns nothing if there are transactions from a different key", func(t *testing.T) {
		olderThan := time.Now()
		attempts, err := txStore.FindTxAttemptsRequiringResend(tests.Context(t), olderThan, 10, testutils.FixtureChainID, utils.RandomAddress())
		require.NoError(t, err)
		assert.Empty(t, attempts)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("returns the highest price attempt for each transaction that was last broadcast before or on the given time", func(t *testing.T) {
		olderThan := time.Unix(1616509200, 0)
		attempts, err := txStore.FindTxAttemptsRequiringResend(tests.Context(t), olderThan, 0, testutils.FixtureChainID, fromAddress)
		require.NoError(t, err)
		assert.Len(t, attempts, 2)
		assert.Equal(t, attempt1_2.ID, attempts[0].ID)
		assert.Equal(t, etxs[1].TxAttempts[0].ID, attempts[1].ID)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("returns the highest price attempt for EIP-1559 transactions", func(t *testing.T) {
		olderThan := time.Unix(1616509400, 0)
		attempts, err := txStore.FindTxAttemptsRequiringResend(tests.Context(t), olderThan, 0, testutils.FixtureChainID, fromAddress)
		require.NoError(t, err)
		assert.Len(t, attempts, 4)
		assert.Equal(t, attempt4_4.ID, attempts[3].ID)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("does not update when broadcast_at is NULL", func(t *testing.T) {
		t.Parallel()
		ctx := tests.Context(t)
		etx := mustCreateUnstartedGeneratedTx(t, orm, fromAddress, testutils.FixtureChainID)

		var nullTime *time.Time
		assert.Equal(t, nullTime, etx.BroadcastAt)

		currTime := time.Now()
		err := orm.UpdateBroadcastAts(tests.Context(t), currTime, []int64{etx.ID})
		require.NoError(t, err)
		etx, err = orm.FindTxWithAttempts(ctx, etx.ID)

		require.NoError(t, err)
		assert.Equal(t, nullTime, etx.BroadcastAt)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx, err = orm.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.Sequence = new(types.Nonce)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.State = txmgrcommon.TxUnconfirmed`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.BroadcastAt = &time1`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.InitialBroadcastAt = &time1`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = orm.UpdateBroadcastAts(ctx, time2, []int64{etx.ID})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx, err = orm.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("saves block num to unconfirmed evm.tx_attempts without one", func(t *testing.T) {
		// Do the thing
		require.NoError(t, txStore.SetBroadcastBeforeBlockNum(tests.Context(t), headNum, chainID))

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]

		assert.Equal(t, int64(9000), *attempt.BroadcastBeforeBlockNum)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("does not change evm.tx_attempts that already have BroadcastBeforeBlockNum set", func(t *testing.T) {
		n := int64(42)
		attempt := newBroadcastLegacyEthTxAttempt(t, etx.ID, 2)
		attempt.BroadcastBeforeBlockNum = &n
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt))

		// Do the thing
		require.NoError(t, txStore.SetBroadcastBeforeBlockNum(tests.Context(t), headNum, chainID))

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 2)
		attempt = etx.TxAttempts[0]

		assert.Equal(t, int64(42), *attempt.BroadcastBeforeBlockNum)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt.BroadcastBeforeBlockNum = &n`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt = etx.TxAttempts[0]`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etxThisChain, err = txStore.FindTxWithAttempts(ctx, etxThisChain.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etxOtherChain, err = txStore.FindTxWithAttempts(ctx, etxOtherChain.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt = etxOtherChain.TxAttempts[0]`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx0, err = txStore.FindTxWithAttempts(ctx, etx0.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `tx1, err = txStore.FindTxWithAttempts(ctx, tx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `tx2, err = txStore.FindTxWithAttempts(ctx, tx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("loads eth transaction", func(t *testing.T) {
		// insert etx with attempt
		etx := txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, int64(7), fromAddress)

		// create unloaded attempt
		unloadedAttempt := txmgr.TxAttempt{TxID: etx.ID}

		// uninitialized EthTx
		assert.Equal(t, int64(0), unloadedAttempt.Tx.ID)

		attempts := []txmgr.TxAttempt{unloadedAttempt}

		err := txStore.PreloadTxes(tests.Context(t), attempts)
		require.NoError(t, err)

		assert.Equal(t, etx.ID, attempts[0].Tx.ID)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `SET CONSTRAINTS fk_pipeline_runs_pruning_key DEFERRED`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `SET CONSTRAINTS pipeline_runs_pipeline_spec_id_fkey DEFERRED`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `h9.Parent.Store(h8)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE pipeline_runs SET state = 'suspended' WHERE id = $1`, runID1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": true}'`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID1, minConfirmations, etx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE pipeline_runs SET state = 'completed', outputs = '""'::jsonb, finished_at = NOW() WHERE id = $1`, runID2)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": false}'`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertEthReceipt(t, txStore, head.Number-minConfirmations, head.Hash, attempt2.Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE, callback_completed = TRUE WHERE id = $3`, &trID2, minConfirmations, etx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE pipeline_runs SET state = 'suspended' WHERE id = $1`, runID3)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": false}'`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertEthReceipt(t, txStore, head.Number, head.Hash, attempt3.Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID3, minConfirmations, etx3.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertEthReceipt(t, txStore, head.Number, head.Hash, attempt4.Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET min_confirmations = $1 WHERE id = $2`, minConfirmations, etx4.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET min_confirmations = $1 WHERE id = $2`, minConfirmations, etx5.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET min_confirmations = NULL WHERE id = $1`, etx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `receiptsPlus, err = txStore.FindTxesPendingCallback(tests.Context(t), head.Number, 0, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `receiptsPlus, err = txStore.FindTxesPendingCallback(tests.Context(t), head.Number, etxBlockNum, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("returns nil error if no results", func(t *testing.T) {
		idempotencyKey := "777"
		etx, err := txStore.FindTxWithIdempotencyKey(tests.Context(t), idempotencyKey, big.NewInt(0))
		require.NoError(t, err)
		assert.Nil(t, etx)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `cfg.EVM().ChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("returns nil error if no results", func(t *testing.T) {
		r, err := txStore.FindReceiptWithIdempotencyKey(tests.Context(t), idempotencyKey, big.NewInt(0))
		require.NoError(t, err)
		assert.Nil(t, r)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx = txmgrtest.NewEthTx(fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.IdempotencyKey = &idempotencyKey`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attemptD = txmgrtest.NewDynamicFeeEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.AssertCount(t, db, "evm.tx_attempts", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attemptL = txmgrtest.NewLegacyEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attemptL.State = txmgrtypes.TxAttemptBroadcast`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attemptL.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(42)}`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.AssertCount(t, db, "evm.tx_attempts", 2)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `r = newEthReceipt(42, utils.NewHash(), attemptD.Hash, 0x1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `r.ID = id`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.AssertCount(t, db, "evm.receipts", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("returns nil if no results", func(t *testing.T) {
		etx, err := txStore.FindTxWithSequence(tests.Context(t), fromAddress, types.Nonce(777))
		require.NoError(t, err)
		assert.Nil(t, etx)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("marks confirmed tx as unconfirmed, marks latest attempt as in-progress, deletes receipt", func(t *testing.T) {
		etx := mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 777, 1)
		etx, err := txStore.FindTxWithAttempts(ctx, etx.ID)
		assert.NoError(t, err)
		// assert attempt state
		attempt := etx.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
		// assert tx state
		assert.Equal(t, txmgrcommon.TxConfirmed, etx.State)
		// assert receipt
		assert.Len(t, etx.TxAttempts[0].Receipts, 1)

		// use exported method
		err = txStore.UpdateTxsForRebroadcast(tests.Context(t), []int64{etx.ID}, []int64{attempt.ID})
		require.NoError(t, err)

		resultTx, err := txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, resultTx.TxAttempts, 1)
		resultTxAttempt := resultTx.TxAttempts[0]

		// assert attempt state
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, resultTxAttempt.State)
		assert.Nil(t, resultTxAttempt.BroadcastBeforeBlockNum)
		// assert tx state
		assert.Equal(t, txmgrcommon.TxUnconfirmed, resultTx.State)
		// assert receipt
		assert.Empty(t, resultTxAttempt.Receipts)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = txStore.UpdateTxsForRebroadcast(tests.Context(t), []int64{etx.ID}, []int64{attempt.ID})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), etx.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = txStore.UpdateTxsForRebroadcast(tests.Context(t), []int64{etx.ID}, []int64{attempt.ID})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("no unconfirmed eth txes", func(t *testing.T) {
		broadcastAt, err := txStore.FindEarliestUnconfirmedBroadcastTime(tests.Context(t), ethClient.ConfiguredChainID())
		require.NoError(t, err)
		require.False(t, broadcastAt.Valid)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("no earliest unconfirmed tx block", func(t *testing.T) {
		earliestBlock, err := txStore.FindEarliestUnconfirmedTxAttemptBlock(tests.Context(t), ethClient.ConfiguredChainID())
		require.NoError(t, err)
		require.False(t, earliestBlock.Valid)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `_ = mustInsertConfirmedMissingReceiptEthTxWithLegacyAttempt(t, txStore, 123, blockNum, time.Now().Add(time.Minute), fromAddress2)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = txStore.SaveInsufficientFundsAttempt(tests.Context(t), defaultDuration, &etx.TxAttempts[0], now)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = txStore.SaveSentAttempt(tests.Context(t), defaultDuration, &etx.TxAttempts[0], now)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = txStore.SaveConfirmedAttempt(tests.Context(t), defaultDuration, &etx.TxAttempts[0], now)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("saves new in_progress attempt if attempt is new", func(t *testing.T) {
		etx := txmgrtest.MustInsertUnconfirmedEthTx(t, txStore, 1, fromAddress)

		attempt := txmgrtest.NewLegacyEthTxAttempt(t, etx.ID)
		require.Equal(t, int64(0), attempt.ID)

		err := txStore.SaveInProgressAttempt(tests.Context(t), &attempt)
		require.NoError(t, err)

		attemptResult, err := txStore.FindTxAttempt(ctx, attempt.Hash)
		require.NoError(t, err)
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, attemptResult.State)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt.BroadcastBeforeBlockNum = nil`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt.State = txmgrtypes.TxAttemptInProgress`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, 2, fromAddress, txmgrtypes.TxAttemptBroadcast)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = txStore.SetBroadcastBeforeBlockNum(tests.Context(t), currentBlockNum+1, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt3_2.State = txmgrtypes.TxAttemptInsufficientFunds`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt3_2.TxFee.GasPrice = assets.NewWeiI(100)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 3, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 4, 100, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertUnconfirmedEthTxWithInsufficientEthAttempt(t, txStore, 0, otherAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("returns all eth_txes with at least one attempt that is in insufficient_eth state", func(t *testing.T) {
		etxs, err := txStore.FindTxsRequiringResubmissionDueToInsufficientFunds(tests.Context(t), fromAddress, testutils.FixtureChainID)
		require.NoError(t, err)

		assert.Len(t, etxs, 3)

		assert.Equal(t, *etx1.Sequence, *etxs[0].Sequence)
		assert.Equal(t, etx1.ID, etxs[0].ID)
		assert.Equal(t, *etx2.Sequence, *etxs[1].Sequence)
		assert.Equal(t, etx2.ID, etxs[1].ID)
		assert.Equal(t, *etx3.Sequence, *etxs[2].Sequence)
		assert.Equal(t, etx3.ID, etxs[2].ID)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("does not return eth_txes with different chain ID", func(t *testing.T) {
		etxs, err := txStore.FindTxsRequiringResubmissionDueToInsufficientFunds(tests.Context(t), fromAddress, big.NewInt(42))
		require.NoError(t, err)

		assert.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET state='confirmed' WHERE id = $1`, etx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET state='fatal_error', nonce=NULL, error='foo', broadcast_at=NULL, initial_broadcast_at=NULL WHERE id = $1`, etx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("load eth tx attempt", func(t *testing.T) {
		etx := mustInsertConfirmedMissingReceiptEthTxWithLegacyAttempt(t, txStore, 1, 7, time.Now(), fromAddress)
		etx.TxAttempts = []txmgr.TxAttempt{}

		err := txStore.LoadTxesAttempts(ctx, []*txmgr.Tx{&etx})
		require.NoError(t, err)
		assert.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.TxAttempts = []txmgr.TxAttempt{}`
$DIR/pkg/txmgr/evm_tx_store_test.go: `dbAttempt.FromTxAttempt(&newAttempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `func() {
			tx, err := db.BeginTx(ctx, nil)
			require.NoError(t, err)

			const insertEthTxAttemptSQL = `INSERT INTO evm.tx_attempts (eth_tx_id, gas_price, signed_raw_tx, hash, broadcast_before_block_num, state, created_at, chain_specific_gas_limit, tx_type, gas_tip_cap, gas_fee_cap, is_purge_attempt) VALUES (
					:eth_tx_id, :gas_price, :signed_raw_tx, :hash, :broadcast_before_block_num, :state, NOW(), :chain_specific_gas_limit, :tx_type, :gas_tip_cap, :gas_fee_cap, :is_purge_attempt
					) RETURNING *`
			query, args, err := sqlutil.DataSource(db).BindNamed(insertEthTxAttemptSQL, dbAttempt)
			require.NoError(t, err)
			_, err = tx.ExecContext(ctx, query, args...)
			require.NoError(t, err)

			etx.TxAttempts = []txmgr.TxAttempt{}
			err = txStore.LoadTxesAttempts(ctx, []*txmgr.Tx{&etx})
			require.NoError(t, err)
			assert.Len(t, etx.TxAttempts, 2)

			err = tx.Commit()
			require.NoError(t, err)
		}()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `_, err = tx.ExecContext(ctx, query, args...)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.TxAttempts = []txmgr.TxAttempt{}`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = txStore.LoadTxesAttempts(ctx, []*txmgr.Tx{&etx})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = tx.Commit()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.TxAttempts = []txmgr.TxAttempt{}`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("cannot find unstarted tx", func(t *testing.T) {
		mustInsertInProgressEthTxWithAttempt(t, txStore, 13, fromAddress)

		resultEtx, err := txStore.FindNextUnstartedTransactionFromAddress(tests.Context(t), fromAddress, ethClient.ConfiguredChainID())
		assert.ErrorIs(t, err, sql.ErrNoRows)
		assert.Nil(t, resultEtx)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertInProgressEthTxWithAttempt(t, txStore, 13, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.Error = etxPretendError`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.BroadcastAt = &time1`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.InitialBroadcastAt = &time1`
$DIR/pkg/txmgr/evm_tx_store_test.go: `i++`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("update successful", func(t *testing.T) {
		etx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID)
		etx.Sequence = &nonce
		attempt := txmgrtest.NewLegacyEthTxAttempt(t, etx.ID)

		err := txStore.UpdateTxUnstartedToInProgress(tests.Context(t), &etx, &attempt)
		require.NoError(t, err)

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		assert.Equal(t, txmgrcommon.TxInProgress, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.Sequence = &nonce`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("update fails because tx is removed", func(t *testing.T) {
		etx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID)
		etx.Sequence = &nonce

		attempt := txmgrtest.NewLegacyEthTxAttempt(t, etx.ID)

		_, err := db.ExecContext(ctx, "DELETE FROM evm.txes WHERE id = $1", etx.ID)
		require.NoError(t, err)

		err = txStore.UpdateTxUnstartedToInProgress(tests.Context(t), &etx, &attempt)
		require.ErrorContains(t, err, "tx removed")
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.Sequence = &nonce`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = txStore.UpdateTxUnstartedToInProgress(tests.Context(t), &etx, &attempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `db = testutils.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txStore = txmgrtest.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `fromAddress = testutils.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("update replaces abandoned tx with same hash", func(t *testing.T) {
		etx := mustInsertInProgressEthTxWithAttempt(t, txStore, nonce, fromAddress)
		require.Len(t, etx.TxAttempts, 1)

		zero := commonconfig.MustNewDuration(time.Duration(0))
		ccfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.Transactions.ReaperInterval = zero
			c.Transactions.ReaperThreshold = zero
			c.Transactions.ResendAfterThreshold = zero
		})
		evmTxmCfg := txmgr.NewEvmTxmConfig(ccfg.EVM())
		ec := clienttest.NewClientWithDefaultChainID(t)
		txMgr := txmgr.NewEvmTxm(ec.ConfiguredChainID(), evmTxmCfg, ccfg.EVM().Transactions(), nil, logger.Test(t), nil, nil,
			nil, txStore, nil, nil, nil, nil, nil, nil)
		err := txMgr.XXXTestAbandon(fromAddress) // mark transaction as abandoned
		require.NoError(t, err)

		etx2 := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID)
		etx2.Sequence = &nonce
		attempt2 := txmgrtest.NewLegacyEthTxAttempt(t, etx2.ID)
		attempt2.Hash = etx.TxAttempts[0].Hash

		// Even though this will initially fail due to idx_eth_tx_attempts_hash constraint, because the conflicting tx has been abandoned
		// it should succeed after removing the abandoned attempt and retrying the insert
		err = txStore.UpdateTxUnstartedToInProgress(tests.Context(t), &etx2, &attempt2)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `c.Transactions.ReaperInterval = zero`
$DIR/pkg/txmgr/evm_tx_store_test.go: `c.Transactions.ReaperThreshold = zero`
$DIR/pkg/txmgr/evm_tx_store_test.go: `c.Transactions.ResendAfterThreshold = zero`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx2.Sequence = &nonce`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt2.Hash = etx.TxAttempts[0].Hash`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = txStore.UpdateTxUnstartedToInProgress(tests.Context(t), &etx2, &attempt2)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `fromAddress = testutils.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx.State = txmgrcommon.TxUnstarted`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txStore = txmgrtest.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("gets 0 in progress eth transaction", func(t *testing.T) {
		etxResult, err := txStore.GetTxInProgress(tests.Context(t), fromAddress)
		require.NoError(t, err)
		require.Nil(t, etxResult)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("get 0 abandoned transactions", func(t *testing.T) {
		txes, err := txStore.GetAbandonedTransactionsByBatch(tests.Context(t), ethClient.ConfiguredChainID(), enabledAddrs, 0, 10)
		require.NoError(t, err)
		require.Empty(t, txes)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("do not return enabled addresses", func(t *testing.T) {
		_ = mustInsertInProgressEthTxWithAttempt(t, txStore, 123, enabled)
		_ = mustCreateUnstartedGeneratedTx(t, txStore, enabled, ethClient.ConfiguredChainID())
		txes, err := txStore.GetAbandonedTransactionsByBatch(tests.Context(t), ethClient.ConfiguredChainID(), enabledAddrs, 0, 10)
		require.NoError(t, err)
		require.Empty(t, txes)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `_ = mustInsertInProgressEthTxWithAttempt(t, txStore, 123, enabled)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `_ = mustCreateUnstartedGeneratedTx(t, txStore, enabled, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("get in progress, unstarted, and unconfirmed eth transactions", func(t *testing.T) {
		inProgressTx := mustInsertInProgressEthTxWithAttempt(t, txStore, 123, fromAddress)
		unstartedTx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, ethClient.ConfiguredChainID())

		txes, err := txStore.GetAbandonedTransactionsByBatch(tests.Context(t), ethClient.ConfiguredChainID(), enabledAddrs, 0, 10)
		require.NoError(t, err)
		require.Len(t, txes, 2)

		for _, tx := range txes {
			require.True(t, tx.ID == inProgressTx.ID || tx.ID == unstartedTx.ID)
		}
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `_ = mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `allTxes = append(allTxes, batchTxes...)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("no transaction", func(t *testing.T) {
		tx, err := txStore.GetTxByID(tests.Context(t), int64(0))
		require.NoError(t, err)
		require.Nil(t, tx)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("gets 0 fatal eth transactions", func(t *testing.T) {
		txes, err := txStore.GetFatalTransactions(tests.Context(t))
		require.NoError(t, err)
		require.Empty(t, txes)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("no in progress eth transaction", func(t *testing.T) {
		exists, err := txStore.HasInProgressTransaction(tests.Context(t), fromAddress, ethClient.ConfiguredChainID())
		require.NoError(t, err)
		require.False(t, exists)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertInProgressEthTxWithAttempt(t, txStore, 123, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, otherAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 2, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 1, fromAddress2)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 2, fromAddress3)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustCreateUnstartedGeneratedTx(t, txStore, otherAddress, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 2, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("with no eth_txes returns nil", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustCreateUnstartedTx(t, txStore, otherAddress, toAddress, encodedPayload, feeLimit, value, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("with eth_txes from another address returns nil", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertFatalErrorEthTx(t, txStore, otherAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("ignores fatally_errored transactions", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertInProgressEthTxWithAttempt(t, txStore, types.Nonce(n), fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `n++`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, n, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `n++`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("unconfirmed and in_progress transactions do not count", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, 1, testutils.FixtureChainID)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, n, 42, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `n++`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("with many confirmed eth_txes from the same address returns nil", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, feeLimit, value, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("with fewer unstarted eth_txes than limit returns nil", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, feeLimit, value, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("with equal or more unstarted eth_txes than limit returns error", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.Error(t, err)
		require.Contains(t, err.Error(), fmt.Sprintf("cannot create transaction; too many unstarted transactions in the queue (2/%d). WARNING: Hitting EVM.Transactions.MaxQueued", maxUnconfirmedTransactions))

		mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, feeLimit, value, testutils.FixtureChainID)
		err = txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.Error(t, err)
		require.Contains(t, err.Error(), fmt.Sprintf("cannot create transaction; too many unstarted transactions in the queue (3/%d). WARNING: Hitting EVM.Transactions.MaxQueued", maxUnconfirmedTransactions))
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, feeLimit, value, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("with different chain ID ignores txes", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, big.NewInt(42))
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("with queue under capacity inserts eth_tx", func(t *testing.T) {
		subject := uuid.New()
		strategy := newMockTxStrategy(t)
		strategy.On("Subject").Return(uuid.NullUUID{UUID: subject, Valid: true})
		etx, err := txStore.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
		}, ethClient.ConfiguredChainID())
		assert.NoError(t, err)

		assert.Greater(t, etx.ID, int64(0))
		assert.Equal(t, etx.State, txmgrcommon.TxUnstarted)
		assert.Equal(t, gasLimit, etx.FeeLimit)
		assert.Equal(t, fromAddress, etx.FromAddress)
		assert.Equal(t, toAddress, etx.ToAddress)
		assert.Equal(t, payload, etx.EncodedPayload)
		assert.Equal(t, big.Int(assets.NewEthValue(0)), etx.Value)
		assert.Equal(t, subject, etx.Subject.UUID)

		txmgrtest.AssertCount(t, db, "evm.txes", 1)

		var dbEthTx txmgr.DbEthTx
		require.NoError(t, db.Get(&dbEthTx, `SELECT * FROM evm.txes ORDER BY id ASC LIMIT 1`))

		assert.Equal(t, dbEthTx.State, txmgrcommon.TxUnstarted)
		assert.Equal(t, gasLimit, dbEthTx.GasLimit)
		assert.Equal(t, fromAddress, dbEthTx.FromAddress)
		assert.Equal(t, toAddress, dbEthTx.ToAddress)
		assert.Equal(t, payload, dbEthTx.EncodedPayload)
		assert.Equal(t, assets.NewEthValue(0), dbEthTx.Value)
		assert.Equal(t, subject, dbEthTx.Subject.UUID)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `strategy.On("Subject").Return(uuid.NullUUID{UUID: subject, Valid: true})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("doesn't insert eth_tx if a matching tx already exists for that pipeline_task_run_id", func(t *testing.T) {
		id := uuid.New()
		txRequest := txmgr.TxRequest{
			FromAddress:       fromAddress,
			ToAddress:         testutils.NewAddress(),
			EncodedPayload:    []byte{1, 2, 3},
			FeeLimit:          21000,
			PipelineTaskRunID: &id,
			Strategy:          txmgrcommon.NewSendEveryStrategy(),
		}
		tx1, err := txStore.CreateTransaction(tests.Context(t), txRequest, ethClient.ConfiguredChainID())
		assert.NoError(t, err)

		tx2, err := txStore.CreateTransaction(tests.Context(t), txRequest, ethClient.ConfiguredChainID())
		assert.NoError(t, err)

		assert.Equal(t, tx1.GetID(), tx2.GetID())
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `strategy.On("Subject").Return(uuid.NullUUID{UUID: subject, Valid: true})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 3)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("does not prune if queue has not exceeded capacity-1", func(t *testing.T) {
		subject1 := uuid.New()
		strategy1 := txmgrcommon.NewDropOldestStrategy(subject1, uint32(5))
		for i := 0; i < 5; i++ {
			mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID, txRequestWithStrategy(strategy1))
		}
		AssertCountPerSubject(t, txStore, int64(4), subject1)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID, txRequestWithStrategy(strategy1))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `AssertCountPerSubject(t, txStore, int64(4), subject1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID, txRequestWithStrategy(strategy2))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `AssertCountPerSubject(t, txStore, int64(2), subject2)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("finds confirmed transaction requiring receipt fetch", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		// Transactions whose attempts should not be picked up for receipt fetch
		mustInsertFatalErrorEthTx(t, txStore, fromAddress)
		mustInsertUnstartedTx(t, txStore, fromAddress)
		mustInsertInProgressEthTxWithAttempt(t, txStore, 4, fromAddress)
		mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, 3, fromAddress, txmgrtypes.TxAttemptBroadcast)
		mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 2, blockNum)
		// Terminally stuck transaction with receipt should NOT be picked up for receipt fetch
		stuckTx := mustInsertTerminallyStuckTxWithAttempt(t, txStore, fromAddress, 1, blockNum)
		mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), stuckTx.TxAttempts[0].Hash)
		// Fatal transactions with nil nonce and stored attempts should NOT be picked up for receipt fetch
		fatalTxWithAttempt := mustInsertFatalErrorEthTx(t, txStore, fromAddress)
		attempt := newBroadcastLegacyEthTxAttempt(t, fatalTxWithAttempt.ID)
		err := txStore.InsertTxAttempt(ctx, &attempt)
		require.NoError(t, err)

		// Confirmed transaction without receipt should be picked up for receipt fetch
		confirmedTx := mustInsertConfirmedEthTx(t, txStore, 0, fromAddress)
		attempt = newBroadcastLegacyEthTxAttempt(t, confirmedTx.ID)
		err = txStore.InsertTxAttempt(ctx, &attempt)
		require.NoError(t, err)

		attempts, err := txStore.FindAttemptsRequiringReceiptFetch(ctx, testutils.FixtureChainID)
		require.NoError(t, err)
		require.Len(t, attempts, 1)
		require.Equal(t, attempt.Hash.String(), attempts[0].Hash.String())
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertFatalErrorEthTx(t, txStore, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertUnstartedTx(t, txStore, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertInProgressEthTxWithAttempt(t, txStore, 4, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, 3, fromAddress, txmgrtypes.TxAttemptBroadcast)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 2, blockNum)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), stuckTx.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `attempt = newBroadcastLegacyEthTxAttempt(t, confirmedTx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = txStore.InsertTxAttempt(ctx, &attempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertFatalErrorEthTx(t, txStore, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertUnstartedTx(t, txStore, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertInProgressEthTxWithAttempt(t, txStore, 4, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, 3, fromAddress, txmgrtypes.TxAttemptBroadcast)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 2, blockNum)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), stuckTxWithReceipt.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = txStore.InsertTxAttempt(ctx, &attempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertEthReceipt(t, txStore, 100, testutils.NewHash(), attempt.Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `err = txStore.UpdateTxStatesToFinalizedUsingTxHashes(ctx, []common.Hash{attempt.Hash}, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `t.Run("finds re-org'd transactions using the mined tx count", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		otherAddress := testutils.NewAddress()
		// Unstarted can't be re-org'd
		mustInsertUnstartedTx(t, txStore, fromAddress)
		// In-Progress can't be re-org'd
		mustInsertInProgressEthTxWithAttempt(t, txStore, 4, fromAddress)
		// Unconfirmed can't be re-org'd
		mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, 3, fromAddress, txmgrtypes.TxAttemptBroadcast)
		// Confirmed and nonce greater than mined tx count so has been re-org'd
		mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 2, blockNum)
		// Fatal error and nonce equal to mined tx count so has been re-org'd
		mustInsertTerminallyStuckTxWithAttempt(t, txStore, fromAddress, 1, blockNum)
		// Nonce lower than mined tx count so has not been re-org
		mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 0, blockNum)

		// Tx for another from address should not be returned
		mustInsertConfirmedEthTxWithReceipt(t, txStore, otherAddress, 1, blockNum)
		mustInsertConfirmedEthTxWithReceipt(t, txStore, otherAddress, 0, blockNum)

		reorgTxs, includedTxs, err := txStore.FindReorgOrIncludedTxs(ctx, fromAddress, types.Nonce(1), testutils.FixtureChainID)
		require.NoError(t, err)
		require.Len(t, reorgTxs, 2)
		require.Empty(t, includedTxs)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertUnstartedTx(t, txStore, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertInProgressEthTxWithAttempt(t, txStore, 4, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, 3, fromAddress, txmgrtypes.TxAttemptBroadcast)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 2, blockNum)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertTerminallyStuckTxWithAttempt(t, txStore, fromAddress, 1, blockNum)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 0, blockNum)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertConfirmedEthTxWithReceipt(t, txStore, otherAddress, 1, blockNum)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertConfirmedEthTxWithReceipt(t, txStore, otherAddress, 0, blockNum)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertUnstartedTx(t, txStore, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertInProgressEthTxWithAttempt(t, txStore, 5, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, 4, fromAddress, txmgrtypes.TxAttemptBroadcast)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, 3, fromAddress, txmgrtypes.TxAttemptBroadcast)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertUnconfirmedEthTxWithBroadcastPurgeAttempt(t, txStore, 2, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertTerminallyStuckTxWithAttempt(t, txStore, fromAddress, 1, blockNum)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 0, blockNum)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertConfirmedEthTxWithReceipt(t, txStore, otherAddress, 1, blockNum)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `mustInsertConfirmedEthTxWithReceipt(t, txStore, otherAddress, 0, blockNum)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `tx1, err = txStore.FindTxWithAttempts(ctx, tx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `tx2, err = txStore.FindTxWithAttempts(ctx, tx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx2, err = txStore.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx2, err = txStore.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `etx3, err = txStore.FindTxWithAttempts(ctx, etx3.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 1, 2, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewLegacyEthTxAttempt(t, tx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(3)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Get(&count, `SELECT count(*) FROM evm.txes`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.TransactionsWithAttempts(ctx, 0, 100)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.TransactionsWithAttempts(ctx, 0, 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Nonce(1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 1, 2, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewLegacyEthTxAttempt(t, tx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(3)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Get(&count, `SELECT count(*) FROM evm.txes`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Transactions(ctx, 0, 100)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("InsertTx", func(t *testing.T) {
		etx = txmgrtest.NewEthTx(fromAddress)
		require.NoError(t, orm.InsertTx(ctx, &etx))
		assert.Greater(t, int(etx.ID), 0)
		txmgrtest.AssertCount(t, db, "evm.txes", 1)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewEthTx(fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("InsertTxAttempt", func(t *testing.T) {
		attemptD = txmgrtest.NewDynamicFeeEthTxAttempt(t, etx.ID)
		require.NoError(t, orm.InsertTxAttempt(ctx, &attemptD))
		assert.Greater(t, int(attemptD.ID), 0)
		txmgrtest.AssertCount(t, db, "evm.tx_attempts", 1)

		attemptL = txmgrtest.NewLegacyEthTxAttempt(t, etx.ID)
		attemptL.State = txmgrtypes.TxAttemptBroadcast
		attemptL.TxFee = gas.EvmFee{GasPrice: assets.NewWeiI(42)}
		require.NoError(t, orm.InsertTxAttempt(ctx, &attemptL))
		assert.Greater(t, int(attemptL.ID), 0)
		txmgrtest.AssertCount(t, db, "evm.tx_attempts", 2)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewDynamicFeeEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.AssertCount(t, db, "evm.tx_attempts", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewLegacyEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(42)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.AssertCount(t, db, "evm.tx_attempts", 2)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("InsertReceipt", func(t *testing.T) {
		r = newEthReceipt(42, utils.NewHash(), attemptD.Hash, 0x1)
		id, err := orm.InsertReceipt(ctx, &r.Receipt)
		r.ID = id
		require.NoError(t, err)
		assert.Greater(t, int(r.ID), 0)
		txmgrtest.AssertCount(t, db, "evm.receipts", 1)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewHash()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.InsertReceipt(ctx, &r.Receipt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.AssertCount(t, db, "evm.receipts", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("FindTxWithAttempts", func(t *testing.T) {
		var err error
		etx, err = orm.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 2)
		assert.Equal(t, etx.TxAttempts[0].ID, attemptD.ID)
		assert.Equal(t, etx.TxAttempts[1].ID, attemptL.ID)
		require.Len(t, etx.TxAttempts[0].Receipts, 1)
		require.Empty(t, etx.TxAttempts[1].Receipts)
		assert.Equal(t, r.BlockHash, etx.TxAttempts[0].Receipts[0].GetBlockHash())
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("FindTxByHash", func(t *testing.T) {
		foundEtx, err := orm.FindTxByHash(ctx, attemptD.Hash)
		require.NoError(t, err)
		assert.Equal(t, etx.ID, foundEtx.ID)
		assert.Equal(t, etx.ChainID, foundEtx.ChainID)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxByHash(ctx, attemptD.Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxAttemptsByTxIDs(ctx, []int64{etx.ID})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, orm, 0, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, orm, 1, 2, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewLegacyEthTxAttempt(t, tx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(3)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewHash()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.InsertReceipt(ctx, &r.Receipt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTx(t, orm, 3, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, orm, 4, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Get(&count, `SELECT count(*) FROM evm.txes`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Get(&count, `SELECT count(*) FROM evm.tx_attempts`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxAttemptConfirmedByTxIDs(ctx, []int64{tx1.ID, tx2.ID})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("returns nothing if there are no transactions", func(t *testing.T) {
		olderThan := time.Now()
		attempts, err := txStore.FindTxAttemptsRequiringResend(tests.Context(t), olderThan, 10, testutils.FixtureChainID, fromAddress)
		require.NoError(t, err)
		assert.Empty(t, attempts)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Now()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxAttemptsRequiringResend(tests.Context(t), olderThan, 10, testutils.FixtureChainID, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 1, fromAddress, time.Unix(1616509200, 0))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Unix(1616509200, 0)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Unix(1616509400, 0)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress, time.Unix(1616509100, 0))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Unix(1616509100, 0)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 2, fromAddress, time.Unix(1616509300, 0))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Unix(1616509300, 0)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(10)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(10)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewDynamicFeeEthTxAttempt(t, etxs[3].ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(10)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(20)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewDynamicFeeEthTxAttempt(t, etxs[3].ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(30)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(40)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewDynamicFeeEthTxAttempt(t, etxs[3].ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(20)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(30)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("returns nothing if there are transactions from a different key", func(t *testing.T) {
		olderThan := time.Now()
		attempts, err := txStore.FindTxAttemptsRequiringResend(tests.Context(t), olderThan, 10, testutils.FixtureChainID, utils.RandomAddress())
		require.NoError(t, err)
		assert.Empty(t, attempts)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Now()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxAttemptsRequiringResend(tests.Context(t), olderThan, 10, testutils.FixtureChainID, utils.RandomAddress())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.RandomAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("returns the highest price attempt for each transaction that was last broadcast before or on the given time", func(t *testing.T) {
		olderThan := time.Unix(1616509200, 0)
		attempts, err := txStore.FindTxAttemptsRequiringResend(tests.Context(t), olderThan, 0, testutils.FixtureChainID, fromAddress)
		require.NoError(t, err)
		assert.Len(t, attempts, 2)
		assert.Equal(t, attempt1_2.ID, attempts[0].ID)
		assert.Equal(t, etxs[1].TxAttempts[0].ID, attempts[1].ID)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Unix(1616509200, 0)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxAttemptsRequiringResend(tests.Context(t), olderThan, 0, testutils.FixtureChainID, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("returns the highest price attempt for EIP-1559 transactions", func(t *testing.T) {
		olderThan := time.Unix(1616509400, 0)
		attempts, err := txStore.FindTxAttemptsRequiringResend(tests.Context(t), olderThan, 0, testutils.FixtureChainID, fromAddress)
		require.NoError(t, err)
		assert.Len(t, attempts, 4)
		assert.Equal(t, attempt4_4.ID, attempts[3].ID)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Unix(1616509400, 0)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxAttemptsRequiringResend(tests.Context(t), olderThan, 0, testutils.FixtureChainID, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Unix(1616509200, 0)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxAttemptsRequiringResend(tests.Context(t), olderThan, 1, testutils.FixtureChainID, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("does not update when broadcast_at is NULL", func(t *testing.T) {
		t.Parallel()
		ctx := tests.Context(t)
		etx := mustCreateUnstartedGeneratedTx(t, orm, fromAddress, testutils.FixtureChainID)

		var nullTime *time.Time
		assert.Equal(t, nullTime, etx.BroadcastAt)

		currTime := time.Now()
		err := orm.UpdateBroadcastAts(tests.Context(t), currTime, []int64{etx.ID})
		require.NoError(t, err)
		etx, err = orm.FindTxWithAttempts(ctx, etx.ID)

		require.NoError(t, err)
		assert.Equal(t, nullTime, etx.BroadcastAt)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Now()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.UpdateBroadcastAts(tests.Context(t), currTime, []int64{etx.ID})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Now()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewEthTx(fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.InsertTx(ctx, &etx)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Date(2077, 8, 14, 10, 0, 0, 0, time.UTC)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.UpdateBroadcastAts(ctx, time2, []int64{etx.ID})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("saves block num to unconfirmed evm.tx_attempts without one", func(t *testing.T) {
		// Do the thing
		require.NoError(t, txStore.SetBroadcastBeforeBlockNum(tests.Context(t), headNum, chainID))

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]

		assert.Equal(t, int64(9000), *attempt.BroadcastBeforeBlockNum)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("does not change evm.tx_attempts that already have BroadcastBeforeBlockNum set", func(t *testing.T) {
		n := int64(42)
		attempt := newBroadcastLegacyEthTxAttempt(t, etx.ID, 2)
		attempt.BroadcastBeforeBlockNum = &n
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt))

		// Do the thing
		require.NoError(t, txStore.SetBroadcastBeforeBlockNum(tests.Context(t), headNum, chainID))

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 2)
		attempt = etx.TxAttempts[0]

		assert.Equal(t, int64(42), *attempt.BroadcastBeforeBlockNum)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 1, fromAddress, cfg.EVM().ChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.EVM()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress, testutils.SimulatedChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etxThisChain.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etxOtherChain.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx0.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, 100, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewHash()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewHash()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.SaveFetchedReceipts(tests.Context(t), []*types.Receipt{&txmReceipt1, &txmReceipt2})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, tx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, tx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("loads eth transaction", func(t *testing.T) {
		// insert etx with attempt
		etx := txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, int64(7), fromAddress)

		// create unloaded attempt
		unloadedAttempt := txmgr.TxAttempt{TxID: etx.ID}

		// uninitialized EthTx
		assert.Equal(t, int64(0), unloadedAttempt.Tx.ID)

		attempts := []txmgr.TxAttempt{unloadedAttempt}

		err := txStore.PreloadTxes(tests.Context(t), attempts)
		require.NoError(t, err)

		assert.Equal(t, etx.ID, attempts[0].Tx.ID)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, int64(7), fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.PreloadTxes(tests.Context(t), attempts)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.PreloadTxes(tests.Context(t), emptyAttempts)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.GetInProgressTxAttempts(tests.Context(t), fromAddress, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `SET CONSTRAINTS fk_pipeline_runs_pruning_key DEFERRED`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `SET CONSTRAINTS pipeline_runs_pipeline_spec_id_fkey DEFERRED`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewHash()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewHash()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Parent.Store(h8)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewHash()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertPipelineRun(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnfinishedPipelineTaskRun(t, db, runID1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE pipeline_runs SET state = 'suspended' WHERE id = $1`, runID1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 3, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": true}'`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID1, minConfirmations, etx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertPipelineRun(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnfinishedPipelineTaskRun(t, db, runID2)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE pipeline_runs SET state = 'completed', outputs = '""'::jsonb, finished_at = NOW() WHERE id = $1`, runID2)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 4, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": false}'`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE, callback_completed = TRUE WHERE id = $3`, &trID2, minConfirmations, etx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertPipelineRun(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnfinishedPipelineTaskRun(t, db, runID3)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE pipeline_runs SET state = 'suspended' WHERE id = $1`, runID3)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 5, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": false}'`)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID3, minConfirmations, etx3.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 6, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE evm.txes SET min_confirmations = $1 WHERE id = $2`, minConfirmations, etx4.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 7, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE evm.txes SET min_confirmations = $1 WHERE id = $2`, minConfirmations, etx5.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxesPendingCallback(tests.Context(t), head.Number, 0, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE evm.txes SET min_confirmations = NULL WHERE id = $1`, etx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxesPendingCallback(tests.Context(t), head.Number, 0, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxesPendingCallback(tests.Context(t), head.Number, etxBlockNum, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("returns nil error if no results", func(t *testing.T) {
		idempotencyKey := "777"
		etx, err := txStore.FindTxWithIdempotencyKey(tests.Context(t), idempotencyKey, big.NewInt(0))
		require.NoError(t, err)
		assert.Nil(t, etx)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithIdempotencyKey(tests.Context(t), idempotencyKey, big.NewInt(0))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.EVM()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithIdempotencyKey(tests.Context(t), idempotencyKey, big.NewInt(0))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("returns nil error if no results", func(t *testing.T) {
		r, err := txStore.FindReceiptWithIdempotencyKey(tests.Context(t), idempotencyKey, big.NewInt(0))
		require.NoError(t, err)
		assert.Nil(t, r)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindReceiptWithIdempotencyKey(tests.Context(t), idempotencyKey, big.NewInt(0))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewEthTx(fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewDynamicFeeEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.AssertCount(t, db, "evm.tx_attempts", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewLegacyEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(42)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.AssertCount(t, db, "evm.tx_attempts", 2)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewHash()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.InsertReceipt(ctx, &r.Receipt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.AssertCount(t, db, "evm.receipts", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindReceiptWithIdempotencyKey(ctx, idempotencyKey, etx.ChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("returns nil if no results", func(t *testing.T) {
		etx, err := txStore.FindTxWithSequence(tests.Context(t), fromAddress, types.Nonce(777))
		require.NoError(t, err)
		assert.Nil(t, etx)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithSequence(tests.Context(t), fromAddress, types.Nonce(777))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Nonce(777)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 777, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithSequence(tests.Context(t), fromAddress, types.Nonce(777))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Nonce(777)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("marks confirmed tx as unconfirmed, marks latest attempt as in-progress, deletes receipt", func(t *testing.T) {
		etx := mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 777, 1)
		etx, err := txStore.FindTxWithAttempts(ctx, etx.ID)
		assert.NoError(t, err)
		// assert attempt state
		attempt := etx.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
		// assert tx state
		assert.Equal(t, txmgrcommon.TxConfirmed, etx.State)
		// assert receipt
		assert.Len(t, etx.TxAttempts[0].Receipts, 1)

		// use exported method
		err = txStore.UpdateTxsForRebroadcast(tests.Context(t), []int64{etx.ID}, []int64{attempt.ID})
		require.NoError(t, err)

		resultTx, err := txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, resultTx.TxAttempts, 1)
		resultTxAttempt := resultTx.TxAttempts[0]

		// assert attempt state
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, resultTxAttempt.State)
		assert.Nil(t, resultTxAttempt.BroadcastBeforeBlockNum)
		// assert tx state
		assert.Equal(t, txmgrcommon.TxUnconfirmed, resultTx.State)
		// assert receipt
		assert.Empty(t, resultTxAttempt.Receipts)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.UpdateTxsForRebroadcast(tests.Context(t), []int64{etx.ID}, []int64{attempt.ID})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewHash()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.UpdateTxsForRebroadcast(tests.Context(t), []int64{etx.ID}, []int64{attempt.ID})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("no unconfirmed eth txes", func(t *testing.T) {
		broadcastAt, err := txStore.FindEarliestUnconfirmedBroadcastTime(tests.Context(t), ethClient.ConfiguredChainID())
		require.NoError(t, err)
		require.False(t, broadcastAt.Valid)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindEarliestUnconfirmedBroadcastTime(tests.Context(t), ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTx(t, txStore, 123, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindEarliestUnconfirmedBroadcastTime(tests.Context(t), ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("no earliest unconfirmed tx block", func(t *testing.T) {
		earliestBlock, err := txStore.FindEarliestUnconfirmedTxAttemptBlock(tests.Context(t), ethClient.ConfiguredChainID())
		require.NoError(t, err)
		require.False(t, earliestBlock.Valid)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindEarliestUnconfirmedTxAttemptBlock(tests.Context(t), ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Now()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Now()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Add(time.Minute)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.UpdateTxsUnconfirmed(tests.Context(t), []int64{tx.ID})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindEarliestUnconfirmedTxAttemptBlock(tests.Context(t), ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ParseDuration("5s")`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Now()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.SaveInsufficientFundsAttempt(tests.Context(t), defaultDuration, &etx.TxAttempts[0], now)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxAttempt(ctx, etx.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ParseDuration("5s")`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Now()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.SaveSentAttempt(tests.Context(t), defaultDuration, &etx.TxAttempts[0], now)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxAttempt(ctx, etx.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ParseDuration("5s")`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Now()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.SaveConfirmedAttempt(tests.Context(t), defaultDuration, &etx.TxAttempts[0], now)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.DeleteInProgressAttempt(tests.Context(t), etx.TxAttempts[0])`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxAttempt(ctx, attempt.Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("saves new in_progress attempt if attempt is new", func(t *testing.T) {
		etx := txmgrtest.MustInsertUnconfirmedEthTx(t, txStore, 1, fromAddress)

		attempt := txmgrtest.NewLegacyEthTxAttempt(t, etx.ID)
		require.Equal(t, int64(0), attempt.ID)

		err := txStore.SaveInProgressAttempt(tests.Context(t), &attempt)
		require.NoError(t, err)

		attemptResult, err := txStore.FindTxAttempt(ctx, attempt.Hash)
		require.NoError(t, err)
		assert.Equal(t, txmgrtypes.TxAttemptInProgress, attemptResult.State)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTx(t, txStore, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewLegacyEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.SaveInProgressAttempt(tests.Context(t), &attempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxAttempt(ctx, attempt.Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.SaveInProgressAttempt(tests.Context(t), &attempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxAttempt(ctx, attempt.Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.SetBroadcastBeforeBlockNum(tests.Context(t), currentBlockNum, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.SetBroadcastBeforeBlockNum(tests.Context(t), currentBlockNum+1, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxsRequiringGasBump(tests.Context(t), fromAddress, newBlock, gasBumpThreshold, int64(0), ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 2, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewLegacyEthTxAttempt(t, etx3.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewWeiI(100)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 3, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 4, 100, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("returns all eth_txes with at least one attempt that is in insufficient_eth state", func(t *testing.T) {
		etxs, err := txStore.FindTxsRequiringResubmissionDueToInsufficientFunds(tests.Context(t), fromAddress, testutils.FixtureChainID)
		require.NoError(t, err)

		assert.Len(t, etxs, 3)

		assert.Equal(t, *etx1.Sequence, *etxs[0].Sequence)
		assert.Equal(t, etx1.ID, etxs[0].ID)
		assert.Equal(t, *etx2.Sequence, *etxs[1].Sequence)
		assert.Equal(t, etx2.ID, etxs[1].ID)
		assert.Equal(t, *etx3.Sequence, *etxs[2].Sequence)
		assert.Equal(t, etx3.ID, etxs[2].ID)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxsRequiringResubmissionDueToInsufficientFunds(tests.Context(t), fromAddress, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("does not return eth_txes with different chain ID", func(t *testing.T) {
		etxs, err := txStore.FindTxsRequiringResubmissionDueToInsufficientFunds(tests.Context(t), fromAddress, big.NewInt(42))
		require.NoError(t, err)

		assert.Empty(t, etxs)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxsRequiringResubmissionDueToInsufficientFunds(tests.Context(t), fromAddress, big.NewInt(42))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE evm.txes SET state='confirmed' WHERE id = $1`, etx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustExec(t, db, `UPDATE evm.txes SET state='fatal_error', nonce=NULL, error='foo', broadcast_at=NULL, initial_broadcast_at=NULL WHERE id = $1`, etx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxsRequiringResubmissionDueToInsufficientFunds(tests.Context(t), fromAddress, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("load eth tx attempt", func(t *testing.T) {
		etx := mustInsertConfirmedMissingReceiptEthTxWithLegacyAttempt(t, txStore, 1, 7, time.Now(), fromAddress)
		etx.TxAttempts = []txmgr.TxAttempt{}

		err := txStore.LoadTxesAttempts(ctx, []*txmgr.Tx{&etx})
		require.NoError(t, err)
		assert.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Now()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.LoadTxesAttempts(ctx, []*txmgr.Tx{&etx})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Now()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewDynamicFeeEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FromTxAttempt(&newAttempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.BeginTx(ctx, nil)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.DataSource(db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.BindNamed(insertEthTxAttemptSQL, dbAttempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ExecContext(ctx, query, args...)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.LoadTxesAttempts(ctx, []*txmgr.Tx{&etx})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Commit()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.LoadTxesAttempts(ctx, []*txmgr.Tx{&etx})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewDynamicFeeEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.SaveReplacementInProgressAttempt(tests.Context(t), oldAttempt, &newAttempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("cannot find unstarted tx", func(t *testing.T) {
		mustInsertInProgressEthTxWithAttempt(t, txStore, 13, fromAddress)

		resultEtx, err := txStore.FindNextUnstartedTransactionFromAddress(tests.Context(t), fromAddress, ethClient.ConfiguredChainID())
		assert.ErrorIs(t, err, sql.ErrNoRows)
		assert.Nil(t, resultEtx)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindNextUnstartedTransactionFromAddress(tests.Context(t), fromAddress, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindNextUnstartedTransactionFromAddress(tests.Context(t), fromAddress, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.StringFrom("no more toilet paper")`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.UpdateTxFatalErrorAndDeleteAttempts(tests.Context(t), &etx)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Now()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.UpdateTxAttemptInProgressToBroadcast(tests.Context(t), &etx, attempt, txmgrtypes.TxAttemptBroadcast)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxAttempt(ctx, attempt.Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Nonce(123)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("update successful", func(t *testing.T) {
		etx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID)
		etx.Sequence = &nonce
		attempt := txmgrtest.NewLegacyEthTxAttempt(t, etx.ID)

		err := txStore.UpdateTxUnstartedToInProgress(tests.Context(t), &etx, &attempt)
		require.NoError(t, err)

		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		assert.Equal(t, txmgrcommon.TxInProgress, etx.State)
		assert.Len(t, etx.TxAttempts, 1)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewLegacyEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.UpdateTxUnstartedToInProgress(tests.Context(t), &etx, &attempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("update fails because tx is removed", func(t *testing.T) {
		etx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID)
		etx.Sequence = &nonce

		attempt := txmgrtest.NewLegacyEthTxAttempt(t, etx.ID)

		_, err := db.ExecContext(ctx, "DELETE FROM evm.txes WHERE id = $1", etx.ID)
		require.NoError(t, err)

		err = txStore.UpdateTxUnstartedToInProgress(tests.Context(t), &etx, &attempt)
		require.ErrorContains(t, err, "tx removed")
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewLegacyEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ExecContext(ctx, "DELETE FROM evm.txes WHERE id = $1", etx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.UpdateTxUnstartedToInProgress(tests.Context(t), &etx, &attempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("update replaces abandoned tx with same hash", func(t *testing.T) {
		etx := mustInsertInProgressEthTxWithAttempt(t, txStore, nonce, fromAddress)
		require.Len(t, etx.TxAttempts, 1)

		zero := commonconfig.MustNewDuration(time.Duration(0))
		ccfg := configtest.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.Transactions.ReaperInterval = zero
			c.Transactions.ReaperThreshold = zero
			c.Transactions.ResendAfterThreshold = zero
		})
		evmTxmCfg := txmgr.NewEvmTxmConfig(ccfg.EVM())
		ec := clienttest.NewClientWithDefaultChainID(t)
		txMgr := txmgr.NewEvmTxm(ec.ConfiguredChainID(), evmTxmCfg, ccfg.EVM().Transactions(), nil, logger.Test(t), nil, nil,
			nil, txStore, nil, nil, nil, nil, nil, nil)
		err := txMgr.XXXTestAbandon(fromAddress) // mark transaction as abandoned
		require.NoError(t, err)

		etx2 := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID)
		etx2.Sequence = &nonce
		attempt2 := txmgrtest.NewLegacyEthTxAttempt(t, etx2.ID)
		attempt2.Hash = etx.TxAttempts[0].Hash

		// Even though this will initially fail due to idx_eth_tx_attempts_hash constraint, because the conflicting tx has been abandoned
		// it should succeed after removing the abandoned attempt and retrying the insert
		err = txStore.UpdateTxUnstartedToInProgress(tests.Context(t), &etx2, &attempt2)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustNewDuration(time.Duration(0))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Duration(0)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewChainScopedConfig(t, func(c *toml.EVMConfig) {
			c.Transactions.ReaperInterval = zero
			c.Transactions.ReaperThreshold = zero
			c.Transactions.ResendAfterThreshold = zero
		})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewEvmTxmConfig(ccfg.EVM())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.EVM()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewEvmTxm(ec.ConfiguredChainID(), evmTxmCfg, ccfg.EVM().Transactions(), nil, logger.Test(t), nil, nil,
			nil, txStore, nil, nil, nil, nil, nil, nil)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.EVM()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Transactions()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Test(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.XXXTestAbandon(fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewLegacyEthTxAttempt(t, etx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.UpdateTxUnstartedToInProgress(tests.Context(t), &etx2, &attempt2)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.UpdateTxUnstartedToInProgress(tests.Context(t), &etx, &etx.TxAttempts[0])`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("gets 0 in progress eth transaction", func(t *testing.T) {
		etxResult, err := txStore.GetTxInProgress(tests.Context(t), fromAddress)
		require.NoError(t, err)
		require.Nil(t, etxResult)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.GetTxInProgress(tests.Context(t), fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.GetTxInProgress(tests.Context(t), fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("get 0 abandoned transactions", func(t *testing.T) {
		txes, err := txStore.GetAbandonedTransactionsByBatch(tests.Context(t), ethClient.ConfiguredChainID(), enabledAddrs, 0, 10)
		require.NoError(t, err)
		require.Empty(t, txes)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.GetAbandonedTransactionsByBatch(tests.Context(t), ethClient.ConfiguredChainID(), enabledAddrs, 0, 10)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("do not return enabled addresses", func(t *testing.T) {
		_ = mustInsertInProgressEthTxWithAttempt(t, txStore, 123, enabled)
		_ = mustCreateUnstartedGeneratedTx(t, txStore, enabled, ethClient.ConfiguredChainID())
		txes, err := txStore.GetAbandonedTransactionsByBatch(tests.Context(t), ethClient.ConfiguredChainID(), enabledAddrs, 0, 10)
		require.NoError(t, err)
		require.Empty(t, txes)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.GetAbandonedTransactionsByBatch(tests.Context(t), ethClient.ConfiguredChainID(), enabledAddrs, 0, 10)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("get in progress, unstarted, and unconfirmed eth transactions", func(t *testing.T) {
		inProgressTx := mustInsertInProgressEthTxWithAttempt(t, txStore, 123, fromAddress)
		unstartedTx := mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, ethClient.ConfiguredChainID())

		txes, err := txStore.GetAbandonedTransactionsByBatch(tests.Context(t), ethClient.ConfiguredChainID(), enabledAddrs, 0, 10)
		require.NoError(t, err)
		require.Len(t, txes, 2)

		for _, tx := range txes {
			require.True(t, tx.ID == inProgressTx.ID || tx.ID == unstartedTx.ID)
		}
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.GetAbandonedTransactionsByBatch(tests.Context(t), ethClient.ConfiguredChainID(), enabledAddrs, 0, 10)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Batch(func(offset, limit uint) (count uint, err error) {
			batchTxes, err := txStore.GetAbandonedTransactionsByBatch(tests.Context(t), ethClient.ConfiguredChainID(), enabledAddrs, offset, limit)
			require.NoError(t, err)
			allTxes = append(allTxes, batchTxes...)
			return uint(len(batchTxes)), nil
		}, batchSize)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.GetAbandonedTransactionsByBatch(tests.Context(t), ethClient.ConfiguredChainID(), enabledAddrs, offset, limit)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("no transaction", func(t *testing.T) {
		tx, err := txStore.GetTxByID(tests.Context(t), int64(0))
		require.NoError(t, err)
		require.Nil(t, tx)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.GetTxByID(tests.Context(t), int64(0))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.GetTxByID(tests.Context(t), insertedTx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("gets 0 fatal eth transactions", func(t *testing.T) {
		txes, err := txStore.GetFatalTransactions(tests.Context(t))
		require.NoError(t, err)
		require.Empty(t, txes)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.GetFatalTransactions(tests.Context(t))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.GetFatalTransactions(tests.Context(t))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("no in progress eth transaction", func(t *testing.T) {
		exists, err := txStore.HasInProgressTransaction(tests.Context(t), fromAddress, ethClient.ConfiguredChainID())
		require.NoError(t, err)
		require.False(t, exists)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.HasInProgressTransaction(tests.Context(t), fromAddress, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.HasInProgressTransaction(tests.Context(t), fromAddress, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, otherAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 2, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CountUnconfirmedTransactions(tests.Context(t), fromAddress, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 1, fromAddress2)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 2, fromAddress3)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CountTransactionsByState(tests.Context(t), txmgrcommon.TxUnconfirmed, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 2, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CountUnstartedTransactions(tests.Context(t), fromAddress, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Int(assets.NewEthValue(142))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewEthValue(142)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("with no eth_txes returns nil", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("with eth_txes from another address returns nil", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("ignores fatally_errored transactions", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Nonce(n)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, n, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("unconfirmed and in_progress transactions do not count", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, 1, testutils.FixtureChainID)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CheckTxQueueCapacity(tests.Context(t), fromAddress, 1, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, n, 42, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("with many confirmed eth_txes from the same address returns nil", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("with fewer unstarted eth_txes than limit returns nil", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("with equal or more unstarted eth_txes than limit returns error", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.Error(t, err)
		require.Contains(t, err.Error(), fmt.Sprintf("cannot create transaction; too many unstarted transactions in the queue (2/%d). WARNING: Hitting EVM.Transactions.MaxQueued", maxUnconfirmedTransactions))

		mustCreateUnstartedTx(t, txStore, fromAddress, toAddress, encodedPayload, feeLimit, value, testutils.FixtureChainID)
		err = txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)
		require.Error(t, err)
		require.Contains(t, err.Error(), fmt.Sprintf("cannot create transaction; too many unstarted transactions in the queue (3/%d). WARNING: Hitting EVM.Transactions.MaxQueued", maxUnconfirmedTransactions))
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("with different chain ID ignores txes", func(t *testing.T) {
		err := txStore.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, big.NewInt(42))
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CheckTxQueueCapacity(tests.Context(t), fromAddress, maxUnconfirmedTransactions, big.NewInt(42))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CheckTxQueueCapacity(tests.Context(t), fromAddress, 0, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("with queue under capacity inserts eth_tx", func(t *testing.T) {
		subject := uuid.New()
		strategy := newMockTxStrategy(t)
		strategy.On("Subject").Return(uuid.NullUUID{UUID: subject, Valid: true})
		etx, err := txStore.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
		}, ethClient.ConfiguredChainID())
		assert.NoError(t, err)

		assert.Greater(t, etx.ID, int64(0))
		assert.Equal(t, etx.State, txmgrcommon.TxUnstarted)
		assert.Equal(t, gasLimit, etx.FeeLimit)
		assert.Equal(t, fromAddress, etx.FromAddress)
		assert.Equal(t, toAddress, etx.ToAddress)
		assert.Equal(t, payload, etx.EncodedPayload)
		assert.Equal(t, big.Int(assets.NewEthValue(0)), etx.Value)
		assert.Equal(t, subject, etx.Subject.UUID)

		txmgrtest.AssertCount(t, db, "evm.txes", 1)

		var dbEthTx txmgr.DbEthTx
		require.NoError(t, db.Get(&dbEthTx, `SELECT * FROM evm.txes ORDER BY id ASC LIMIT 1`))

		assert.Equal(t, dbEthTx.State, txmgrcommon.TxUnstarted)
		assert.Equal(t, gasLimit, dbEthTx.GasLimit)
		assert.Equal(t, fromAddress, dbEthTx.FromAddress)
		assert.Equal(t, toAddress, dbEthTx.ToAddress)
		assert.Equal(t, payload, dbEthTx.EncodedPayload)
		assert.Equal(t, assets.NewEthValue(0), dbEthTx.Value)
		assert.Equal(t, subject, dbEthTx.Subject.UUID)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.New()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.On("Subject")`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Return(uuid.NullUUID{UUID: subject, Valid: true})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
		}, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("doesn't insert eth_tx if a matching tx already exists for that pipeline_task_run_id", func(t *testing.T) {
		id := uuid.New()
		txRequest := txmgr.TxRequest{
			FromAddress:       fromAddress,
			ToAddress:         testutils.NewAddress(),
			EncodedPayload:    []byte{1, 2, 3},
			FeeLimit:          21000,
			PipelineTaskRunID: &id,
			Strategy:          txmgrcommon.NewSendEveryStrategy(),
		}
		tx1, err := txStore.CreateTransaction(tests.Context(t), txRequest, ethClient.ConfiguredChainID())
		assert.NoError(t, err)

		tx2, err := txStore.CreateTransaction(tests.Context(t), txRequest, ethClient.ConfiguredChainID())
		assert.NoError(t, err)

		assert.Equal(t, tx1.GetID(), tx2.GetID())
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.New()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSendEveryStrategy()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CreateTransaction(tests.Context(t), txRequest, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CreateTransaction(tests.Context(t), txRequest, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.New()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.On("Subject")`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Return(uuid.NullUUID{UUID: subject, Valid: true})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
			SignalCallback: true,
		}, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.AssertCount(t, db, "evm.txes", 3)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTxStore(db, logger.Test(t))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Test(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("does not prune if queue has not exceeded capacity-1", func(t *testing.T) {
		subject1 := uuid.New()
		strategy1 := txmgrcommon.NewDropOldestStrategy(subject1, uint32(5))
		for i := 0; i < 5; i++ {
			mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, testutils.FixtureChainID, txRequestWithStrategy(strategy1))
		}
		AssertCountPerSubject(t, txStore, int64(4), subject1)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.New()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewDropOldestStrategy(subject1, uint32(5))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.New()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewDropOldestStrategy(subject2, uint32(3))`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, 1, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewHash()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.InsertReceipt(ctx, &r.Receipt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxesWithAttemptsAndReceiptsByIdsAndState(ctx, []int64{tx.ID}, []txmgrtypes.TxState{txmgrcommon.TxConfirmed}, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("finds confirmed transaction requiring receipt fetch", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		// Transactions whose attempts should not be picked up for receipt fetch
		mustInsertFatalErrorEthTx(t, txStore, fromAddress)
		mustInsertUnstartedTx(t, txStore, fromAddress)
		mustInsertInProgressEthTxWithAttempt(t, txStore, 4, fromAddress)
		mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, 3, fromAddress, txmgrtypes.TxAttemptBroadcast)
		mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 2, blockNum)
		// Terminally stuck transaction with receipt should NOT be picked up for receipt fetch
		stuckTx := mustInsertTerminallyStuckTxWithAttempt(t, txStore, fromAddress, 1, blockNum)
		mustInsertEthReceipt(t, txStore, blockNum, utils.NewHash(), stuckTx.TxAttempts[0].Hash)
		// Fatal transactions with nil nonce and stored attempts should NOT be picked up for receipt fetch
		fatalTxWithAttempt := mustInsertFatalErrorEthTx(t, txStore, fromAddress)
		attempt := newBroadcastLegacyEthTxAttempt(t, fatalTxWithAttempt.ID)
		err := txStore.InsertTxAttempt(ctx, &attempt)
		require.NoError(t, err)

		// Confirmed transaction without receipt should be picked up for receipt fetch
		confirmedTx := mustInsertConfirmedEthTx(t, txStore, 0, fromAddress)
		attempt = newBroadcastLegacyEthTxAttempt(t, confirmedTx.ID)
		err = txStore.InsertTxAttempt(ctx, &attempt)
		require.NoError(t, err)

		attempts, err := txStore.FindAttemptsRequiringReceiptFetch(ctx, testutils.FixtureChainID)
		require.NoError(t, err)
		require.Len(t, attempts, 1)
		require.Equal(t, attempt.Hash.String(), attempts[0].Hash.String())
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewHash()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.InsertTxAttempt(ctx, &attempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.InsertTxAttempt(ctx, &attempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindAttemptsRequiringReceiptFetch(ctx, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewHash()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.InsertTxAttempt(ctx, &attempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindAttemptsRequiringReceiptFetch(ctx, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Now()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.InsertTx(ctx, tx)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.InsertTxAttempt(ctx, &attempt)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewHash()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.UpdateTxStatesToFinalizedUsingTxHashes(ctx, []common.Hash{attempt.Hash}, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, tx.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Run("finds re-org'd transactions using the mined tx count", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		otherAddress := testutils.NewAddress()
		// Unstarted can't be re-org'd
		mustInsertUnstartedTx(t, txStore, fromAddress)
		// In-Progress can't be re-org'd
		mustInsertInProgressEthTxWithAttempt(t, txStore, 4, fromAddress)
		// Unconfirmed can't be re-org'd
		mustInsertUnconfirmedEthTxWithAttemptState(t, txStore, 3, fromAddress, txmgrtypes.TxAttemptBroadcast)
		// Confirmed and nonce greater than mined tx count so has been re-org'd
		mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 2, blockNum)
		// Fatal error and nonce equal to mined tx count so has been re-org'd
		mustInsertTerminallyStuckTxWithAttempt(t, txStore, fromAddress, 1, blockNum)
		// Nonce lower than mined tx count so has not been re-org
		mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 0, blockNum)

		// Tx for another from address should not be returned
		mustInsertConfirmedEthTxWithReceipt(t, txStore, otherAddress, 1, blockNum)
		mustInsertConfirmedEthTxWithReceipt(t, txStore, otherAddress, 0, blockNum)

		reorgTxs, includedTxs, err := txStore.FindReorgOrIncludedTxs(ctx, fromAddress, types.Nonce(1), testutils.FixtureChainID)
		require.NoError(t, err)
		require.Len(t, reorgTxs, 2)
		require.Empty(t, includedTxs)
	})`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindReorgOrIncludedTxs(ctx, fromAddress, types.Nonce(1), testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Nonce(1)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindReorgOrIncludedTxs(ctx, fromAddress, types.Nonce(4), testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Nonce(4)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.UpdateTxFatalError(ctx, []int64{tx1.ID, tx2.ID}, client.TerminallyStuckMsg)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, tx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, tx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxesByIDs(ctx, etxIDs, testutils.FixtureChainID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.DeleteReceiptByTxHash(ctx, etx1.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Context(t)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.NewAddress()`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.Abandon(ctx, testutils.FixtureChainID, fromAddress)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/evm_tx_store_test.go: `.FindTxWithAttempts(ctx, etx3.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `h99.IsFinalized.Store(true)`
$DIR/pkg/txmgr/finalizer_test.go: `head.Parent.Store(h99)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("returns not finalized for tx with receipt newer than finalized block", func(t *testing.T) {
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		servicetest.Run(t, finalizer)

		idempotencyKey := uuid.New().String()
		fromAddress := testutils.NewAddress()
		nonce := types.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		attemptHash := insertTxAndAttemptWithIdempotencyKey(t, txStore, tx, idempotencyKey)
		// Insert receipt for unfinalized block num
		mustInsertEthReceipt(t, txStore, head.Number, head.Hash, attemptHash)
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()
		ethClient.On("LatestFinalizedBlock", mock.Anything).Return(head.Parent.Load(), nil).Once()
		err := finalizer.ProcessHead(ctx, head)
		require.NoError(t, err)
		tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, tx.State)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `servicetest.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `mustInsertEthReceipt(t, txStore, head.Number, head.Hash, attemptHash)`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("LatestFinalizedBlock", mock.Anything).Return(head.Parent.Load(), nil).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("returns not finalized for tx with receipt re-org'd out and deletes stale receipt", func(t *testing.T) {
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		servicetest.Run(t, finalizer)

		idempotencyKey := uuid.New().String()
		fromAddress := testutils.NewAddress()
		nonce := types.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		attemptHash := insertTxAndAttemptWithIdempotencyKey(t, txStore, tx, idempotencyKey)
		// Insert receipt for finalized block num
		mustInsertEthReceipt(t, txStore, head.Parent.Load().Number, utils.NewHash(), attemptHash)
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()
		ethClient.On("LatestFinalizedBlock", mock.Anything).Return(head.Parent.Load(), nil).Once()
		err := finalizer.ProcessHead(ctx, head)
		require.NoError(t, err)
		tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, tx.State)
		require.Len(t, tx.TxAttempts, 1)
		require.Empty(t, tx.TxAttempts[0].Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `servicetest.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `mustInsertEthReceipt(t, txStore, head.Parent.Load().Number, utils.NewHash(), attemptHash)`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("LatestFinalizedBlock", mock.Anything).Return(head.Parent.Load(), nil).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("returns finalized for tx with receipt in a finalized block", func(t *testing.T) {
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		servicetest.Run(t, finalizer)

		idempotencyKey := uuid.New().String()
		fromAddress := testutils.NewAddress()
		nonce := types.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		attemptHash := insertTxAndAttemptWithIdempotencyKey(t, txStore, tx, idempotencyKey)
		// Insert receipt for finalized block num
		mustInsertEthReceipt(t, txStore, head.Parent.Load().Number, head.Parent.Load().Hash, attemptHash)
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()
		ethClient.On("LatestFinalizedBlock", mock.Anything).Return(head.Parent.Load(), nil).Once()
		err := finalizer.ProcessHead(ctx, head)
		require.NoError(t, err)
		tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFinalized, tx.State)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `servicetest.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `mustInsertEthReceipt(t, txStore, head.Parent.Load().Number, head.Parent.Load().Hash, attemptHash)`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("LatestFinalizedBlock", mock.Anything).Return(head.Parent.Load(), nil).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("returns finalized for tx with receipt older than block history depth", func(t *testing.T) {
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		servicetest.Run(t, finalizer)

		idempotencyKey := uuid.New().String()
		fromAddress := testutils.NewAddress()
		nonce := types.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		attemptHash := insertTxAndAttemptWithIdempotencyKey(t, txStore, tx, idempotencyKey)
		// Insert receipt for finalized block num
		receiptBlockHash1 := utils.NewHash()
		mustInsertEthReceipt(t, txStore, head.Parent.Load().Number-2, receiptBlockHash1, attemptHash)
		idempotencyKey = uuid.New().String()
		nonce = types.Nonce(1)
		tx = &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		attemptHash = insertTxAndAttemptWithIdempotencyKey(t, txStore, tx, idempotencyKey)
		// Insert receipt for finalized block num
		receiptBlockHash2 := utils.NewHash()
		mustInsertEthReceipt(t, txStore, head.Parent.Load().Number-1, receiptBlockHash2, attemptHash)
		// Separate batch calls will be made for each tx due to RPC batch size set to 1 when finalizer initialized above
		ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			require.Len(t, rpcElements, 1)

			require.Equal(t, "eth_getBlockByNumber", rpcElements[0].Method)
			require.Equal(t, false, rpcElements[0].Args[1])

			reqBlockNum := rpcElements[0].Args[0].(string)
			req1BlockNum := hexutil.EncodeBig(big.NewInt(head.Parent.Load().Number - 2))
			req2BlockNum := hexutil.EncodeBig(big.NewInt(head.Parent.Load().Number - 1))
			var headResult types.Head
			if req1BlockNum == reqBlockNum {
				headResult = types.Head{Number: head.Parent.Load().Number - 2, Hash: receiptBlockHash1}
			} else if req2BlockNum == reqBlockNum {
				headResult = types.Head{Number: head.Parent.Load().Number - 1, Hash: receiptBlockHash2}
			} else {
				require.Fail(t, "unrecognized block hash")
			}
			rpcElements[0].Result = &headResult
		}).Return(nil).Twice()
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()
		ethClient.On("LatestFinalizedBlock", mock.Anything).Return(head.Parent.Load(), nil).Once()
		err := finalizer.ProcessHead(ctx, head)
		require.NoError(t, err)
		tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFinalized, tx.State)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `servicetest.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `mustInsertEthReceipt(t, txStore, head.Parent.Load().Number-2, receiptBlockHash1, attemptHash)`
$DIR/pkg/txmgr/finalizer_test.go: `idempotencyKey = uuid.New().String()`
$DIR/pkg/txmgr/finalizer_test.go: `nonce = types.Nonce(1)`
$DIR/pkg/txmgr/finalizer_test.go: `tx = &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}`
$DIR/pkg/txmgr/finalizer_test.go: `attemptHash = insertTxAndAttemptWithIdempotencyKey(t, txStore, tx, idempotencyKey)`
$DIR/pkg/txmgr/finalizer_test.go: `mustInsertEthReceipt(t, txStore, head.Parent.Load().Number-1, receiptBlockHash2, attemptHash)`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			require.Len(t, rpcElements, 1)

			require.Equal(t, "eth_getBlockByNumber", rpcElements[0].Method)
			require.Equal(t, false, rpcElements[0].Args[1])

			reqBlockNum := rpcElements[0].Args[0].(string)
			req1BlockNum := hexutil.EncodeBig(big.NewInt(head.Parent.Load().Number - 2))
			req2BlockNum := hexutil.EncodeBig(big.NewInt(head.Parent.Load().Number - 1))
			var headResult types.Head
			if req1BlockNum == reqBlockNum {
				headResult = types.Head{Number: head.Parent.Load().Number - 2, Hash: receiptBlockHash1}
			} else if req2BlockNum == reqBlockNum {
				headResult = types.Head{Number: head.Parent.Load().Number - 1, Hash: receiptBlockHash2}
			} else {
				require.Fail(t, "unrecognized block hash")
			}
			rpcElements[0].Result = &headResult
		}).Return(nil).Twice()`
$DIR/pkg/txmgr/finalizer_test.go: `headResult = types.Head{Number: head.Parent.Load().Number - 2, Hash: receiptBlockHash1}`
$DIR/pkg/txmgr/finalizer_test.go: `headResult = types.Head{Number: head.Parent.Load().Number - 1, Hash: receiptBlockHash2}`
$DIR/pkg/txmgr/finalizer_test.go: `rpcElements[0].Result = &headResult`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("LatestFinalizedBlock", mock.Anything).Return(head.Parent.Load(), nil).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("returns error if failed to retrieve latest head in headtracker", func(t *testing.T) {
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		servicetest.Run(t, finalizer)

		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(nil, errors.New("failed to get latest head")).Once()
		err := finalizer.ProcessHead(ctx, head)
		require.Error(t, err)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `servicetest.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(nil, errors.New("failed to get latest head")).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `servicetest.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("LatestFinalizedBlock", mock.Anything).Return(nil, errors.New("failed to calculate latest finalized head")).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `parentHead.Parent.Store(grandParentHead)`
$DIR/pkg/txmgr/finalizer_test.go: `head.Parent.Store(parentHead)`
$DIR/pkg/txmgr/finalizer_test.go: `testutils.MustExec(t, db, `SET CONSTRAINTS fk_pipeline_runs_pruning_key DEFERRED`)`
$DIR/pkg/txmgr/finalizer_test.go: `testutils.MustExec(t, db, `SET CONSTRAINTS pipeline_runs_pipeline_spec_id_fkey DEFERRED`)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("doesn't process task runs that are not suspended (possibly already previously resumed)", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		finalizer.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error {
			t.Fatal("No value expected")
			return nil
		})
		servicetest.Run(t, finalizer)

		runID := testutils.MustInsertPipelineRun(t, db)
		trID := testutils.MustInsertUnfinishedPipelineTaskRun(t, db, runID)

		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 1, 1, fromAddress)
		mustInsertEthReceipt(t, txStore, head.Number-minConfirmations, head.Hash, etx.TxAttempts[0].Hash)
		// Setting both signal_callback and callback_completed to TRUE to simulate a completed pipeline task
		// It would only be in a state past suspended if the resume callback was called and callback_completed was set to TRUE
		testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE, callback_completed = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)

		err := finalizer.ResumePendingTaskRuns(ctx, head.BlockNumber(), 0)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `finalizer.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error {
			t.Fatal("No value expected")
			return nil
		})`
$DIR/pkg/txmgr/finalizer_test.go: `servicetest.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `mustInsertEthReceipt(t, txStore, head.Number-minConfirmations, head.Hash, etx.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/finalizer_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE, callback_completed = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("doesn't process task runs where the receipt is younger than minConfirmations", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		finalizer.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error {
			t.Fatal("No value expected")
			return nil
		})
		servicetest.Run(t, finalizer)

		runID := testutils.MustInsertPipelineRun(t, db)
		trID := testutils.MustInsertUnfinishedPipelineTaskRun(t, db, runID)

		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 2, 1, fromAddress)
		mustInsertEthReceipt(t, txStore, head.Number, head.Hash, etx.TxAttempts[0].Hash)

		testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)

		err := finalizer.ResumePendingTaskRuns(ctx, head.BlockNumber(), 0)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `finalizer.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error {
			t.Fatal("No value expected")
			return nil
		})`
$DIR/pkg/txmgr/finalizer_test.go: `servicetest.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `mustInsertEthReceipt(t, txStore, head.Number, head.Hash, etx.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/finalizer_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("processes transactions with receipts older than minConfirmations", func(t *testing.T) {
		ch := make(chan interface{})
		nonce := types.Nonce(3)
		var err error
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		finalizer.SetResumeCallback(func(ctx context.Context, id uuid.UUID, value interface{}, thisErr error) error {
			err = thisErr
			ch <- value
			return nil
		})
		servicetest.Run(t, finalizer)

		runID := testutils.MustInsertPipelineRun(t, db)
		trID := testutils.MustInsertUnfinishedPipelineTaskRun(t, db, runID)
		testutils.MustExec(t, db, `UPDATE pipeline_runs SET state = 'suspended' WHERE id = $1`, runID)

		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, int64(nonce), 1, fromAddress)
		testutils.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": true}'`)
		receipt := mustInsertEthReceipt(t, txStore, head.Number-minConfirmations, head.Hash, etx.TxAttempts[0].Hash)

		testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)

		done := make(chan struct{})
		t.Cleanup(func() { <-done })
		go func() {
			defer close(done)
			err2 := finalizer.ResumePendingTaskRuns(ctx, head.BlockNumber(), 0)
			assert.NoError(t, err2)

			// Retrieve Tx to check if callback completed flag was set to true
			updateTx, err3 := txStore.FindTxWithSequence(ctx, fromAddress, nonce)
			assert.NoError(t, err3)
			assert.True(t, updateTx.CallbackCompleted)
		}()

		select {
		case data := <-ch:
			require.NoError(t, err)

			require.IsType(t, &types.Receipt{}, data)
			r := data.(*types.Receipt)
			require.Equal(t, receipt.TxHash, r.TxHash)

		case <-time.After(time.Second):
			t.Fatal("no value received")
		}
	})`
$DIR/pkg/txmgr/finalizer_test.go: `finalizer.SetResumeCallback(func(ctx context.Context, id uuid.UUID, value interface{}, thisErr error) error {
			err = thisErr
			ch <- value
			return nil
		})`
$DIR/pkg/txmgr/finalizer_test.go: `err = thisErr`
$DIR/pkg/txmgr/finalizer_test.go: `ch <- value`
$DIR/pkg/txmgr/finalizer_test.go: `servicetest.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `testutils.MustExec(t, db, `UPDATE pipeline_runs SET state = 'suspended' WHERE id = $1`, runID)`
$DIR/pkg/txmgr/finalizer_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": true}'`)`
$DIR/pkg/txmgr/finalizer_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Cleanup(func() { <-done })`
$DIR/pkg/txmgr/finalizer_test.go: `<-done`
$DIR/pkg/txmgr/finalizer_test.go: `testutils.MustExec(t, db, `DELETE FROM pipeline_runs`)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("processes transactions with receipt older than minConfirmations that reverted", func(t *testing.T) {
		type data struct {
			value any
			error
		}
		ch := make(chan data)
		nonce := types.Nonce(4)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		finalizer.SetResumeCallback(func(ctx context.Context, id uuid.UUID, value interface{}, err error) error {
			ch <- data{value, err}
			return nil
		})
		servicetest.Run(t, finalizer)

		runID := testutils.MustInsertPipelineRun(t, db)
		trID := testutils.MustInsertUnfinishedPipelineTaskRun(t, db, runID)
		testutils.MustExec(t, db, `UPDATE pipeline_runs SET state = 'suspended' WHERE id = $1`, runID)

		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, int64(nonce), 1, fromAddress)
		testutils.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": true}'`)

		// receipt is not passed through as a value since it reverted and caused an error
		mustInsertRevertedEthReceipt(t, txStore, head.Number-minConfirmations, head.Hash, etx.TxAttempts[0].Hash)

		testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)

		done := make(chan struct{})
		t.Cleanup(func() { <-done })
		go func() {
			defer close(done)
			err2 := finalizer.ResumePendingTaskRuns(ctx, head.BlockNumber(), 0)
			assert.NoError(t, err2)

			// Retrieve Tx to check if callback completed flag was set to true
			updateTx, err3 := txStore.FindTxWithSequence(ctx, fromAddress, nonce)
			assert.NoError(t, err3)
			assert.True(t, updateTx.CallbackCompleted)
		}()

		select {
		case data := <-ch:
			require.Error(t, data.error)

			require.EqualError(t, data.error, fmt.Sprintf("transaction %s reverted on-chain", etx.TxAttempts[0].Hash.String()))

			require.Nil(t, data.value)

		case <-time.After(tests.WaitTimeout(t)):
			t.Fatal("no value received")
		}
	})`
$DIR/pkg/txmgr/finalizer_test.go: `finalizer.SetResumeCallback(func(ctx context.Context, id uuid.UUID, value interface{}, err error) error {
			ch <- data{value, err}
			return nil
		})`
$DIR/pkg/txmgr/finalizer_test.go: `ch <- data{value, err}`
$DIR/pkg/txmgr/finalizer_test.go: `servicetest.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `testutils.MustExec(t, db, `UPDATE pipeline_runs SET state = 'suspended' WHERE id = $1`, runID)`
$DIR/pkg/txmgr/finalizer_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": true}'`)`
$DIR/pkg/txmgr/finalizer_test.go: `mustInsertRevertedEthReceipt(t, txStore, head.Number-minConfirmations, head.Hash, etx.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/finalizer_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Cleanup(func() { <-done })`
$DIR/pkg/txmgr/finalizer_test.go: `<-done`
$DIR/pkg/txmgr/finalizer_test.go: `finalizer.SetResumeCallback(func(ctx context.Context, id uuid.UUID, value interface{}, err error) error {
			return errors.New("error")
		})`
$DIR/pkg/txmgr/finalizer_test.go: `servicetest.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `mustInsertEthReceipt(t, txStore, head.Number-minConfirmations, head.Hash, etx.TxAttempts[0].Hash)`
$DIR/pkg/txmgr/finalizer_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `latestFinalizedHead.IsFinalized.Store(true)`
$DIR/pkg/txmgr/finalizer_test.go: `head.Parent.Store(latestFinalizedHead)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("does nothing if no confirmed transactions without receipts found", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, config.EVM().RPCDefaultBatchSize(), false, txStore, txmClient, ht, metrics)

		mustInsertFatalErrorEthTx(t, txStore, fromAddress)
		mustInsertInProgressEthTx(t, txStore, 0, fromAddress)
		mustInsertUnconfirmedEthTxWithInsufficientEthAttempt(t, txStore, 2, fromAddress)
		mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, config.EVM().ChainID())
		// Insert confirmed transactions with receipt and multiple attempts to ensure none of the attempts are picked up
		etx := mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 3, head.Number)
		attempt := newBroadcastLegacyEthTxAttempt(t, etx.ID, 2)
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt))

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))
	})`
$DIR/pkg/txmgr/finalizer_test.go: `mustInsertFatalErrorEthTx(t, txStore, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `mustInsertInProgressEthTx(t, txStore, 0, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `mustInsertUnconfirmedEthTxWithInsufficientEthAttempt(t, txStore, 2, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, config.EVM().ChainID())`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("fetches receipt for confirmed transaction without a receipt", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		// Transaction not confirmed yet, receipt is nil
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		require.NoError(t, err)
		require.Empty(t, attempt.Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `elems[0].Result = &types.Receipt{}`
$DIR/pkg/txmgr/finalizer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("saves nothing if returned receipt does not match the attempt", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		txmReceipt := types.Receipt{
			TxHash:           testutils.NewHash(),
			BlockHash:        testutils.NewHash(),
			BlockNumber:      big.NewInt(42),
			TransactionIndex: uint(1),
		}

		// First transaction confirmed
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
		}).Once()

		// No error because it is merely logged
		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 1)
		require.Empty(t, etx.TxAttempts[0].Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `*(elems[0].Result.(*types.Receipt)) = txmReceipt`
$DIR/pkg/txmgr/finalizer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("saves nothing if query returns error", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		txmReceipt := types.Receipt{
			TxHash:           etx.TxAttempts[0].Hash,
			BlockHash:        testutils.NewHash(),
			BlockNumber:      big.NewInt(42),
			TransactionIndex: uint(1),
		}

		// Batch receipt call fails
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
			elems[0].Error = errors.New("foo")
		}).Once()

		// No error because it is merely logged
		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 1)
		require.Empty(t, etx.TxAttempts[0].Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
			elems[0].Error = errors.New("foo")
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `*(elems[0].Result.(*types.Receipt)) = txmReceipt`
$DIR/pkg/txmgr/finalizer_test.go: `elems[0].Error = errors.New("foo")`
$DIR/pkg/txmgr/finalizer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("saves valid receipt returned by client", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx1 := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		// Insert confirmed transaction without receipt
		etx2 := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 1, head.Number, fromAddress)
		txmReceipt := types.Receipt{
			TxHash:           etx1.TxAttempts[0].Hash,
			BlockHash:        testutils.NewHash(),
			BlockNumber:      big.NewInt(42),
			TransactionIndex: uint(1),
			Status:           uint64(1),
		}

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], etx1.TxAttempts[0].Hash) &&
				matchTranscationReceipt(b[1], etx2.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// First transaction confirmed
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
			// Second transaction still unconfirmed
			elems[1].Result = &types.Receipt{}
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// Check that the receipt was saved
		var err error
		etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)
		require.NoError(t, err)

		require.Equal(t, txmgrcommon.TxConfirmed, etx1.State)
		require.Len(t, etx1.TxAttempts, 1)
		attempt := etx1.TxAttempts[0]
		require.Len(t, attempt.Receipts, 1)
		receipt := attempt.Receipts[0]
		require.Equal(t, txmReceipt.TxHash, receipt.GetTxHash())
		require.Equal(t, txmReceipt.BlockHash, receipt.GetBlockHash())
		require.Equal(t, txmReceipt.BlockNumber.Int64(), receipt.GetBlockNumber().Int64())
		require.Equal(t, txmReceipt.TransactionIndex, receipt.GetTransactionIndex())

		receiptJSON, err := json.Marshal(txmReceipt)
		require.NoError(t, err)

		storedReceiptJSON, err := json.Marshal(receipt)
		require.NoError(t, err)
		require.JSONEq(t, string(receiptJSON), string(storedReceiptJSON))
	})`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], etx1.TxAttempts[0].Hash) &&
				matchTranscationReceipt(b[1], etx2.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// First transaction confirmed
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
			// Second transaction still unconfirmed
			elems[1].Result = &types.Receipt{}
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `*(elems[0].Result.(*types.Receipt)) = txmReceipt`
$DIR/pkg/txmgr/finalizer_test.go: `elems[1].Result = &types.Receipt{}`
$DIR/pkg/txmgr/finalizer_test.go: `etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("fetches and saves receipts for several attempts in gas price order", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		attempt1 := etx.TxAttempts[0]
		attempt2 := newBroadcastLegacyEthTxAttempt(t, etx.ID, 2)
		attempt3 := newBroadcastLegacyEthTxAttempt(t, etx.ID, 3)

		// Insert order deliberately reversed to test sorting by gas price
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt3))
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt2))

		txmReceipt := types.Receipt{
			TxHash:           attempt2.Hash,
			BlockHash:        testutils.NewHash(),
			BlockNumber:      big.NewInt(42),
			TransactionIndex: uint(1),
			Status:           uint64(1),
		}

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				matchTranscationReceipt(b[2], attempt1.Hash) &&
				matchTranscationReceipt(b[1], attempt2.Hash) &&
				matchTranscationReceipt(b[0], attempt3.Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// Most expensive attempt still unconfirmed
			elems[2].Result = &types.Receipt{}
			// Second most expensive attempt is confirmed
			*(elems[1].Result.(*types.Receipt)) = txmReceipt
			// Cheapest attempt still unconfirmed
			elems[0].Result = &types.Receipt{}
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// Check that the receipt was stored
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Equal(t, txmgrcommon.TxConfirmed, etx.State)
		require.Len(t, etx.TxAttempts, 3)
		require.Empty(t, etx.TxAttempts[0].Receipts)
		require.Len(t, etx.TxAttempts[1].Receipts, 1)
		require.Empty(t, etx.TxAttempts[2].Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				matchTranscationReceipt(b[2], attempt1.Hash) &&
				matchTranscationReceipt(b[1], attempt2.Hash) &&
				matchTranscationReceipt(b[0], attempt3.Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// Most expensive attempt still unconfirmed
			elems[2].Result = &types.Receipt{}
			// Second most expensive attempt is confirmed
			*(elems[1].Result.(*types.Receipt)) = txmReceipt
			// Cheapest attempt still unconfirmed
			elems[0].Result = &types.Receipt{}
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `elems[2].Result = &types.Receipt{}`
$DIR/pkg/txmgr/finalizer_test.go: `*(elems[1].Result.(*types.Receipt)) = txmReceipt`
$DIR/pkg/txmgr/finalizer_test.go: `elems[0].Result = &types.Receipt{}`
$DIR/pkg/txmgr/finalizer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("ignores receipt missing BlockHash that comes from querying parity too early", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		receipt := types.Receipt{
			TxHash: etx.TxAttempts[0].Hash,
			Status: uint64(1),
		}
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = receipt
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// No receipt, but no error either
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Equal(t, txmgrcommon.TxConfirmed, etx.State)
		require.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		require.Empty(t, attempt.Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = receipt
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `*(elems[0].Result.(*types.Receipt)) = receipt`
$DIR/pkg/txmgr/finalizer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("does not panic if receipt has BlockHash but is missing some other fields somehow", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		// NOTE: This should never happen, but we shouldn't panic regardless
		receipt := types.Receipt{
			TxHash:    etx.TxAttempts[0].Hash,
			BlockHash: testutils.NewHash(),
			Status:    uint64(1),
		}
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = receipt
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// No receipt, but no error either
		etx, err := txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Equal(t, txmgrcommon.TxConfirmed, etx.State)
		require.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		require.Empty(t, attempt.Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = receipt
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `*(elems[0].Result.(*types.Receipt)) = receipt`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("simulate on revert", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		attempt := etx.TxAttempts[0]
		txmReceipt := types.Receipt{
			TxHash:           attempt.Hash,
			BlockHash:        testutils.NewHash(),
			BlockNumber:      big.NewInt(42),
			TransactionIndex: uint(1),
			Status:           uint64(0),
		}

		// First attempt is confirmed and reverted
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], attempt.Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// First attempt still unconfirmed
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
		}).Once()
		data, err := utils.ABIEncode(`[{"type":"uint256"}]`, big.NewInt(10))
		require.NoError(t, err)
		sig := utils.Keccak256Fixed([]byte(`MyError(uint256)`))
		ethClient.On("CallContract", mock.Anything, mock.Anything, mock.Anything).Return(nil, &client.JsonError{
			Code:    1,
			Message: "reverted",
			Data:    utils.ConcatBytes(sig[:4], data),
		}).Once()

		// Do the thing
		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// Check that the state was updated
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		attempt = etx.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
		require.NotNil(t, attempt.BroadcastBeforeBlockNum)
		// Check receipts
		require.Len(t, attempt.Receipts, 1)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], attempt.Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// First attempt still unconfirmed
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `*(elems[0].Result.(*types.Receipt)) = txmReceipt`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("CallContract", mock.Anything, mock.Anything, mock.Anything).Return(nil, &client.JsonError{
			Code:    1,
			Message: "reverted",
			Data:    utils.ConcatBytes(sig[:4], data),
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `attempt = etx.TxAttempts[0]`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("find receipt for old transaction, avoid marking as fatal", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, true, txStore, txmClient, ht, metrics)

		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, latestFinalizedHead.Number, fromAddress)

		txmReceipt := types.Receipt{
			TxHash:           etx.TxAttempts[0].Hash,
			BlockHash:        testutils.NewHash(),
			BlockNumber:      big.NewInt(42),
			TransactionIndex: uint(1),
			Status:           uint64(1),
		}

		// Transaction receipt is nil
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// Check that transaction was picked up as old and marked as fatal
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, etx.State)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `*(elems[0].Result.(*types.Receipt)) = txmReceipt`
$DIR/pkg/txmgr/finalizer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("old transaction failed to find receipt, marked as fatal", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, true, txStore, txmClient, ht, metrics)

		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, latestFinalizedHead.Number, fromAddress)

		// Transaction receipt is nil
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// Check that transaction was picked up as old and marked as fatal
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFatalError, etx.State)
		require.Equal(t, txmgr.ErrCouldNotGetReceipt, etx.Error.String)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `elems[0].Result = &types.Receipt{}`
$DIR/pkg/txmgr/finalizer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `txStore.On("SaveFetchedReceipts", mock.Anything, mock.Anything).Return(nil).Maybe()`
$DIR/pkg/txmgr/finalizer_test.go: `txStore.On("FindTxesPendingCallback", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(nil, nil).Maybe()`
$DIR/pkg/txmgr/finalizer_test.go: `txStore.On("UpdateTxCallbackCompleted", mock.Anything, mock.Anything, mock.Anything).Return(nil).Maybe()`
$DIR/pkg/txmgr/finalizer_test.go: `txStore.On("FindConfirmedTxesReceipts", mock.Anything, mock.Anything, mock.Anything).Return(nil, nil).Maybe()`
$DIR/pkg/txmgr/finalizer_test.go: `txStore.On("FindTxesByIDs", mock.Anything, mock.Anything, mock.Anything).Return(nil, nil).Maybe()`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.Anything).Return(nil).Maybe()`
$DIR/pkg/txmgr/finalizer_test.go: `txStore.On("FindAttemptsRequiringReceiptFetch", mock.Anything, mock.Anything).Return([]txmgr.TxAttempt{attempt}, nil).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `latestFinalizedHead.IsFinalized.Store(true)`
$DIR/pkg/txmgr/finalizer_test.go: `head.Parent.Store(latestFinalizedHead)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("fetch and store receipts from multiple batch calls", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		rpcBatchSize := uint32(2)
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)

		// Insert confirmed transaction without receipt
		etx := mustInsertConfirmedEthTx(t, txStore, 0, fromAddress)

		var attempts []txmgr.TxAttempt
		// Total of 5 attempts should lead to 3 batched fetches (2, 2, 1)v
		for i := 0; i < 5; i++ {
			attempt := newBroadcastLegacyEthTxAttempt(t, etx.ID, int64(i+2))
			attempt.BroadcastBeforeBlockNum = &head.Number
			require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt))
			attempts = append(attempts, attempt)
		}

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], attempts[4].Hash) &&
				matchTranscationReceipt(b[1], attempts[3].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
			elems[1].Result = &types.Receipt{}
		}).Once()
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], attempts[2].Hash) &&
				matchTranscationReceipt(b[1], attempts[1].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
			elems[1].Result = &types.Receipt{}
		}).Once()
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], attempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))
	})`
$DIR/pkg/txmgr/finalizer_test.go: `attempt.BroadcastBeforeBlockNum = &head.Number`
$DIR/pkg/txmgr/finalizer_test.go: `attempts = append(attempts, attempt)`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], attempts[4].Hash) &&
				matchTranscationReceipt(b[1], attempts[3].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
			elems[1].Result = &types.Receipt{}
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `elems[0].Result = &types.Receipt{}`
$DIR/pkg/txmgr/finalizer_test.go: `elems[1].Result = &types.Receipt{}`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], attempts[2].Hash) &&
				matchTranscationReceipt(b[1], attempts[1].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
			elems[1].Result = &types.Receipt{}
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `elems[0].Result = &types.Receipt{}`
$DIR/pkg/txmgr/finalizer_test.go: `elems[1].Result = &types.Receipt{}`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], attempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `elems[0].Result = &types.Receipt{}`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx1.TxAttempts[0].Hash)
		})).Return(errors.New("batch call failed")).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx2.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt // confirmed
		}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `*(elems[0].Result.(*types.Receipt)) = txmReceipt`
$DIR/pkg/txmgr/finalizer_test.go: `etx2, err = txStore.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `latestFinalizedHead.IsFinalized.Store(true)`
$DIR/pkg/txmgr/finalizer_test.go: `head.Parent.Store(latestFinalizedHead)`
$DIR/pkg/txmgr/finalizer_test.go: `attempt.Tx.Meta = nil`
$DIR/pkg/txmgr/finalizer_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
		return len(b) == 1 && matchTranscationReceipt(b[0], attempt.Hash)
	})).Return(nil).Run(func(args mock.Arguments) {
		elems := args.Get(1).([]rpc.BatchElem)
		*(elems[0].Result.(*types.Receipt)) = txmReceipt // confirmed
	}).Once()`
$DIR/pkg/txmgr/finalizer_test.go: `*(elems[0].Result.(*types.Receipt)) = txmReceipt`
$DIR/pkg/txmgr/finalizer_test.go: `dbtx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `latestFinalizedHead.IsFinalized.Store(true)`
$DIR/pkg/txmgr/finalizer_test.go: `head.Parent.Store(latestFinalizedHead)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("does nothing if no old transactions found", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, 1, true, txStore, txmClient, ht, metrics)
		require.NoError(t, finalizer.ProcessOldTxsWithoutReceipts(ctx, []int64{}, head, latestFinalizedHead))
	})`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("marks multiple old transactions as fatal", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, 1, true, txStore, txmClient, ht, metrics)

		// Insert confirmed transaction without receipt
		etx1 := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, latestFinalizedHead.Number, fromAddress)
		etx2 := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 1, latestFinalizedHead.Number, fromAddress)

		etxIDs := []int64{etx1.ID, etx2.ID}
		require.NoError(t, finalizer.ProcessOldTxsWithoutReceipts(ctx, etxIDs, head, latestFinalizedHead))

		// Check transactions marked as fatal
		var err error
		etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFatalError, etx1.State)
		require.Equal(t, txmgr.ErrCouldNotGetReceipt, etx1.Error.String)

		etx2, err = txStore.FindTxWithAttempts(ctx, etx2.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFatalError, etx2.State)
		require.Equal(t, txmgr.ErrCouldNotGetReceipt, etx2.Error.String)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `etx2, err = txStore.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `t.Run("marks old transaction as fatal, resumes pending task as failed", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, 1, true, txStore, txmClient, ht, metrics)
		finalizer.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error { return nil })

		// Insert confirmed transaction with pending task run
		etx := txmgrtest.NewEthTx(fromAddress)
		etx.State = txmgrcommon.TxConfirmed
		n := types.Nonce(0)
		etx.Sequence = &n
		now := time.Now()
		etx.BroadcastAt = &now
		etx.InitialBroadcastAt = &now
		etx.SignalCallback = true
		etx.PipelineTaskRunID = uuid.NullUUID{UUID: uuid.New(), Valid: true}
		require.NoError(t, txStore.InsertTx(t.Context(), &etx))

		attempt := newBroadcastLegacyEthTxAttempt(t, etx.ID, 0)
		attempt.BroadcastBeforeBlockNum = &latestFinalizedHead.Number // set broadcast time to finalized block num
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt))

		require.NoError(t, finalizer.ProcessOldTxsWithoutReceipts(ctx, []int64{etx.ID}, head, latestFinalizedHead))

		// Check transaction marked as fatal
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFatalError, etx.State)
		require.Equal(t, txmgr.ErrCouldNotGetReceipt, etx.Error.String)
		require.True(t, etx.CallbackCompleted)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `finalizer.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error { return nil })`
$DIR/pkg/txmgr/finalizer_test.go: `etx.State = txmgrcommon.TxConfirmed`
$DIR/pkg/txmgr/finalizer_test.go: `etx.Sequence = &n`
$DIR/pkg/txmgr/finalizer_test.go: `etx.BroadcastAt = &now`
$DIR/pkg/txmgr/finalizer_test.go: `etx.InitialBroadcastAt = &now`
$DIR/pkg/txmgr/finalizer_test.go: `etx.SignalCallback = true`
$DIR/pkg/txmgr/finalizer_test.go: `etx.PipelineTaskRunID = uuid.NullUUID{UUID: uuid.New(), Valid: true}`
$DIR/pkg/txmgr/finalizer_test.go: `attempt.BroadcastBeforeBlockNum = &latestFinalizedHead.Number`
$DIR/pkg/txmgr/finalizer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `finalizer.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error { return errors.New("failure") })`
$DIR/pkg/txmgr/finalizer_test.go: `etx.State = txmgrcommon.TxConfirmed`
$DIR/pkg/txmgr/finalizer_test.go: `etx.Sequence = &n`
$DIR/pkg/txmgr/finalizer_test.go: `etx.BroadcastAt = &now`
$DIR/pkg/txmgr/finalizer_test.go: `etx.InitialBroadcastAt = &now`
$DIR/pkg/txmgr/finalizer_test.go: `etx.SignalCallback = true`
$DIR/pkg/txmgr/finalizer_test.go: `etx.PipelineTaskRunID = uuid.NullUUID{UUID: uuid.New(), Valid: true}`
$DIR/pkg/txmgr/finalizer_test.go: `attempt.BroadcastBeforeBlockNum = &latestFinalizedHead.Number`
$DIR/pkg/txmgr/finalizer_test.go: `etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Context()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSimulatedHeadTracker(ethClient, true, 0)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/finalizer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/finalizer_test.go: `.String()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Store(h99)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("returns not finalized for tx with receipt newer than finalized block", func(t *testing.T) {
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		servicetest.Run(t, finalizer)

		idempotencyKey := uuid.New().String()
		fromAddress := testutils.NewAddress()
		nonce := types.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		attemptHash := insertTxAndAttemptWithIdempotencyKey(t, txStore, tx, idempotencyKey)
		// Insert receipt for unfinalized block num
		mustInsertEthReceipt(t, txStore, head.Number, head.Hash, attemptHash)
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()
		ethClient.On("LatestFinalizedBlock", mock.Anything).Return(head.Parent.Load(), nil).Once()
		err := finalizer.ProcessHead(ctx, head)
		require.NoError(t, err)
		tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, tx.State)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `.New()`
$DIR/pkg/txmgr/finalizer_test.go: `.String()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/finalizer_test.go: `.Now()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(head, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(head.Parent.Load(), nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.ProcessHead(ctx, head)`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("returns not finalized for tx with receipt re-org'd out and deletes stale receipt", func(t *testing.T) {
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		servicetest.Run(t, finalizer)

		idempotencyKey := uuid.New().String()
		fromAddress := testutils.NewAddress()
		nonce := types.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		attemptHash := insertTxAndAttemptWithIdempotencyKey(t, txStore, tx, idempotencyKey)
		// Insert receipt for finalized block num
		mustInsertEthReceipt(t, txStore, head.Parent.Load().Number, utils.NewHash(), attemptHash)
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()
		ethClient.On("LatestFinalizedBlock", mock.Anything).Return(head.Parent.Load(), nil).Once()
		err := finalizer.ProcessHead(ctx, head)
		require.NoError(t, err)
		tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, tx.State)
		require.Len(t, tx.TxAttempts, 1)
		require.Empty(t, tx.TxAttempts[0].Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `.New()`
$DIR/pkg/txmgr/finalizer_test.go: `.String()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/finalizer_test.go: `.Now()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(head, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(head.Parent.Load(), nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.ProcessHead(ctx, head)`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("returns finalized for tx with receipt in a finalized block", func(t *testing.T) {
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		servicetest.Run(t, finalizer)

		idempotencyKey := uuid.New().String()
		fromAddress := testutils.NewAddress()
		nonce := types.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		attemptHash := insertTxAndAttemptWithIdempotencyKey(t, txStore, tx, idempotencyKey)
		// Insert receipt for finalized block num
		mustInsertEthReceipt(t, txStore, head.Parent.Load().Number, head.Parent.Load().Hash, attemptHash)
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()
		ethClient.On("LatestFinalizedBlock", mock.Anything).Return(head.Parent.Load(), nil).Once()
		err := finalizer.ProcessHead(ctx, head)
		require.NoError(t, err)
		tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFinalized, tx.State)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `.New()`
$DIR/pkg/txmgr/finalizer_test.go: `.String()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/finalizer_test.go: `.Now()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(head, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(head.Parent.Load(), nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.ProcessHead(ctx, head)`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("returns finalized for tx with receipt older than block history depth", func(t *testing.T) {
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		servicetest.Run(t, finalizer)

		idempotencyKey := uuid.New().String()
		fromAddress := testutils.NewAddress()
		nonce := types.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		attemptHash := insertTxAndAttemptWithIdempotencyKey(t, txStore, tx, idempotencyKey)
		// Insert receipt for finalized block num
		receiptBlockHash1 := utils.NewHash()
		mustInsertEthReceipt(t, txStore, head.Parent.Load().Number-2, receiptBlockHash1, attemptHash)
		idempotencyKey = uuid.New().String()
		nonce = types.Nonce(1)
		tx = &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		attemptHash = insertTxAndAttemptWithIdempotencyKey(t, txStore, tx, idempotencyKey)
		// Insert receipt for finalized block num
		receiptBlockHash2 := utils.NewHash()
		mustInsertEthReceipt(t, txStore, head.Parent.Load().Number-1, receiptBlockHash2, attemptHash)
		// Separate batch calls will be made for each tx due to RPC batch size set to 1 when finalizer initialized above
		ethClient.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{})).Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			require.Len(t, rpcElements, 1)

			require.Equal(t, "eth_getBlockByNumber", rpcElements[0].Method)
			require.Equal(t, false, rpcElements[0].Args[1])

			reqBlockNum := rpcElements[0].Args[0].(string)
			req1BlockNum := hexutil.EncodeBig(big.NewInt(head.Parent.Load().Number - 2))
			req2BlockNum := hexutil.EncodeBig(big.NewInt(head.Parent.Load().Number - 1))
			var headResult types.Head
			if req1BlockNum == reqBlockNum {
				headResult = types.Head{Number: head.Parent.Load().Number - 2, Hash: receiptBlockHash1}
			} else if req2BlockNum == reqBlockNum {
				headResult = types.Head{Number: head.Parent.Load().Number - 1, Hash: receiptBlockHash2}
			} else {
				require.Fail(t, "unrecognized block hash")
			}
			rpcElements[0].Result = &headResult
		}).Return(nil).Twice()
		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()
		ethClient.On("LatestFinalizedBlock", mock.Anything).Return(head.Parent.Load(), nil).Once()
		err := finalizer.ProcessHead(ctx, head)
		require.NoError(t, err)
		tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFinalized, tx.State)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `.New()`
$DIR/pkg/txmgr/finalizer_test.go: `.String()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/finalizer_test.go: `.Now()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/finalizer_test.go: `.New()`
$DIR/pkg/txmgr/finalizer_test.go: `.String()`
$DIR/pkg/txmgr/finalizer_test.go: `.Nonce(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.IsType([]rpc.BatchElem{}))`
$DIR/pkg/txmgr/finalizer_test.go: `.IsType([]rpc.BatchElem{})`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			rpcElements := args.Get(1).([]rpc.BatchElem)
			require.Len(t, rpcElements, 1)

			require.Equal(t, "eth_getBlockByNumber", rpcElements[0].Method)
			require.Equal(t, false, rpcElements[0].Args[1])

			reqBlockNum := rpcElements[0].Args[0].(string)
			req1BlockNum := hexutil.EncodeBig(big.NewInt(head.Parent.Load().Number - 2))
			req2BlockNum := hexutil.EncodeBig(big.NewInt(head.Parent.Load().Number - 1))
			var headResult types.Head
			if req1BlockNum == reqBlockNum {
				headResult = types.Head{Number: head.Parent.Load().Number - 2, Hash: receiptBlockHash1}
			} else if req2BlockNum == reqBlockNum {
				headResult = types.Head{Number: head.Parent.Load().Number - 1, Hash: receiptBlockHash2}
			} else {
				require.Fail(t, "unrecognized block hash")
			}
			rpcElements[0].Result = &headResult
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.EncodeBig(big.NewInt(head.Parent.Load().Number - 2))`
$DIR/pkg/txmgr/finalizer_test.go: `.NewInt(head.Parent.Load().Number - 2)`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/finalizer_test.go: `.EncodeBig(big.NewInt(head.Parent.Load().Number - 1))`
$DIR/pkg/txmgr/finalizer_test.go: `.NewInt(head.Parent.Load().Number - 1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Twice()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(head, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(head.Parent.Load(), nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.ProcessHead(ctx, head)`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("returns error if failed to retrieve latest head in headtracker", func(t *testing.T) {
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		servicetest.Run(t, finalizer)

		ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(nil, errors.New("failed to get latest head")).Once()
		err := finalizer.ProcessHead(ctx, head)
		require.Error(t, err)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil, errors.New("failed to get latest head"))`
$DIR/pkg/txmgr/finalizer_test.go: `.New("failed to get latest head")`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.ProcessHead(ctx, head)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(head, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("LatestFinalizedBlock", mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil, errors.New("failed to calculate latest finalized head"))`
$DIR/pkg/txmgr/finalizer_test.go: `.New("failed to calculate latest finalized head")`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.ProcessHead(ctx, head)`
$DIR/pkg/txmgr/finalizer_test.go: `.Context()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSimulatedHeadTracker(ethClient, true, 0)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/finalizer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/finalizer_test.go: `.String()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Store(grandParentHead)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Store(parentHead)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustExec(t, db, `SET CONSTRAINTS fk_pipeline_runs_pruning_key DEFERRED`)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustExec(t, db, `SET CONSTRAINTS pipeline_runs_pipeline_spec_id_fkey DEFERRED`)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("doesn't process task runs that are not suspended (possibly already previously resumed)", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		finalizer.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error {
			t.Fatal("No value expected")
			return nil
		})
		servicetest.Run(t, finalizer)

		runID := testutils.MustInsertPipelineRun(t, db)
		trID := testutils.MustInsertUnfinishedPipelineTaskRun(t, db, runID)

		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 1, 1, fromAddress)
		mustInsertEthReceipt(t, txStore, head.Number-minConfirmations, head.Hash, etx.TxAttempts[0].Hash)
		// Setting both signal_callback and callback_completed to TRUE to simulate a completed pipeline task
		// It would only be in a state past suspended if the resume callback was called and callback_completed was set to TRUE
		testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE, callback_completed = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)

		err := finalizer.ResumePendingTaskRuns(ctx, head.BlockNumber(), 0)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error {
			t.Fatal("No value expected")
			return nil
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertPipelineRun(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertUnfinishedPipelineTaskRun(t, db, runID)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 1, 1, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE, callback_completed = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.ResumePendingTaskRuns(ctx, head.BlockNumber(), 0)`
$DIR/pkg/txmgr/finalizer_test.go: `.BlockNumber()`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("doesn't process task runs where the receipt is younger than minConfirmations", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		finalizer.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error {
			t.Fatal("No value expected")
			return nil
		})
		servicetest.Run(t, finalizer)

		runID := testutils.MustInsertPipelineRun(t, db)
		trID := testutils.MustInsertUnfinishedPipelineTaskRun(t, db, runID)

		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 2, 1, fromAddress)
		mustInsertEthReceipt(t, txStore, head.Number, head.Hash, etx.TxAttempts[0].Hash)

		testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)

		err := finalizer.ResumePendingTaskRuns(ctx, head.BlockNumber(), 0)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error {
			t.Fatal("No value expected")
			return nil
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertPipelineRun(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertUnfinishedPipelineTaskRun(t, db, runID)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 2, 1, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.ResumePendingTaskRuns(ctx, head.BlockNumber(), 0)`
$DIR/pkg/txmgr/finalizer_test.go: `.BlockNumber()`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("processes transactions with receipts older than minConfirmations", func(t *testing.T) {
		ch := make(chan interface{})
		nonce := types.Nonce(3)
		var err error
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		finalizer.SetResumeCallback(func(ctx context.Context, id uuid.UUID, value interface{}, thisErr error) error {
			err = thisErr
			ch <- value
			return nil
		})
		servicetest.Run(t, finalizer)

		runID := testutils.MustInsertPipelineRun(t, db)
		trID := testutils.MustInsertUnfinishedPipelineTaskRun(t, db, runID)
		testutils.MustExec(t, db, `UPDATE pipeline_runs SET state = 'suspended' WHERE id = $1`, runID)

		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, int64(nonce), 1, fromAddress)
		testutils.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": true}'`)
		receipt := mustInsertEthReceipt(t, txStore, head.Number-minConfirmations, head.Hash, etx.TxAttempts[0].Hash)

		testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)

		done := make(chan struct{})
		t.Cleanup(func() { <-done })
		go func() {
			defer close(done)
			err2 := finalizer.ResumePendingTaskRuns(ctx, head.BlockNumber(), 0)
			assert.NoError(t, err2)

			// Retrieve Tx to check if callback completed flag was set to true
			updateTx, err3 := txStore.FindTxWithSequence(ctx, fromAddress, nonce)
			assert.NoError(t, err3)
			assert.True(t, updateTx.CallbackCompleted)
		}()

		select {
		case data := <-ch:
			require.NoError(t, err)

			require.IsType(t, &types.Receipt{}, data)
			r := data.(*types.Receipt)
			require.Equal(t, receipt.TxHash, r.TxHash)

		case <-time.After(time.Second):
			t.Fatal("no value received")
		}
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.Nonce(3)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.SetResumeCallback(func(ctx context.Context, id uuid.UUID, value interface{}, thisErr error) error {
			err = thisErr
			ch <- value
			return nil
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertPipelineRun(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertUnfinishedPipelineTaskRun(t, db, runID)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustExec(t, db, `UPDATE pipeline_runs SET state = 'suspended' WHERE id = $1`, runID)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, int64(nonce), 1, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": true}'`)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Cleanup(func() { <-done })`
$DIR/pkg/txmgr/finalizer_test.go: `.ResumePendingTaskRuns(ctx, head.BlockNumber(), 0)`
$DIR/pkg/txmgr/finalizer_test.go: `.BlockNumber()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithSequence(ctx, fromAddress, nonce)`
$DIR/pkg/txmgr/finalizer_test.go: `.After(time.Second)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustExec(t, db, `DELETE FROM pipeline_runs`)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("processes transactions with receipt older than minConfirmations that reverted", func(t *testing.T) {
		type data struct {
			value any
			error
		}
		ch := make(chan data)
		nonce := types.Nonce(4)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		finalizer.SetResumeCallback(func(ctx context.Context, id uuid.UUID, value interface{}, err error) error {
			ch <- data{value, err}
			return nil
		})
		servicetest.Run(t, finalizer)

		runID := testutils.MustInsertPipelineRun(t, db)
		trID := testutils.MustInsertUnfinishedPipelineTaskRun(t, db, runID)
		testutils.MustExec(t, db, `UPDATE pipeline_runs SET state = 'suspended' WHERE id = $1`, runID)

		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, int64(nonce), 1, fromAddress)
		testutils.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": true}'`)

		// receipt is not passed through as a value since it reverted and caused an error
		mustInsertRevertedEthReceipt(t, txStore, head.Number-minConfirmations, head.Hash, etx.TxAttempts[0].Hash)

		testutils.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)

		done := make(chan struct{})
		t.Cleanup(func() { <-done })
		go func() {
			defer close(done)
			err2 := finalizer.ResumePendingTaskRuns(ctx, head.BlockNumber(), 0)
			assert.NoError(t, err2)

			// Retrieve Tx to check if callback completed flag was set to true
			updateTx, err3 := txStore.FindTxWithSequence(ctx, fromAddress, nonce)
			assert.NoError(t, err3)
			assert.True(t, updateTx.CallbackCompleted)
		}()

		select {
		case data := <-ch:
			require.Error(t, data.error)

			require.EqualError(t, data.error, fmt.Sprintf("transaction %s reverted on-chain", etx.TxAttempts[0].Hash.String()))

			require.Nil(t, data.value)

		case <-time.After(tests.WaitTimeout(t)):
			t.Fatal("no value received")
		}
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.Nonce(4)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.SetResumeCallback(func(ctx context.Context, id uuid.UUID, value interface{}, err error) error {
			ch <- data{value, err}
			return nil
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertPipelineRun(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertUnfinishedPipelineTaskRun(t, db, runID)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustExec(t, db, `UPDATE pipeline_runs SET state = 'suspended' WHERE id = $1`, runID)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, int64(nonce), 1, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustExec(t, db, `UPDATE evm.txes SET meta='{"FailOnRevert": true}'`)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Cleanup(func() { <-done })`
$DIR/pkg/txmgr/finalizer_test.go: `.ResumePendingTaskRuns(ctx, head.BlockNumber(), 0)`
$DIR/pkg/txmgr/finalizer_test.go: `.BlockNumber()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithSequence(ctx, fromAddress, nonce)`
$DIR/pkg/txmgr/finalizer_test.go: `.After(tests.WaitTimeout(t))`
$DIR/pkg/txmgr/finalizer_test.go: `.WaitTimeout(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.Nonce(5)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.SetResumeCallback(func(ctx context.Context, id uuid.UUID, value interface{}, err error) error {
			return errors.New("error")
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.New("error")`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(t, finalizer)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertPipelineRun(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertUnfinishedPipelineTaskRun(t, db, runID)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, int64(nonce), 1, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustExec(t, db, `UPDATE evm.txes SET pipeline_task_run_id = $1, min_confirmations = $2, signal_callback = TRUE WHERE id = $3`, &trID, minConfirmations, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.ResumePendingTaskRuns(ctx, head.BlockNumber(), 0)`
$DIR/pkg/txmgr/finalizer_test.go: `.BlockNumber()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithSequence(ctx, fromAddress, nonce)`
$DIR/pkg/txmgr/finalizer_test.go: `.Context()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.EVM()`
$DIR/pkg/txmgr/finalizer_test.go: `.RPCDefaultBatchSize()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSimulatedHeadTracker(ethClient, true, 0)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/finalizer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/finalizer_test.go: `.String()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Store(latestFinalizedHead)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("does nothing if no confirmed transactions without receipts found", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, config.EVM().RPCDefaultBatchSize(), false, txStore, txmClient, ht, metrics)

		mustInsertFatalErrorEthTx(t, txStore, fromAddress)
		mustInsertInProgressEthTx(t, txStore, 0, fromAddress)
		mustInsertUnconfirmedEthTxWithInsufficientEthAttempt(t, txStore, 2, fromAddress)
		mustCreateUnstartedGeneratedTx(t, txStore, fromAddress, config.EVM().ChainID())
		// Insert confirmed transactions with receipt and multiple attempts to ensure none of the attempts are picked up
		etx := mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 3, head.Number)
		attempt := newBroadcastLegacyEthTxAttempt(t, etx.ID, 2)
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt))

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, config.EVM().RPCDefaultBatchSize(), false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.EVM()`
$DIR/pkg/txmgr/finalizer_test.go: `.RPCDefaultBatchSize()`
$DIR/pkg/txmgr/finalizer_test.go: `.EVM()`
$DIR/pkg/txmgr/finalizer_test.go: `.ChainID()`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("fetches receipt for confirmed transaction without a receipt", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		// Transaction not confirmed yet, receipt is nil
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		require.NoError(t, err)
		require.Empty(t, attempt.Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("saves nothing if returned receipt does not match the attempt", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		txmReceipt := types.Receipt{
			TxHash:           testutils.NewHash(),
			BlockHash:        testutils.NewHash(),
			BlockNumber:      big.NewInt(42),
			TransactionIndex: uint(1),
		}

		// First transaction confirmed
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
		}).Once()

		// No error because it is merely logged
		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 1)
		require.Empty(t, etx.TxAttempts[0].Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("saves nothing if query returns error", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		txmReceipt := types.Receipt{
			TxHash:           etx.TxAttempts[0].Hash,
			BlockHash:        testutils.NewHash(),
			BlockNumber:      big.NewInt(42),
			TransactionIndex: uint(1),
		}

		// Batch receipt call fails
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
			elems[0].Error = errors.New("foo")
		}).Once()

		// No error because it is merely logged
		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Len(t, etx.TxAttempts, 1)
		require.Empty(t, etx.TxAttempts[0].Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
			elems[0].Error = errors.New("foo")
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.New("foo")`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("saves valid receipt returned by client", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx1 := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		// Insert confirmed transaction without receipt
		etx2 := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 1, head.Number, fromAddress)
		txmReceipt := types.Receipt{
			TxHash:           etx1.TxAttempts[0].Hash,
			BlockHash:        testutils.NewHash(),
			BlockNumber:      big.NewInt(42),
			TransactionIndex: uint(1),
			Status:           uint64(1),
		}

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], etx1.TxAttempts[0].Hash) &&
				matchTranscationReceipt(b[1], etx2.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// First transaction confirmed
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
			// Second transaction still unconfirmed
			elems[1].Result = &types.Receipt{}
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// Check that the receipt was saved
		var err error
		etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)
		require.NoError(t, err)

		require.Equal(t, txmgrcommon.TxConfirmed, etx1.State)
		require.Len(t, etx1.TxAttempts, 1)
		attempt := etx1.TxAttempts[0]
		require.Len(t, attempt.Receipts, 1)
		receipt := attempt.Receipts[0]
		require.Equal(t, txmReceipt.TxHash, receipt.GetTxHash())
		require.Equal(t, txmReceipt.BlockHash, receipt.GetBlockHash())
		require.Equal(t, txmReceipt.BlockNumber.Int64(), receipt.GetBlockNumber().Int64())
		require.Equal(t, txmReceipt.TransactionIndex, receipt.GetTransactionIndex())

		receiptJSON, err := json.Marshal(txmReceipt)
		require.NoError(t, err)

		storedReceiptJSON, err := json.Marshal(receipt)
		require.NoError(t, err)
		require.JSONEq(t, string(receiptJSON), string(storedReceiptJSON))
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 1, head.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], etx1.TxAttempts[0].Hash) &&
				matchTranscationReceipt(b[1], etx2.TxAttempts[0].Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], etx1.TxAttempts[0].Hash) &&
				matchTranscationReceipt(b[1], etx2.TxAttempts[0].Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// First transaction confirmed
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
			// Second transaction still unconfirmed
			elems[1].Result = &types.Receipt{}
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Marshal(txmReceipt)`
$DIR/pkg/txmgr/finalizer_test.go: `.Marshal(receipt)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("fetches and saves receipts for several attempts in gas price order", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		attempt1 := etx.TxAttempts[0]
		attempt2 := newBroadcastLegacyEthTxAttempt(t, etx.ID, 2)
		attempt3 := newBroadcastLegacyEthTxAttempt(t, etx.ID, 3)

		// Insert order deliberately reversed to test sorting by gas price
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt3))
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt2))

		txmReceipt := types.Receipt{
			TxHash:           attempt2.Hash,
			BlockHash:        testutils.NewHash(),
			BlockNumber:      big.NewInt(42),
			TransactionIndex: uint(1),
			Status:           uint64(1),
		}

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				matchTranscationReceipt(b[2], attempt1.Hash) &&
				matchTranscationReceipt(b[1], attempt2.Hash) &&
				matchTranscationReceipt(b[0], attempt3.Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// Most expensive attempt still unconfirmed
			elems[2].Result = &types.Receipt{}
			// Second most expensive attempt is confirmed
			*(elems[1].Result.(*types.Receipt)) = txmReceipt
			// Cheapest attempt still unconfirmed
			elems[0].Result = &types.Receipt{}
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// Check that the receipt was stored
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Equal(t, txmgrcommon.TxConfirmed, etx.State)
		require.Len(t, etx.TxAttempts, 3)
		require.Empty(t, etx.TxAttempts[0].Receipts)
		require.Len(t, etx.TxAttempts[1].Receipts, 1)
		require.Empty(t, etx.TxAttempts[2].Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				matchTranscationReceipt(b[2], attempt1.Hash) &&
				matchTranscationReceipt(b[1], attempt2.Hash) &&
				matchTranscationReceipt(b[0], attempt3.Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 3 &&
				matchTranscationReceipt(b[2], attempt1.Hash) &&
				matchTranscationReceipt(b[1], attempt2.Hash) &&
				matchTranscationReceipt(b[0], attempt3.Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// Most expensive attempt still unconfirmed
			elems[2].Result = &types.Receipt{}
			// Second most expensive attempt is confirmed
			*(elems[1].Result.(*types.Receipt)) = txmReceipt
			// Cheapest attempt still unconfirmed
			elems[0].Result = &types.Receipt{}
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("ignores receipt missing BlockHash that comes from querying parity too early", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		receipt := types.Receipt{
			TxHash: etx.TxAttempts[0].Hash,
			Status: uint64(1),
		}
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = receipt
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// No receipt, but no error either
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Equal(t, txmgrcommon.TxConfirmed, etx.State)
		require.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		require.Empty(t, attempt.Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = receipt
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("does not panic if receipt has BlockHash but is missing some other fields somehow", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		// NOTE: This should never happen, but we shouldn't panic regardless
		receipt := types.Receipt{
			TxHash:    etx.TxAttempts[0].Hash,
			BlockHash: testutils.NewHash(),
			Status:    uint64(1),
		}
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = receipt
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// No receipt, but no error either
		etx, err := txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)

		require.Equal(t, txmgrcommon.TxConfirmed, etx.State)
		require.Len(t, etx.TxAttempts, 1)
		attempt := etx.TxAttempts[0]
		require.Empty(t, attempt.Receipts)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = receipt
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("simulate on revert", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)
		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)
		attempt := etx.TxAttempts[0]
		txmReceipt := types.Receipt{
			TxHash:           attempt.Hash,
			BlockHash:        testutils.NewHash(),
			BlockNumber:      big.NewInt(42),
			TransactionIndex: uint(1),
			Status:           uint64(0),
		}

		// First attempt is confirmed and reverted
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], attempt.Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// First attempt still unconfirmed
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
		}).Once()
		data, err := utils.ABIEncode(`[{"type":"uint256"}]`, big.NewInt(10))
		require.NoError(t, err)
		sig := utils.Keccak256Fixed([]byte(`MyError(uint256)`))
		ethClient.On("CallContract", mock.Anything, mock.Anything, mock.Anything).Return(nil, &client.JsonError{
			Code:    1,
			Message: "reverted",
			Data:    utils.ConcatBytes(sig[:4], data),
		}).Once()

		// Do the thing
		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// Check that the state was updated
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		attempt = etx.TxAttempts[0]
		require.Equal(t, txmgrtypes.TxAttemptBroadcast, attempt.State)
		require.NotNil(t, attempt.BroadcastBeforeBlockNum)
		// Check receipts
		require.Len(t, attempt.Receipts, 1)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], attempt.Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], attempt.Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// First attempt still unconfirmed
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.ABIEncode(`[{"type":"uint256"}]`, big.NewInt(10))`
$DIR/pkg/txmgr/finalizer_test.go: `.NewInt(10)`
$DIR/pkg/txmgr/finalizer_test.go: `.Keccak256Fixed([]byte(`MyError(uint256)`))`
$DIR/pkg/txmgr/finalizer_test.go: `.On("CallContract", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil, &client.JsonError{
			Code:    1,
			Message: "reverted",
			Data:    utils.ConcatBytes(sig[:4], data),
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.ConcatBytes(sig[:4], data)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("find receipt for old transaction, avoid marking as fatal", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, true, txStore, txmClient, ht, metrics)

		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, latestFinalizedHead.Number, fromAddress)

		txmReceipt := types.Receipt{
			TxHash:           etx.TxAttempts[0].Hash,
			BlockHash:        testutils.NewHash(),
			BlockNumber:      big.NewInt(42),
			TransactionIndex: uint(1),
			Status:           uint64(1),
		}

		// Transaction receipt is nil
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// Check that transaction was picked up as old and marked as fatal
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxConfirmed, etx.State)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, true, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, latestFinalizedHead.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("old transaction failed to find receipt, marked as fatal", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, true, txStore, txmClient, ht, metrics)

		// Insert confirmed transaction without receipt
		etx := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, latestFinalizedHead.Number, fromAddress)

		// Transaction receipt is nil
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))

		// Check that transaction was picked up as old and marked as fatal
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFatalError, etx.State)
		require.Equal(t, txmgr.ErrCouldNotGetReceipt, etx.Error.String)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, true, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, latestFinalizedHead.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx.TxAttempts[0].Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmTxStore(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("SaveFetchedReceipts", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Maybe()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("FindTxesPendingCallback", mock.Anything, mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Maybe()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("UpdateTxCallbackCompleted", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Maybe()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("FindConfirmedTxesReceipts", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Maybe()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("FindTxesByIDs", mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Maybe()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Maybe()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewLegacyEthTxAttempt(t, 0)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("FindAttemptsRequiringReceiptFetch", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/finalizer_test.go: `.Return([]txmgr.TxAttempt{attempt}, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.Context()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSimulatedHeadTracker(ethClient, true, 0)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/finalizer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/finalizer_test.go: `.String()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Store(latestFinalizedHead)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("fetch and store receipts from multiple batch calls", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		rpcBatchSize := uint32(2)
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)

		// Insert confirmed transaction without receipt
		etx := mustInsertConfirmedEthTx(t, txStore, 0, fromAddress)

		var attempts []txmgr.TxAttempt
		// Total of 5 attempts should lead to 3 batched fetches (2, 2, 1)v
		for i := 0; i < 5; i++ {
			attempt := newBroadcastLegacyEthTxAttempt(t, etx.ID, int64(i+2))
			attempt.BroadcastBeforeBlockNum = &head.Number
			require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt))
			attempts = append(attempts, attempt)
		}

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], attempts[4].Hash) &&
				matchTranscationReceipt(b[1], attempts[3].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
			elems[1].Result = &types.Receipt{}
		}).Once()
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], attempts[2].Hash) &&
				matchTranscationReceipt(b[1], attempts[1].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
			elems[1].Result = &types.Receipt{}
		}).Once()
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], attempts[0].Hash)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
		}).Once()

		require.NoError(t, finalizer.FetchAndStoreReceipts(ctx, head, latestFinalizedHead))
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], attempts[4].Hash) &&
				matchTranscationReceipt(b[1], attempts[3].Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], attempts[4].Hash) &&
				matchTranscationReceipt(b[1], attempts[3].Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
			elems[1].Result = &types.Receipt{}
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], attempts[2].Hash) &&
				matchTranscationReceipt(b[1], attempts[1].Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 &&
				matchTranscationReceipt(b[0], attempts[2].Hash) &&
				matchTranscationReceipt(b[1], attempts[1].Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
			elems[1].Result = &types.Receipt{}
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], attempts[0].Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], attempts[0].Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = &types.Receipt{}
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, rpcBatchSize, false, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, head.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 1, head.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx1.TxAttempts[0].Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx1.TxAttempts[0].Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(errors.New("batch call failed"))`
$DIR/pkg/txmgr/finalizer_test.go: `.New("batch call failed")`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx2.TxAttempts[0].Hash)
		}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 && matchTranscationReceipt(b[0], etx2.TxAttempts[0].Hash)
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			*(elems[0].Result.(*types.Receipt)) = txmReceipt // confirmed
		})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Context()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSimulatedHeadTracker(ethClient, true, 0)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/finalizer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/finalizer_test.go: `.String()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Store(latestFinalizedHead)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, 1, true, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/finalizer_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
		return len(b) == 1 && matchTranscationReceipt(b[0], attempt.Hash)
	}))`
$DIR/pkg/txmgr/finalizer_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
		return len(b) == 1 && matchTranscationReceipt(b[0], attempt.Hash)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.Return(nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run(func(args mock.Arguments) {
		elems := args.Get(1).([]rpc.BatchElem)
		*(elems[0].Result.(*types.Receipt)) = txmReceipt // confirmed
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.Get(1)`
$DIR/pkg/txmgr/finalizer_test.go: `.Once()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Context()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSimulatedHeadTracker(ethClient, true, 0)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEVMTxmMetrics(ethClient.ConfiguredChainID().String())`
$DIR/pkg/txmgr/finalizer_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/finalizer_test.go: `.String()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewHash()`
$DIR/pkg/txmgr/finalizer_test.go: `.Parent.Store(latestFinalizedHead)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("does nothing if no old transactions found", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, 1, true, txStore, txmClient, ht, metrics)
		require.NoError(t, finalizer.ProcessOldTxsWithoutReceipts(ctx, []int64{}, head, latestFinalizedHead))
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, 1, true, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("marks multiple old transactions as fatal", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, 1, true, txStore, txmClient, ht, metrics)

		// Insert confirmed transaction without receipt
		etx1 := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, latestFinalizedHead.Number, fromAddress)
		etx2 := txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 1, latestFinalizedHead.Number, fromAddress)

		etxIDs := []int64{etx1.ID, etx2.ID}
		require.NoError(t, finalizer.ProcessOldTxsWithoutReceipts(ctx, etxIDs, head, latestFinalizedHead))

		// Check transactions marked as fatal
		var err error
		etx1, err = txStore.FindTxWithAttempts(ctx, etx1.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFatalError, etx1.State)
		require.Equal(t, txmgr.ErrCouldNotGetReceipt, etx1.Error.String)

		etx2, err = txStore.FindTxWithAttempts(ctx, etx2.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFatalError, etx2.State)
		require.Equal(t, txmgr.ErrCouldNotGetReceipt, etx2.Error.String)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, 1, true, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, latestFinalizedHead.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 1, latestFinalizedHead.Number, fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx1.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx2.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.Run("marks old transaction as fatal, resumes pending task as failed", func(t *testing.T) {
		db := testutils.NewSqlxDB(t)
		txStore := txmgrtest.NewTestTxStore(t, db)
		fromAddress := testutils.NewAddress()
		finalizer := txmgr.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, 1, true, txStore, txmClient, ht, metrics)
		finalizer.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error { return nil })

		// Insert confirmed transaction with pending task run
		etx := txmgrtest.NewEthTx(fromAddress)
		etx.State = txmgrcommon.TxConfirmed
		n := types.Nonce(0)
		etx.Sequence = &n
		now := time.Now()
		etx.BroadcastAt = &now
		etx.InitialBroadcastAt = &now
		etx.SignalCallback = true
		etx.PipelineTaskRunID = uuid.NullUUID{UUID: uuid.New(), Valid: true}
		require.NoError(t, txStore.InsertTx(t.Context(), &etx))

		attempt := newBroadcastLegacyEthTxAttempt(t, etx.ID, 0)
		attempt.BroadcastBeforeBlockNum = &latestFinalizedHead.Number // set broadcast time to finalized block num
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt))

		require.NoError(t, finalizer.ProcessOldTxsWithoutReceipts(ctx, []int64{etx.ID}, head, latestFinalizedHead))

		// Check transaction marked as fatal
		var err error
		etx, err = txStore.FindTxWithAttempts(ctx, etx.ID)
		require.NoError(t, err)
		require.Equal(t, txmgrcommon.TxFatalError, etx.State)
		require.Equal(t, txmgr.ErrCouldNotGetReceipt, etx.Error.String)
		require.True(t, etx.CallbackCompleted)
	})`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, 1, true, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error { return nil })`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEthTx(fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/finalizer_test.go: `.Now()`
$DIR/pkg/txmgr/finalizer_test.go: `.New()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/finalizer_test.go: `.NewAddress()`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEvmFinalizer(logger.Test(t), testutils.FixtureChainID, 1, true, txStore, txmClient, ht, metrics)`
$DIR/pkg/txmgr/finalizer_test.go: `.Test(t)`
$DIR/pkg/txmgr/finalizer_test.go: `.SetResumeCallback(func(context.Context, uuid.UUID, interface{}, error) error { return errors.New("failure") })`
$DIR/pkg/txmgr/finalizer_test.go: `.New("failure")`
$DIR/pkg/txmgr/finalizer_test.go: `.NewEthTx(fromAddress)`
$DIR/pkg/txmgr/finalizer_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/finalizer_test.go: `.Now()`
$DIR/pkg/txmgr/finalizer_test.go: `.New()`
$DIR/pkg/txmgr/finalizer_test.go: `.FindTxWithAttempts(ctx, etx.ID)`
$DIR/pkg/txmgr/models_test.go: `.GetID()`
$DIR/pkg/txmgr/models_test.go: `.NewInt(3)`
$DIR/pkg/txmgr/models_test.go: `.NewCancunSigner(chainID)`
$DIR/pkg/txmgr/models_test.go: `.NewAddress()`
$DIR/pkg/txmgr/models_test.go: `.GenerateKey()`
$DIR/pkg/txmgr/models_test.go: `.MustSignNewTx(key, signer, &gethtypes.LegacyTx{
		Nonce:    42,
		To:       &to,
		Value:    big.NewInt(142),
		Gas:      242,
		GasPrice: big.NewInt(342),
		Data:     []byte{1, 2, 3},
	})`
$DIR/pkg/txmgr/models_test.go: `.NewInt(142)`
$DIR/pkg/txmgr/models_test.go: `.NewInt(342)`
$DIR/pkg/txmgr/models_test.go: `.Bytes()`
$DIR/pkg/txmgr/models_test.go: `.GetGethSignedTx(signedRawTx)`
$DIR/pkg/txmgr/models_test.go: `.Bytes()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("ConfiguredChainID").Return(chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `t.Run("set next nonce using entries from tx table", func(t *testing.T) {
		randNonce1 := rand.Int63()
		randNonce2 := rand.Int63()
		txStore.On("FindLatestSequence", mock.Anything, addr1, chainID).Return(types.Nonce(randNonce1), nil).Once()
		txStore.On("FindLatestSequence", mock.Anything, addr2, chainID).Return(types.Nonce(randNonce2), nil).Once()

		nonceTracker.LoadNextSequences(ctx, enabledAddresses)
		seq, err := nonceTracker.GetNextSequence(ctx, addr1)
		require.NoError(t, err)
		require.Equal(t, types.Nonce(randNonce1+1), seq)
		seq, err = nonceTracker.GetNextSequence(ctx, addr2)
		require.NoError(t, err)
		require.Equal(t, types.Nonce(randNonce2+1), seq)
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `txStore.On("FindLatestSequence", mock.Anything, addr1, chainID).Return(types.Nonce(randNonce1), nil).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `txStore.On("FindLatestSequence", mock.Anything, addr2, chainID).Return(types.Nonce(randNonce2), nil).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonceTracker.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `seq, err = nonceTracker.GetNextSequence(ctx, addr2)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `txStore.On("FindLatestSequence", mock.Anything, addr1, chainID).Return(emptyNonce, errors.New("no rows")).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `txStore.On("FindLatestSequence", mock.Anything, addr2, chainID).Return(emptyNonce, errors.New("no rows")).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("NonceAt", mock.Anything, addr1, mock.Anything).Return(uint64(randNonce1), nil).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("NonceAt", mock.Anything, addr2, mock.Anything).Return(uint64(randNonce2), nil).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonceTracker.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `seq, err = nonceTracker.GetNextSequence(ctx, addr2)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("ConfiguredChainID").Return(chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `t.Run("throws error if RPC call fails", func(t *testing.T) {
		client.On("PendingNonceAt", mock.Anything, addr).Return(uint64(0), errors.New("RPC unavailable")).Once()

		err := nonceTracker.SyncOnChain(ctx, addr, types.Nonce(2))
		require.Error(t, err)
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("PendingNonceAt", mock.Anything, addr).Return(uint64(0), errors.New("RPC unavailable")).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `t.Run("uses local nonce instead of on-chain nonce if on-chain nonce is lower", func(t *testing.T) {
		nonce := 2
		newNonce := 5
		client.On("PendingNonceAt", mock.Anything, addr).Return(uint64(nonce), nil).Once()

		enabledAddresses := []common.Address{}
		nonceTracker.LoadNextSequences(ctx, enabledAddresses)

		// syncOnChain will set the next sequence even if the address is not present in the map
		err := nonceTracker.SyncOnChain(ctx, addr, types.Nonce(newNonce))
		require.NoError(t, err)

		seq, err := nonceTracker.GetNextSequence(ctx, addr)
		require.NoError(t, err)
		require.Equal(t, types.Nonce(newNonce), seq)
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("PendingNonceAt", mock.Anything, addr).Return(uint64(nonce), nil).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonceTracker.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("PendingNonceAt", mock.Anything, addr).Return(uint64(nonce), nil).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonceTracker.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("ConfiguredChainID").Return(chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `t.Run("syncs sequence successfully", func(t *testing.T) {
		txStoreNonce := 2
		onChainNonce := 3
		txStore.On("FindLatestSequence", mock.Anything, addr, chainID).Return(types.Nonce(txStoreNonce), nil).Once()
		nonceTracker.LoadNextSequences(ctx, enabledAddresses)

		var chStop services.StopChan
		client.On("PendingNonceAt", mock.Anything, addr).Return(uint64(onChainNonce), nil).Once()
		nonceTracker.SyncSequence(ctx, addr, chStop)

		seq, err := nonceTracker.GetNextSequence(ctx, addr)
		require.NoError(t, err)
		require.Equal(t, types.Nonce(onChainNonce), seq)
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `txStore.On("FindLatestSequence", mock.Anything, addr, chainID).Return(types.Nonce(txStoreNonce), nil).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonceTracker.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("PendingNonceAt", mock.Anything, addr).Return(uint64(onChainNonce), nil).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonceTracker.SyncSequence(ctx, addr, chStop)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `txStore.On("FindLatestSequence", mock.Anything, addr, chainID).Return(types.Nonce(txStoreNonce), nil).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonceTracker.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("PendingNonceAt", mock.Anything, addr).Return(uint64(0), errors.New("RPC unavailable")).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("PendingNonceAt", mock.Anything, addr).Return(uint64(onChainNonce), nil).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonceTracker.SyncSequence(ctx, addr, chStop)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("ConfiguredChainID").Return(chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `t.Run("fails to get sequence if address doesn't exist in map", func(t *testing.T) {
		_, err := nonceTracker.GetNextSequence(ctx, addr)
		require.Error(t, err)
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `t.Run("fails to get sequence if address doesn't exist in map and is disabled", func(t *testing.T) {
		_, err := nonceTracker.GetNextSequence(ctx, addr)
		require.Error(t, err)
		require.Contains(t, err.Error(), fmt.Sprintf("address disabled: %s", addr.Hex()))
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `t.Run("fails to get sequence if address is enabled, doesn't exist in map, and getSequenceForAddr fails", func(t *testing.T) {
		enabledAddresses := []common.Address{addr}
		txStore.On("FindLatestSequence", mock.Anything, addr, chainID).Return(types.Nonce(0), errors.New("no rows")).Twice()
		client.On("NonceAt", mock.Anything, addr, mock.Anything).Return(uint64(0), errors.New("RPC unavailable")).Twice()
		nonceTracker.LoadNextSequences(ctx, enabledAddresses)

		_, err := nonceTracker.GetNextSequence(ctx, addr)
		require.Error(t, err)
		require.Contains(t, err.Error(), fmt.Sprintf("failed to find next sequence for address: %s", addr.Hex()))
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `txStore.On("FindLatestSequence", mock.Anything, addr, chainID).Return(types.Nonce(0), errors.New("no rows")).Twice()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("NonceAt", mock.Anything, addr, mock.Anything).Return(uint64(0), errors.New("RPC unavailable")).Twice()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonceTracker.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `txStore.On("FindLatestSequence", mock.Anything, addr, chainID).Return(types.Nonce(0), errors.New("no rows")).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("NonceAt", mock.Anything, addr, mock.Anything).Return(uint64(0), errors.New("RPC unavailable")).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonceTracker.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `txStore.On("FindLatestSequence", mock.Anything, addr, chainID).Return(types.Nonce(txStoreNonce), nil).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("ConfiguredChainID").Return(chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `txStore.On("FindLatestSequence", mock.Anything, addr, chainID).Return(types.Nonce(randNonce), nil).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonceTracker.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonceTracker.GenerateNextSequence(addr, types.Nonce(randNonce+1))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `seq, err = nonceTracker.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("ConfiguredChainID").Return(chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("NonceAt", mock.Anything, addr, mock.Anything).Return(uint64(0), errors.New("failed to retrieve nonce at startup")).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `client.On("NonceAt", mock.Anything, addr, mock.Anything).Return(uint64(randNonce), nil).Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonceTracker.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `nonce, err = nonceTracker.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Context(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewEvmTxStore(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewClient(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("ConfiguredChainID")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(client, nil))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Test(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewEvmTxmClient(client, nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.HexToAddress("0xd5e099c71b797516c10ed0f0d895f429c2781142")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.HexToAddress("0xd5e099c71b797516c10ed0f0d895f429c2781140")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Run("set next nonce using entries from tx table", func(t *testing.T) {
		randNonce1 := rand.Int63()
		randNonce2 := rand.Int63()
		txStore.On("FindLatestSequence", mock.Anything, addr1, chainID).Return(types.Nonce(randNonce1), nil).Once()
		txStore.On("FindLatestSequence", mock.Anything, addr2, chainID).Return(types.Nonce(randNonce2), nil).Once()

		nonceTracker.LoadNextSequences(ctx, enabledAddresses)
		seq, err := nonceTracker.GetNextSequence(ctx, addr1)
		require.NoError(t, err)
		require.Equal(t, types.Nonce(randNonce1+1), seq)
		seq, err = nonceTracker.GetNextSequence(ctx, addr2)
		require.NoError(t, err)
		require.Equal(t, types.Nonce(randNonce2+1), seq)
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Int63()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Int63()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("FindLatestSequence", mock.Anything, addr1, chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(types.Nonce(randNonce1), nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Nonce(randNonce1)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("FindLatestSequence", mock.Anything, addr2, chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(types.Nonce(randNonce2), nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Nonce(randNonce2)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr1)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr2)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("FindLatestSequence", mock.Anything, addr1, chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(emptyNonce, errors.New("no rows"))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.New("no rows")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("FindLatestSequence", mock.Anything, addr2, chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(emptyNonce, errors.New("no rows"))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.New("no rows")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Int63()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Int63()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("NonceAt", mock.Anything, addr1, mock.Anything)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(uint64(randNonce1), nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("NonceAt", mock.Anything, addr2, mock.Anything)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(uint64(randNonce2), nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr1)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr2)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Context(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewEvmTxStore(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewClient(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("ConfiguredChainID")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(client, nil))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Test(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewEvmTxmClient(client, nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.HexToAddress("0xd5e099c71b797516c10ed0f0d895f429c2781142")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Run("throws error if RPC call fails", func(t *testing.T) {
		client.On("PendingNonceAt", mock.Anything, addr).Return(uint64(0), errors.New("RPC unavailable")).Once()

		err := nonceTracker.SyncOnChain(ctx, addr, types.Nonce(2))
		require.Error(t, err)
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("PendingNonceAt", mock.Anything, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(uint64(0), errors.New("RPC unavailable"))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.New("RPC unavailable")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.SyncOnChain(ctx, addr, types.Nonce(2))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Nonce(2)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Run("uses local nonce instead of on-chain nonce if on-chain nonce is lower", func(t *testing.T) {
		nonce := 2
		newNonce := 5
		client.On("PendingNonceAt", mock.Anything, addr).Return(uint64(nonce), nil).Once()

		enabledAddresses := []common.Address{}
		nonceTracker.LoadNextSequences(ctx, enabledAddresses)

		// syncOnChain will set the next sequence even if the address is not present in the map
		err := nonceTracker.SyncOnChain(ctx, addr, types.Nonce(newNonce))
		require.NoError(t, err)

		seq, err := nonceTracker.GetNextSequence(ctx, addr)
		require.NoError(t, err)
		require.Equal(t, types.Nonce(newNonce), seq)
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("PendingNonceAt", mock.Anything, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(uint64(nonce), nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.SyncOnChain(ctx, addr, types.Nonce(newNonce))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Nonce(newNonce)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("PendingNonceAt", mock.Anything, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(uint64(nonce), nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.SyncOnChain(ctx, addr, types.Nonce(onChainNonce))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Nonce(onChainNonce)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Context(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewEvmTxStore(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewClient(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("ConfiguredChainID")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(client, nil))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Test(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewEvmTxmClient(client, nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.HexToAddress("0xd5e099c71b797516c10ed0f0d895f429c2781142")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Run("syncs sequence successfully", func(t *testing.T) {
		txStoreNonce := 2
		onChainNonce := 3
		txStore.On("FindLatestSequence", mock.Anything, addr, chainID).Return(types.Nonce(txStoreNonce), nil).Once()
		nonceTracker.LoadNextSequences(ctx, enabledAddresses)

		var chStop services.StopChan
		client.On("PendingNonceAt", mock.Anything, addr).Return(uint64(onChainNonce), nil).Once()
		nonceTracker.SyncSequence(ctx, addr, chStop)

		seq, err := nonceTracker.GetNextSequence(ctx, addr)
		require.NoError(t, err)
		require.Equal(t, types.Nonce(onChainNonce), seq)
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("FindLatestSequence", mock.Anything, addr, chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(types.Nonce(txStoreNonce), nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Nonce(txStoreNonce)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("PendingNonceAt", mock.Anything, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(uint64(onChainNonce), nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.SyncSequence(ctx, addr, chStop)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("FindLatestSequence", mock.Anything, addr, chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(types.Nonce(txStoreNonce), nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Nonce(txStoreNonce)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("PendingNonceAt", mock.Anything, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(uint64(0), errors.New("RPC unavailable"))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.New("RPC unavailable")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("PendingNonceAt", mock.Anything, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(uint64(onChainNonce), nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.SyncSequence(ctx, addr, chStop)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Context(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewEvmTxStore(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewClient(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("ConfiguredChainID")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(client, nil))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Test(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewEvmTxmClient(client, nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.HexToAddress("0xd5e099c71b797516c10ed0f0d895f429c2781142")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Run("fails to get sequence if address doesn't exist in map", func(t *testing.T) {
		_, err := nonceTracker.GetNextSequence(ctx, addr)
		require.Error(t, err)
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Run("fails to get sequence if address doesn't exist in map and is disabled", func(t *testing.T) {
		_, err := nonceTracker.GetNextSequence(ctx, addr)
		require.Error(t, err)
		require.Contains(t, err.Error(), fmt.Sprintf("address disabled: %s", addr.Hex()))
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Run("fails to get sequence if address is enabled, doesn't exist in map, and getSequenceForAddr fails", func(t *testing.T) {
		enabledAddresses := []common.Address{addr}
		txStore.On("FindLatestSequence", mock.Anything, addr, chainID).Return(types.Nonce(0), errors.New("no rows")).Twice()
		client.On("NonceAt", mock.Anything, addr, mock.Anything).Return(uint64(0), errors.New("RPC unavailable")).Twice()
		nonceTracker.LoadNextSequences(ctx, enabledAddresses)

		_, err := nonceTracker.GetNextSequence(ctx, addr)
		require.Error(t, err)
		require.Contains(t, err.Error(), fmt.Sprintf("failed to find next sequence for address: %s", addr.Hex()))
	})`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("FindLatestSequence", mock.Anything, addr, chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(types.Nonce(0), errors.New("no rows"))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.New("no rows")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Twice()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("NonceAt", mock.Anything, addr, mock.Anything)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(uint64(0), errors.New("RPC unavailable"))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.New("RPC unavailable")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Twice()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("FindLatestSequence", mock.Anything, addr, chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(types.Nonce(0), errors.New("no rows"))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.New("no rows")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("NonceAt", mock.Anything, addr, mock.Anything)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(uint64(0), errors.New("RPC unavailable"))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.New("RPC unavailable")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("FindLatestSequence", mock.Anything, addr, chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(types.Nonce(txStoreNonce), nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Nonce(txStoreNonce)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Context(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewEvmTxStore(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewClient(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("ConfiguredChainID")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(client, nil))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Test(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewEvmTxmClient(client, nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.HexToAddress("0xd5e099c71b797516c10ed0f0d895f429c2781142")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Int63()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("FindLatestSequence", mock.Anything, addr, chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(types.Nonce(randNonce), nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Nonce(randNonce)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GenerateNextSequence(addr, types.Nonce(randNonce+1))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Nonce(randNonce+1)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Nonce(randNonce+2)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Context(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewTxStore(db, logger.Test(t))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Test(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewClient(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("ConfiguredChainID")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(chainID)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewNonceTracker(logger.Test(t), txStore, txmgr.NewEvmTxmClient(client, nil))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Test(t)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.NewEvmTxmClient(client, nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.HexToAddress("0xd5e099c71b797516c10ed0f0d895f429c2781142")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Int63()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("NonceAt", mock.Anything, addr, mock.Anything)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(uint64(0), errors.New("failed to retrieve nonce at startup"))`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.New("failed to retrieve nonce at startup")`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.On("NonceAt", mock.Anything, addr, mock.Anything)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Return(uint64(randNonce), nil)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.Once()`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.LoadNextSequences(ctx, enabledAddresses)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/nonce_tracker_test.go: `.GetNextSequence(ctx, addr)`
$DIR/pkg/txmgr/reaper_test.go: `t.Run("with nothing in the database, doesn't error", func(t *testing.T) {
		tc := &reaperConfig{reaperThreshold: 1 * time.Hour}

		r := newReaper(t, txStore, tc)

		err := r.ReapTxes(42)
		assert.NoError(t, err)
	})`
$DIR/pkg/txmgr/reaper_test.go: `mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, nonce, 5)`
$DIR/pkg/txmgr/reaper_test.go: `t.Run("skips if threshold=0", func(t *testing.T) {
		tc := &reaperConfig{reaperThreshold: 0 * time.Second}

		r := newReaper(t, txStore, tc)

		err := r.ReapTxes(42)
		assert.NoError(t, err)

		txmgrtest.AssertCount(t, db, "evm.txes", 1)
	})`
$DIR/pkg/txmgr/reaper_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/reaper_test.go: `t.Run("doesn't touch ethtxes with different chain ID", func(t *testing.T) {
		tc := &reaperConfig{reaperThreshold: 1 * time.Hour}

		r := newReaperWithChainID(t, txStore, tc, big.NewInt(42))

		err := r.ReapTxes(42)
		assert.NoError(t, err)
		// Didn't delete because eth_tx has chain ID of 0
		txmgrtest.AssertCount(t, db, "evm.txes", 1)
	})`
$DIR/pkg/txmgr/reaper_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/reaper_test.go: `t.Run("deletes finalized evm.txes that exceed the age threshold", func(t *testing.T) {
		tc := &reaperConfig{reaperThreshold: 1 * time.Hour}

		r := newReaper(t, txStore, tc)

		err := r.ReapTxes(42)
		assert.NoError(t, err)
		// Didn't delete because eth_tx was not old enough
		txmgrtest.AssertCount(t, db, "evm.txes", 1)

		testutils.MustExec(t, db, `UPDATE evm.txes SET created_at=$1, state='finalized'`, oneDayAgo)

		err = r.ReapTxes(42)
		assert.NoError(t, err)
		// Now it deleted because the eth_tx was past the age threshold
		txmgrtest.AssertCount(t, db, "evm.txes", 0)
	})`
$DIR/pkg/txmgr/reaper_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/reaper_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET created_at=$1, state='finalized'`, oneDayAgo)`
$DIR/pkg/txmgr/reaper_test.go: `err = r.ReapTxes(42)`
$DIR/pkg/txmgr/reaper_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 0)`
$DIR/pkg/txmgr/reaper_test.go: `mustInsertFatalErrorEthTx(t, txStore, fromAddress)`
$DIR/pkg/txmgr/reaper_test.go: `t.Run("deletes errored evm.txes that exceed the age threshold", func(t *testing.T) {
		tc := &reaperConfig{reaperThreshold: 1 * time.Hour}

		r := newReaper(t, txStore, tc)

		err := r.ReapTxes(42)
		assert.NoError(t, err)
		// Didn't delete because eth_tx was not old enough
		txmgrtest.AssertCount(t, db, "evm.txes", 1)

		require.NoError(t, utils.JustError(db.Exec(`UPDATE evm.txes SET created_at=$1`, oneDayAgo)))

		err = r.ReapTxes(42)
		assert.NoError(t, err)
		// Deleted because it is old enough now
		txmgrtest.AssertCount(t, db, "evm.txes", 0)
	})`
$DIR/pkg/txmgr/reaper_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/reaper_test.go: `err = r.ReapTxes(42)`
$DIR/pkg/txmgr/reaper_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 0)`
$DIR/pkg/txmgr/reaper_test.go: `mustInsertConfirmedEthTxWithReceipt(t, txStore, fromAddress, 0, 42)`
$DIR/pkg/txmgr/reaper_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/reaper_test.go: `testutils.MustExec(t, db, `UPDATE evm.txes SET created_at=$1`, oneDayAgo)`
$DIR/pkg/txmgr/reaper_test.go: `err = r.ReapTxes(42)`
$DIR/pkg/txmgr/reaper_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 0)`
$DIR/pkg/txmgr/reaper_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/reaper_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/reaper_test.go: `.NewAddress()`
$DIR/pkg/txmgr/reaper_test.go: `.Now()`
$DIR/pkg/txmgr/reaper_test.go: `.Add(-24 * time.Hour)`
$DIR/pkg/txmgr/reaper_test.go: `.Run("with nothing in the database, doesn't error", func(t *testing.T) {
		tc := &reaperConfig{reaperThreshold: 1 * time.Hour}

		r := newReaper(t, txStore, tc)

		err := r.ReapTxes(42)
		assert.NoError(t, err)
	})`
$DIR/pkg/txmgr/reaper_test.go: `.ReapTxes(42)`
$DIR/pkg/txmgr/reaper_test.go: `.Run("skips if threshold=0", func(t *testing.T) {
		tc := &reaperConfig{reaperThreshold: 0 * time.Second}

		r := newReaper(t, txStore, tc)

		err := r.ReapTxes(42)
		assert.NoError(t, err)

		txmgrtest.AssertCount(t, db, "evm.txes", 1)
	})`
$DIR/pkg/txmgr/reaper_test.go: `.ReapTxes(42)`
$DIR/pkg/txmgr/reaper_test.go: `.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/reaper_test.go: `.Run("doesn't touch ethtxes with different chain ID", func(t *testing.T) {
		tc := &reaperConfig{reaperThreshold: 1 * time.Hour}

		r := newReaperWithChainID(t, txStore, tc, big.NewInt(42))

		err := r.ReapTxes(42)
		assert.NoError(t, err)
		// Didn't delete because eth_tx has chain ID of 0
		txmgrtest.AssertCount(t, db, "evm.txes", 1)
	})`
$DIR/pkg/txmgr/reaper_test.go: `.NewInt(42)`
$DIR/pkg/txmgr/reaper_test.go: `.ReapTxes(42)`
$DIR/pkg/txmgr/reaper_test.go: `.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/reaper_test.go: `.Run("deletes finalized evm.txes that exceed the age threshold", func(t *testing.T) {
		tc := &reaperConfig{reaperThreshold: 1 * time.Hour}

		r := newReaper(t, txStore, tc)

		err := r.ReapTxes(42)
		assert.NoError(t, err)
		// Didn't delete because eth_tx was not old enough
		txmgrtest.AssertCount(t, db, "evm.txes", 1)

		testutils.MustExec(t, db, `UPDATE evm.txes SET created_at=$1, state='finalized'`, oneDayAgo)

		err = r.ReapTxes(42)
		assert.NoError(t, err)
		// Now it deleted because the eth_tx was past the age threshold
		txmgrtest.AssertCount(t, db, "evm.txes", 0)
	})`
$DIR/pkg/txmgr/reaper_test.go: `.ReapTxes(42)`
$DIR/pkg/txmgr/reaper_test.go: `.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/reaper_test.go: `.MustExec(t, db, `UPDATE evm.txes SET created_at=$1, state='finalized'`, oneDayAgo)`
$DIR/pkg/txmgr/reaper_test.go: `.ReapTxes(42)`
$DIR/pkg/txmgr/reaper_test.go: `.AssertCount(t, db, "evm.txes", 0)`
$DIR/pkg/txmgr/reaper_test.go: `.Run("deletes errored evm.txes that exceed the age threshold", func(t *testing.T) {
		tc := &reaperConfig{reaperThreshold: 1 * time.Hour}

		r := newReaper(t, txStore, tc)

		err := r.ReapTxes(42)
		assert.NoError(t, err)
		// Didn't delete because eth_tx was not old enough
		txmgrtest.AssertCount(t, db, "evm.txes", 1)

		require.NoError(t, utils.JustError(db.Exec(`UPDATE evm.txes SET created_at=$1`, oneDayAgo)))

		err = r.ReapTxes(42)
		assert.NoError(t, err)
		// Deleted because it is old enough now
		txmgrtest.AssertCount(t, db, "evm.txes", 0)
	})`
$DIR/pkg/txmgr/reaper_test.go: `.ReapTxes(42)`
$DIR/pkg/txmgr/reaper_test.go: `.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/reaper_test.go: `.ReapTxes(42)`
$DIR/pkg/txmgr/reaper_test.go: `.AssertCount(t, db, "evm.txes", 0)`
$DIR/pkg/txmgr/reaper_test.go: `.ReapTxes(42)`
$DIR/pkg/txmgr/reaper_test.go: `.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/reaper_test.go: `.MustExec(t, db, `UPDATE evm.txes SET created_at=$1`, oneDayAgo)`
$DIR/pkg/txmgr/reaper_test.go: `.ReapTxes(42)`
$DIR/pkg/txmgr/reaper_test.go: `.AssertCount(t, db, "evm.txes", 0)`
$DIR/pkg/txmgr/resender_test.go: `ethClient.On("IsL2").Return(false).Maybe()`
$DIR/pkg/txmgr/resender_test.go: `addr1TxesRawHex = append(addr1TxesRawHex, hexutil.Encode(etx.TxAttempts[0].SignedRawTx))`
$DIR/pkg/txmgr/resender_test.go: `addr2TxesRawHex = append(addr2TxesRawHex, hexutil.Encode(etx.TxAttempts[0].SignedRawTx))`
$DIR/pkg/txmgr/resender_test.go: `addr3TxesRawHex = append(addr3TxesRawHex, hexutil.Encode(etx.TxAttempts[0].SignedRawTx))`
$DIR/pkg/txmgr/resender_test.go: `ethClient.On("BatchCallContextAll", mock.Anything, mock.MatchedBy(func(elems []rpc.BatchElem) bool {
		for _, elem := range elems {
			resentHex[elem.Args[0].(string)] = struct{}{}
		}
		assert.Len(t, elems, len(addr1TxesRawHex)+len(addr2TxesRawHex)+int(txConfig.MaxInFlight()))
		// All addr1TxesRawHex should be included
		for _, addr := range addr1TxesRawHex {
			assert.Contains(t, resentHex, addr)
		}
		// All addr2TxesRawHex should be included
		for _, addr := range addr2TxesRawHex {
			assert.Contains(t, resentHex, addr)
		}
		// Up to limit EvmMaxInFlightTransactions addr3TxesRawHex should be included
		for i, addr := range addr3TxesRawHex {
			if i >= int(txConfig.MaxInFlight()) {
				// Above limit EvmMaxInFlightTransactions addr3TxesRawHex should NOT be included
				assert.NotContains(t, resentHex, addr)
			} else {
				assert.Contains(t, resentHex, addr)
			}
		}
		return true
	})).Run(func(args mock.Arguments) {}).Return(nil)`
$DIR/pkg/txmgr/resender_test.go: `resentHex[elem.Args[0].(string)] = struct{}{}`
$DIR/pkg/txmgr/resender_test.go: `ethClient.On("IsL2").Return(false).Maybe()`
$DIR/pkg/txmgr/resender_test.go: `c.Chain = toml.Defaults(ubig.New(big.NewInt(0)), &toml.Chain{
			Transactions: toml.Transactions{ResendAfterThreshold: delay},
		})`
$DIR/pkg/txmgr/resender_test.go: `_ = txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, int64(1), fromAddress, originalBroadcastAt)`
$DIR/pkg/txmgr/resender_test.go: `ethClient.On("BatchCallContextAll", mock.Anything, mock.Anything).Return(nil)`
$DIR/pkg/txmgr/resender_test.go: `tests.AssertLogCountEventually(t, o, "TxAttempt has been unconfirmed for more than max duration", 1)`
$DIR/pkg/txmgr/resender_test.go: `c.Transactions.ResendAfterThreshold = commonconfig.MustNewDuration(42 * time.Hour)`
$DIR/pkg/txmgr/resender_test.go: `c.RPCDefaultBatchSize = ptr[uint32](1)`
$DIR/pkg/txmgr/resender_test.go: `ethClient.On("IsL2").Return(false).Maybe()`
$DIR/pkg/txmgr/resender_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 2, fromAddress, time.Now().Add(1*time.Hour))`
$DIR/pkg/txmgr/resender_test.go: `ethClient.On("BatchCallContextAll", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_sendRawTransaction" && b[0].Args[0] == hexutil.Encode(etx.TxAttempts[0].SignedRawTx)
		})).Return(nil)`
$DIR/pkg/txmgr/resender_test.go: `ethClient.On("BatchCallContextAll", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_sendRawTransaction" && b[0].Args[0] == hexutil.Encode(etx2.TxAttempts[0].SignedRawTx)
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// It should update BroadcastAt even if there is an error here
			elems[0].Error = pkgerrors.New("kaboom")
		})`
$DIR/pkg/txmgr/resender_test.go: `elems[0].Error = pkgerrors.New("kaboom")`
$DIR/pkg/txmgr/resender_test.go: `func() {
			er.Start(ctx)
			defer er.Stop()

			assert.Eventually(t, func() bool { return ethClient.AssertExpectations(t) },
				testutils.WaitTimeout(t), time.Second)
		}()`
$DIR/pkg/txmgr/resender_test.go: `er.Start(ctx)`
$DIR/pkg/txmgr/resender_test.go: `err = db.Get(&dbEtx2, `SELECT * FROM evm.txes WHERE id = $1`, etx2.ID)`
$DIR/pkg/txmgr/resender_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/resender_test.go: `.Test(t)`
$DIR/pkg/txmgr/resender_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/resender_test.go: `.On("IsL2")`
$DIR/pkg/txmgr/resender_test.go: `.Return(false)`
$DIR/pkg/txmgr/resender_test.go: `.Maybe()`
$DIR/pkg/txmgr/resender_test.go: `.NewTestChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/resender_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/resender_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/resender_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/resender_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/resender_test.go: `.NewChainStore(memKS, big.NewInt(0))`
$DIR/pkg/txmgr/resender_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/resender_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/resender_test.go: `.Unix(1616509100, 0)`
$DIR/pkg/txmgr/resender_test.go: `.EVM()`
$DIR/pkg/txmgr/resender_test.go: `.Transactions()`
$DIR/pkg/txmgr/resender_test.go: `.MaxInFlight()`
$DIR/pkg/txmgr/resender_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, int64(i), fromAddress, originalBroadcastAt)`
$DIR/pkg/txmgr/resender_test.go: `.Encode(etx.TxAttempts[0].SignedRawTx)`
$DIR/pkg/txmgr/resender_test.go: `.MaxInFlight()`
$DIR/pkg/txmgr/resender_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, int64(i), fromAddress2, originalBroadcastAt)`
$DIR/pkg/txmgr/resender_test.go: `.Encode(etx.TxAttempts[0].SignedRawTx)`
$DIR/pkg/txmgr/resender_test.go: `.MaxInFlight()`
$DIR/pkg/txmgr/resender_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, int64(i), fromAddress3, originalBroadcastAt)`
$DIR/pkg/txmgr/resender_test.go: `.Encode(etx.TxAttempts[0].SignedRawTx)`
$DIR/pkg/txmgr/resender_test.go: `.NewEvmResender(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTracker(txStore, ethKeyStore, big.NewInt(0), lggr), ethKeyStore, 100*time.Millisecond, ccfg.EVM(), ccfg.EVM().Transactions())`
$DIR/pkg/txmgr/resender_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/resender_test.go: `.NewEvmTracker(txStore, ethKeyStore, big.NewInt(0), lggr)`
$DIR/pkg/txmgr/resender_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/resender_test.go: `.EVM()`
$DIR/pkg/txmgr/resender_test.go: `.EVM()`
$DIR/pkg/txmgr/resender_test.go: `.Transactions()`
$DIR/pkg/txmgr/resender_test.go: `.On("BatchCallContextAll", mock.Anything, mock.MatchedBy(func(elems []rpc.BatchElem) bool {
		for _, elem := range elems {
			resentHex[elem.Args[0].(string)] = struct{}{}
		}
		assert.Len(t, elems, len(addr1TxesRawHex)+len(addr2TxesRawHex)+int(txConfig.MaxInFlight()))
		// All addr1TxesRawHex should be included
		for _, addr := range addr1TxesRawHex {
			assert.Contains(t, resentHex, addr)
		}
		// All addr2TxesRawHex should be included
		for _, addr := range addr2TxesRawHex {
			assert.Contains(t, resentHex, addr)
		}
		// Up to limit EvmMaxInFlightTransactions addr3TxesRawHex should be included
		for i, addr := range addr3TxesRawHex {
			if i >= int(txConfig.MaxInFlight()) {
				// Above limit EvmMaxInFlightTransactions addr3TxesRawHex should NOT be included
				assert.NotContains(t, resentHex, addr)
			} else {
				assert.Contains(t, resentHex, addr)
			}
		}
		return true
	}))`
$DIR/pkg/txmgr/resender_test.go: `.MatchedBy(func(elems []rpc.BatchElem) bool {
		for _, elem := range elems {
			resentHex[elem.Args[0].(string)] = struct{}{}
		}
		assert.Len(t, elems, len(addr1TxesRawHex)+len(addr2TxesRawHex)+int(txConfig.MaxInFlight()))
		// All addr1TxesRawHex should be included
		for _, addr := range addr1TxesRawHex {
			assert.Contains(t, resentHex, addr)
		}
		// All addr2TxesRawHex should be included
		for _, addr := range addr2TxesRawHex {
			assert.Contains(t, resentHex, addr)
		}
		// Up to limit EvmMaxInFlightTransactions addr3TxesRawHex should be included
		for i, addr := range addr3TxesRawHex {
			if i >= int(txConfig.MaxInFlight()) {
				// Above limit EvmMaxInFlightTransactions addr3TxesRawHex should NOT be included
				assert.NotContains(t, resentHex, addr)
			} else {
				assert.Contains(t, resentHex, addr)
			}
		}
		return true
	})`
$DIR/pkg/txmgr/resender_test.go: `.MaxInFlight()`
$DIR/pkg/txmgr/resender_test.go: `.Run(func(args mock.Arguments) {})`
$DIR/pkg/txmgr/resender_test.go: `.Return(nil)`
$DIR/pkg/txmgr/resender_test.go: `.XXXTestResendUnconfirmed()`
$DIR/pkg/txmgr/resender_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/resender_test.go: `.TestObserved(t, zapcore.DebugLevel)`
$DIR/pkg/txmgr/resender_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/resender_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/resender_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/resender_test.go: `.NewChainStore(memKS, big.NewInt(0))`
$DIR/pkg/txmgr/resender_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/resender_test.go: `.On("IsL2")`
$DIR/pkg/txmgr/resender_test.go: `.Return(false)`
$DIR/pkg/txmgr/resender_test.go: `.Maybe()`
$DIR/pkg/txmgr/resender_test.go: `.MustNewDuration(1 * time.Nanosecond)`
$DIR/pkg/txmgr/resender_test.go: `.NewTestChainScopedConfig(t, func(c *toml.EVMConfig) {
		c.Chain = toml.Defaults(ubig.New(big.NewInt(0)), &toml.Chain{
			Transactions: toml.Transactions{ResendAfterThreshold: delay},
		})
	})`
$DIR/pkg/txmgr/resender_test.go: `.Defaults(ubig.New(big.NewInt(0)), &toml.Chain{
			Transactions: toml.Transactions{ResendAfterThreshold: delay},
		})`
$DIR/pkg/txmgr/resender_test.go: `.New(big.NewInt(0))`
$DIR/pkg/txmgr/resender_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/resender_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/resender_test.go: `.Unix(1616509100, 0)`
$DIR/pkg/txmgr/resender_test.go: `.NewEvmResender(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTracker(txStore, ethKeyStore, big.NewInt(0), lggr), ethKeyStore, 100*time.Millisecond, ccfg.EVM(), ccfg.EVM().Transactions())`
$DIR/pkg/txmgr/resender_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/resender_test.go: `.NewEvmTracker(txStore, ethKeyStore, big.NewInt(0), lggr)`
$DIR/pkg/txmgr/resender_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/resender_test.go: `.EVM()`
$DIR/pkg/txmgr/resender_test.go: `.EVM()`
$DIR/pkg/txmgr/resender_test.go: `.Transactions()`
$DIR/pkg/txmgr/resender_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, int64(1), fromAddress, originalBroadcastAt)`
$DIR/pkg/txmgr/resender_test.go: `.On("BatchCallContextAll", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/resender_test.go: `.Return(nil)`
$DIR/pkg/txmgr/resender_test.go: `.XXXTestResendUnconfirmed()`
$DIR/pkg/txmgr/resender_test.go: `.XXXTestResendUnconfirmed()`
$DIR/pkg/txmgr/resender_test.go: `.AssertLogCountEventually(t, o, "TxAttempt has been unconfirmed for more than max duration", 1)`
$DIR/pkg/txmgr/resender_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/resender_test.go: `.NewTestChainScopedConfig(t, func(c *toml.EVMConfig) {
		// This can be anything as long as it isn't zero
		c.Transactions.ResendAfterThreshold = commonconfig.MustNewDuration(42 * time.Hour)
		// Set batch size low to test batching
		c.RPCDefaultBatchSize = ptr[uint32](1)
	})`
$DIR/pkg/txmgr/resender_test.go: `.MustNewDuration(42 * time.Hour)`
$DIR/pkg/txmgr/resender_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/resender_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/resender_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/resender_test.go: `.NewChainStore(memKS, big.NewInt(0))`
$DIR/pkg/txmgr/resender_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/resender_test.go: `.Test(t)`
$DIR/pkg/txmgr/resender_test.go: `.Context(t)`
$DIR/pkg/txmgr/resender_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/resender_test.go: `.On("IsL2")`
$DIR/pkg/txmgr/resender_test.go: `.Return(false)`
$DIR/pkg/txmgr/resender_test.go: `.Maybe()`
$DIR/pkg/txmgr/resender_test.go: `.NewEvmResender(lggr, txStore, txmgr.NewEvmTxmClient(ethClient, nil), txmgr.NewEvmTracker(txStore, ethKeyStore, big.NewInt(0), lggr), ethKeyStore, 100*time.Millisecond, ccfg.EVM(), ccfg.EVM().Transactions())`
$DIR/pkg/txmgr/resender_test.go: `.NewEvmTxmClient(ethClient, nil)`
$DIR/pkg/txmgr/resender_test.go: `.NewEvmTracker(txStore, ethKeyStore, big.NewInt(0), lggr)`
$DIR/pkg/txmgr/resender_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/resender_test.go: `.EVM()`
$DIR/pkg/txmgr/resender_test.go: `.EVM()`
$DIR/pkg/txmgr/resender_test.go: `.Transactions()`
$DIR/pkg/txmgr/resender_test.go: `.Unix(1616509100, 0)`
$DIR/pkg/txmgr/resender_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress, originalBroadcastAt)`
$DIR/pkg/txmgr/resender_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 1, fromAddress, originalBroadcastAt)`
$DIR/pkg/txmgr/resender_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 2, fromAddress, time.Now().Add(1*time.Hour))`
$DIR/pkg/txmgr/resender_test.go: `.Now()`
$DIR/pkg/txmgr/resender_test.go: `.Add(1*time.Hour)`
$DIR/pkg/txmgr/resender_test.go: `.On("BatchCallContextAll", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_sendRawTransaction" && b[0].Args[0] == hexutil.Encode(etx.TxAttempts[0].SignedRawTx)
		}))`
$DIR/pkg/txmgr/resender_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_sendRawTransaction" && b[0].Args[0] == hexutil.Encode(etx.TxAttempts[0].SignedRawTx)
		})`
$DIR/pkg/txmgr/resender_test.go: `.Encode(etx.TxAttempts[0].SignedRawTx)`
$DIR/pkg/txmgr/resender_test.go: `.Return(nil)`
$DIR/pkg/txmgr/resender_test.go: `.On("BatchCallContextAll", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_sendRawTransaction" && b[0].Args[0] == hexutil.Encode(etx2.TxAttempts[0].SignedRawTx)
		}))`
$DIR/pkg/txmgr/resender_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1 &&
				b[0].Method == "eth_sendRawTransaction" && b[0].Args[0] == hexutil.Encode(etx2.TxAttempts[0].SignedRawTx)
		})`
$DIR/pkg/txmgr/resender_test.go: `.Encode(etx2.TxAttempts[0].SignedRawTx)`
$DIR/pkg/txmgr/resender_test.go: `.Return(nil)`
$DIR/pkg/txmgr/resender_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			// It should update BroadcastAt even if there is an error here
			elems[0].Error = pkgerrors.New("kaboom")
		})`
$DIR/pkg/txmgr/resender_test.go: `.Get(1)`
$DIR/pkg/txmgr/resender_test.go: `.New("kaboom")`
$DIR/pkg/txmgr/resender_test.go: `.Start(ctx)`
$DIR/pkg/txmgr/resender_test.go: `.Stop()`
$DIR/pkg/txmgr/resender_test.go: `.Get(&dbEtx, `SELECT * FROM evm.txes WHERE id = $1`, etx.ID)`
$DIR/pkg/txmgr/resender_test.go: `.Get(&dbEtx2, `SELECT * FROM evm.txes WHERE id = $1`, etx2.ID)`
$DIR/pkg/txmgr/strategies_test.go: `mockTxStore.On("PruneUnstartedTxQueue", mock.Anything, queueSize-1, subject, mock.Anything, mock.Anything).Once().Return([]int64{1, 2}, nil)`
$DIR/pkg/txmgr/strategies_test.go: `.PruneQueue(tests.Context(t), nil)`
$DIR/pkg/txmgr/strategies_test.go: `.Context(t)`
$DIR/pkg/txmgr/strategies_test.go: `.New()`
$DIR/pkg/txmgr/strategies_test.go: `.NewDropOldestStrategy(subject, 1)`
$DIR/pkg/txmgr/strategies_test.go: `.Subject()`
$DIR/pkg/txmgr/strategies_test.go: `.New()`
$DIR/pkg/txmgr/strategies_test.go: `.NewEvmTxStore(t)`
$DIR/pkg/txmgr/strategies_test.go: `.NewDropOldestStrategy(subject, queueSize)`
$DIR/pkg/txmgr/strategies_test.go: `.On("PruneUnstartedTxQueue", mock.Anything, queueSize-1, subject, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/strategies_test.go: `.Once()`
$DIR/pkg/txmgr/strategies_test.go: `.Return([]int64{1, 2}, nil)`
$DIR/pkg/txmgr/strategies_test.go: `.PruneQueue(tests.Context(t), mockTxStore)`
$DIR/pkg/txmgr/strategies_test.go: `.Context(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `feeEstimator.On("GetFee", mock.Anything, []byte{}, uint64(0), mock.Anything, mock.Anything, mock.Anything).Return(fee, uint64(0), nil)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `mustInsertFatalErrorTxWithError(t, txStore, 0, fromAddress, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 1, fromAddress, autoPurgeMinAttempts, blockNum-int64(autoPurgeThreshold), marketGasPrice.Add(oneGwei))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("returns empty list if no unconfimed transactions found", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		stuckTxs, err := stuckTxDetector.FindUnconfirmedTxWithLowestNonce(ctx, []common.Address{fromAddress})
		require.NoError(t, err)
		require.Len(t, stuckTxs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("returns 1 unconfirmed transaction for each unique from address", func(t *testing.T) {
		fromAddress1 := testutils.NewAddress()
		fromAddress2 := testutils.NewAddress()
		// Insert 2 txs for from address, should only return the lowest nonce txs
		txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress1)
		txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 1, fromAddress1)
		// Insert 1 tx for other from address, should return a tx
		txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress2)
		stuckTxs, err := stuckTxDetector.FindUnconfirmedTxWithLowestNonce(ctx, []common.Address{fromAddress1, fromAddress2})
		require.NoError(t, err)

		require.Len(t, stuckTxs, 2)
		var foundFromAddresses []common.Address
		for _, stuckTx := range stuckTxs {
			// Make sure lowest nonce tx is returned for both from addresses
			require.Equal(t, evmtypes.Nonce(0), *stuckTx.Sequence)
			// Make sure attempts are loaded into the tx
			require.Len(t, stuckTx.TxAttempts, 1)
			foundFromAddresses = append(foundFromAddresses, stuckTx.FromAddress)
		}
		require.Contains(t, foundFromAddresses, fromAddress1)
		require.Contains(t, foundFromAddresses, fromAddress2)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress1)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 1, fromAddress1)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress2)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `foundFromAddresses = append(foundFromAddresses, stuckTx.FromAddress)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("excludes transactions already marked for purge", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		mustInsertUnconfirmedEthTxWithBroadcastPurgeAttempt(t, txStore, 0, fromAddress)
		stuckTxs, err := stuckTxDetector.FindUnconfirmedTxWithLowestNonce(ctx, []common.Address{fromAddress})
		require.NoError(t, err)
		require.Len(t, stuckTxs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `mustInsertUnconfirmedEthTxWithBroadcastPurgeAttempt(t, txStore, 0, fromAddress)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("excludes transactions with a in-progress attempt", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		etx := txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress)
		attempt := txmgrtest.NewLegacyEthTxAttempt(t, etx.ID)
		attempt.TxFee.GasPrice = assets.NewWeiI(2)
		attempt.State = txmgrtypes.TxAttemptInProgress
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt))
		stuckTxs, err := stuckTxDetector.FindUnconfirmedTxWithLowestNonce(ctx, []common.Address{fromAddress})
		require.NoError(t, err)
		require.Len(t, stuckTxs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `attempt.TxFee.GasPrice = assets.NewWeiI(2)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `attempt.State = txmgrtypes.TxAttemptInProgress`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `attempt.TxFee.GasPrice = assets.NewWeiI(2)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `attempt.State = txmgrtypes.TxAttemptInsufficientFunds`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `feeEstimator.On("GetFee", mock.Anything, []byte{}, uint64(0), mock.Anything, mock.Anything, mock.Anything).Return(fee, uint64(0), nil)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("not stuck, Threshold amount of blocks have not passed since broadcast", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		enabledAddresses := []common.Address{fromAddress}
		// Create attempts broadcasted at the current broadcast number to test the block num threshold check
		// Create autoPurgeMinAttempts number of attempts to ensure the broadcast attempt count check is not being triggered
		// Create attempts so that the latest has a higher gas price than the market to ensure the gas price check is not being triggered
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum, marketGasPrice.Add(oneGwei))

		// Run detection logic on the same block number as the latest broadcast attempt to stay within the autoPurgeThreshold
		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, enabledAddresses, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum, marketGasPrice.Add(oneGwei))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("not stuck, Threshold amount of blocks have not passed since last purge", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		enabledAddresses := []common.Address{fromAddress}
		// Create attempts broadcasted autoPurgeThreshold block ago to ensure broadcast block num check is not being triggered
		// Create autoPurgeMinAttempts number of attempts to ensure the broadcast attempt count check is not being triggered
		// Create attempts so that the latest has a higher gas price than the market to ensure the gas price check is not being triggered
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum-int64(autoPurgeThreshold), marketGasPrice.Add(oneGwei))

		// Set the last purge block num as the current block num to test rate limiting condition
		stuckTxDetector.SetPurgeBlockNum(fromAddress, blockNum)

		// Run detection logic on autoPurgeThreshold blocks past the latest broadcast attempt
		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, enabledAddresses, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum-int64(autoPurgeThreshold), marketGasPrice.Add(oneGwei))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `stuckTxDetector.SetPurgeBlockNum(fromAddress, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("not stuck, MinAttempts amount of attempts have not been broadcasted", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		enabledAddresses := []common.Address{fromAddress}
		// Create attempts broadcasted autoPurgeThreshold block ago to ensure broadcast block num check is not being triggered
		// Create fewer attempts than autoPurgeMinAttempts to test min attempt check
		// Create attempts so that the latest has a higher gas price than the market to ensure the gas price check is not being triggered
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts-1, blockNum-int64(autoPurgeThreshold), marketGasPrice.Add(oneGwei))

		// Run detection logic on autoPurgeThreshold blocks past the latest broadcast attempt
		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, enabledAddresses, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts-1, blockNum-int64(autoPurgeThreshold), marketGasPrice.Add(oneGwei))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("not stuck, transaction gas price is lower than market gas price", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		enabledAddresses := []common.Address{fromAddress}
		// Create attempts broadcasted autoPurgeThreshold block ago to ensure broadcast block num check is not being triggered
		// Create autoPurgeMinAttempts number of attempts to ensure the broadcast attempt count check is not being triggered
		// Create attempts so that the latest has a lower gas price than the market to test the gas price check
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum-int64(autoPurgeThreshold), marketGasPrice.Sub(oneGwei))

		// Run detection logic on autoPurgeThreshold blocks past the latest broadcast attempt
		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, enabledAddresses, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum-int64(autoPurgeThreshold), marketGasPrice.Sub(oneGwei))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("detects stuck transaction", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		enabledAddresses := []common.Address{fromAddress}
		// Create attempts so that the oldest broadcast attempt's block num is what meets the threshold check
		// Create autoPurgeMinAttempts number of attempts to ensure the broadcast attempt count check is not being triggered
		// Create attempts broadcasted autoPurgeThreshold block ago to ensure broadcast block num check is not being triggered
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum-int64(autoPurgeThreshold)+int64(autoPurgeMinAttempts-1), marketGasPrice.Add(oneGwei))

		// Run detection logic on autoPurgeThreshold blocks past the latest broadcast attempt
		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, enabledAddresses, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 1)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum-int64(autoPurgeThreshold)+int64(autoPurgeMinAttempts-1), marketGasPrice.Add(oneGwei))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `mustInsertUnconfirmedTxWithBroadcastAttemptsContainsEmptyBroadcastBeforeBlockNum(t, txStore, 0, fromAddress, autoPurgeMinAttempts, marketGasPrice.Add(oneGwei))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `feeEstimator.On("GetFee", mock.Anything, []byte{}, uint64(0), mock.Anything, mock.Anything, mock.Anything).Return(fee, uint64(0), nil)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("returns empty list if no fraud or stuck transactions identified", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		tx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, blockNum, tenGwei)
		attempts := tx.TxAttempts[0]
		// Request still returns transaction by hash, transaction not discarded by network and not considered stuck
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: false})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		}).Once()

		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, []common.Address{fromAddress}, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: false})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		}).Once()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `elems[0].Error = json.Unmarshal(resp, elems[0].Result)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("returns fraud transactions identified", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		tx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, blockNum, tenGwei)
		attempts := tx.TxAttempts[0]
		// Request still returns transaction by hash, transaction not discarded by network and not considered stuck
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: true})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		}).Once()

		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, []common.Address{fromAddress}, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 1)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: true})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		}).Once()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `elems[0].Error = json.Unmarshal(resp, elems[0].Result)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("returns the transaction only once if it's identified as both fraud and stuck", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		tx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum-int64(autoPurgeThreshold)+int64(autoPurgeMinAttempts-1), marketGasPrice.Add(oneGwei))
		attempts := tx.TxAttempts[0]

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: true})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		}).Once()

		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, []common.Address{fromAddress}, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 1)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: true})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		}).Once()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `elems[0].Error = json.Unmarshal(resp, elems[0].Result)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})).Return(fmt.Errorf("failed to fetch rpc"))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("returns empty list if no stuck transactions identified", func(t *testing.T) {
		stuckTxDetector := txmgr.NewStuckTxDetector(lggr, testutils.FixtureChainID, chaintype.ChainZkEvm, assets.NewWei(assets.NewEth(100).ToInt()), autoPurgeCfg, feeEstimator, txStore, ethClient)
		fromAddress := testutils.NewAddress()
		tx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, blockNum, tenGwei)
		attempts := tx.TxAttempts[0]
		// Request still returns transaction by hash, transaction not discarded by network and not considered stuck
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "eth_getTransactionByHash")
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(evmtypes.Transaction{})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		}).Once()

		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, []common.Address{fromAddress}, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "eth_getTransactionByHash")
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(evmtypes.Transaction{})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		}).Once()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `elems[0].Error = json.Unmarshal(resp, elems[0].Result)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `t.Run("returns stuck transactions discarded by chain", func(t *testing.T) {
		stuckTxDetector := txmgr.NewStuckTxDetector(lggr, testutils.FixtureChainID, chaintype.ChainZkEvm, assets.NewWei(assets.NewEth(100).ToInt()), autoPurgeCfg, feeEstimator, txStore, ethClient)
		// Insert tx that will be mocked as stuck
		fromAddress1 := testutils.NewAddress()
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress1, 1, blockNum, tenGwei)

		// Insert tx that will still be valid
		fromAddress2 := testutils.NewAddress()
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress2, 1, blockNum, tenGwei)

		// Return nil response for a tx and a normal response for the other
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = nil // Return nil to signal discarded tx
			resp, err := json.Marshal(evmtypes.Transaction{})
			require.NoError(t, err)
			elems[1].Error = json.Unmarshal(resp, elems[1].Result) // Return non-nil result to signal a valid tx
		}).Once()

		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, []common.Address{fromAddress1, fromAddress2}, blockNum)
		require.NoError(t, err)
		// Expect only 1 tx to return as stuck due to nil eth_getTransactionByHash response
		require.Len(t, txs, 1)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress1, 1, blockNum, tenGwei)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress2, 1, blockNum, tenGwei)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = nil // Return nil to signal discarded tx
			resp, err := json.Marshal(evmtypes.Transaction{})
			require.NoError(t, err)
			elems[1].Error = json.Unmarshal(resp, elems[1].Result) // Return non-nil result to signal a valid tx
		}).Once()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `elems[0].Result = nil`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `elems[1].Error = json.Unmarshal(resp, elems[1].Result)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `autoPurgeCfg.minAttempts = ptr(uint32(2))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `attempt.TxFee.GasPrice = assets.NewWeiI(2)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `attempt.State = txmgrtypes.TxAttemptBroadcast`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress2, 1, blockNum, tenGwei)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = nil // Return nil to signal discarded tx
		}).Once()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `elems[0].Result = nil`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Test(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewStuckTxDetector(lggr, testutils.FixtureChainID, "", assets.NewWei(assets.NewEth(100).ToInt()), autoPurgeCfg, feeEstimator, txStore, ethClient)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewWei(assets.NewEth(100).ToInt())`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEth(100)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.ToInt()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(tests.Context(t), []common.Address{fromAddress}, 100)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Context(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Context(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Test(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.GWei(15)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.On("GetFee", mock.Anything, []byte{}, uint64(0), mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Return(fee, uint64(0), nil)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewStuckTxDetector(lggr, testutils.FixtureChainID, "", assets.NewWei(assets.NewEth(100).ToInt()), autoPurgeCfg, feeEstimator, txStore, ethClient)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewWei(assets.NewEth(100).ToInt())`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEth(100)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.ToInt()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.LoadPurgeBlockNumMap(ctx, []common.Address{fromAddress})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Add(oneGwei)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, enabledAddresses, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewChainScopedConfig(t, nil)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Context(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Test(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewStuckTxDetector(lggr, testutils.FixtureChainID, "", assets.NewWei(assets.NewEth(100).ToInt()), config.EVM().Transactions().AutoPurge(), feeEstimator, txStore, ethClient)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewWei(assets.NewEth(100).ToInt())`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEth(100)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.ToInt()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.EVM()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Transactions()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.AutoPurge()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("returns empty list if no unconfimed transactions found", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		stuckTxs, err := stuckTxDetector.FindUnconfirmedTxWithLowestNonce(ctx, []common.Address{fromAddress})
		require.NoError(t, err)
		require.Len(t, stuckTxs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.FindUnconfirmedTxWithLowestNonce(ctx, []common.Address{fromAddress})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("returns 1 unconfirmed transaction for each unique from address", func(t *testing.T) {
		fromAddress1 := testutils.NewAddress()
		fromAddress2 := testutils.NewAddress()
		// Insert 2 txs for from address, should only return the lowest nonce txs
		txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress1)
		txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 1, fromAddress1)
		// Insert 1 tx for other from address, should return a tx
		txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress2)
		stuckTxs, err := stuckTxDetector.FindUnconfirmedTxWithLowestNonce(ctx, []common.Address{fromAddress1, fromAddress2})
		require.NoError(t, err)

		require.Len(t, stuckTxs, 2)
		var foundFromAddresses []common.Address
		for _, stuckTx := range stuckTxs {
			// Make sure lowest nonce tx is returned for both from addresses
			require.Equal(t, evmtypes.Nonce(0), *stuckTx.Sequence)
			// Make sure attempts are loaded into the tx
			require.Len(t, stuckTx.TxAttempts, 1)
			foundFromAddresses = append(foundFromAddresses, stuckTx.FromAddress)
		}
		require.Contains(t, foundFromAddresses, fromAddress1)
		require.Contains(t, foundFromAddresses, fromAddress2)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress1)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 1, fromAddress1)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress2)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.FindUnconfirmedTxWithLowestNonce(ctx, []common.Address{fromAddress1, fromAddress2})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("excludes transactions already marked for purge", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		mustInsertUnconfirmedEthTxWithBroadcastPurgeAttempt(t, txStore, 0, fromAddress)
		stuckTxs, err := stuckTxDetector.FindUnconfirmedTxWithLowestNonce(ctx, []common.Address{fromAddress})
		require.NoError(t, err)
		require.Len(t, stuckTxs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.FindUnconfirmedTxWithLowestNonce(ctx, []common.Address{fromAddress})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("excludes transactions with a in-progress attempt", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		etx := txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress)
		attempt := txmgrtest.NewLegacyEthTxAttempt(t, etx.ID)
		attempt.TxFee.GasPrice = assets.NewWeiI(2)
		attempt.State = txmgrtypes.TxAttemptInProgress
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attempt))
		stuckTxs, err := stuckTxDetector.FindUnconfirmedTxWithLowestNonce(ctx, []common.Address{fromAddress})
		require.NoError(t, err)
		require.Len(t, stuckTxs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewLegacyEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewWeiI(2)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.FindUnconfirmedTxWithLowestNonce(ctx, []common.Address{fromAddress})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 0, fromAddress)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewLegacyEthTxAttempt(t, etx.ID)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewWeiI(2)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.FindUnconfirmedTxWithLowestNonce(ctx, []common.Address{fromAddress})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Context(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Test(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.On("GetFee", mock.Anything, []byte{}, uint64(0), mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Return(fee, uint64(0), nil)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewStuckTxDetector(lggr, testutils.FixtureChainID, "", assets.NewWei(assets.NewEth(100).ToInt()), autoPurgeCfg, feeEstimator, txStore, ethClient)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewWei(assets.NewEth(100).ToInt())`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEth(100)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.ToInt()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("not stuck, Threshold amount of blocks have not passed since broadcast", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		enabledAddresses := []common.Address{fromAddress}
		// Create attempts broadcasted at the current broadcast number to test the block num threshold check
		// Create autoPurgeMinAttempts number of attempts to ensure the broadcast attempt count check is not being triggered
		// Create attempts so that the latest has a higher gas price than the market to ensure the gas price check is not being triggered
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum, marketGasPrice.Add(oneGwei))

		// Run detection logic on the same block number as the latest broadcast attempt to stay within the autoPurgeThreshold
		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, enabledAddresses, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Add(oneGwei)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, enabledAddresses, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("not stuck, Threshold amount of blocks have not passed since last purge", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		enabledAddresses := []common.Address{fromAddress}
		// Create attempts broadcasted autoPurgeThreshold block ago to ensure broadcast block num check is not being triggered
		// Create autoPurgeMinAttempts number of attempts to ensure the broadcast attempt count check is not being triggered
		// Create attempts so that the latest has a higher gas price than the market to ensure the gas price check is not being triggered
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum-int64(autoPurgeThreshold), marketGasPrice.Add(oneGwei))

		// Set the last purge block num as the current block num to test rate limiting condition
		stuckTxDetector.SetPurgeBlockNum(fromAddress, blockNum)

		// Run detection logic on autoPurgeThreshold blocks past the latest broadcast attempt
		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, enabledAddresses, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Add(oneGwei)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.SetPurgeBlockNum(fromAddress, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, enabledAddresses, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("not stuck, MinAttempts amount of attempts have not been broadcasted", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		enabledAddresses := []common.Address{fromAddress}
		// Create attempts broadcasted autoPurgeThreshold block ago to ensure broadcast block num check is not being triggered
		// Create fewer attempts than autoPurgeMinAttempts to test min attempt check
		// Create attempts so that the latest has a higher gas price than the market to ensure the gas price check is not being triggered
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts-1, blockNum-int64(autoPurgeThreshold), marketGasPrice.Add(oneGwei))

		// Run detection logic on autoPurgeThreshold blocks past the latest broadcast attempt
		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, enabledAddresses, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Add(oneGwei)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, enabledAddresses, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("not stuck, transaction gas price is lower than market gas price", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		enabledAddresses := []common.Address{fromAddress}
		// Create attempts broadcasted autoPurgeThreshold block ago to ensure broadcast block num check is not being triggered
		// Create autoPurgeMinAttempts number of attempts to ensure the broadcast attempt count check is not being triggered
		// Create attempts so that the latest has a lower gas price than the market to test the gas price check
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum-int64(autoPurgeThreshold), marketGasPrice.Sub(oneGwei))

		// Run detection logic on autoPurgeThreshold blocks past the latest broadcast attempt
		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, enabledAddresses, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Sub(oneGwei)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, enabledAddresses, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("detects stuck transaction", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		enabledAddresses := []common.Address{fromAddress}
		// Create attempts so that the oldest broadcast attempt's block num is what meets the threshold check
		// Create autoPurgeMinAttempts number of attempts to ensure the broadcast attempt count check is not being triggered
		// Create attempts broadcasted autoPurgeThreshold block ago to ensure broadcast block num check is not being triggered
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum-int64(autoPurgeThreshold)+int64(autoPurgeMinAttempts-1), marketGasPrice.Add(oneGwei))

		// Run detection logic on autoPurgeThreshold blocks past the latest broadcast attempt
		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, enabledAddresses, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 1)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Add(oneGwei)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, enabledAddresses, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Add(oneGwei)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, enabledAddresses, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Context(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Test(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.On("GetFee", mock.Anything, []byte{}, uint64(0), mock.Anything, mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Return(fee, uint64(0), nil)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewStuckTxDetector(lggr, testutils.FixtureChainID, chaintype.ChainZircuit, assets.NewWei(assets.NewEth(100).ToInt()), autoPurgeCfg, feeEstimator, txStore, ethClient)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewWei(assets.NewEth(100).ToInt())`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEth(100)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.ToInt()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("returns empty list if no fraud or stuck transactions identified", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		tx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, blockNum, tenGwei)
		attempts := tx.TxAttempts[0]
		// Request still returns transaction by hash, transaction not discarded by network and not considered stuck
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: false})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		}).Once()

		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, []common.Address{fromAddress}, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		}))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Return(nil)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: false})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Get(1)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: false})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Unmarshal(resp, elems[0].Result)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Once()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, []common.Address{fromAddress}, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("returns fraud transactions identified", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		tx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, blockNum, tenGwei)
		attempts := tx.TxAttempts[0]
		// Request still returns transaction by hash, transaction not discarded by network and not considered stuck
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: true})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		}).Once()

		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, []common.Address{fromAddress}, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 1)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		}))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Return(nil)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: true})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Get(1)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: true})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Unmarshal(resp, elems[0].Result)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Once()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, []common.Address{fromAddress}, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("returns the transaction only once if it's identified as both fraud and stuck", func(t *testing.T) {
		fromAddress := testutils.NewAddress()
		tx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, autoPurgeMinAttempts, blockNum-int64(autoPurgeThreshold)+int64(autoPurgeMinAttempts-1), marketGasPrice.Add(oneGwei))
		attempts := tx.TxAttempts[0]

		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: true})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		}).Once()

		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, []common.Address{fromAddress}, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 1)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Add(oneGwei)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		}))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Return(nil)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: true})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Get(1)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Marshal(struct {
				IsQuarantined bool `json:"isQuarantined"`
			}{IsQuarantined: true})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Unmarshal(resp, elems[0].Result)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Once()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, []common.Address{fromAddress}, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Add(oneGwei)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		}))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "zirc_isQuarantined")
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Return(fmt.Errorf("failed to fetch rpc"))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, []common.Address{fromAddress}, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Context(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Test(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("returns empty list if no stuck transactions identified", func(t *testing.T) {
		stuckTxDetector := txmgr.NewStuckTxDetector(lggr, testutils.FixtureChainID, chaintype.ChainZkEvm, assets.NewWei(assets.NewEth(100).ToInt()), autoPurgeCfg, feeEstimator, txStore, ethClient)
		fromAddress := testutils.NewAddress()
		tx := mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress, 1, blockNum, tenGwei)
		attempts := tx.TxAttempts[0]
		// Request still returns transaction by hash, transaction not discarded by network and not considered stuck
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "eth_getTransactionByHash")
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(evmtypes.Transaction{})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		}).Once()

		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, []common.Address{fromAddress}, blockNum)
		require.NoError(t, err)
		require.Len(t, txs, 0)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewStuckTxDetector(lggr, testutils.FixtureChainID, chaintype.ChainZkEvm, assets.NewWei(assets.NewEth(100).ToInt()), autoPurgeCfg, feeEstimator, txStore, ethClient)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewWei(assets.NewEth(100).ToInt())`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEth(100)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.ToInt()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "eth_getTransactionByHash")
		}))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return matchBatchElemParams(b, attempts.Hash, "eth_getTransactionByHash")
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Return(nil)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			resp, err := json.Marshal(evmtypes.Transaction{})
			require.NoError(t, err)
			elems[0].Error = json.Unmarshal(resp, elems[0].Result)
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Get(1)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Marshal(evmtypes.Transaction{})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Unmarshal(resp, elems[0].Result)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Once()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, []common.Address{fromAddress}, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run("returns stuck transactions discarded by chain", func(t *testing.T) {
		stuckTxDetector := txmgr.NewStuckTxDetector(lggr, testutils.FixtureChainID, chaintype.ChainZkEvm, assets.NewWei(assets.NewEth(100).ToInt()), autoPurgeCfg, feeEstimator, txStore, ethClient)
		// Insert tx that will be mocked as stuck
		fromAddress1 := testutils.NewAddress()
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress1, 1, blockNum, tenGwei)

		// Insert tx that will still be valid
		fromAddress2 := testutils.NewAddress()
		mustInsertUnconfirmedTxWithBroadcastAttempts(t, txStore, 0, fromAddress2, 1, blockNum, tenGwei)

		// Return nil response for a tx and a normal response for the other
		ethClient.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2
		})).Return(nil).Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = nil // Return nil to signal discarded tx
			resp, err := json.Marshal(evmtypes.Transaction{})
			require.NoError(t, err)
			elems[1].Error = json.Unmarshal(resp, elems[1].Result) // Return non-nil result to signal a valid tx
		}).Once()

		txs, err := stuckTxDetector.DetectStuckTransactions(ctx, []common.Address{fromAddress1, fromAddress2}, blockNum)
		require.NoError(t, err)
		// Expect only 1 tx to return as stuck due to nil eth_getTransactionByHash response
		require.Len(t, txs, 1)
	})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewStuckTxDetector(lggr, testutils.FixtureChainID, chaintype.ChainZkEvm, assets.NewWei(assets.NewEth(100).ToInt()), autoPurgeCfg, feeEstimator, txStore, ethClient)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewWei(assets.NewEth(100).ToInt())`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEth(100)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.ToInt()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2
		}))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Return(nil)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = nil // Return nil to signal discarded tx
			resp, err := json.Marshal(evmtypes.Transaction{})
			require.NoError(t, err)
			elems[1].Error = json.Unmarshal(resp, elems[1].Result) // Return non-nil result to signal a valid tx
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Get(1)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Marshal(evmtypes.Transaction{})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Unmarshal(resp, elems[1].Result)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Once()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, []common.Address{fromAddress1, fromAddress2}, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewStuckTxDetector(lggr, testutils.FixtureChainID, chaintype.ChainZkEvm, assets.NewWei(assets.NewEth(100).ToInt()), autoPurgeCfg, feeEstimator, txStore, ethClient)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewWei(assets.NewEth(100).ToInt())`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEth(100)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.ToInt()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewLegacyEthTxAttempt(t, etx1.ID)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewWeiI(2)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1
		}))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 1
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Return(nil)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Run(func(args mock.Arguments) {
			elems := args.Get(1).([]rpc.BatchElem)
			elems[0].Result = nil // Return nil to signal discarded tx
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Get(1)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Once()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, []common.Address{fromAddress1, fromAddress2}, blockNum)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Context(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Test(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewAddress()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
			_, err := res.Write([]byte(fmt.Sprintf(`{"errcode": 0,"errmsg": "","data": {"%s": 1, "%s": 0}}`, attempts1.Hash, attempts2.Hash)))
			require.NoError(t, err)
		}))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
			_, err := res.Write([]byte(fmt.Sprintf(`{"errcode": 0,"errmsg": "","data": {"%s": 1, "%s": 0}}`, attempts1.Hash, attempts2.Hash)))
			require.NoError(t, err)
		})`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Write([]byte(fmt.Sprintf(`{"errcode": 0,"errmsg": "","data": {"%s": 1, "%s": 0}}`, attempts1.Hash, attempts2.Hash)))`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Sprintf(`{"errcode": 0,"errmsg": "","data": {"%s": 1, "%s": 0}}`, attempts1.Hash, attempts2.Hash)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.Parse(testServer.URL)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewStuckTxDetector(lggr, testutils.FixtureChainID, chaintype.ChainScroll, assets.NewWei(assets.NewEth(100).ToInt()), autoPurgeCfg, feeEstimator, txStore, ethClient)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewWei(assets.NewEth(100).ToInt())`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.NewEth(100)`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.ToInt()`
$DIR/pkg/txmgr/stuck_tx_detector_test.go: `.DetectStuckTransactions(ctx, []common.Address{fromAddress1, fromAddress2}, blockNum)`
$DIR/pkg/txmgr/tracker_test.go: `_ = mustInsertInProgressEthTxWithAttempt(t, txStore, 123, inProgressAddr)`
$DIR/pkg/txmgr/tracker_test.go: `_ = txmgrtest.MustInsertUnconfirmedEthTx(t, txStore, 123, unconfirmedAddr)`
$DIR/pkg/txmgr/tracker_test.go: `_ = mustInsertConfirmedEthTxWithReceipt(t, txStore, confirmedAddr, 123, 1)`
$DIR/pkg/txmgr/tracker_test.go: `_ = mustCreateUnstartedTx(t, txStore, unstartedAddr, testutils.NewAddress(), []byte{}, 0, big.Int{}, ethClient.ConfiguredChainID())`
$DIR/pkg/txmgr/tracker_test.go: `servicetest.Run(t, tracker)`
$DIR/pkg/txmgr/tracker_test.go: `tracker.XXXTestSetTTL(time.Nanosecond)`
$DIR/pkg/txmgr/tracker_test.go: `servicetest.Run(t, tracker)`
$DIR/pkg/txmgr/tracker_test.go: `.Context(t)`
$DIR/pkg/txmgr/tracker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/tracker_test.go: `.NewAddress()`
$DIR/pkg/txmgr/tracker_test.go: `.NewAddress()`
$DIR/pkg/txmgr/tracker_test.go: `.NewAddress()`
$DIR/pkg/txmgr/tracker_test.go: `.NewAddress()`
$DIR/pkg/txmgr/tracker_test.go: `.MustInsertUnconfirmedEthTx(t, txStore, 123, unconfirmedAddr)`
$DIR/pkg/txmgr/tracker_test.go: `.NewAddress()`
$DIR/pkg/txmgr/tracker_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/tracker_test.go: `.Run(t, tracker)`
$DIR/pkg/txmgr/tracker_test.go: `.Context(t)`
$DIR/pkg/txmgr/tracker_test.go: `.NewAddress()`
$DIR/pkg/txmgr/tracker_test.go: `.NewAddress()`
$DIR/pkg/txmgr/tracker_test.go: `.MustInsertUnconfirmedEthTx(t, txStore, 123, addr2)`
$DIR/pkg/txmgr/tracker_test.go: `.XXXTestSetTTL(time.Nanosecond)`
$DIR/pkg/txmgr/tracker_test.go: `.Run(t, tracker)`
$DIR/pkg/txmgr/tracker_test.go: `.GetFatalTransactions(ctx)`
$DIR/pkg/txmgr/tracker_test.go: `.WaitTimeout(t)`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("no checker", func(t *testing.T) {
		c, err := factory.BuildChecker(txmgr.TransmitCheckerSpec{})
		require.NoError(t, err)
		require.Equal(t, txmgr.NoChecker, c)
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("vrf v1 checker", func(t *testing.T) {
		c, err := factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV1,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
		})
		require.NoError(t, err)
		require.IsType(t, &txmgr.VRFV1Checker{}, c)
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("vrf v2 checker", func(t *testing.T) {
		c, err := factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
			VRFRequestBlockNumber: big.NewInt(1),
		})
		require.NoError(t, err)
		require.IsType(t, &txmgr.VRFV2Checker{}, c)

		// request block number not provided should error out.
		c, err = factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
		})
		require.Error(t, err)
		require.Nil(t, c)
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `c, err = factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("vrf v2 plus checker", func(t *testing.T) {
		c, err := factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2Plus,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
			VRFRequestBlockNumber: big.NewInt(1),
		})
		require.NoError(t, err)
		require.IsType(t, &txmgr.VRFV2Checker{}, c)

		// request block number not provided should error out.
		c, err = factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2Plus,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
		})
		require.Error(t, err)
		require.Nil(t, c)
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `c, err = factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2Plus,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("simulate checker", func(t *testing.T) {
		c, err := factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType: txmgr.TransmitCheckerTypeSimulate,
		})
		require.NoError(t, err)
		require.Equal(t, &txmgr.SimulateChecker{Client: client}, c)
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("no checker", func(t *testing.T) {
		checker := txmgr.NoChecker
		require.NoError(t, checker.Check(ctx, log, txmgr.Tx{}, txmgr.TxAttempt{}))
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("simulate", func(t *testing.T) {
		checker := txmgr.SimulateChecker{Client: client}

		tx := txmgr.Tx{
			FromAddress:    common.HexToAddress("0xfe0629509E6CB8dfa7a99214ae58Ceb465d5b5A9"),
			ToAddress:      common.HexToAddress("0xff0Aac13eab788cb9a2D662D3FB661Aa5f58FA21"),
			EncodedPayload: []byte{42, 0, 0},
			Value:          big.Int(assets.NewEthValue(642)),
			FeeLimit:       1e9,
			CreatedAt:      time.Unix(0, 0),
			State:          txmgrcommon.TxUnstarted,
		}
		attempt := txmgr.TxAttempt{
			Tx:        tx,
			Hash:      common.Hash{},
			CreatedAt: tx.CreatedAt,
			State:     txmgrtypes.TxAttemptInProgress,
		}

		t.Run("success", func(t *testing.T) {
			client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(nil).Once()

			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})

		t.Run("revert", func(t *testing.T) {
			jerr := evmclient.JsonError{
				Code:    42,
				Message: "oh no, it reverted",
				Data:    []byte{42, 166, 34},
			}
			client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(&jerr).Once()

			err := checker.Check(ctx, log, tx, attempt)
			expErrMsg := "transaction reverted during simulation: json-rpc error { Code = 42, Message = 'oh no, it reverted', Data = 'KqYi' }"
			require.EqualError(t, err, expErrMsg)
		})

		t.Run("non revert error", func(t *testing.T) {
			client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(pkgerrors.New("error")).Once()

			// Non-revert errors are logged but should not prevent transmission, and do not need
			// to be passed to the caller
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("success", func(t *testing.T) {
			client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(nil).Once()

			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(nil).Once()`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("revert", func(t *testing.T) {
			jerr := evmclient.JsonError{
				Code:    42,
				Message: "oh no, it reverted",
				Data:    []byte{42, 166, 34},
			}
			client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(&jerr).Once()

			err := checker.Check(ctx, log, tx, attempt)
			expErrMsg := "transaction reverted during simulation: json-rpc error { Code = 42, Message = 'oh no, it reverted', Data = 'KqYi' }"
			require.EqualError(t, err, expErrMsg)
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(&jerr).Once()`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("non revert error", func(t *testing.T) {
			client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(pkgerrors.New("error")).Once()

			// Non-revert errors are logged but should not prevent transmission, and do not need
			// to be passed to the caller
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(pkgerrors.New("error")).Once()`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("VRF V1", func(t *testing.T) {
		testDefaultSubID := uint64(2)
		testDefaultMaxLink := "1000000000000000000"

		txRequest := func(t *testing.T, vrfReqID [32]byte, nilTxHash bool) (txmgr.Tx, txmgr.TxAttempt) {
			h := common.BytesToHash(vrfReqID[:])
			txHash := common.Hash{}
			meta := txmgr.TxMeta{
				RequestID:     &h,
				MaxLink:       &testDefaultMaxLink, // 1 LINK
				SubID:         &testDefaultSubID,
				RequestTxHash: &txHash,
			}

			if nilTxHash {
				meta.RequestTxHash = nil
			}

			b, err := json.Marshal(meta)
			require.NoError(t, err)
			metaJson := sqlutil.JSON(b)

			tx := txmgr.Tx{
				FromAddress:    common.HexToAddress("0xfe0629509E6CB8dfa7a99214ae58Ceb465d5b5A9"),
				ToAddress:      common.HexToAddress("0xff0Aac13eab788cb9a2D662D3FB661Aa5f58FA21"),
				EncodedPayload: []byte{42, 0, 0},
				Value:          big.Int(assets.NewEthValue(642)),
				FeeLimit:       1e9,
				CreatedAt:      time.Unix(0, 0),
				State:          txmgrcommon.TxUnstarted,
				Meta:           &metaJson,
			}
			return tx, txmgr.TxAttempt{
				Tx:        tx,
				Hash:      common.Hash{},
				CreatedAt: tx.CreatedAt,
				State:     txmgrtypes.TxAttemptInProgress,
			}
		}

		r1 := [32]byte{1}
		r2 := [32]byte{2}
		r3 := [32]byte{3}

		checker := txmgr.VRFV1Checker{
			Callbacks: func(opts *bind.CallOpts, reqID [32]byte) (v1.Callbacks, error) {
				if opts.BlockNumber.Cmp(big.NewInt(6)) != 0 {
					// Ensure correct logic is applied to get callbacks.
					return v1.Callbacks{}, pkgerrors.New("error getting callback")
				}
				if reqID == r1 {
					// Request 1 is already fulfilled
					return v1.Callbacks{
						SeedAndBlockNum: [32]byte{},
					}, nil
				} else if reqID == r2 {
					// Request 2 errors
					return v1.Callbacks{}, pkgerrors.New("error getting commitment")
				}
				return v1.Callbacks{
					SeedAndBlockNum: [32]byte{1},
				}, nil
			},
			Client: client,
		}

		mockBatch := client.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 && b[0].Method == "eth_getBlockByNumber" && b[1].Method == "eth_getTransactionReceipt"
		})).Return(nil).Run(func(args mock.Arguments) {
			batch := args.Get(1).([]rpc.BatchElem)

			// Return block 10 for eth_getBlockByNumber
			mostRecentHead := batch[0].Result.(*evmtypes.Head)
			mostRecentHead.Number = 10

			// Return block 6 for eth_getTransactionReceipt
			requestTransactionReceipt := batch[1].Result.(*types.Receipt)
			requestTransactionReceipt.BlockNumber = big.NewInt(6)
		})

		t.Run("already fulfilled", func(t *testing.T) {
			tx, attempt := txRequest(t, r1, false)
			err := checker.Check(ctx, log, tx, attempt)
			require.Error(t, err, "request already fulfilled")
		})

		t.Run("nil RequestTxHash", func(t *testing.T) {
			tx, attempt := txRequest(t, r1, true)
			err := checker.Check(ctx, log, tx, attempt)
			require.NoError(t, err)
		})

		t.Run("not fulfilled", func(t *testing.T) {
			tx, attempt := txRequest(t, r3, false)
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})

		t.Run("error checking fulfillment, should transmit", func(t *testing.T) {
			tx, attempt := txRequest(t, r2, false)
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})

		t.Run("failure fetching tx receipt and block head", func(t *testing.T) {
			tx, attempt := txRequest(t, r1, false)
			mockBatch.Return(pkgerrors.New("could not fetch"))
			err := checker.Check(ctx, log, tx, attempt)
			require.NoError(t, err)
		})
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `meta.RequestTxHash = nil`
$DIR/pkg/txmgr/transmitchecker_test.go: `mostRecentHead.Number = 10`
$DIR/pkg/txmgr/transmitchecker_test.go: `requestTransactionReceipt.BlockNumber = big.NewInt(6)`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("already fulfilled", func(t *testing.T) {
			tx, attempt := txRequest(t, r1, false)
			err := checker.Check(ctx, log, tx, attempt)
			require.Error(t, err, "request already fulfilled")
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("nil RequestTxHash", func(t *testing.T) {
			tx, attempt := txRequest(t, r1, true)
			err := checker.Check(ctx, log, tx, attempt)
			require.NoError(t, err)
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("not fulfilled", func(t *testing.T) {
			tx, attempt := txRequest(t, r3, false)
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("error checking fulfillment, should transmit", func(t *testing.T) {
			tx, attempt := txRequest(t, r2, false)
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("failure fetching tx receipt and block head", func(t *testing.T) {
			tx, attempt := txRequest(t, r1, false)
			mockBatch.Return(pkgerrors.New("could not fetch"))
			err := checker.Check(ctx, log, tx, attempt)
			require.NoError(t, err)
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `mockBatch.Return(pkgerrors.New("could not fetch"))`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("already fulfilled", func(t *testing.T) {
			tx, attempt := txRequest(t, big.NewInt(1))
			err := checker.Check(ctx, log, tx, attempt)
			require.Error(t, err, "request already fulfilled")
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("not fulfilled", func(t *testing.T) {
			tx, attempt := txRequest(t, big.NewInt(3))
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("error checking fulfillment, should transmit", func(t *testing.T) {
			tx, attempt := txRequest(t, big.NewInt(2))
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("can't get header", func(t *testing.T) {
			checker.HeadByNumber = func(ctx context.Context, n *big.Int) (*evmtypes.Head, error) {
				return nil, pkgerrors.New("can't get head")
			}
			tx, attempt := txRequest(t, big.NewInt(3))
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `t.Run("nil request block number", func(t *testing.T) {
			checker.HeadByNumber = func(ctx context.Context, n *big.Int) (*evmtypes.Head, error) {
				return &evmtypes.Head{
					Number: 1,
				}, nil
			}
			checker.RequestBlockNumber = nil
			tx, attempt := txRequest(t, big.NewInt(4))
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `checker.RequestBlockNumber = nil`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("no checker", func(t *testing.T) {
		c, err := factory.BuildChecker(txmgr.TransmitCheckerSpec{})
		require.NoError(t, err)
		require.Equal(t, txmgr.NoChecker, c)
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.BuildChecker(txmgr.TransmitCheckerSpec{})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("vrf v1 checker", func(t *testing.T) {
		c, err := factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV1,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
		})
		require.NoError(t, err)
		require.IsType(t, &txmgr.VRFV1Checker{}, c)
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV1,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewAddressPtr()`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("vrf v2 checker", func(t *testing.T) {
		c, err := factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
			VRFRequestBlockNumber: big.NewInt(1),
		})
		require.NoError(t, err)
		require.IsType(t, &txmgr.VRFV2Checker{}, c)

		// request block number not provided should error out.
		c, err = factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
		})
		require.Error(t, err)
		require.Nil(t, c)
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
			VRFRequestBlockNumber: big.NewInt(1),
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewAddressPtr()`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewAddressPtr()`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("vrf v2 plus checker", func(t *testing.T) {
		c, err := factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2Plus,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
			VRFRequestBlockNumber: big.NewInt(1),
		})
		require.NoError(t, err)
		require.IsType(t, &txmgr.VRFV2Checker{}, c)

		// request block number not provided should error out.
		c, err = factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2Plus,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
		})
		require.Error(t, err)
		require.Nil(t, c)
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2Plus,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
			VRFRequestBlockNumber: big.NewInt(1),
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewAddressPtr()`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2Plus,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewAddressPtr()`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("simulate checker", func(t *testing.T) {
		c, err := factory.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType: txmgr.TransmitCheckerTypeSimulate,
		})
		require.NoError(t, err)
		require.Equal(t, &txmgr.SimulateChecker{Client: client}, c)
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType: txmgr.TransmitCheckerTypeSimulate,
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.BuildChecker(txmgr.TransmitCheckerSpec{
			CheckerType: "invalid",
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Sugared(logger.Test(t))`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Test(t)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Context(t)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("no checker", func(t *testing.T) {
		checker := txmgr.NoChecker
		require.NoError(t, checker.Check(ctx, log, txmgr.Tx{}, txmgr.TxAttempt{}))
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("simulate", func(t *testing.T) {
		checker := txmgr.SimulateChecker{Client: client}

		tx := txmgr.Tx{
			FromAddress:    common.HexToAddress("0xfe0629509E6CB8dfa7a99214ae58Ceb465d5b5A9"),
			ToAddress:      common.HexToAddress("0xff0Aac13eab788cb9a2D662D3FB661Aa5f58FA21"),
			EncodedPayload: []byte{42, 0, 0},
			Value:          big.Int(assets.NewEthValue(642)),
			FeeLimit:       1e9,
			CreatedAt:      time.Unix(0, 0),
			State:          txmgrcommon.TxUnstarted,
		}
		attempt := txmgr.TxAttempt{
			Tx:        tx,
			Hash:      common.Hash{},
			CreatedAt: tx.CreatedAt,
			State:     txmgrtypes.TxAttemptInProgress,
		}

		t.Run("success", func(t *testing.T) {
			client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(nil).Once()

			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})

		t.Run("revert", func(t *testing.T) {
			jerr := evmclient.JsonError{
				Code:    42,
				Message: "oh no, it reverted",
				Data:    []byte{42, 166, 34},
			}
			client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(&jerr).Once()

			err := checker.Check(ctx, log, tx, attempt)
			expErrMsg := "transaction reverted during simulation: json-rpc error { Code = 42, Message = 'oh no, it reverted', Data = 'KqYi' }"
			require.EqualError(t, err, expErrMsg)
		})

		t.Run("non revert error", func(t *testing.T) {
			client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(pkgerrors.New("error")).Once()

			// Non-revert errors are logged but should not prevent transmission, and do not need
			// to be passed to the caller
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.HexToAddress("0xfe0629509E6CB8dfa7a99214ae58Ceb465d5b5A9")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.HexToAddress("0xff0Aac13eab788cb9a2D662D3FB661Aa5f58FA21")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Int(assets.NewEthValue(642))`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewEthValue(642)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Unix(0, 0)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("success", func(t *testing.T) {
			client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(nil).Once()

			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.AnythingOfType("*hexutil.Bytes")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Sprintf("%s", callarg["value"])`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Return(nil)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Once()`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("revert", func(t *testing.T) {
			jerr := evmclient.JsonError{
				Code:    42,
				Message: "oh no, it reverted",
				Data:    []byte{42, 166, 34},
			}
			client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(&jerr).Once()

			err := checker.Check(ctx, log, tx, attempt)
			expErrMsg := "transaction reverted during simulation: json-rpc error { Code = 42, Message = 'oh no, it reverted', Data = 'KqYi' }"
			require.EqualError(t, err, expErrMsg)
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.AnythingOfType("*hexutil.Bytes")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Sprintf("%s", callarg["value"])`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Return(&jerr)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Once()`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Check(ctx, log, tx, attempt)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("non revert error", func(t *testing.T) {
			client.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest").Return(pkgerrors.New("error")).Once()

			// Non-revert errors are logged but should not prevent transmission, and do not need
			// to be passed to the caller
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.On("CallContext", mock.Anything,
				mock.AnythingOfType("*hexutil.Bytes"), "eth_call",
				mock.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				}), "latest")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.AnythingOfType("*hexutil.Bytes")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.MatchedBy(func(callarg map[string]interface{}) bool {
					return fmt.Sprintf("%s", callarg["value"]) == "0x282" // 642
				})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Sprintf("%s", callarg["value"])`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Return(pkgerrors.New("error"))`
$DIR/pkg/txmgr/transmitchecker_test.go: `.New("error")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Once()`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("VRF V1", func(t *testing.T) {
		testDefaultSubID := uint64(2)
		testDefaultMaxLink := "1000000000000000000"

		txRequest := func(t *testing.T, vrfReqID [32]byte, nilTxHash bool) (txmgr.Tx, txmgr.TxAttempt) {
			h := common.BytesToHash(vrfReqID[:])
			txHash := common.Hash{}
			meta := txmgr.TxMeta{
				RequestID:     &h,
				MaxLink:       &testDefaultMaxLink, // 1 LINK
				SubID:         &testDefaultSubID,
				RequestTxHash: &txHash,
			}

			if nilTxHash {
				meta.RequestTxHash = nil
			}

			b, err := json.Marshal(meta)
			require.NoError(t, err)
			metaJson := sqlutil.JSON(b)

			tx := txmgr.Tx{
				FromAddress:    common.HexToAddress("0xfe0629509E6CB8dfa7a99214ae58Ceb465d5b5A9"),
				ToAddress:      common.HexToAddress("0xff0Aac13eab788cb9a2D662D3FB661Aa5f58FA21"),
				EncodedPayload: []byte{42, 0, 0},
				Value:          big.Int(assets.NewEthValue(642)),
				FeeLimit:       1e9,
				CreatedAt:      time.Unix(0, 0),
				State:          txmgrcommon.TxUnstarted,
				Meta:           &metaJson,
			}
			return tx, txmgr.TxAttempt{
				Tx:        tx,
				Hash:      common.Hash{},
				CreatedAt: tx.CreatedAt,
				State:     txmgrtypes.TxAttemptInProgress,
			}
		}

		r1 := [32]byte{1}
		r2 := [32]byte{2}
		r3 := [32]byte{3}

		checker := txmgr.VRFV1Checker{
			Callbacks: func(opts *bind.CallOpts, reqID [32]byte) (v1.Callbacks, error) {
				if opts.BlockNumber.Cmp(big.NewInt(6)) != 0 {
					// Ensure correct logic is applied to get callbacks.
					return v1.Callbacks{}, pkgerrors.New("error getting callback")
				}
				if reqID == r1 {
					// Request 1 is already fulfilled
					return v1.Callbacks{
						SeedAndBlockNum: [32]byte{},
					}, nil
				} else if reqID == r2 {
					// Request 2 errors
					return v1.Callbacks{}, pkgerrors.New("error getting commitment")
				}
				return v1.Callbacks{
					SeedAndBlockNum: [32]byte{1},
				}, nil
			},
			Client: client,
		}

		mockBatch := client.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 && b[0].Method == "eth_getBlockByNumber" && b[1].Method == "eth_getTransactionReceipt"
		})).Return(nil).Run(func(args mock.Arguments) {
			batch := args.Get(1).([]rpc.BatchElem)

			// Return block 10 for eth_getBlockByNumber
			mostRecentHead := batch[0].Result.(*evmtypes.Head)
			mostRecentHead.Number = 10

			// Return block 6 for eth_getTransactionReceipt
			requestTransactionReceipt := batch[1].Result.(*types.Receipt)
			requestTransactionReceipt.BlockNumber = big.NewInt(6)
		})

		t.Run("already fulfilled", func(t *testing.T) {
			tx, attempt := txRequest(t, r1, false)
			err := checker.Check(ctx, log, tx, attempt)
			require.Error(t, err, "request already fulfilled")
		})

		t.Run("nil RequestTxHash", func(t *testing.T) {
			tx, attempt := txRequest(t, r1, true)
			err := checker.Check(ctx, log, tx, attempt)
			require.NoError(t, err)
		})

		t.Run("not fulfilled", func(t *testing.T) {
			tx, attempt := txRequest(t, r3, false)
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})

		t.Run("error checking fulfillment, should transmit", func(t *testing.T) {
			tx, attempt := txRequest(t, r2, false)
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})

		t.Run("failure fetching tx receipt and block head", func(t *testing.T) {
			tx, attempt := txRequest(t, r1, false)
			mockBatch.Return(pkgerrors.New("could not fetch"))
			err := checker.Check(ctx, log, tx, attempt)
			require.NoError(t, err)
		})
	})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.BytesToHash(vrfReqID[:])`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Marshal(meta)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.JSON(b)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.HexToAddress("0xfe0629509E6CB8dfa7a99214ae58Ceb465d5b5A9")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.HexToAddress("0xff0Aac13eab788cb9a2D662D3FB661Aa5f58FA21")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Int(assets.NewEthValue(642))`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewEthValue(642)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Unix(0, 0)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.BlockNumber.Cmp(big.NewInt(6))`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewInt(6)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.New("error getting callback")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.New("error getting commitment")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.On("BatchCallContext", mock.Anything, mock.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 && b[0].Method == "eth_getBlockByNumber" && b[1].Method == "eth_getTransactionReceipt"
		}))`
$DIR/pkg/txmgr/transmitchecker_test.go: `.MatchedBy(func(b []rpc.BatchElem) bool {
			return len(b) == 2 && b[0].Method == "eth_getBlockByNumber" && b[1].Method == "eth_getTransactionReceipt"
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Return(nil)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run(func(args mock.Arguments) {
			batch := args.Get(1).([]rpc.BatchElem)

			// Return block 10 for eth_getBlockByNumber
			mostRecentHead := batch[0].Result.(*evmtypes.Head)
			mostRecentHead.Number = 10

			// Return block 6 for eth_getTransactionReceipt
			requestTransactionReceipt := batch[1].Result.(*types.Receipt)
			requestTransactionReceipt.BlockNumber = big.NewInt(6)
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Get(1)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewInt(6)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("already fulfilled", func(t *testing.T) {
			tx, attempt := txRequest(t, r1, false)
			err := checker.Check(ctx, log, tx, attempt)
			require.Error(t, err, "request already fulfilled")
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Check(ctx, log, tx, attempt)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("nil RequestTxHash", func(t *testing.T) {
			tx, attempt := txRequest(t, r1, true)
			err := checker.Check(ctx, log, tx, attempt)
			require.NoError(t, err)
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Check(ctx, log, tx, attempt)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("not fulfilled", func(t *testing.T) {
			tx, attempt := txRequest(t, r3, false)
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("error checking fulfillment, should transmit", func(t *testing.T) {
			tx, attempt := txRequest(t, r2, false)
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("failure fetching tx receipt and block head", func(t *testing.T) {
			tx, attempt := txRequest(t, r1, false)
			mockBatch.Return(pkgerrors.New("could not fetch"))
			err := checker.Check(ctx, log, tx, attempt)
			require.NoError(t, err)
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Return(pkgerrors.New("could not fetch"))`
$DIR/pkg/txmgr/transmitchecker_test.go: `.New("could not fetch")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Check(ctx, log, tx, attempt)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.BytesToHash(vrfReqID.Bytes())`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Bytes()`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Marshal(meta)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.JSON(b)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.HexToAddress("0xfe0629509E6CB8dfa7a99214ae58Ceb465d5b5A9")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.HexToAddress("0xff0Aac13eab788cb9a2D662D3FB661Aa5f58FA21")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Int(assets.NewEthValue(642))`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewEthValue(642)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Unix(0, 0)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.String()`
$DIR/pkg/txmgr/transmitchecker_test.go: `.String()`
$DIR/pkg/txmgr/transmitchecker_test.go: `.New("error getting commitment")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("already fulfilled", func(t *testing.T) {
			tx, attempt := txRequest(t, big.NewInt(1))
			err := checker.Check(ctx, log, tx, attempt)
			require.Error(t, err, "request already fulfilled")
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewInt(1)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Check(ctx, log, tx, attempt)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("not fulfilled", func(t *testing.T) {
			tx, attempt := txRequest(t, big.NewInt(3))
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewInt(3)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("error checking fulfillment, should transmit", func(t *testing.T) {
			tx, attempt := txRequest(t, big.NewInt(2))
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewInt(2)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("can't get header", func(t *testing.T) {
			checker.HeadByNumber = func(ctx context.Context, n *big.Int) (*evmtypes.Head, error) {
				return nil, pkgerrors.New("can't get head")
			}
			tx, attempt := txRequest(t, big.NewInt(3))
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.New("can't get head")`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewInt(3)`
$DIR/pkg/txmgr/transmitchecker_test.go: `.Run("nil request block number", func(t *testing.T) {
			checker.HeadByNumber = func(ctx context.Context, n *big.Int) (*evmtypes.Head, error) {
				return &evmtypes.Head{
					Number: 1,
				}, nil
			}
			checker.RequestBlockNumber = nil
			tx, attempt := txRequest(t, big.NewInt(4))
			require.NoError(t, checker.Check(ctx, log, tx, attempt))
		})`
$DIR/pkg/txmgr/transmitchecker_test.go: `.NewInt(4)`
$DIR/pkg/txmgr/txmgr_test.go: `_, err = txm.SendNativeToken(tests.Context(t), big.NewInt(0), from, to, *value, 21000)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("with queue under capacity inserts eth_tx", func(t *testing.T) {
		subject := uuid.New()
		strategy := newMockTxStrategy(t)
		strategy.On("Subject").Return(uuid.NullUUID{UUID: subject, Valid: true})
		strategy.On("PruneQueue", mock.Anything, mock.Anything).Return(nil, nil)
		evmConfig.MaxQueued = uint64(1)
		etx, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
		})
		assert.NoError(t, err)
		assert.Greater(t, etx.ID, int64(0))
		assert.Equal(t, etx.State, txmgrcommon.TxUnstarted)
		assert.Equal(t, gasLimit, etx.FeeLimit)
		assert.Equal(t, fromAddress, etx.FromAddress)
		assert.Equal(t, toAddress, etx.ToAddress)
		assert.Equal(t, payload, etx.EncodedPayload)
		assert.Equal(t, big.Int(assets.NewEthValue(0)), etx.Value)
		assert.Equal(t, subject, etx.Subject.UUID)

		txmgrtest.AssertCount(t, db, "evm.txes", 1)

		var dbEtx txmgr.DbEthTx
		require.NoError(t, db.Get(&dbEtx, `SELECT * FROM evm.txes ORDER BY id ASC LIMIT 1`))

		assert.Equal(t, etx.State, txmgrcommon.TxUnstarted)
		assert.Equal(t, gasLimit, etx.FeeLimit)
		assert.Equal(t, fromAddress, etx.FromAddress)
		assert.Equal(t, toAddress, etx.ToAddress)
		assert.Equal(t, payload, etx.EncodedPayload)
		assert.Equal(t, big.Int(assets.NewEthValue(0)), etx.Value)
		assert.Equal(t, subject, etx.Subject.UUID)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `strategy.On("Subject").Return(uuid.NullUUID{UUID: subject, Valid: true})`
$DIR/pkg/txmgr/txmgr_test.go: `strategy.On("PruneQueue", mock.Anything, mock.Anything).Return(nil, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.MaxQueued = uint64(1)`
$DIR/pkg/txmgr/txmgr_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/txmgr_test.go: `mustInsertUnconfirmedEthTxWithInsufficientEthAttempt(t, txStore, 0, fromAddress)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("with queue at capacity does not insert eth_tx", func(t *testing.T) {
		evmConfig.MaxQueued = uint64(1)
		_, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      testutils.NewAddress(),
			EncodedPayload: []byte{1, 2, 3},
			FeeLimit:       21000,
			Meta:           nil,
			Strategy:       txmgrcommon.NewSendEveryStrategy(),
		})
		require.Error(t, err)
		assert.Contains(t, err.Error(), "Txm#CreateTransaction: cannot create transaction; too many unstarted transactions in the queue (1/1). WARNING: Hitting EVM.Transactions.MaxQueued")
	})`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.MaxQueued = uint64(1)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("doesn't insert eth_tx if a matching tx already exists for that pipeline_task_run_id", func(t *testing.T) {
		evmConfig.MaxQueued = uint64(3)
		id := uuid.New()
		tx1, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:       fromAddress,
			ToAddress:         testutils.NewAddress(),
			EncodedPayload:    []byte{1, 2, 3},
			FeeLimit:          21000,
			PipelineTaskRunID: &id,
			Strategy:          txmgrcommon.NewSendEveryStrategy(),
		})
		assert.NoError(t, err)

		tx2, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:       fromAddress,
			ToAddress:         testutils.NewAddress(),
			EncodedPayload:    []byte{1, 2, 3},
			FeeLimit:          21000,
			PipelineTaskRunID: &id,
			Strategy:          txmgrcommon.NewSendEveryStrategy(),
		})
		assert.NoError(t, err)

		assert.Equal(t, tx1.GetID(), tx2.GetID())
	})`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.MaxQueued = uint64(3)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("returns error if eth key is not enabled", func(t *testing.T) {
		rndAddr := testutils.NewAddress()
		_, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    rndAddr,
			ToAddress:      testutils.NewAddress(),
			EncodedPayload: []byte{1, 2, 3},
			FeeLimit:       21000,
			Strategy:       txmgrcommon.NewSendEveryStrategy(),
		})
		require.Error(t, err)
		assert.ErrorIs(t, err, evmtxm.NotEnabledError{})
		assert.ErrorIs(t, err, evmtxm.NotEnabledError{FromAddress: rndAddr})
		var as evmtxm.NotEnabledError
		if assert.ErrorAs(t, err, &as) {
			assert.Equal(t, rndAddr.String(), as.FromAddress.String())
		}
	})`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("simulate transmit checker", func(t *testing.T) {
		testutils.MustExec(t, db, `DELETE FROM evm.txes`)

		checker := txmgr.TransmitCheckerSpec{
			CheckerType: txmgr.TransmitCheckerTypeSimulate,
		}
		evmConfig.MaxQueued = uint64(1)
		etx, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Strategy:       txmgrcommon.NewSendEveryStrategy(),
			Checker:        checker,
		})
		assert.NoError(t, err)
		txmgrtest.AssertCount(t, db, "evm.txes", 1)
		var dbEtx txmgr.DbEthTx
		require.NoError(t, db.Get(&dbEtx, `SELECT * FROM evm.txes ORDER BY id ASC LIMIT 1`))

		var c txmgr.TransmitCheckerSpec
		require.NotNil(t, etx.TransmitChecker)
		require.NoError(t, json.Unmarshal(*etx.TransmitChecker, &c))
		require.Equal(t, checker, c)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `testutils.MustExec(t, db, `DELETE FROM evm.txes`)`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.MaxQueued = uint64(1)`
$DIR/pkg/txmgr/txmgr_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("meta and vrf checker", func(t *testing.T) {
		testutils.MustExec(t, db, `DELETE FROM evm.txes`)
		testDefaultSubID := uint64(2)
		testDefaultMaxLink := "1000000000000000000"
		testDefaultMaxEth := "2000000000000000000"
		// max uint256 is 1.1579209e+77
		testDefaultGlobalSubID := crypto.Keccak256Hash([]byte("sub id")).String()
		jobID := int32(25)
		requestID := common.HexToHash("abcd")
		requestTxHash := common.HexToHash("dcba")
		meta := &txmgr.TxMeta{
			JobID:         &jobID,
			RequestID:     &requestID,
			RequestTxHash: &requestTxHash,
			MaxLink:       &testDefaultMaxLink, // 1e18
			MaxEth:        &testDefaultMaxEth,  // 2e18
			SubID:         &testDefaultSubID,
			GlobalSubID:   &testDefaultGlobalSubID,
		}
		evmConfig.MaxQueued = uint64(1)
		checker := txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
		}
		etx, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           meta,
			Strategy:       txmgrcommon.NewSendEveryStrategy(),
			Checker:        checker,
		})
		assert.NoError(t, err)
		txmgrtest.AssertCount(t, db, "evm.txes", 1)
		var dbEtx txmgr.DbEthTx
		require.NoError(t, db.Get(&dbEtx, `SELECT * FROM evm.txes ORDER BY id ASC LIMIT 1`))

		m, err := etx.GetMeta()
		require.NoError(t, err)
		require.Equal(t, meta, m)

		var c txmgr.TransmitCheckerSpec
		require.NotNil(t, etx.TransmitChecker)
		require.NoError(t, json.Unmarshal(*etx.TransmitChecker, &c))
		require.Equal(t, checker, c)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `testutils.MustExec(t, db, `DELETE FROM evm.txes`)`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.MaxQueued = uint64(1)`
$DIR/pkg/txmgr/txmgr_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("forwards tx when a proper forwarder is set up", func(t *testing.T) {
		testutils.MustExec(t, db, `DELETE FROM evm.txes`)
		testutils.MustExec(t, db, `DELETE FROM evm.forwarders`)
		evmConfig.MaxQueued = uint64(1)

		// Create mock forwarder, mock authorizedsenders call.
		form := forwarders.NewORM(db)
		fwdrAddr := testutils.NewAddress()
		fwdr, err := form.CreateForwarder(tests.Context(t), fwdrAddr, ubig.Big(*testutils.FixtureChainID))
		require.NoError(t, err)
		require.Equal(t, fwdr.Address, fwdrAddr)

		etx, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:      fromAddress,
			ToAddress:        toAddress,
			EncodedPayload:   payload,
			FeeLimit:         gasLimit,
			ForwarderAddress: fwdr.Address,
			Strategy:         txmgrcommon.NewSendEveryStrategy(),
		})
		assert.NoError(t, err)
		txmgrtest.AssertCount(t, db, "evm.txes", 1)

		var dbEtx txmgr.DbEthTx
		require.NoError(t, db.Get(&dbEtx, `SELECT * FROM evm.txes ORDER BY id ASC LIMIT 1`))

		m, err := etx.GetMeta()
		require.NoError(t, err)

		require.NotEqual(t, etx.ToAddress, *m.FwdrDestAddress)
		require.Equal(t, toAddress, *m.FwdrDestAddress)
		require.NotNil(t, m.FwdrDestAddress)
		require.Equal(t, etx.ToAddress.String(), fwdrAddr.String())
	})`
$DIR/pkg/txmgr/txmgr_test.go: `testutils.MustExec(t, db, `DELETE FROM evm.txes`)`
$DIR/pkg/txmgr/txmgr_test.go: `testutils.MustExec(t, db, `DELETE FROM evm.forwarders`)`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.MaxQueued = uint64(1)`
$DIR/pkg/txmgr/txmgr_test.go: `txmgrtest.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("insert Tx successfully with a IdempotencyKey", func(t *testing.T) {
		evmConfig.MaxQueued = uint64(3)
		id := uuid.New()
		idempotencyKey := "1"
		_, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			IdempotencyKey:    &idempotencyKey,
			FromAddress:       fromAddress,
			ToAddress:         testutils.NewAddress(),
			EncodedPayload:    []byte{1, 2, 3},
			FeeLimit:          21000,
			PipelineTaskRunID: &id,
			Strategy:          txmgrcommon.NewSendEveryStrategy(),
		})
		assert.NoError(t, err)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.MaxQueued = uint64(3)`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.MaxQueued = uint64(3)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("if another key has any transactions with insufficient eth errors, transmits as normal", func(t *testing.T) {
		payload := []byte("payload1")

		evmConfig.MaxQueued = uint64(1)
		mustInsertUnconfirmedEthTxWithInsufficientEthAttempt(t, txStore, 0, otherAddress)
		strategy := newMockTxStrategy(t)
		strategy.On("Subject").Return(uuid.NullUUID{})
		strategy.On("PruneQueue", mock.Anything, mock.Anything).Return(nil, nil)

		etx, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
		})
		assert.NoError(t, err)

		require.Equal(t, payload, etx.EncodedPayload)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.MaxQueued = uint64(1)`
$DIR/pkg/txmgr/txmgr_test.go: `mustInsertUnconfirmedEthTxWithInsufficientEthAttempt(t, txStore, 0, otherAddress)`
$DIR/pkg/txmgr/txmgr_test.go: `strategy.On("Subject").Return(uuid.NullUUID{})`
$DIR/pkg/txmgr/txmgr_test.go: `strategy.On("PruneQueue", mock.Anything, mock.Anything).Return(nil, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("if this key has any transactions with insufficient eth errors, inserts it anyway", func(t *testing.T) {
		payload := []byte("payload2")
		evmConfig.MaxQueued = uint64(1)

		mustInsertUnconfirmedEthTxWithInsufficientEthAttempt(t, txStore, 0, fromAddress)
		strategy := newMockTxStrategy(t)
		strategy.On("Subject").Return(uuid.NullUUID{})
		strategy.On("PruneQueue", mock.Anything, mock.Anything).Return(nil, nil)

		etx, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
		})
		require.NoError(t, err)
		require.Equal(t, payload, etx.EncodedPayload)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.MaxQueued = uint64(1)`
$DIR/pkg/txmgr/txmgr_test.go: `mustInsertUnconfirmedEthTxWithInsufficientEthAttempt(t, txStore, 0, fromAddress)`
$DIR/pkg/txmgr/txmgr_test.go: `strategy.On("Subject").Return(uuid.NullUUID{})`
$DIR/pkg/txmgr/txmgr_test.go: `strategy.On("PruneQueue", mock.Anything, mock.Anything).Return(nil, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, 42, fromAddress)`
$DIR/pkg/txmgr/txmgr_test.go: `strategy.On("Subject").Return(uuid.NullUUID{})`
$DIR/pkg/txmgr/txmgr_test.go: `strategy.On("PruneQueue", mock.Anything, mock.Anything).Return(nil, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.MaxQueued = uint64(1)`
$DIR/pkg/txmgr/txmgr_test.go: `config.SetFinalityDepth(uint32(42))`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.RpcDefaultBatchSize = uint32(4)`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.ResendAfterThreshold = 1 * time.Hour`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.ReaperThreshold = 1 * time.Hour`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.ReaperInterval = 1 * time.Hour`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(finalizedHead, nil).Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `txm.OnNewLongestChain(tests.Context(t), head)`
$DIR/pkg/txmgr/txmgr_test.go: `evmConfig.BumpThreshold = uint64(1)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Cleanup(cancel)`
$DIR/pkg/txmgr/txmgr_test.go: `txm.OnNewLongestChain(ctx, head)`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("PendingNonceAt", mock.AnythingOfType("*context.cancelCtx"), common.Address{}).Return(uint64(0), nil).Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, i, i*42+1, addr)`
$DIR/pkg/txmgr/txmgr_test.go: `txmgrtest.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, i, i*42+1, addr2)`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("HeadByNumber", mock.Anything, (*big.Int)(nil)).Return(nil, nil).Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("BatchCallContextAll", mock.Anything, mock.Anything).Return(nil).Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("NonceAt", mock.Anything, addr, mock.Anything).Return(uint64(128), nil).Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("NonceAt", mock.Anything, addr2, mock.Anything).Return(uint64(44), nil).Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 2, addr2)`
$DIR/pkg/txmgr/txmgr_test.go: `txmgrtest.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 4+int64(i), addr)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("returns error if not started", func(t *testing.T) {
		err := txm.Reset(addr, false)
		require.Error(t, err)
		assert.EqualError(t, err, "not started")
	})`
$DIR/pkg/txmgr/txmgr_test.go: `servicetest.Run(t, txm)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("returns no error if started", func(t *testing.T) {
		err := txm.Reset(addr, false)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `err = db.Get(&s, `SELECT error FROM evm.txes WHERE from_address = $1 AND state = 'fatal_error'`, addr)`
$DIR/pkg/txmgr/txmgr_test.go: `err = db.Get(&count, `SELECT count(*) FROM evm.txes WHERE from_address = $1 AND state = 'fatal_error'`, addr2)`
$DIR/pkg/txmgr/txmgr_test.go: `h99.IsFinalized.Store(true)`
$DIR/pkg/txmgr/txmgr_test.go: `head.Parent.Store(h99)`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("PendingNonceAt", mock.Anything, mock.Anything).Return(uint64(0), nil).Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head.Parent.Load(), nil).Once()`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `feeEstimator.On("Start", mock.Anything).Return(nil).Once()`
$DIR/pkg/txmgr/txmgr_test.go: `feeEstimator.On("Close", mock.Anything).Return(nil).Once()`
$DIR/pkg/txmgr/txmgr_test.go: `feeEstimator.On("OnNewLongestChain", mock.Anything, mock.Anything).Once()`
$DIR/pkg/txmgr/txmgr_test.go: `servicetest.Run(t, txm)`
$DIR/pkg/txmgr/txmgr_test.go: `txm.OnNewLongestChain(ctx, head)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("returns error if receipt not found", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		_, err := txm.GetTransactionFee(ctx, idempotencyKey)
		require.Error(t, err, fmt.Sprintf("failed to find receipt with IdempotencyKey: %s", idempotencyKey))
	})`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("returns error for unstarted state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		tx := &txmgr.Tx{
			IdempotencyKey: &idempotencyKey,
			FromAddress:    fromAddress,
			EncodedPayload: []byte{1, 2, 3},
			FeeLimit:       feeLimit,
			State:          txmgrcommon.TxUnstarted,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)

		attemptD := txmgrtest.NewDynamicFeeEthTxAttempt(t, tx.ID)
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attemptD))

		// insert receipt
		var r txmgr.Receipt
		r = newEthReceipt(42, utils.NewHash(), attemptD.Hash, 0x1)
		_, err = txStore.InsertReceipt(ctx, &r.Receipt)
		require.NoError(t, err)

		_, err = txm.GetTransactionFee(ctx, idempotencyKey)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `r = newEthReceipt(42, utils.NewHash(), attemptD.Hash, 0x1)`
$DIR/pkg/txmgr/txmgr_test.go: `_, err = txStore.InsertReceipt(ctx, &r.Receipt)`
$DIR/pkg/txmgr/txmgr_test.go: `_, err = txm.GetTransactionFee(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `r = newEthReceipt(42, utils.NewHash(), attemptD.Hash, 0x1)`
$DIR/pkg/txmgr/txmgr_test.go: `_, err = txStore.InsertReceipt(ctx, &r.Receipt)`
$DIR/pkg/txmgr/txmgr_test.go: `h99.IsFinalized.Store(true)`
$DIR/pkg/txmgr/txmgr_test.go: `head.Parent.Store(h99)`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("PendingNonceAt", mock.Anything, mock.Anything).Return(uint64(0), nil).Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil).Once()`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head.Parent.Load(), nil).Once()`
$DIR/pkg/txmgr/txmgr_test.go: `ethClient.On("HeadByNumber", mock.Anything, mock.Anything).Return(head, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `feeEstimator.On("Start", mock.Anything).Return(nil).Once()`
$DIR/pkg/txmgr/txmgr_test.go: `feeEstimator.On("Close", mock.Anything).Return(nil).Once()`
$DIR/pkg/txmgr/txmgr_test.go: `feeEstimator.On("OnNewLongestChain", mock.Anything, mock.Anything).Once()`
$DIR/pkg/txmgr/txmgr_test.go: `servicetest.Run(t, txm)`
$DIR/pkg/txmgr/txmgr_test.go: `txm.OnNewLongestChain(ctx, head)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("returns error if transaction not found", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.Error(t, err, fmt.Sprintf("failed to find transaction with IdempotencyKey: %s", idempotencyKey))
		require.Equal(t, commontypes.Unknown, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("returns unknown for unstarted state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		tx := &txmgr.Tx{
			IdempotencyKey: &idempotencyKey,
			FromAddress:    fromAddress,
			EncodedPayload: []byte{1, 2, 3},
			FeeLimit:       feeLimit,
			State:          txmgrcommon.TxUnstarted,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.NoError(t, err)
		require.Equal(t, commontypes.Unknown, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("returns unknown for in-progress state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		nonce := evmtypes.Nonce(0)
		tx := &txmgr.Tx{
			Sequence:       &nonce,
			IdempotencyKey: &idempotencyKey,
			FromAddress:    fromAddress,
			EncodedPayload: []byte{1, 2, 3},
			FeeLimit:       feeLimit,
			State:          txmgrcommon.TxInProgress,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.NoError(t, err)
		require.Equal(t, commontypes.Unknown, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("returns pending for unconfirmed state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		nonce := evmtypes.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxUnconfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.NoError(t, err)
		require.Equal(t, commontypes.Pending, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("returns unconfirmed for confirmed state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		nonce := evmtypes.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)
		require.NoError(t, err)
		attempt := txmgrtest.NewLegacyEthTxAttempt(t, tx.ID)
		err = txStore.InsertTxAttempt(ctx, &attempt)
		require.NoError(t, err)
		// Insert receipt for unfinalized block num
		mustInsertEthReceipt(t, txStore, head.Number, head.Hash, attempt.Hash)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.NoError(t, err)
		require.Equal(t, commontypes.Unconfirmed, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)`
$DIR/pkg/txmgr/txmgr_test.go: `err = txStore.InsertTxAttempt(ctx, &attempt)`
$DIR/pkg/txmgr/txmgr_test.go: `mustInsertEthReceipt(t, txStore, head.Number, head.Hash, attempt.Hash)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("returns finalized for finalized state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		nonce := evmtypes.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxFinalized,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)
		require.NoError(t, err)
		attempt := txmgrtest.NewLegacyEthTxAttempt(t, tx.ID)
		err = txStore.InsertTxAttempt(ctx, &attempt)
		require.NoError(t, err)
		// Insert receipt for finalized block num
		mustInsertEthReceipt(t, txStore, head.Parent.Load().Number, head.Parent.Load().Hash, attempt.Hash)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.NoError(t, err)
		require.Equal(t, commontypes.Finalized, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)`
$DIR/pkg/txmgr/txmgr_test.go: `err = txStore.InsertTxAttempt(ctx, &attempt)`
$DIR/pkg/txmgr/txmgr_test.go: `mustInsertEthReceipt(t, txStore, head.Parent.Load().Number, head.Parent.Load().Hash, attempt.Hash)`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("returns pending for confirmed missing receipt state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		nonce := evmtypes.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmedMissingReceipt,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.NoError(t, err)
		require.Equal(t, commontypes.Pending, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `t.Run("returns fatal for fatal error state with terminally stuck error", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		// Test the internal terminally stuck error returns Fatal
		nonce := evmtypes.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxFatalError,
			Error:              null.NewString(evmclient.TerminallyStuckMsg, true),
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.Equal(t, commontypes.Fatal, state)
		require.Error(t, err)
		require.Equal(t, evmclient.TerminallyStuckMsg, err.Error())

		// Test a terminally stuck client error returns Fatal
		nonce = evmtypes.Nonce(1)
		idempotencyKey = uuid.New().String()
		terminallyStuckClientError := "failed to add tx to the pool: not enough step counters to continue the execution"
		tx = &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxFatalError,
			Error:              null.NewString(terminallyStuckClientError, true),
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		err = txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		state, err = txm.GetTransactionStatus(ctx, idempotencyKey)
		require.Equal(t, commontypes.Fatal, state)
		require.Error(t, err)
		require.Equal(t, terminallyStuckClientError, err.Error())
	})`
$DIR/pkg/txmgr/txmgr_test.go: `nonce = evmtypes.Nonce(1)`
$DIR/pkg/txmgr/txmgr_test.go: `idempotencyKey = uuid.New().String()`
$DIR/pkg/txmgr/txmgr_test.go: `tx = &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxFatalError,
			Error:              null.NewString(terminallyStuckClientError, true),
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}`
$DIR/pkg/txmgr/txmgr_test.go: `err = txStore.InsertTx(ctx, tx)`
$DIR/pkg/txmgr/txmgr_test.go: `state, err = txm.GetTransactionStatus(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewEth(1)`
$DIR/pkg/txmgr/txmgr_test.go: `.ToInt()`
$DIR/pkg/txmgr/txmgr_test.go: `.MakeTestConfigs(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewEstimator(logger.Test(t), ethClient, config.ChainType(), ethClient.ConfiguredChainID(), evmConfig.GasEstimator(), nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Test(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.ChainType()`
$DIR/pkg/txmgr/txmgr_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/txmgr_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/txmgr_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/txmgr_test.go: `.Transactions()`
$DIR/pkg/txmgr/txmgr_test.go: `.Listener()`
$DIR/pkg/txmgr/txmgr_test.go: `.SendNativeToken(tests.Context(t), big.NewInt(0), from, to, *value, 21000)`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewChainStore(memKS, big.NewInt(0))`
$DIR/pkg/txmgr/txmgr_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewAddress()`
$DIR/pkg/txmgr/txmgr_test.go: `.MakeTestConfigs(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewEstimator(logger.Test(t), ethClient, config.ChainType(), ethClient.ConfiguredChainID(), evmConfig.GasEstimator(), nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Test(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.ChainType()`
$DIR/pkg/txmgr/txmgr_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/txmgr_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/txmgr_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/txmgr_test.go: `.Transactions()`
$DIR/pkg/txmgr/txmgr_test.go: `.Listener()`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("with queue under capacity inserts eth_tx", func(t *testing.T) {
		subject := uuid.New()
		strategy := newMockTxStrategy(t)
		strategy.On("Subject").Return(uuid.NullUUID{UUID: subject, Valid: true})
		strategy.On("PruneQueue", mock.Anything, mock.Anything).Return(nil, nil)
		evmConfig.MaxQueued = uint64(1)
		etx, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
		})
		assert.NoError(t, err)
		assert.Greater(t, etx.ID, int64(0))
		assert.Equal(t, etx.State, txmgrcommon.TxUnstarted)
		assert.Equal(t, gasLimit, etx.FeeLimit)
		assert.Equal(t, fromAddress, etx.FromAddress)
		assert.Equal(t, toAddress, etx.ToAddress)
		assert.Equal(t, payload, etx.EncodedPayload)
		assert.Equal(t, big.Int(assets.NewEthValue(0)), etx.Value)
		assert.Equal(t, subject, etx.Subject.UUID)

		txmgrtest.AssertCount(t, db, "evm.txes", 1)

		var dbEtx txmgr.DbEthTx
		require.NoError(t, db.Get(&dbEtx, `SELECT * FROM evm.txes ORDER BY id ASC LIMIT 1`))

		assert.Equal(t, etx.State, txmgrcommon.TxUnstarted)
		assert.Equal(t, gasLimit, etx.FeeLimit)
		assert.Equal(t, fromAddress, etx.FromAddress)
		assert.Equal(t, toAddress, etx.ToAddress)
		assert.Equal(t, payload, etx.EncodedPayload)
		assert.Equal(t, big.Int(assets.NewEthValue(0)), etx.Value)
		assert.Equal(t, subject, etx.Subject.UUID)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("Subject")`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(uuid.NullUUID{UUID: subject, Valid: true})`
$DIR/pkg/txmgr/txmgr_test.go: `.On("PruneQueue", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(nil, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("with queue at capacity does not insert eth_tx", func(t *testing.T) {
		evmConfig.MaxQueued = uint64(1)
		_, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      testutils.NewAddress(),
			EncodedPayload: []byte{1, 2, 3},
			FeeLimit:       21000,
			Meta:           nil,
			Strategy:       txmgrcommon.NewSendEveryStrategy(),
		})
		require.Error(t, err)
		assert.Contains(t, err.Error(), "Txm#CreateTransaction: cannot create transaction; too many unstarted transactions in the queue (1/1). WARNING: Hitting EVM.Transactions.MaxQueued")
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      testutils.NewAddress(),
			EncodedPayload: []byte{1, 2, 3},
			FeeLimit:       21000,
			Meta:           nil,
			Strategy:       txmgrcommon.NewSendEveryStrategy(),
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewAddress()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSendEveryStrategy()`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("doesn't insert eth_tx if a matching tx already exists for that pipeline_task_run_id", func(t *testing.T) {
		evmConfig.MaxQueued = uint64(3)
		id := uuid.New()
		tx1, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:       fromAddress,
			ToAddress:         testutils.NewAddress(),
			EncodedPayload:    []byte{1, 2, 3},
			FeeLimit:          21000,
			PipelineTaskRunID: &id,
			Strategy:          txmgrcommon.NewSendEveryStrategy(),
		})
		assert.NoError(t, err)

		tx2, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:       fromAddress,
			ToAddress:         testutils.NewAddress(),
			EncodedPayload:    []byte{1, 2, 3},
			FeeLimit:          21000,
			PipelineTaskRunID: &id,
			Strategy:          txmgrcommon.NewSendEveryStrategy(),
		})
		assert.NoError(t, err)

		assert.Equal(t, tx1.GetID(), tx2.GetID())
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:       fromAddress,
			ToAddress:         testutils.NewAddress(),
			EncodedPayload:    []byte{1, 2, 3},
			FeeLimit:          21000,
			PipelineTaskRunID: &id,
			Strategy:          txmgrcommon.NewSendEveryStrategy(),
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewAddress()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSendEveryStrategy()`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:       fromAddress,
			ToAddress:         testutils.NewAddress(),
			EncodedPayload:    []byte{1, 2, 3},
			FeeLimit:          21000,
			PipelineTaskRunID: &id,
			Strategy:          txmgrcommon.NewSendEveryStrategy(),
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewAddress()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSendEveryStrategy()`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("returns error if eth key is not enabled", func(t *testing.T) {
		rndAddr := testutils.NewAddress()
		_, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    rndAddr,
			ToAddress:      testutils.NewAddress(),
			EncodedPayload: []byte{1, 2, 3},
			FeeLimit:       21000,
			Strategy:       txmgrcommon.NewSendEveryStrategy(),
		})
		require.Error(t, err)
		assert.ErrorIs(t, err, evmtxm.NotEnabledError{})
		assert.ErrorIs(t, err, evmtxm.NotEnabledError{FromAddress: rndAddr})
		var as evmtxm.NotEnabledError
		if assert.ErrorAs(t, err, &as) {
			assert.Equal(t, rndAddr.String(), as.FromAddress.String())
		}
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.NewAddress()`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    rndAddr,
			ToAddress:      testutils.NewAddress(),
			EncodedPayload: []byte{1, 2, 3},
			FeeLimit:       21000,
			Strategy:       txmgrcommon.NewSendEveryStrategy(),
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewAddress()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSendEveryStrategy()`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("simulate transmit checker", func(t *testing.T) {
		testutils.MustExec(t, db, `DELETE FROM evm.txes`)

		checker := txmgr.TransmitCheckerSpec{
			CheckerType: txmgr.TransmitCheckerTypeSimulate,
		}
		evmConfig.MaxQueued = uint64(1)
		etx, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Strategy:       txmgrcommon.NewSendEveryStrategy(),
			Checker:        checker,
		})
		assert.NoError(t, err)
		txmgrtest.AssertCount(t, db, "evm.txes", 1)
		var dbEtx txmgr.DbEthTx
		require.NoError(t, db.Get(&dbEtx, `SELECT * FROM evm.txes ORDER BY id ASC LIMIT 1`))

		var c txmgr.TransmitCheckerSpec
		require.NotNil(t, etx.TransmitChecker)
		require.NoError(t, json.Unmarshal(*etx.TransmitChecker, &c))
		require.Equal(t, checker, c)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.MustExec(t, db, `DELETE FROM evm.txes`)`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Strategy:       txmgrcommon.NewSendEveryStrategy(),
			Checker:        checker,
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSendEveryStrategy()`
$DIR/pkg/txmgr/txmgr_test.go: `.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("meta and vrf checker", func(t *testing.T) {
		testutils.MustExec(t, db, `DELETE FROM evm.txes`)
		testDefaultSubID := uint64(2)
		testDefaultMaxLink := "1000000000000000000"
		testDefaultMaxEth := "2000000000000000000"
		// max uint256 is 1.1579209e+77
		testDefaultGlobalSubID := crypto.Keccak256Hash([]byte("sub id")).String()
		jobID := int32(25)
		requestID := common.HexToHash("abcd")
		requestTxHash := common.HexToHash("dcba")
		meta := &txmgr.TxMeta{
			JobID:         &jobID,
			RequestID:     &requestID,
			RequestTxHash: &requestTxHash,
			MaxLink:       &testDefaultMaxLink, // 1e18
			MaxEth:        &testDefaultMaxEth,  // 2e18
			SubID:         &testDefaultSubID,
			GlobalSubID:   &testDefaultGlobalSubID,
		}
		evmConfig.MaxQueued = uint64(1)
		checker := txmgr.TransmitCheckerSpec{
			CheckerType:           txmgr.TransmitCheckerTypeVRFV2,
			VRFCoordinatorAddress: testutils.NewAddressPtr(),
		}
		etx, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           meta,
			Strategy:       txmgrcommon.NewSendEveryStrategy(),
			Checker:        checker,
		})
		assert.NoError(t, err)
		txmgrtest.AssertCount(t, db, "evm.txes", 1)
		var dbEtx txmgr.DbEthTx
		require.NoError(t, db.Get(&dbEtx, `SELECT * FROM evm.txes ORDER BY id ASC LIMIT 1`))

		m, err := etx.GetMeta()
		require.NoError(t, err)
		require.Equal(t, meta, m)

		var c txmgr.TransmitCheckerSpec
		require.NotNil(t, etx.TransmitChecker)
		require.NoError(t, json.Unmarshal(*etx.TransmitChecker, &c))
		require.Equal(t, checker, c)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.MustExec(t, db, `DELETE FROM evm.txes`)`
$DIR/pkg/txmgr/txmgr_test.go: `.Keccak256Hash([]byte("sub id"))`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.HexToHash("abcd")`
$DIR/pkg/txmgr/txmgr_test.go: `.HexToHash("dcba")`
$DIR/pkg/txmgr/txmgr_test.go: `.NewAddressPtr()`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           meta,
			Strategy:       txmgrcommon.NewSendEveryStrategy(),
			Checker:        checker,
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSendEveryStrategy()`
$DIR/pkg/txmgr/txmgr_test.go: `.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/txmgr_test.go: `.GetMeta()`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("forwards tx when a proper forwarder is set up", func(t *testing.T) {
		testutils.MustExec(t, db, `DELETE FROM evm.txes`)
		testutils.MustExec(t, db, `DELETE FROM evm.forwarders`)
		evmConfig.MaxQueued = uint64(1)

		// Create mock forwarder, mock authorizedsenders call.
		form := forwarders.NewORM(db)
		fwdrAddr := testutils.NewAddress()
		fwdr, err := form.CreateForwarder(tests.Context(t), fwdrAddr, ubig.Big(*testutils.FixtureChainID))
		require.NoError(t, err)
		require.Equal(t, fwdr.Address, fwdrAddr)

		etx, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:      fromAddress,
			ToAddress:        toAddress,
			EncodedPayload:   payload,
			FeeLimit:         gasLimit,
			ForwarderAddress: fwdr.Address,
			Strategy:         txmgrcommon.NewSendEveryStrategy(),
		})
		assert.NoError(t, err)
		txmgrtest.AssertCount(t, db, "evm.txes", 1)

		var dbEtx txmgr.DbEthTx
		require.NoError(t, db.Get(&dbEtx, `SELECT * FROM evm.txes ORDER BY id ASC LIMIT 1`))

		m, err := etx.GetMeta()
		require.NoError(t, err)

		require.NotEqual(t, etx.ToAddress, *m.FwdrDestAddress)
		require.Equal(t, toAddress, *m.FwdrDestAddress)
		require.NotNil(t, m.FwdrDestAddress)
		require.Equal(t, etx.ToAddress.String(), fwdrAddr.String())
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.MustExec(t, db, `DELETE FROM evm.txes`)`
$DIR/pkg/txmgr/txmgr_test.go: `.MustExec(t, db, `DELETE FROM evm.forwarders`)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewORM(db)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewAddress()`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateForwarder(tests.Context(t), fwdrAddr, ubig.Big(*testutils.FixtureChainID))`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.Big(*testutils.FixtureChainID)`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:      fromAddress,
			ToAddress:        toAddress,
			EncodedPayload:   payload,
			FeeLimit:         gasLimit,
			ForwarderAddress: fwdr.Address,
			Strategy:         txmgrcommon.NewSendEveryStrategy(),
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSendEveryStrategy()`
$DIR/pkg/txmgr/txmgr_test.go: `.AssertCount(t, db, "evm.txes", 1)`
$DIR/pkg/txmgr/txmgr_test.go: `.GetMeta()`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("insert Tx successfully with a IdempotencyKey", func(t *testing.T) {
		evmConfig.MaxQueued = uint64(3)
		id := uuid.New()
		idempotencyKey := "1"
		_, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			IdempotencyKey:    &idempotencyKey,
			FromAddress:       fromAddress,
			ToAddress:         testutils.NewAddress(),
			EncodedPayload:    []byte{1, 2, 3},
			FeeLimit:          21000,
			PipelineTaskRunID: &id,
			Strategy:          txmgrcommon.NewSendEveryStrategy(),
		})
		assert.NoError(t, err)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			IdempotencyKey:    &idempotencyKey,
			FromAddress:       fromAddress,
			ToAddress:         testutils.NewAddress(),
			EncodedPayload:    []byte{1, 2, 3},
			FeeLimit:          21000,
			PipelineTaskRunID: &id,
			Strategy:          txmgrcommon.NewSendEveryStrategy(),
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewAddress()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSendEveryStrategy()`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			IdempotencyKey:    &idempotencyKey,
			FromAddress:       fromAddress,
			ToAddress:         testutils.NewAddress(),
			EncodedPayload:    []byte{1, 2, 3},
			FeeLimit:          21000,
			PipelineTaskRunID: &id,
			Strategy:          txmgrcommon.NewSendEveryStrategy(),
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewAddress()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSendEveryStrategy()`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			IdempotencyKey:    &idempotencyKey,
			FromAddress:       fromAddress,
			ToAddress:         testutils.NewAddress(),
			EncodedPayload:    []byte{1, 2, 3},
			FeeLimit:          21000,
			PipelineTaskRunID: &id,
			Strategy:          txmgrcommon.NewSendEveryStrategy(),
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewAddress()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSendEveryStrategy()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewChainStore(memKS, big.NewInt(0))`
$DIR/pkg/txmgr/txmgr_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewAddress()`
$DIR/pkg/txmgr/txmgr_test.go: `.MakeTestConfigs(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewEstimator(logger.Test(t), ethClient, config.ChainType(), ethClient.ConfiguredChainID(), evmConfig.GasEstimator(), nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Test(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.ChainType()`
$DIR/pkg/txmgr/txmgr_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/txmgr_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/txmgr_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/txmgr_test.go: `.Transactions()`
$DIR/pkg/txmgr/txmgr_test.go: `.Listener()`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("if another key has any transactions with insufficient eth errors, transmits as normal", func(t *testing.T) {
		payload := []byte("payload1")

		evmConfig.MaxQueued = uint64(1)
		mustInsertUnconfirmedEthTxWithInsufficientEthAttempt(t, txStore, 0, otherAddress)
		strategy := newMockTxStrategy(t)
		strategy.On("Subject").Return(uuid.NullUUID{})
		strategy.On("PruneQueue", mock.Anything, mock.Anything).Return(nil, nil)

		etx, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
		})
		assert.NoError(t, err)

		require.Equal(t, payload, etx.EncodedPayload)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.On("Subject")`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(uuid.NullUUID{})`
$DIR/pkg/txmgr/txmgr_test.go: `.On("PruneQueue", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(nil, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("if this key has any transactions with insufficient eth errors, inserts it anyway", func(t *testing.T) {
		payload := []byte("payload2")
		evmConfig.MaxQueued = uint64(1)

		mustInsertUnconfirmedEthTxWithInsufficientEthAttempt(t, txStore, 0, fromAddress)
		strategy := newMockTxStrategy(t)
		strategy.On("Subject").Return(uuid.NullUUID{})
		strategy.On("PruneQueue", mock.Anything, mock.Anything).Return(nil, nil)

		etx, err := txm.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
		})
		require.NoError(t, err)
		require.Equal(t, payload, etx.EncodedPayload)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.On("Subject")`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(uuid.NullUUID{})`
$DIR/pkg/txmgr/txmgr_test.go: `.On("PruneQueue", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(nil, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, 0, 42, fromAddress)`
$DIR/pkg/txmgr/txmgr_test.go: `.On("Subject")`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(uuid.NullUUID{})`
$DIR/pkg/txmgr/txmgr_test.go: `.On("PruneQueue", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(nil, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.CreateTransaction(tests.Context(t), txmgr.TxRequest{
			FromAddress:    fromAddress,
			ToAddress:      toAddress,
			EncodedPayload: payload,
			FeeLimit:       gasLimit,
			Meta:           nil,
			Strategy:       strategy,
		})`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.MakeTestConfigs(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.SetFinalityDepth(uint32(42))`
$DIR/pkg/txmgr/txmgr_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(head, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(finalizedHead, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewEstimator(logger.Test(t), ethClient, config.ChainType(), ethClient.ConfiguredChainID(), evmConfig.GasEstimator(), nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Test(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.ChainType()`
$DIR/pkg/txmgr/txmgr_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/txmgr_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/txmgr_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/txmgr_test.go: `.Transactions()`
$DIR/pkg/txmgr/txmgr_test.go: `.Listener()`
$DIR/pkg/txmgr/txmgr_test.go: `.OnNewLongestChain(tests.Context(t), head)`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.WithTimeout(tests.Context(t), 5*time.Second)`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.Cleanup(cancel)`
$DIR/pkg/txmgr/txmgr_test.go: `.OnNewLongestChain(ctx, head)`
$DIR/pkg/txmgr/txmgr_test.go: `.On("PendingNonceAt", mock.AnythingOfType("*context.cancelCtx"), common.Address{})`
$DIR/pkg/txmgr/txmgr_test.go: `.AnythingOfType("*context.cancelCtx")`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.MakeTestConfigs(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewChainStore(memKS, big.NewInt(0))`
$DIR/pkg/txmgr/txmgr_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/txmgr_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, i, i*42+1, addr)`
$DIR/pkg/txmgr/txmgr_test.go: `.MustInsertConfirmedEthTxWithLegacyAttempt(t, txStore, i, i*42+1, addr2)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.On("HeadByNumber", mock.Anything, (*big.Int)(nil))`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(nil, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("BatchCallContextAll", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("NonceAt", mock.Anything, addr, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(uint64(128), nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("NonceAt", mock.Anything, addr2, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(uint64(44), nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewEstimator(logger.Test(t), ethClient, evmConfig.ChainType(), ethClient.ConfiguredChainID(), evmConfig.GasEstimator(), nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Test(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.ChainType()`
$DIR/pkg/txmgr/txmgr_test.go: `.ConfiguredChainID()`
$DIR/pkg/txmgr/txmgr_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/txmgr_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/txmgr_test.go: `.Transactions()`
$DIR/pkg/txmgr/txmgr_test.go: `.Listener()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 2, addr2)`
$DIR/pkg/txmgr/txmgr_test.go: `.MustInsertUnconfirmedEthTxWithBroadcastLegacyAttempt(t, txStore, 4+int64(i), addr)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("returns error if not started", func(t *testing.T) {
		err := txm.Reset(addr, false)
		require.Error(t, err)
		assert.EqualError(t, err, "not started")
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.Reset(addr, false)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run(t, txm)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("returns no error if started", func(t *testing.T) {
		err := txm.Reset(addr, false)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.Reset(addr, false)`
$DIR/pkg/txmgr/txmgr_test.go: `.Reset(addr, true)`
$DIR/pkg/txmgr/txmgr_test.go: `.Get(&s, `SELECT error FROM evm.txes WHERE from_address = $1 AND state = 'fatal_error'`, addr)`
$DIR/pkg/txmgr/txmgr_test.go: `.Get(&count, `SELECT count(*) FROM evm.txes WHERE from_address = $1 AND state = 'fatal_error'`, addr2)`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewChainStore(memKS, big.NewInt(0))`
$DIR/pkg/txmgr/txmgr_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/txmgr_test.go: `.MakeTestConfigs(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewHash()`
$DIR/pkg/txmgr/txmgr_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewHash()`
$DIR/pkg/txmgr/txmgr_test.go: `.Parent.Store(h99)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.On("PendingNonceAt", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(head, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Once()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(head.Parent.Load(), nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/txmgr_test.go: `.Once()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(head, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.On("Start", mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Once()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("Close", mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Once()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("OnNewLongestChain", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Once()`
$DIR/pkg/txmgr/txmgr_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/txmgr_test.go: `.Transactions()`
$DIR/pkg/txmgr/txmgr_test.go: `.Listener()`
$DIR/pkg/txmgr/txmgr_test.go: `.Run(t, txm)`
$DIR/pkg/txmgr/txmgr_test.go: `.OnNewLongestChain(ctx, head)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("returns error if receipt not found", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		_, err := txm.GetTransactionFee(ctx, idempotencyKey)
		require.Error(t, err, fmt.Sprintf("failed to find receipt with IdempotencyKey: %s", idempotencyKey))
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.GetTransactionFee(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("returns error for unstarted state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		tx := &txmgr.Tx{
			IdempotencyKey: &idempotencyKey,
			FromAddress:    fromAddress,
			EncodedPayload: []byte{1, 2, 3},
			FeeLimit:       feeLimit,
			State:          txmgrcommon.TxUnstarted,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)

		attemptD := txmgrtest.NewDynamicFeeEthTxAttempt(t, tx.ID)
		require.NoError(t, txStore.InsertTxAttempt(ctx, &attemptD))

		// insert receipt
		var r txmgr.Receipt
		r = newEthReceipt(42, utils.NewHash(), attemptD.Hash, 0x1)
		_, err = txStore.InsertReceipt(ctx, &r.Receipt)
		require.NoError(t, err)

		_, err = txm.GetTransactionFee(ctx, idempotencyKey)
		require.NoError(t, err)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertTx(ctx, tx)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewDynamicFeeEthTxAttempt(t, tx.ID)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewHash()`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertReceipt(ctx, &r.Receipt)`
$DIR/pkg/txmgr/txmgr_test.go: `.GetTransactionFee(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/txmgr_test.go: `.Now()`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertTx(ctx, tx)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewDynamicFeeEthTxAttempt(t, tx.ID)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewHash()`
$DIR/pkg/txmgr/txmgr_test.go: `.Receipt.EffectiveGasPrice.Uint64()`
$DIR/pkg/txmgr/txmgr_test.go: `.Receipt.L1Fee.Uint64()`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertReceipt(ctx, &r.Receipt)`
$DIR/pkg/txmgr/txmgr_test.go: `.GetTransactionFee(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `.Context(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewSqlxDB(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewTestTxStore(t, db)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewMemoryChainStore()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewChainStore(memKS, big.NewInt(0))`
$DIR/pkg/txmgr/txmgr_test.go: `.NewInt(0)`
$DIR/pkg/txmgr/txmgr_test.go: `.MakeTestConfigs(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewHash()`
$DIR/pkg/txmgr/txmgr_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewHash()`
$DIR/pkg/txmgr/txmgr_test.go: `.Parent.Store(h99)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewClientWithDefaultChainID(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.On("PendingNonceAt", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(uint64(0), nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Maybe()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(head, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Once()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(head.Parent.Load(), nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/txmgr_test.go: `.Once()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("HeadByNumber", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(head, nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewEvmFeeEstimator(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.On("Start", mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Once()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("Close", mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Return(nil)`
$DIR/pkg/txmgr/txmgr_test.go: `.Once()`
$DIR/pkg/txmgr/txmgr_test.go: `.On("OnNewLongestChain", mock.Anything, mock.Anything)`
$DIR/pkg/txmgr/txmgr_test.go: `.Once()`
$DIR/pkg/txmgr/txmgr_test.go: `.GasEstimator()`
$DIR/pkg/txmgr/txmgr_test.go: `.Transactions()`
$DIR/pkg/txmgr/txmgr_test.go: `.Listener()`
$DIR/pkg/txmgr/txmgr_test.go: `.Run(t, txm)`
$DIR/pkg/txmgr/txmgr_test.go: `.OnNewLongestChain(ctx, head)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("returns error if transaction not found", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.Error(t, err, fmt.Sprintf("failed to find transaction with IdempotencyKey: %s", idempotencyKey))
		require.Equal(t, commontypes.Unknown, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.GetTransactionStatus(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("returns unknown for unstarted state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		tx := &txmgr.Tx{
			IdempotencyKey: &idempotencyKey,
			FromAddress:    fromAddress,
			EncodedPayload: []byte{1, 2, 3},
			FeeLimit:       feeLimit,
			State:          txmgrcommon.TxUnstarted,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.NoError(t, err)
		require.Equal(t, commontypes.Unknown, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertTx(ctx, tx)`
$DIR/pkg/txmgr/txmgr_test.go: `.GetTransactionStatus(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("returns unknown for in-progress state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		nonce := evmtypes.Nonce(0)
		tx := &txmgr.Tx{
			Sequence:       &nonce,
			IdempotencyKey: &idempotencyKey,
			FromAddress:    fromAddress,
			EncodedPayload: []byte{1, 2, 3},
			FeeLimit:       feeLimit,
			State:          txmgrcommon.TxInProgress,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.NoError(t, err)
		require.Equal(t, commontypes.Unknown, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertTx(ctx, tx)`
$DIR/pkg/txmgr/txmgr_test.go: `.GetTransactionStatus(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("returns pending for unconfirmed state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		nonce := evmtypes.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxUnconfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.NoError(t, err)
		require.Equal(t, commontypes.Pending, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/txmgr_test.go: `.Now()`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertTx(ctx, tx)`
$DIR/pkg/txmgr/txmgr_test.go: `.GetTransactionStatus(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("returns unconfirmed for confirmed state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		nonce := evmtypes.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmed,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)
		require.NoError(t, err)
		attempt := txmgrtest.NewLegacyEthTxAttempt(t, tx.ID)
		err = txStore.InsertTxAttempt(ctx, &attempt)
		require.NoError(t, err)
		// Insert receipt for unfinalized block num
		mustInsertEthReceipt(t, txStore, head.Number, head.Hash, attempt.Hash)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.NoError(t, err)
		require.Equal(t, commontypes.Unconfirmed, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/txmgr_test.go: `.Now()`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertTx(ctx, tx)`
$DIR/pkg/txmgr/txmgr_test.go: `.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewLegacyEthTxAttempt(t, tx.ID)`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertTxAttempt(ctx, &attempt)`
$DIR/pkg/txmgr/txmgr_test.go: `.GetTransactionStatus(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("returns finalized for finalized state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		nonce := evmtypes.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxFinalized,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		tx, err = txStore.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)
		require.NoError(t, err)
		attempt := txmgrtest.NewLegacyEthTxAttempt(t, tx.ID)
		err = txStore.InsertTxAttempt(ctx, &attempt)
		require.NoError(t, err)
		// Insert receipt for finalized block num
		mustInsertEthReceipt(t, txStore, head.Parent.Load().Number, head.Parent.Load().Hash, attempt.Hash)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.NoError(t, err)
		require.Equal(t, commontypes.Finalized, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/txmgr_test.go: `.Now()`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertTx(ctx, tx)`
$DIR/pkg/txmgr/txmgr_test.go: `.FindTxWithIdempotencyKey(ctx, idempotencyKey, testutils.FixtureChainID)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewLegacyEthTxAttempt(t, tx.ID)`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertTxAttempt(ctx, &attempt)`
$DIR/pkg/txmgr/txmgr_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/txmgr_test.go: `.Parent.Load()`
$DIR/pkg/txmgr/txmgr_test.go: `.GetTransactionStatus(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("returns pending for confirmed missing receipt state", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		nonce := evmtypes.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxConfirmedMissingReceipt,
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.NoError(t, err)
		require.Equal(t, commontypes.Pending, state)
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/txmgr_test.go: `.Now()`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertTx(ctx, tx)`
$DIR/pkg/txmgr/txmgr_test.go: `.GetTransactionStatus(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `.Run("returns fatal for fatal error state with terminally stuck error", func(t *testing.T) {
		idempotencyKey := uuid.New().String()
		fromAddress := memKS.MustCreate(t)
		// Test the internal terminally stuck error returns Fatal
		nonce := evmtypes.Nonce(0)
		broadcast := time.Now()
		tx := &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxFatalError,
			Error:              null.NewString(evmclient.TerminallyStuckMsg, true),
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		err := txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		state, err := txm.GetTransactionStatus(ctx, idempotencyKey)
		require.Equal(t, commontypes.Fatal, state)
		require.Error(t, err)
		require.Equal(t, evmclient.TerminallyStuckMsg, err.Error())

		// Test a terminally stuck client error returns Fatal
		nonce = evmtypes.Nonce(1)
		idempotencyKey = uuid.New().String()
		terminallyStuckClientError := "failed to add tx to the pool: not enough step counters to continue the execution"
		tx = &txmgr.Tx{
			Sequence:           &nonce,
			IdempotencyKey:     &idempotencyKey,
			FromAddress:        fromAddress,
			EncodedPayload:     []byte{1, 2, 3},
			FeeLimit:           feeLimit,
			State:              txmgrcommon.TxFatalError,
			Error:              null.NewString(terminallyStuckClientError, true),
			BroadcastAt:        &broadcast,
			InitialBroadcastAt: &broadcast,
		}
		err = txStore.InsertTx(ctx, tx)
		require.NoError(t, err)
		state, err = txm.GetTransactionStatus(ctx, idempotencyKey)
		require.Equal(t, commontypes.Fatal, state)
		require.Error(t, err)
		require.Equal(t, terminallyStuckClientError, err.Error())
	})`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.Nonce(0)`
$DIR/pkg/txmgr/txmgr_test.go: `.Now()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewString(evmclient.TerminallyStuckMsg, true)`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertTx(ctx, tx)`
$DIR/pkg/txmgr/txmgr_test.go: `.GetTransactionStatus(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `.Nonce(1)`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.NewString(terminallyStuckClientError, true)`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertTx(ctx, tx)`
$DIR/pkg/txmgr/txmgr_test.go: `.GetTransactionStatus(ctx, idempotencyKey)`
$DIR/pkg/txmgr/txmgr_test.go: `.New()`
$DIR/pkg/txmgr/txmgr_test.go: `.String()`
$DIR/pkg/txmgr/txmgr_test.go: `.MustCreate(t)`
$DIR/pkg/txmgr/txmgr_test.go: `.NewString(errorMsg, true)`
$DIR/pkg/txmgr/txmgr_test.go: `.InsertTx(ctx, tx)`
$DIR/pkg/txmgr/txmgr_test.go: `.GetTransactionStatus(ctx, idempotencyKey)`
$DIR/pkg/types/address_test.go: `zeroAddress = types.EIP55Address("")`
$DIR/pkg/types/address_test.go: `err = zeroAddress.UnmarshalText([]byte("0xa0788FC17B1dEe36f057c42B6F373A34B014687e"))`
$DIR/pkg/types/address_test.go: `t.Run(test.name, func(t *testing.T) {
			_, err := types.NewEIP55Address(test.input)
			valid := err == nil
			assert.Equal(t, test.valid, valid)
		})`
$DIR/pkg/types/address_test.go: `err = eip55New.Scan(val)`
$DIR/pkg/types/address_test.go: `err = collectionNew.Scan(val)`
$DIR/pkg/types/address_test.go: `eip55 = types.EIP55AddressFromAddress(common.HexToAddress("0x1"))`
$DIR/pkg/types/address_test.go: `.EIP55Address("0xa0788FC17B1dEe36f057c42B6F373A34B014687e")`
$DIR/pkg/types/address_test.go: `.SetString("a0788FC17B1dEe36f057c42B6F373A34B014687e", 16)`
$DIR/pkg/types/address_test.go: `.EIP55Address("")`
$DIR/pkg/types/address_test.go: `.Unmarshal([]byte(`"0xa0788FC17B1dEe36f057c42B6F373A34B014687e"`), &zeroAddress)`
$DIR/pkg/types/address_test.go: `.EIP55Address("")`
$DIR/pkg/types/address_test.go: `.UnmarshalText([]byte("0xa0788FC17B1dEe36f057c42B6F373A34B014687e"))`
$DIR/pkg/types/address_test.go: `.String()`
$DIR/pkg/types/address_test.go: `.Run(test.name, func(t *testing.T) {
			_, err := types.NewEIP55Address(test.input)
			valid := err == nil
			assert.Equal(t, test.valid, valid)
		})`
$DIR/pkg/types/address_test.go: `.NewEIP55Address(test.input)`
$DIR/pkg/types/address_test.go: `.HexToAddress("0xa0788FC17B1dEe36f057c42B6F373A34B014687e")`
$DIR/pkg/types/address_test.go: `.EIP55AddressFromAddress(addr)`
$DIR/pkg/types/address_test.go: `.Address()`
$DIR/pkg/types/address_test.go: `.NewEIP55Address("0xa0788FC17B1dEe36f057c42B6F373A34B014687e")`
$DIR/pkg/types/address_test.go: `.Value()`
$DIR/pkg/types/address_test.go: `.Scan(val)`
$DIR/pkg/types/address_test.go: `.EIP55Address("0xa0788FC17B1dEe36f057c42B6F373A34B0146111")`
$DIR/pkg/types/address_test.go: `.EIP55Address("0xa0788FC17B1dEe36f057c42B6F373A34B0146222")`
$DIR/pkg/types/address_test.go: `.Value()`
$DIR/pkg/types/address_test.go: `.Scan(val)`
$DIR/pkg/types/address_test.go: `.EIP55AddressFromAddress(common.HexToAddress("0x0"))`
$DIR/pkg/types/address_test.go: `.HexToAddress("0x0")`
$DIR/pkg/types/address_test.go: `.EIP55AddressFromAddress(common.HexToAddress("0x1"))`
$DIR/pkg/types/address_test.go: `.HexToAddress("0x1")`
$DIR/pkg/types/address_test.go: `.IsZero()`
$DIR/pkg/types/head_test.go: `result.IsFinalized.Store(true)`
$DIR/pkg/types/head_test.go: `t.Run(tc.Name, func(t *testing.T) {
			actual := tc.Head.LatestFinalizedHead()
			if tc.Finalized == nil {
				assert.Nil(t, actual)
			} else {
				require.NotNil(t, actual)
				assert.Equal(t, tc.Finalized.Number, actual.BlockNumber())
			}
		})`
$DIR/pkg/types/head_test.go: `t.Run(testCase.Name, func(t *testing.T) {
			assert.Equal(t, testCase.ExpectedResult, testCase.Chain.ChainString())
		})`
$DIR/pkg/types/head_test.go: `.IsFinalized.Store(true)`
$DIR/pkg/types/head_test.go: `.Run(tc.Name, func(t *testing.T) {
			actual := tc.Head.LatestFinalizedHead()
			if tc.Finalized == nil {
				assert.Nil(t, actual)
			} else {
				require.NotNil(t, actual)
				assert.Equal(t, tc.Finalized.Number, actual.BlockNumber())
			}
		})`
$DIR/pkg/types/head_test.go: `.Head.LatestFinalizedHead()`
$DIR/pkg/types/head_test.go: `.Run(testCase.Name, func(t *testing.T) {
			assert.Equal(t, testCase.ExpectedResult, testCase.Chain.ChainString())
		})`
$DIR/pkg/types/models_test.go: `t.Run(test.want, func(t *testing.T) {
			num := NewHead(test.input, utils.NewHash(), utils.NewHash(), nil)
			assert.Equal(t, test.want, fmt.Sprintf("%x", num.ToInt()))
		})`
$DIR/pkg/types/models_test.go: `t.Run(test.name, func(t *testing.T) {
			assert.Equal(t, test.greater, test.left.GreaterThan(test.right))
		})`
$DIR/pkg/types/models_test.go: `t.Run(test.name, func(t *testing.T) {
			assert.Equal(t, test.want, test.bn.NextInt())
		})`
$DIR/pkg/types/models_test.go: `head.Parent.Store(&Head{})`
$DIR/pkg/types/models_test.go: `head.Parent.Load().Parent.Store(&Head{})`
$DIR/pkg/types/models_test.go: `h2.Parent.Store(h1)`
$DIR/pkg/types/models_test.go: `h3.Parent.Store(h2)`
$DIR/pkg/types/models_test.go: `t.Run(strconv.Itoa(i), func(t *testing.T) {
			actual, err := test.ary.SafeByteSlice(test.start, test.end)
			assert.NoError(t, err)
			assert.Equal(t, test.expected, actual)
		})`
$DIR/pkg/types/models_test.go: `t.Run(strconv.Itoa(i), func(t *testing.T) {
			actual, err := test.ary.SafeByteSlice(test.start, test.end)
			assert.EqualError(t, err, "out of bounds slice access")
			var expected []byte
			assert.Equal(t, expected, actual)
		})`
$DIR/pkg/types/models_test.go: `h3.Parent.Store(h2)`
$DIR/pkg/types/models_test.go: `h2.Parent.Store(h1)`
$DIR/pkg/types/models_test.go: `h2.Parent.Store(h1)`
$DIR/pkg/types/models_test.go: `h3.Parent.Store(h2)`
$DIR/pkg/types/models_test.go: `_, err = h3.HeadAtHeight(0)`
$DIR/pkg/types/models_test.go: `h2.Parent.Store(h1)`
$DIR/pkg/types/models_test.go: `h3.Parent.Store(h2)`
$DIR/pkg/types/models_test.go: `t.Run(test.name, func(t *testing.T) {
			b, err := os.ReadFile(test.path)
			require.NoError(t, err)
			data := gjson.ParseBytes(b)
			var receipt gethtypes.Receipt
			require.NoError(t, json.Unmarshal([]byte(data.Get("result").String()), &receipt))
			require.Equal(t, test.want, ReceiptIndicatesRunLogFulfillment(receipt))
		})`
$DIR/pkg/types/models_test.go: `t.Run(test.name, func(t *testing.T) {
			var head Head
			err := head.UnmarshalJSON([]byte(test.json))
			require.NoError(t, err)
			assert.Equal(t, test.expected.Hash, head.Hash)
			assert.Equal(t, test.expected.Number, head.Number)
			assert.Equal(t, test.expected.ParentHash, head.ParentHash)
			assert.Equal(t, test.expected.Timestamp.UTC().Unix(), head.Timestamp.UTC().Unix())
			assert.Equal(t, test.expected.L1BlockNumber, head.L1BlockNumber)
			assert.Equal(t, test.expected.ReceiptsRoot, head.ReceiptsRoot)
			assert.Equal(t, test.expected.TransactionsRoot, head.TransactionsRoot)
			assert.Equal(t, test.expected.StateRoot, head.StateRoot)
		})`
$DIR/pkg/types/models_test.go: `t.Run(test.name, func(t *testing.T) {
			bs, err := test.head.MarshalJSON()
			require.NoError(t, err)
			require.Equal(t, test.expected, string(bs))
		})`
$DIR/pkg/types/models_test.go: `t.Run("unmarshals parity block", func(t *testing.T) {
		b := new(Block)
		err := b.UnmarshalJSON([]byte(paritySampleBlock))
		assert.NoError(t, err)

		assert.Equal(t, int64(32473599), b.Number)
		assert.Equal(t, "0x0ec62c2a397e114d84ce932387d841787d7ec5757ceba3708386da87934b7c82", b.Hash.Hex())
		assert.Equal(t, "0x3aa1c729fb45888bc1ce777d00bad9637c0b5f7cb48b145ebacc16098e0132d4", b.ParentHash.Hex())
		assert.Equal(t, assets.NewWeiI(7), b.BaseFeePerGas)
		assert.Equal(t, int64(1656602604), b.Timestamp.Unix())
		assert.Len(t, b.Transactions, 2)
	})`
$DIR/pkg/types/models_test.go: `t.Run("unmarshals geth block", func(t *testing.T) {
		b := new(Block)
		err := b.UnmarshalJSON([]byte(gethSampleBlock))
		require.NoError(t, err)

		assert.Equal(t, int64(15051090), b.Number)
		assert.Equal(t, "0x45eb0a650b6b0b9fd1ee676b870e43fa7614f1034f7404070327a332faed05c0", b.Hash.Hex())
		assert.Equal(t, "0x653ea251c180d93296ef79378e64d7dc9a74f565a54df477faeb64d3330977dd", b.ParentHash.Hex())
		assert.Equal(t, assets.NewWeiI(39678999761), b.BaseFeePerGas)
		assert.Equal(t, int64(1656603143), b.Timestamp.Unix())
		assert.Len(t, b.Transactions, 7)
	})`
$DIR/pkg/types/models_test.go: `t.Run("handles empty result", func(t *testing.T) {
		b := new(Block)
		err := b.UnmarshalJSON([]byte("null"))
		require.Error(t, err)
		assert.Equal(t, pkgerrors.Cause(err), ErrMissingBlock)
		assert.True(t, pkgerrors.Is(err, ErrMissingBlock))
	})`
$DIR/pkg/types/models_test.go: `t.Run("unmarshals EIP-4844 block", func(t *testing.T) {
		b := new(Block)
		err := b.UnmarshalJSON([]byte(eip4844Block))
		require.NoError(t, err)
		assert.Equal(t, int64(5300694), b.Number)
		assert.Equal(t, "0x3edd900025edab70dde26a52377c3d0a9474c3f540bd0131d58f508711272590", b.Hash.Hex())
		assert.Equal(t, "0x077c1d68b52f8203cb90a71759a09b11c2a6577f97ea1fd4a8686a387fbedac8", b.ParentHash.Hex())
		assert.Equal(t, assets.NewWeiI(96436174005), b.BaseFeePerGas)
		assert.Equal(t, int64(1708087260), b.Timestamp.Unix())
		assert.Len(t, b.Transactions, 6)
	})`
$DIR/pkg/types/models_test.go: `t.Run(tt.name, func(t *testing.T) {
			got := &Transaction{}
			err := got.UnmarshalJSON(tt.args.data)
			require.NoError(t, err)
			require.Equal(t, tt.want, got)
		})`
$DIR/pkg/types/models_test.go: `err = json.Unmarshal(d, got)`
$DIR/pkg/types/models_test.go: `err = json.Unmarshal(d, got)`
$DIR/pkg/types/models_test.go: `t.Run("non zero", func(t *testing.T) {
		t.Parallel()
		want := TxType(2)
		d, err := json.Marshal(&want)
		require.NoError(t, err)
		got := new(TxType)
		err = json.Unmarshal(d, got)
		require.NoError(t, err)
		assert.Equal(t, want, *got)
	})`
$DIR/pkg/types/models_test.go: `err = json.Unmarshal(d, got)`
$DIR/pkg/types/models_test.go: `err = json.Unmarshal(d, got)`
$DIR/pkg/types/models_test.go: `t.Run("normal hash", func(t *testing.T) {
		t.Parallel()

		expectedHash := utils.NewHash()
		jsonData := []byte(fmt.Sprintf(`"%s"`, expectedHash.Hex()))

		var hash Hash
		err := json.Unmarshal(jsonData, &hash)
		require.NoError(t, err)

		assert.Equal(t, expectedHash.Bytes(), hash.Bytes())
	})`
$DIR/pkg/types/models_test.go: `t.Run("empty string should return zero hash", func(t *testing.T) {
		t.Parallel()

		jsonData := []byte(`""`)
		var hash Hash
		err := json.Unmarshal(jsonData, &hash)
		require.NoError(t, err)
		assert.Equal(t, zeroHash.Bytes(), hash.Bytes())
	})`
$DIR/pkg/types/models_test.go: `t.Run("0x00", func(t *testing.T) {
		t.Parallel()

		jsonData := []byte(`"0x00"`)
		var hash Hash
		err := json.Unmarshal(jsonData, &hash)
		require.NoError(t, err)

		assert.Equal(t, zeroHash.Bytes(), hash.Bytes())
	})`
$DIR/pkg/types/models_test.go: `t.Run("0x", func(t *testing.T) {
		t.Parallel()

		jsonData := []byte(`"0x"`)
		var hash Hash
		err := json.Unmarshal(jsonData, &hash)
		require.NoError(t, err)

		assert.Equal(t, zeroHash.Bytes(), hash.Bytes())
	})`
$DIR/pkg/types/models_test.go: `t.Run("odd length hex string should fail", func(t *testing.T) {
		t.Parallel()

		jsonData := []byte(`"0x1"`)
		var hash Hash
		err := json.Unmarshal(jsonData, &hash)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "hex string")
	})`
$DIR/pkg/types/models_test.go: `.NewInt(0)`
$DIR/pkg/types/models_test.go: `.NewInt(0xf)`
$DIR/pkg/types/models_test.go: `.NewInt(0x10)`
$DIR/pkg/types/models_test.go: `.Run(test.want, func(t *testing.T) {
			num := NewHead(test.input, utils.NewHash(), utils.NewHash(), nil)
			assert.Equal(t, test.want, fmt.Sprintf("%x", num.ToInt()))
		})`
$DIR/pkg/types/models_test.go: `.NewHash()`
$DIR/pkg/types/models_test.go: `.NewHash()`
$DIR/pkg/types/models_test.go: `.Run(test.name, func(t *testing.T) {
			assert.Equal(t, test.greater, test.left.GreaterThan(test.right))
		})`
$DIR/pkg/types/models_test.go: `.NewInt(2)`
$DIR/pkg/types/models_test.go: `.Run(test.name, func(t *testing.T) {
			assert.Equal(t, test.want, test.bn.NextInt())
		})`
$DIR/pkg/types/models_test.go: `.Parent.Store(&Head{})`
$DIR/pkg/types/models_test.go: `.Parent.Load()`
$DIR/pkg/types/models_test.go: `.Parent.Store(&Head{})`
$DIR/pkg/types/models_test.go: `.ChainLength()`
$DIR/pkg/types/models_test.go: `.Parent.Store(h1)`
$DIR/pkg/types/models_test.go: `.Parent.Store(h2)`
$DIR/pkg/types/models_test.go: `.AsSlice(4)`
$DIR/pkg/types/models_test.go: `.String()`
$DIR/pkg/types/models_test.go: `.String()`
$DIR/pkg/types/models_test.go: `.Unmarshal(bytes, &fid)`
$DIR/pkg/types/models_test.go: `.String()`
$DIR/pkg/types/models_test.go: `.Unmarshal(literalSelectorBytes, &fid)`
$DIR/pkg/types/models_test.go: `.String()`
$DIR/pkg/types/models_test.go: `.Unmarshal(bytes, &fid)`
$DIR/pkg/types/models_test.go: `.Run(strconv.Itoa(i), func(t *testing.T) {
			actual, err := test.ary.SafeByteSlice(test.start, test.end)
			assert.NoError(t, err)
			assert.Equal(t, test.expected, actual)
		})`
$DIR/pkg/types/models_test.go: `.Itoa(i)`
$DIR/pkg/types/models_test.go: `.ary.SafeByteSlice(test.start, test.end)`
$DIR/pkg/types/models_test.go: `.Run(strconv.Itoa(i), func(t *testing.T) {
			actual, err := test.ary.SafeByteSlice(test.start, test.end)
			assert.EqualError(t, err, "out of bounds slice access")
			var expected []byte
			assert.Equal(t, expected, actual)
		})`
$DIR/pkg/types/models_test.go: `.Itoa(i)`
$DIR/pkg/types/models_test.go: `.ary.SafeByteSlice(test.start, test.end)`
$DIR/pkg/types/models_test.go: `.Parent.Store(h2)`
$DIR/pkg/types/models_test.go: `.Parent.Store(h1)`
$DIR/pkg/types/models_test.go: `.EarliestInChain()`
$DIR/pkg/types/models_test.go: `.BlockNumber()`
$DIR/pkg/types/models_test.go: `.BigToHash(big.NewInt(10))`
$DIR/pkg/types/models_test.go: `.NewInt(10)`
$DIR/pkg/types/models_test.go: `.Parent.Store(h1)`
$DIR/pkg/types/models_test.go: `.Parent.Store(h2)`
$DIR/pkg/types/models_test.go: `.HeadAtHeight(2)`
$DIR/pkg/types/models_test.go: `.HeadAtHeight(0)`
$DIR/pkg/types/models_test.go: `.NewHash()`
$DIR/pkg/types/models_test.go: `.NewHash()`
$DIR/pkg/types/models_test.go: `.NewHash()`
$DIR/pkg/types/models_test.go: `.Parent.Store(h1)`
$DIR/pkg/types/models_test.go: `.Parent.Store(h2)`
$DIR/pkg/types/models_test.go: `.IsInChain(common.Hash{})`
$DIR/pkg/types/models_test.go: `.Run(test.name, func(t *testing.T) {
			b, err := os.ReadFile(test.path)
			require.NoError(t, err)
			data := gjson.ParseBytes(b)
			var receipt gethtypes.Receipt
			require.NoError(t, json.Unmarshal([]byte(data.Get("result").String()), &receipt))
			require.Equal(t, test.want, ReceiptIndicatesRunLogFulfillment(receipt))
		})`
$DIR/pkg/types/models_test.go: `.ReadFile(test.path)`
$DIR/pkg/types/models_test.go: `.ParseBytes(b)`
$DIR/pkg/types/models_test.go: `.HexToHash("0x41800b5c3f1717687d85fc9018faac0a6e90b39deaa0b99e7fe4fe796ddeb26a")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x41941023680923e0fe4d74a34bdac8141f2540e3ae90623718e47d66d1ca4a2d")`
$DIR/pkg/types/models_test.go: `.Unix(0x58318da2, 0)`
$DIR/pkg/types/models_test.go: `.UTC()`
$DIR/pkg/types/models_test.go: `.HexToHash("0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421")`
$DIR/pkg/types/models_test.go: `.HexToHash("0xc7b01007a10da045eacb90385887dd0c38fcb5db7393006bdde24b93873c334b")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x41800b5c3f1717687d85fc9018faac0a6e90b39deaa0b99e7fe4fe796ddeb26a")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x41941023680923e0fe4d74a34bdac8141f2540e3ae90623718e47d66d1ca4a2d")`
$DIR/pkg/types/models_test.go: `.Unix(0x58318da2, 0)`
$DIR/pkg/types/models_test.go: `.UTC()`
$DIR/pkg/types/models_test.go: `.HexToHash("0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421")`
$DIR/pkg/types/models_test.go: `.HexToHash("0xc7b01007a10da045eacb90385887dd0c38fcb5db7393006bdde24b93873c334b")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x752dab43f7a2482db39227d46cd307623b26167841e2207e93e7566ab7ab7871")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x923ad1e27c1d43cb2d2fb09e26d2502ca4b4914a2e0599161d279c6c06117d34")`
$DIR/pkg/types/models_test.go: `.Unix(0x60d0952d, 0)`
$DIR/pkg/types/models_test.go: `.UTC()`
$DIR/pkg/types/models_test.go: `.HexToHash("0x2c292672b8fc9d223647a2569e19721f0757c96a1421753a93e141f8e56cf504")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x71448077f5ce420a8e24db62d4d58e8d8e6ad2c7e76318868e089d41f7e0faf3")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x0000000000000000000000000000000000000000000000000000000000000000")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x752dab43f7a2482db39227d46cd307623b26167841e2207e93e7566ab7ab7871")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x923ad1e27c1d43cb2d2fb09e26d2502ca4b4914a2e0599161d279c6c06117d34")`
$DIR/pkg/types/models_test.go: `.Unix(0x60d0952d, 0)`
$DIR/pkg/types/models_test.go: `.UTC()`
$DIR/pkg/types/models_test.go: `.HexToHash("0x2c292672b8fc9d223647a2569e19721f0757c96a1421753a93e141f8e56cf504")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x71448077f5ce420a8e24db62d4d58e8d8e6ad2c7e76318868e089d41f7e0faf3")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x0000000000000000000000000000000000000000000000000000000000000000")`
$DIR/pkg/types/models_test.go: `.Run(test.name, func(t *testing.T) {
			var head Head
			err := head.UnmarshalJSON([]byte(test.json))
			require.NoError(t, err)
			assert.Equal(t, test.expected.Hash, head.Hash)
			assert.Equal(t, test.expected.Number, head.Number)
			assert.Equal(t, test.expected.ParentHash, head.ParentHash)
			assert.Equal(t, test.expected.Timestamp.UTC().Unix(), head.Timestamp.UTC().Unix())
			assert.Equal(t, test.expected.L1BlockNumber, head.L1BlockNumber)
			assert.Equal(t, test.expected.ReceiptsRoot, head.ReceiptsRoot)
			assert.Equal(t, test.expected.TransactionsRoot, head.TransactionsRoot)
			assert.Equal(t, test.expected.StateRoot, head.StateRoot)
		})`
$DIR/pkg/types/models_test.go: `.UnmarshalJSON([]byte(test.json))`
$DIR/pkg/types/models_test.go: `.HexToHash("0x41800b5c3f1717687d85fc9018faac0a6e90b39deaa0b99e7fe4fe796ddeb26a")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x41941023680923e0fe4d74a34bdac8141f2540e3ae90623718e47d66d1ca4a2d")`
$DIR/pkg/types/models_test.go: `.Unix(0x58318da2, 0)`
$DIR/pkg/types/models_test.go: `.UTC()`
$DIR/pkg/types/models_test.go: `.HexToHash("0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421")`
$DIR/pkg/types/models_test.go: `.HexToHash("0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421")`
$DIR/pkg/types/models_test.go: `.HexToHash("0xc7b01007a10da045eacb90385887dd0c38fcb5db7393006bdde24b93873c334b")`
$DIR/pkg/types/models_test.go: `.Run(test.name, func(t *testing.T) {
			bs, err := test.head.MarshalJSON()
			require.NoError(t, err)
			require.Equal(t, test.expected, string(bs))
		})`
$DIR/pkg/types/models_test.go: `.head.MarshalJSON()`
$DIR/pkg/types/models_test.go: `.Run("unmarshals parity block", func(t *testing.T) {
		b := new(Block)
		err := b.UnmarshalJSON([]byte(paritySampleBlock))
		assert.NoError(t, err)

		assert.Equal(t, int64(32473599), b.Number)
		assert.Equal(t, "0x0ec62c2a397e114d84ce932387d841787d7ec5757ceba3708386da87934b7c82", b.Hash.Hex())
		assert.Equal(t, "0x3aa1c729fb45888bc1ce777d00bad9637c0b5f7cb48b145ebacc16098e0132d4", b.ParentHash.Hex())
		assert.Equal(t, assets.NewWeiI(7), b.BaseFeePerGas)
		assert.Equal(t, int64(1656602604), b.Timestamp.Unix())
		assert.Len(t, b.Transactions, 2)
	})`
$DIR/pkg/types/models_test.go: `.UnmarshalJSON([]byte(paritySampleBlock))`
$DIR/pkg/types/models_test.go: `.Run("unmarshals geth block", func(t *testing.T) {
		b := new(Block)
		err := b.UnmarshalJSON([]byte(gethSampleBlock))
		require.NoError(t, err)

		assert.Equal(t, int64(15051090), b.Number)
		assert.Equal(t, "0x45eb0a650b6b0b9fd1ee676b870e43fa7614f1034f7404070327a332faed05c0", b.Hash.Hex())
		assert.Equal(t, "0x653ea251c180d93296ef79378e64d7dc9a74f565a54df477faeb64d3330977dd", b.ParentHash.Hex())
		assert.Equal(t, assets.NewWeiI(39678999761), b.BaseFeePerGas)
		assert.Equal(t, int64(1656603143), b.Timestamp.Unix())
		assert.Len(t, b.Transactions, 7)
	})`
$DIR/pkg/types/models_test.go: `.UnmarshalJSON([]byte(gethSampleBlock))`
$DIR/pkg/types/models_test.go: `.Run("handles empty result", func(t *testing.T) {
		b := new(Block)
		err := b.UnmarshalJSON([]byte("null"))
		require.Error(t, err)
		assert.Equal(t, pkgerrors.Cause(err), ErrMissingBlock)
		assert.True(t, pkgerrors.Is(err, ErrMissingBlock))
	})`
$DIR/pkg/types/models_test.go: `.UnmarshalJSON([]byte("null"))`
$DIR/pkg/types/models_test.go: `.Run("unmarshals EIP-4844 block", func(t *testing.T) {
		b := new(Block)
		err := b.UnmarshalJSON([]byte(eip4844Block))
		require.NoError(t, err)
		assert.Equal(t, int64(5300694), b.Number)
		assert.Equal(t, "0x3edd900025edab70dde26a52377c3d0a9474c3f540bd0131d58f508711272590", b.Hash.Hex())
		assert.Equal(t, "0x077c1d68b52f8203cb90a71759a09b11c2a6577f97ea1fd4a8686a387fbedac8", b.ParentHash.Hex())
		assert.Equal(t, assets.NewWeiI(96436174005), b.BaseFeePerGas)
		assert.Equal(t, int64(1708087260), b.Timestamp.Unix())
		assert.Len(t, b.Transactions, 6)
	})`
$DIR/pkg/types/models_test.go: `.UnmarshalJSON([]byte(eip4844Block))`
$DIR/pkg/types/models_test.go: `.UnmarshalJSON([]byte(eip4844Block))`
$DIR/pkg/types/models_test.go: `.NewWei(mustHexToBig(t, "978a846d2"))`
$DIR/pkg/types/models_test.go: `.NewWei(mustHexToBig(t, "d0892241d"))`
$DIR/pkg/types/models_test.go: `.NewWei(mustHexToBig(t, "3b9aca01"))`
$DIR/pkg/types/models_test.go: `.HexToHash("0x754f49f0a2ca7680806d261dd36ee95ac88a81da59fef0b5d8d691478f075d46")`
$DIR/pkg/types/models_test.go: `.NewWei(mustHexToBig(t, "17d9abf8b5"))`
$DIR/pkg/types/models_test.go: `.NewWei(mustHexToBig(t, "8bb2c97000"))`
$DIR/pkg/types/models_test.go: `.NewWei(mustHexToBig(t, "165a0bc00"))`
$DIR/pkg/types/models_test.go: `.HexToHash("0xa97e14a2e87d322fcb97edc4b25cd976d18963cfad19bfd4b9c8066a6a2d97cf")`
$DIR/pkg/types/models_test.go: `.NewWei(mustHexToBig(t, "4f7915f5"))`
$DIR/pkg/types/models_test.go: `.HexToHash("0xbe6122d6aaf84fb85f4df136d4662c6dc344248e987255c0daa1193b3f17d5a9")`
$DIR/pkg/types/models_test.go: `.Run(tt.name, func(t *testing.T) {
			got := &Transaction{}
			err := got.UnmarshalJSON(tt.args.data)
			require.NoError(t, err)
			require.Equal(t, tt.want, got)
		})`
$DIR/pkg/types/models_test.go: `.UnmarshalJSON(tt.args.data)`
$DIR/pkg/types/models_test.go: `.NewWei(mustHexToBig(t, "978a846d2"))`
$DIR/pkg/types/models_test.go: `.NewWei(mustHexToBig(t, "d0892241d"))`
$DIR/pkg/types/models_test.go: `.NewWei(mustHexToBig(t, "3b9aca01"))`
$DIR/pkg/types/models_test.go: `.HexToHash("0x754f49f0a2ca7680806d261dd36ee95ac88a81da59fef0b5d8d691478f075d46")`
$DIR/pkg/types/models_test.go: `.Marshal(want)`
$DIR/pkg/types/models_test.go: `.Unmarshal(d, got)`
$DIR/pkg/types/models_test.go: `.Marshal(smallBlock)`
$DIR/pkg/types/models_test.go: `.Unmarshal(d, got)`
$DIR/pkg/types/models_test.go: `.Run("non zero", func(t *testing.T) {
		t.Parallel()
		want := TxType(2)
		d, err := json.Marshal(&want)
		require.NoError(t, err)
		got := new(TxType)
		err = json.Unmarshal(d, got)
		require.NoError(t, err)
		assert.Equal(t, want, *got)
	})`
$DIR/pkg/types/models_test.go: `.Marshal(&want)`
$DIR/pkg/types/models_test.go: `.Unmarshal(d, got)`
$DIR/pkg/types/models_test.go: `.Marshal(&want)`
$DIR/pkg/types/models_test.go: `.Unmarshal(d, got)`
$DIR/pkg/types/models_test.go: `.Run("normal hash", func(t *testing.T) {
		t.Parallel()

		expectedHash := utils.NewHash()
		jsonData := []byte(fmt.Sprintf(`"%s"`, expectedHash.Hex()))

		var hash Hash
		err := json.Unmarshal(jsonData, &hash)
		require.NoError(t, err)

		assert.Equal(t, expectedHash.Bytes(), hash.Bytes())
	})`
$DIR/pkg/types/models_test.go: `.NewHash()`
$DIR/pkg/types/models_test.go: `.Sprintf(`"%s"`, expectedHash.Hex())`
$DIR/pkg/types/models_test.go: `.Hex()`
$DIR/pkg/types/models_test.go: `.Unmarshal(jsonData, &hash)`
$DIR/pkg/types/models_test.go: `.Run("empty string should return zero hash", func(t *testing.T) {
		t.Parallel()

		jsonData := []byte(`""`)
		var hash Hash
		err := json.Unmarshal(jsonData, &hash)
		require.NoError(t, err)
		assert.Equal(t, zeroHash.Bytes(), hash.Bytes())
	})`
$DIR/pkg/types/models_test.go: `.Unmarshal(jsonData, &hash)`
$DIR/pkg/types/models_test.go: `.Run("0x00", func(t *testing.T) {
		t.Parallel()

		jsonData := []byte(`"0x00"`)
		var hash Hash
		err := json.Unmarshal(jsonData, &hash)
		require.NoError(t, err)

		assert.Equal(t, zeroHash.Bytes(), hash.Bytes())
	})`
$DIR/pkg/types/models_test.go: `.Unmarshal(jsonData, &hash)`
$DIR/pkg/types/models_test.go: `.Run("0x", func(t *testing.T) {
		t.Parallel()

		jsonData := []byte(`"0x"`)
		var hash Hash
		err := json.Unmarshal(jsonData, &hash)
		require.NoError(t, err)

		assert.Equal(t, zeroHash.Bytes(), hash.Bytes())
	})`
$DIR/pkg/types/models_test.go: `.Unmarshal(jsonData, &hash)`
$DIR/pkg/types/models_test.go: `.Run("odd length hex string should fail", func(t *testing.T) {
		t.Parallel()

		jsonData := []byte(`"0x1"`)
		var hash Hash
		err := json.Unmarshal(jsonData, &hash)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "hex string")
	})`
$DIR/pkg/types/models_test.go: `.Unmarshal(jsonData, &hash)`
$DIR/pkg/types/models_test.go: `.Unmarshal(jsonData, &hash)`
$DIR/pkg/types/types_test.go: `zeroTxHash.TxHash = common.HexToHash("0x0")`
$DIR/pkg/types/types_test.go: `receipt = types.FromGethReceipt(&zeroTxHash)`
$DIR/pkg/types/types_test.go: `zeroBlockHash.BlockHash = common.HexToHash("0x0")`
$DIR/pkg/types/types_test.go: `receipt = types.FromGethReceipt(&zeroBlockHash)`
$DIR/pkg/types/types_test.go: `err = parsedReceipt.UnmarshalJSON(json)`
$DIR/pkg/types/types_test.go: `err = parsedLog.UnmarshalJSON(json)`
$DIR/pkg/types/types_test.go: `.FromGethReceipt(testGethReceipt)`
$DIR/pkg/types/types_test.go: `.FromGethReceipt(testGethReceipt)`
$DIR/pkg/types/types_test.go: `.HexToHash("0x0")`
$DIR/pkg/types/types_test.go: `.FromGethReceipt(&zeroTxHash)`
$DIR/pkg/types/types_test.go: `.IsZero()`
$DIR/pkg/types/types_test.go: `.FromGethReceipt(testGethReceipt)`
$DIR/pkg/types/types_test.go: `.HexToHash("0x0")`
$DIR/pkg/types/types_test.go: `.FromGethReceipt(&zeroBlockHash)`
$DIR/pkg/types/types_test.go: `.IsUnmined()`
$DIR/pkg/types/types_test.go: `.FromGethReceipt(testGethReceipt)`
$DIR/pkg/types/types_test.go: `.MarshalJSON()`
$DIR/pkg/types/types_test.go: `.UnmarshalJSON(json)`
$DIR/pkg/types/types_test.go: `.FromGethLog(testGethLog1)`
$DIR/pkg/types/types_test.go: `.MarshalJSON()`
$DIR/pkg/types/types_test.go: `.UnmarshalJSON(json)`
$DIR/pkg/types/types_test.go: `.DecodeString("2ab9a2dc53736b361b72d900cdf9f78f9406fbbb")`
$DIR/pkg/types/types_test.go: `.DecodeString("56b9a2dc53736b361b72d900cdf9f78f9406fbbb")`
$DIR/pkg/types/types_test.go: `.DecodeString("6b361b72d900cdf9f78f9406fbbb6b361b72d900cdf9f78f9406fbbb")`
$DIR/pkg/types/types_test.go: `.DecodeString("2ab9130c6b361b72d900cdf9f78f9406fbbb6b361b72d900cdf9f78f9406fbbb")`
$DIR/pkg/types/types_test.go: `.DecodeString("56b9a2dc53736b361b72d900cdf9f78f9406fbbb06fbbb6b361b7206fbbb6b36")`
$DIR/pkg/types/types_test.go: `.DecodeString("6b361b72d900cdf9f78f9406fbbb6b361b72d900cdf9f78f9406fbbb")`
$DIR/pkg/utils/big/big_test.go: `t.Run(tc.payload, func(t *testing.T) {
			var b BigFloat
			err := json.Unmarshal([]byte(tc.payload), &b)
			require.NoError(t, err)
			assert.Equal(t, tc.exp.String(), b.Value().String())
		})`
$DIR/pkg/utils/big/big_test.go: `t.Run(tc.payload, func(t *testing.T) {
			var b BigFloat
			err := json.Unmarshal([]byte(tc.payload), &b)
			require.NoError(t, err)
			assert.Equal(t, tc.exp.String(), b.Value().String())
		})`
$DIR/pkg/utils/big/big_test.go: `t.Run(test.name, func(t *testing.T) {
			err := i.UnmarshalText([]byte(test.input))
			require.NoError(t, err)
			assert.Equal(t, test.want, i.ToInt())
		})`
$DIR/pkg/utils/big/big_test.go: `t.Run(test.name, func(t *testing.T) {
			err := i.UnmarshalText([]byte(test.input))
			require.Error(t, err)
		})`
$DIR/pkg/utils/big/big_test.go: `t.Run(test.name, func(t *testing.T) {
			i := (*Big)(test.input)
			b, err := json.Marshal(&i)
			assert.NoError(t, err)
			assert.Equal(t, test.want, string(b))
		})`
$DIR/pkg/utils/big/big_test.go: `t.Run(test.name, func(t *testing.T) {
			i := new(Big)
			err := json.Unmarshal([]byte(test.input), &i)
			assert.NoError(t, err)
			assert.Equal(t, test.want, i)
		})`
$DIR/pkg/utils/big/big_test.go: `t.Run(test.name, func(t *testing.T) {
			i := new(Big)
			err := json.Unmarshal([]byte(test.input), &i)
			assert.Error(t, err)
		})`
$DIR/pkg/utils/big/big_test.go: `t.Run(test.name, func(t *testing.T) {
			big := &Big{}
			err := big.Scan(test.input)
			require.NoError(t, err)
			assert.Equal(t, test.want, big)
		})`
$DIR/pkg/utils/big/big_test.go: `t.Run(test.name, func(t *testing.T) {
			big := &Big{}
			err := big.Scan(test.input)
			require.Error(t, err)
		})`
$DIR/pkg/utils/big/big_test.go: `.NewFloat(1)`
$DIR/pkg/utils/big/big_test.go: `.Marshal(tc.obj)`
$DIR/pkg/utils/big/big_test.go: `.NewFloat(-1)`
$DIR/pkg/utils/big/big_test.go: `.NewFloat(-1)`
$DIR/pkg/utils/big/big_test.go: `.NewFloat(100)`
$DIR/pkg/utils/big/big_test.go: `.NewFloat(100)`
$DIR/pkg/utils/big/big_test.go: `.NewFloat(3.146)`
$DIR/pkg/utils/big/big_test.go: `.NewFloat(3.146)`
$DIR/pkg/utils/big/big_test.go: `.Run(tc.payload, func(t *testing.T) {
			var b BigFloat
			err := json.Unmarshal([]byte(tc.payload), &b)
			require.NoError(t, err)
			assert.Equal(t, tc.exp.String(), b.Value().String())
		})`
$DIR/pkg/utils/big/big_test.go: `.Unmarshal([]byte(tc.payload), &b)`
$DIR/pkg/utils/big/big_test.go: `.NewFloat(-1)`
$DIR/pkg/utils/big/big_test.go: `.NewFloat(100)`
$DIR/pkg/utils/big/big_test.go: `.NewFloat(3.146)`
$DIR/pkg/utils/big/big_test.go: `.RequireFromString("1.000000000000000001")`
$DIR/pkg/utils/big/big_test.go: `.BigFloat()`
$DIR/pkg/utils/big/big_test.go: `.RequireFromString("1000000.000000000000000001")`
$DIR/pkg/utils/big/big_test.go: `.BigFloat()`
$DIR/pkg/utils/big/big_test.go: `.RequireFromString("1000000000.000000000000000001")`
$DIR/pkg/utils/big/big_test.go: `.BigFloat()`
$DIR/pkg/utils/big/big_test.go: `.Run(tc.payload, func(t *testing.T) {
			var b BigFloat
			err := json.Unmarshal([]byte(tc.payload), &b)
			require.NoError(t, err)
			assert.Equal(t, tc.exp.String(), b.Value().String())
		})`
$DIR/pkg/utils/big/big_test.go: `.Unmarshal([]byte(tc.payload), &b)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(1234)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(1234)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(4660)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(4660)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(1234)`
$DIR/pkg/utils/big/big_test.go: `.Run(test.name, func(t *testing.T) {
			err := i.UnmarshalText([]byte(test.input))
			require.NoError(t, err)
			assert.Equal(t, test.want, i.ToInt())
		})`
$DIR/pkg/utils/big/big_test.go: `.UnmarshalText([]byte(test.input))`
$DIR/pkg/utils/big/big_test.go: `.NewInt(0)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(0)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(0)`
$DIR/pkg/utils/big/big_test.go: `.Run(test.name, func(t *testing.T) {
			err := i.UnmarshalText([]byte(test.input))
			require.Error(t, err)
		})`
$DIR/pkg/utils/big/big_test.go: `.UnmarshalText([]byte(test.input))`
$DIR/pkg/utils/big/big_test.go: `.SetString("9223372036854775808", 10)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(0)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(1234)`
$DIR/pkg/utils/big/big_test.go: `.Run(test.name, func(t *testing.T) {
			i := (*Big)(test.input)
			b, err := json.Marshal(&i)
			assert.NoError(t, err)
			assert.Equal(t, test.want, string(b))
		})`
$DIR/pkg/utils/big/big_test.go: `.Marshal(&i)`
$DIR/pkg/utils/big/big_test.go: `.SetString("9223372036854775808", 10)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(0)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(1234)`
$DIR/pkg/utils/big/big_test.go: `.Run(test.name, func(t *testing.T) {
			i := new(Big)
			err := json.Unmarshal([]byte(test.input), &i)
			assert.NoError(t, err)
			assert.Equal(t, test.want, i)
		})`
$DIR/pkg/utils/big/big_test.go: `.Unmarshal([]byte(test.input), &i)`
$DIR/pkg/utils/big/big_test.go: `.Run(test.name, func(t *testing.T) {
			i := new(Big)
			err := json.Unmarshal([]byte(test.input), &i)
			assert.Error(t, err)
		})`
$DIR/pkg/utils/big/big_test.go: `.Unmarshal([]byte(test.input), &i)`
$DIR/pkg/utils/big/big_test.go: `.SetString("115792089237316195423570985008687907853269984665640564039457584007913129639935", 10)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(0)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(1)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(0)`
$DIR/pkg/utils/big/big_test.go: `.NewInt(14)`
$DIR/pkg/utils/big/big_test.go: `.Run(test.name, func(t *testing.T) {
			big := &Big{}
			err := big.Scan(test.input)
			require.NoError(t, err)
			assert.Equal(t, test.want, big)
		})`
$DIR/pkg/utils/big/big_test.go: `.Scan(test.input)`
$DIR/pkg/utils/big/big_test.go: `.Run(test.name, func(t *testing.T) {
			big := &Big{}
			err := big.Scan(test.input)
			require.Error(t, err)
		})`
$DIR/pkg/utils/big/big_test.go: `.Scan(test.input)`
$DIR/pkg/utils/ethabi_test.go: `val, err = EVMWordSignedBigInt(new(big.Int).SetInt64(1))`
$DIR/pkg/utils/ethabi_test.go: `val, err = EVMWordSignedBigInt(new(big.Int).SetInt64(256))`
$DIR/pkg/utils/ethabi_test.go: `val, err = EVMWordSignedBigInt(new(big.Int).SetInt64(-1))`
$DIR/pkg/utils/ethabi_test.go: `val, err = EVMWordSignedBigInt(MaxInt256)`
$DIR/pkg/utils/ethabi_test.go: `val, err = EVMWordSignedBigInt(new(big.Int).Add(MaxInt256, big.NewInt(1)))`
$DIR/pkg/utils/ethabi_test.go: `val, err = EVMWordBigInt(new(big.Int).SetInt64(1))`
$DIR/pkg/utils/ethabi_test.go: `val, err = EVMWordBigInt(new(big.Int).SetInt64(256))`
$DIR/pkg/utils/ethabi_test.go: `val, err = EVMWordBigInt(new(big.Int).SetInt64(-1))`
$DIR/pkg/utils/ethabi_test.go: `val, err = EVMWordBigInt(MaxUint256)`
$DIR/pkg/utils/ethabi_test.go: `val, err = EVMWordBigInt(new(big.Int).Add(MaxUint256, big.NewInt(1)))`
$DIR/pkg/utils/ethabi_test.go: `t.Run(test.name, func(t *testing.T) {
			input := gjson.Parse(test.input)
			out, err := EVMTranscodeBytes(input)
			assert.NoError(t, err)
			assert.Equal(t, test.output, hexutil.Encode(out))
		})`
$DIR/pkg/utils/ethabi_test.go: `t.Run(test.name, func(t *testing.T) {
			out, err := EVMTranscodeBool(test.input)
			assert.NoError(t, err)
			assert.Equal(t, test.output, hexutil.Encode(out))
		})`
$DIR/pkg/utils/ethabi_test.go: `t.Run(test.name, func(t *testing.T) {
			out, err := EVMTranscodeUint256(test.input)
			if test.wantError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, test.output, hexutil.Encode(out))
			}
		})`
$DIR/pkg/utils/ethabi_test.go: `t.Run(test.name, func(t *testing.T) {
			out, err := EVMTranscodeInt256(test.input)
			if test.wantError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, test.output, hexutil.Encode(out))
			}
		})`
$DIR/pkg/utils/ethabi_test.go: `t.Run(test.name, func(t *testing.T) {
			input := gjson.GetBytes([]byte(test.input), "result")
			out, err := EVMTranscodeJSONWithFormat(input, test.format)
			require.NoError(t, err)
			assert.Equal(t, test.output, hexutil.Encode(out))
		})`
$DIR/pkg/utils/ethabi_test.go: `t.Run(tc.name, func(t *testing.T) {
			abiBytes, err := ABIEncode(tc.abiStr, tc.vals...)
			if tc.expectErr {
				t.Log(err)
				require.Error(t, err)
				return
			}
			require.NoError(t, err)
			res, err := ABIDecode(tc.abiStr, abiBytes)
			require.NoError(t, err)
			assert.Equal(t, tc.vals, res)
		})`
$DIR/pkg/utils/ethabi_test.go: `.MustDecode("0x000000000000000000000000000000000000000000000000ffffffffffffffff")`
$DIR/pkg/utils/ethabi_test.go: `.NewInt(1)`
$DIR/pkg/utils/ethabi_test.go: `.NewInt(256)`
$DIR/pkg/utils/ethabi_test.go: `.Sub(pow2(128), big.NewInt(1))`
$DIR/pkg/utils/ethabi_test.go: `.NewInt(1)`
$DIR/pkg/utils/ethabi_test.go: `.NewInt(-1)`
$DIR/pkg/utils/ethabi_test.go: `.SetInt64(1)`
$DIR/pkg/utils/ethabi_test.go: `.SetInt64(256)`
$DIR/pkg/utils/ethabi_test.go: `.SetInt64(-1)`
$DIR/pkg/utils/ethabi_test.go: `.Add(MaxInt256, big.NewInt(1))`
$DIR/pkg/utils/ethabi_test.go: `.NewInt(1)`
$DIR/pkg/utils/ethabi_test.go: `.SetInt64(1)`
$DIR/pkg/utils/ethabi_test.go: `.SetInt64(256)`
$DIR/pkg/utils/ethabi_test.go: `.SetInt64(-1)`
$DIR/pkg/utils/ethabi_test.go: `.Add(MaxUint256, big.NewInt(1))`
$DIR/pkg/utils/ethabi_test.go: `.NewInt(1)`
$DIR/pkg/utils/ethabi_test.go: `.Run(test.name, func(t *testing.T) {
			input := gjson.Parse(test.input)
			out, err := EVMTranscodeBytes(input)
			assert.NoError(t, err)
			assert.Equal(t, test.output, hexutil.Encode(out))
		})`
$DIR/pkg/utils/ethabi_test.go: `.Parse(test.input)`
$DIR/pkg/utils/ethabi_test.go: `.Parse("1e+300")`
$DIR/pkg/utils/ethabi_test.go: `.Parse("{}")`
$DIR/pkg/utils/ethabi_test.go: `.Run(test.name, func(t *testing.T) {
			out, err := EVMTranscodeBool(test.input)
			assert.NoError(t, err)
			assert.Equal(t, test.output, hexutil.Encode(out))
		})`
$DIR/pkg/utils/ethabi_test.go: `.Run(test.name, func(t *testing.T) {
			out, err := EVMTranscodeUint256(test.input)
			if test.wantError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, test.output, hexutil.Encode(out))
			}
		})`
$DIR/pkg/utils/ethabi_test.go: `.Run(test.name, func(t *testing.T) {
			out, err := EVMTranscodeInt256(test.input)
			if test.wantError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, test.output, hexutil.Encode(out))
			}
		})`
$DIR/pkg/utils/ethabi_test.go: `.Run(test.name, func(t *testing.T) {
			input := gjson.GetBytes([]byte(test.input), "result")
			out, err := EVMTranscodeJSONWithFormat(input, test.format)
			require.NoError(t, err)
			assert.Equal(t, test.output, hexutil.Encode(out))
		})`
$DIR/pkg/utils/ethabi_test.go: `.GetBytes([]byte(test.input), "result")`
$DIR/pkg/utils/ethabi_test.go: `.NewInt(10)`
$DIR/pkg/utils/ethabi_test.go: `.NewInt(12)`
$DIR/pkg/utils/ethabi_test.go: `.NewInt(10)`
$DIR/pkg/utils/ethabi_test.go: `.NewInt(1)`
$DIR/pkg/utils/ethabi_test.go: `.NewInt(10)`
$DIR/pkg/utils/ethabi_test.go: `.Run(tc.name, func(t *testing.T) {
			abiBytes, err := ABIEncode(tc.abiStr, tc.vals...)
			if tc.expectErr {
				t.Log(err)
				require.Error(t, err)
				return
			}
			require.NoError(t, err)
			res, err := ABIDecode(tc.abiStr, abiBytes)
			require.NoError(t, err)
			assert.Equal(t, tc.vals, res)
		})`
$DIR/pkg/utils/utils_test.go: `t.Run(test.name, func(t *testing.T) {
			input, err := hexutil.Decode(test.input)
			assert.NoError(t, err)
			result, err := utils.Keccak256(input)
			assert.NoError(t, err)

			assert.Equal(t, test.want, hexutil.Encode(result))
		})`
$DIR/pkg/utils/utils_test.go: `t.Run(test.name, func(t *testing.T) {
			t.Parallel()

			actual := utils.IsEmptyAddress(test.addr)
			assert.Equal(t, test.want, actual)
		})`
$DIR/pkg/utils/utils_test.go: `t.Run(address, func(t *testing.T) {
			a1, err := parse(address)
			require.NoError(t, err)
			no0xPrefix := address[2:]
			a2, err := parse(no0xPrefix)
			require.NoError(t, err)
			assert.Equal(t, a1, a2)
			_, lowerErr := parse(strings.ToLower(address))
			_, upperErr := parse(strings.ToUpper(address))
			shouldBeError := multierr.Combine(lowerErr, upperErr)
			require.ErrorContains(t, shouldBeError, no0xPrefix)

		})`
$DIR/pkg/utils/utils_test.go: `_, err = utils.Uint256ToBytes(large)`
$DIR/pkg/utils/utils_test.go: `_, _ = utils.Uint256ToBytes(negative)`
$DIR/pkg/utils/utils_test.go: `err = utils.CheckUint256(negative)`
$DIR/pkg/utils/utils_test.go: `err = utils.CheckUint256(big.NewInt(123))`
$DIR/pkg/utils/utils_test.go: `b, err = utils.HexToUint256("0xFFFFFFFF")`
$DIR/pkg/utils/utils_test.go: `bs.Sleep()`
$DIR/pkg/utils/utils_test.go: `bs.Min = d`
$DIR/pkg/utils/utils_test.go: `bs.Factor = 2`
$DIR/pkg/utils/utils_test.go: `bs.Sleep()`
$DIR/pkg/utils/utils_test.go: `bs.Reset()`
$DIR/pkg/utils/utils_test.go: `utils.RetryWithBackoff(ctx, func() bool {
		return false
	})`
$DIR/pkg/utils/utils_test.go: `go utils.RetryWithBackoff(ctx, retry)`
$DIR/pkg/utils/utils_test.go: `cancel()`
$DIR/pkg/utils/utils_test.go: `utils.RetryWithBackoff(ctx, retry)`
$DIR/pkg/utils/utils_test.go: `.Run(test.name, func(t *testing.T) {
			input, err := hexutil.Decode(test.input)
			assert.NoError(t, err)
			result, err := utils.Keccak256(input)
			assert.NoError(t, err)

			assert.Equal(t, test.want, hexutil.Encode(result))
		})`
$DIR/pkg/utils/utils_test.go: `.Decode(test.input)`
$DIR/pkg/utils/utils_test.go: `.Keccak256(input)`
$DIR/pkg/utils/utils_test.go: `.BigToAddress(big.NewInt(12345 + math.MaxInt32))`
$DIR/pkg/utils/utils_test.go: `.NewInt(12345 + math.MaxInt32)`
$DIR/pkg/utils/utils_test.go: `.Run(test.name, func(t *testing.T) {
			t.Parallel()

			actual := utils.IsEmptyAddress(test.addr)
			assert.Equal(t, test.want, actual)
		})`
$DIR/pkg/utils/utils_test.go: `.IsEmptyAddress(test.addr)`
$DIR/pkg/utils/utils_test.go: `.Run(address, func(t *testing.T) {
			a1, err := parse(address)
			require.NoError(t, err)
			no0xPrefix := address[2:]
			a2, err := parse(no0xPrefix)
			require.NoError(t, err)
			assert.Equal(t, a1, a2)
			_, lowerErr := parse(strings.ToLower(address))
			_, upperErr := parse(strings.ToUpper(address))
			shouldBeError := multierr.Combine(lowerErr, upperErr)
			require.ErrorContains(t, shouldBeError, no0xPrefix)

		})`
$DIR/pkg/utils/utils_test.go: `.ToLower(address)`
$DIR/pkg/utils/utils_test.go: `.ToUpper(address)`
$DIR/pkg/utils/utils_test.go: `.Combine(lowerErr, upperErr)`
$DIR/pkg/utils/utils_test.go: `.NewInt(0)`
$DIR/pkg/utils/utils_test.go: `.Sub(utils.MaxUint256, big.NewInt(1))`
$DIR/pkg/utils/utils_test.go: `.NewInt(1)`
$DIR/pkg/utils/utils_test.go: `.Uint256ToBytes(v)`
$DIR/pkg/utils/utils_test.go: `.Uint256ToBytes32(v)`
$DIR/pkg/utils/utils_test.go: `.NewInt(0)`
$DIR/pkg/utils/utils_test.go: `.Add(utils.MaxUint256, big.NewInt(1))`
$DIR/pkg/utils/utils_test.go: `.NewInt(1)`
$DIR/pkg/utils/utils_test.go: `.Uint256ToBytes(large)`
$DIR/pkg/utils/utils_test.go: `.NewInt(-1)`
$DIR/pkg/utils/utils_test.go: `.Uint256ToBytes(negative)`
$DIR/pkg/utils/utils_test.go: `.NewInt(0)`
$DIR/pkg/utils/utils_test.go: `.Add(utils.MaxUint256, big.NewInt(1))`
$DIR/pkg/utils/utils_test.go: `.NewInt(1)`
$DIR/pkg/utils/utils_test.go: `.CheckUint256(large)`
$DIR/pkg/utils/utils_test.go: `.NewInt(-123)`
$DIR/pkg/utils/utils_test.go: `.CheckUint256(negative)`
$DIR/pkg/utils/utils_test.go: `.CheckUint256(big.NewInt(123))`
$DIR/pkg/utils/utils_test.go: `.NewInt(123)`
$DIR/pkg/utils/utils_test.go: `.RandUint256()`
$DIR/pkg/utils/utils_test.go: `.HexToUint256("0x00")`
$DIR/pkg/utils/utils_test.go: `.HexToUint256("0xFFFFFFFF")`
$DIR/pkg/utils/utils_test.go: `.Cmp(big.NewInt(4294967295))`
$DIR/pkg/utils/utils_test.go: `.NewInt(4294967295)`
$DIR/pkg/utils/utils_test.go: `.NewHash()`
$DIR/pkg/utils/utils_test.go: `.NewHash()`
$DIR/pkg/utils/utils_test.go: `.HexToHash("0x0")`
$DIR/pkg/utils/utils_test.go: `.PadByteToHash(1)`
$DIR/pkg/utils/utils_test.go: `.String()`
$DIR/pkg/utils/utils_test.go: `.NewBackoffSleeper()`
$DIR/pkg/utils/utils_test.go: `.Sleep()`
$DIR/pkg/utils/utils_test.go: `.Sleep()`
$DIR/pkg/utils/utils_test.go: `.Reset()`
$DIR/pkg/utils/utils_test.go: `.Duration(0)`
$DIR/pkg/utils/utils_test.go: `.Duration()`
$DIR/pkg/utils/utils_test.go: `.WithCancel(tests.Context(t))`
$DIR/pkg/utils/utils_test.go: `.Context(t)`
$DIR/pkg/utils/utils_test.go: `.RetryWithBackoff(ctx, func() bool {
		return false
	})`
$DIR/pkg/utils/utils_test.go: `.Add(1)`
$DIR/pkg/utils/utils_test.go: `.RetryWithBackoff(ctx, retry)`
$DIR/pkg/utils/utils_test.go: `.RetryWithBackoff(ctx, retry)`
$DIR/pkg/utils/utils_test.go: `.Load()`
