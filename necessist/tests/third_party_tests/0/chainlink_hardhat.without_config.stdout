{"emits the buffer"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.setBuffer('0xA161616162')`
{"stores and logs keys and values"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.add('first', 'word!!')`
{"handles two entries"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.add('first', 'uno')`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.add('second', 'dos')`
{"stores and logs keys and values"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.addBytes('first', '0xaabbccddeeff')`
{"handles two entries"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.addBytes('first', '0x756E6F')`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.addBytes('second', '0x646F73')`
{"handles strings"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.addBytes('first', ethers.utils.toUtf8Bytes('apple'))`
{"stores and logs keys and values"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.addInt('first', 1)`
{"handles two entries"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.addInt('first', 1)`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.addInt('second', 2)`
{"stores and logs keys and values"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.addUint('first', 1)`
{"handles two entries"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.addUint('first', 1)`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.addUint('second', 2)`
{"stores and logs keys and values"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `await ccl.addStringArray('word', ['seinfeld', '"4"', 'LIFE'])`
{"handles empty payloads"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.closeEvent()`
{"emits the buffer"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.setBuffer('0xA161616162')`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.closeEvent()`
{"stores and logs keys and values"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.add('first', 'word!!')`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.closeEvent()`
{"handles two entries"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.add('first', 'uno')`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.add('second', 'dos')`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.closeEvent()`
{"stores and logs keys and values"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.addBytes('first', '0xaabbccddeeff')`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.closeEvent()`
{"handles two entries"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.addBytes('first', '0x756E6F')`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.addBytes('second', '0x646F73')`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.closeEvent()`
{"handles strings"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.addBytes('first', ethers.utils.toUtf8Bytes('apple'))`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.utils.toUtf8Bytes('apple')`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.closeEvent()`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.utils.toUtf8Bytes('apple')`
{"stores and logs keys and values"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.addInt('first', 1)`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.closeEvent()`
{"handles two entries"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.addInt('first', 1)`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.addInt('second', 2)`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.closeEvent()`
{"stores and logs keys and values"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.addUint('first', 1)`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.closeEvent()`
{"handles two entries"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.addUint('first', 1)`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.addUint('second', 2)`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.closeEvent()`
{"stores and logs keys and values"}
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.addStringArray('word', ['seinfeld', '"4"', 'LIFE'])`
$DIR/contracts/test/v0.8/Chainlink.test.ts: `.closeEvent()`
{"does not modify the stored oracle address"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `await cc.publicRequestRunTo(
        newoc.address,
        specId,
        cc.address,
        ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'),
        0,
      )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `await cc.publicRequestOracleDataFrom(
        newoc.address,
        specId,
        ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'),
        0,
      )`
{"should only allow one fulfillment per id"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `await oc
        .connect(roles.defaultAccount)
        .fulfillOracleRequest(
          ...convertFufillParams(
            request,
            ethers.utils.formatBytes32String('hi mom!'),
          ),
        )`
{"emits an event marking the request fulfilled"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `await oc.setAuthorizedSenders([await roles.defaultAccount.getAddress()])`
{"should only allow one fulfillment per id"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `await oc
        .connect(roles.defaultAccount)
        .fulfillOracleRequest(
          ...convertFufillParams(
            request,
            ethers.utils.formatBytes32String('hi mom!'),
          ),
        )`
{"allows the external request to be fulfilled"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `await oc.setAuthorizedSenders([await roles.defaultAccount.getAddress()])`
{"forwards the information to the oracle contract through the link token"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicNewRequest(
        specId,
        gs.address,
        ethers.utils.toUtf8Bytes('requestedBytes32(bytes32,bytes32)'),
      )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.toUtf8Bytes('requestedBytes32(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.wait()`
{"emits an event from the contract showing the run ID"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicRequest(
        specId,
        cc.address,
        ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'),
        0,
      )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.wait()`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicRequestRunTo(
        newoc.address,
        specId,
        cc.address,
        ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'),
        0,
      )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.wait()`
{"emits an event on the target oracle contract"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicRequestRunTo(
        newoc.address,
        specId,
        cc.address,
        ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'),
        0,
      )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.wait()`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.interface.parseLog(logs[3])`
{"does not modify the stored oracle address"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicRequestRunTo(
        newoc.address,
        specId,
        cc.address,
        ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'),
        0,
      )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicOracleAddress()`
{"emits an event from the contract showing the run ID"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicRequestOracleData(
        specId,
        ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'),
        0,
      )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.wait()`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicRequestOracleDataFrom(
        newoc.address,
        specId,
        ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'),
        0,
      )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.wait()`
{"emits an event on the target oracle contract"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicRequestOracleDataFrom(
        newoc.address,
        specId,
        ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'),
        0,
      )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.wait()`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.interface.parseLog(logs[3])`
{"does not modify the stored oracle address"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicRequestOracleDataFrom(
        newoc.address,
        specId,
        ethers.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)'),
        0,
      )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.toUtf8Bytes('fulfillRequest(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicOracleAddress()`
{"emits an event from the contract showing the run was cancelled"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicCancelRequest(
        requestId,
        0,
        ethers.utils.hexZeroPad('0x', 4),
        0,
      )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.hexZeroPad('0x', 4)`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.wait()`
{"throws if given a bogus event ID"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicCancelRequest(
          ethers.utils.formatBytes32String('bogusId'),
          0,
          ethers.utils.hexZeroPad('0x', 4),
          0,
        )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.formatBytes32String('bogusId')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.hexZeroPad('0x', 4)`
{"emits an event marking the request fulfilled"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.fulfillOracleRequest(
          ...convertFufillParams(
            request,
            ethers.utils.formatBytes32String('hi mom!'),
          ),
        )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.formatBytes32String('hi mom!')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.wait()`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.interface.parseLog(logs[1])`
{"should only allow one fulfillment per id"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.fulfillOracleRequest(
          ...convertFufillParams(
            request,
            ethers.utils.formatBytes32String('hi mom!'),
          ),
        )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.formatBytes32String('hi mom!')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.fulfillOracleRequest(
            ...convertFufillParams(
              request,
              ethers.utils.formatBytes32String('hi mom!'),
            ),
          )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.formatBytes32String('hi mom!')`
{"should only allow the oracle to fulfill the request"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.fulfillOracleRequest(
            ...convertFufillParams(
              request,
              ethers.utils.formatBytes32String('hi mom!'),
            ),
          )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.formatBytes32String('hi mom!')`
{"emits an event marking the request fulfilled"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.setAuthorizedSenders([await roles.defaultAccount.getAddress()])`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.defaultAccount.getAddress()`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.fulfillOracleRequest(
          ...convertFufillParams(
            request,
            ethers.utils.formatBytes32String('hi mom!'),
          ),
        )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.formatBytes32String('hi mom!')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.wait()`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.interface.parseLog(logs[1])`
{"should only allow one fulfillment per id"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.fulfillOracleRequest(
          ...convertFufillParams(
            request,
            ethers.utils.formatBytes32String('hi mom!'),
          ),
        )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.formatBytes32String('hi mom!')`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.fulfillOracleRequest(
            ...convertFufillParams(
              request,
              ethers.utils.formatBytes32String('hi mom!'),
            ),
          )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.formatBytes32String('hi mom!')`
{"should only allow the oracle to fulfill the request"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.fulfillOracleRequest(
            ...convertFufillParams(
              request,
              ethers.utils.formatBytes32String('hi mom!'),
            ),
          )`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.formatBytes32String('hi mom!')`
{"returns the Link Token address"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicChainlinkToken()`
{"allows the external request to be fulfilled"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.setAuthorizedSenders([await roles.defaultAccount.getAddress()])`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.defaultAccount.getAddress()`
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.utils.formatBytes32String('hi mom!')`
{"does not allow the same requestId to be used"}
$DIR/contracts/test/v0.8/ChainlinkClient.test.ts: `.publicAddExternalRequest(newoc.address, request.requestId)`
{"correctly identifies the next & last ticks for cron jobs [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/Cron.test.ts: `await setTimestamp(timeStamp)`
{"converts all valid cron strings to encoded structs and back"}
$DIR/contracts/test/v0.8/Cron.test.ts: `.map(async (input) => {
            const spec = await cron.encodeCronString(input)
            const output = await cron.encodedSpecToString(spec)
            assert.equal(output, input)
          })`
$DIR/contracts/test/v0.8/Cron.test.ts: `.encodeCronString(input)`
$DIR/contracts/test/v0.8/Cron.test.ts: `.encodedSpecToString(spec)`
{"correctly identifies the next & last ticks for cron jobs [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/Cron.test.ts: `.unix(timeStamp)`
$DIR/contracts/test/v0.8/Cron.test.ts: `.add(30, 'days')`
$DIR/contracts/test/v0.8/Cron.test.ts: `.unix()`
$DIR/contracts/test/v0.8/Cron.test.ts: `.subtract(1, 'day')`
$DIR/contracts/test/v0.8/Cron.test.ts: `.unix()`
$DIR/contracts/test/v0.8/Cron.test.ts: `.add(12, 'hours')`
$DIR/contracts/test/v0.8/Cron.test.ts: `.unix()`
$DIR/contracts/test/v0.8/Cron.test.ts: `.subtract(12, 'hours')`
$DIR/contracts/test/v0.8/Cron.test.ts: `.unix()`
$DIR/contracts/test/v0.8/Cron.test.ts: `.add(2, 'hours')`
$DIR/contracts/test/v0.8/Cron.test.ts: `.add(10, 'minutes')`
$DIR/contracts/test/v0.8/Cron.test.ts: `.unix()`
$DIR/contracts/test/v0.8/Cron.test.ts: `.subtract(17, 'hours')`
$DIR/contracts/test/v0.8/Cron.test.ts: `.subtract(50, 'minutes')`
$DIR/contracts/test/v0.8/Cron.test.ts: `.unix()`
$DIR/contracts/test/v0.8/Cron.test.ts: `.add(2, 'months')`
$DIR/contracts/test/v0.8/Cron.test.ts: `.unix()`
$DIR/contracts/test/v0.8/Cron.test.ts: `.subtract(1, 'months')`
$DIR/contracts/test/v0.8/Cron.test.ts: `.unix()`
$DIR/contracts/test/v0.8/Cron.test.ts: `.calculateNextTick(test.cron)`
$DIR/contracts/test/v0.8/Cron.test.ts: `.calculateLastTick(test.cron)`
{"updates the warning flag"}
$DIR/contracts/test/v0.8/Flags.test.ts: `await flags.connect(personas.Nelly).raiseFlag(consumer.address)`
{"succeeds for the owner"}
$DIR/contracts/test/v0.8/Flags.test.ts: `await flags.connect(personas.Nelly).raiseFlag(consumer.address)`
{"updates the warning flag"}
$DIR/contracts/test/v0.8/Flags.test.ts: `await flags.connect(personas.Nelly).raiseFlags([consumer.address])`
{"succeeds for the owner"}
$DIR/contracts/test/v0.8/Flags.test.ts: `await flags.connect(personas.Nelly).raiseFlags([consumer.address])`
{"updates the warning flag"}
$DIR/contracts/test/v0.8/Flags.test.ts: `await flags.connect(personas.Nelly).lowerFlags([consumer.address])`
{"respects the access controls of #getFlag"}
$DIR/contracts/test/v0.8/Flags.test.ts: `await flags.connect(personas.Nelly).enableAccessCheck()`
$DIR/contracts/test/v0.8/Flags.test.ts: `await flags.connect(personas.Nelly).addAccess(consumer.address)`
{"updates access control rules"}
$DIR/contracts/test/v0.8/Flags.test.ts: `await controller.connect(personas.Nelly).addAccess(neilAddress)`
$DIR/contracts/test/v0.8/Flags.test.ts: `await flags.connect(personas.Neil).raiseFlags([consumer.address])`
$DIR/contracts/test/v0.8/Flags.test.ts: `await flags
        .connect(personas.Nelly)
        .setRaisingAccessController(controller2.address)`
{"does not emit a log when there is no change"}
$DIR/contracts/test/v0.8/Flags.test.ts: `await flags
        .connect(personas.Nelly)
        .setRaisingAccessController(controller2.address)`
{"updates the warning flag"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Nelly)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.raiseFlag(consumer.address)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.getFlag(consumer.address)`
{"emits an event log"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Nelly)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.raiseFlag(consumer.address)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.wait()`
{"sets the flags"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Neil)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.raiseFlag(consumer.address)`
{"succeeds for the owner"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Nelly)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.raiseFlag(consumer.address)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.getFlag(consumer.address)`
{"reverts for non-owner"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Neil)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.raiseFlag(consumer.address)`
{"updates the warning flag"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Nelly)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.raiseFlags([consumer.address])`
$DIR/contracts/test/v0.8/Flags.test.ts: `.getFlag(consumer.address)`
{"emits an event log"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Nelly)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.raiseFlags([consumer.address])`
$DIR/contracts/test/v0.8/Flags.test.ts: `.wait()`
{"sets the flags"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Neil)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.raiseFlags([consumer.address])`
{"succeeds for the owner"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Nelly)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.raiseFlags([consumer.address])`
$DIR/contracts/test/v0.8/Flags.test.ts: `.getFlag(consumer.address)`
{"reverts for non-owners"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Neil)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.raiseFlags([consumer.address])`
{"updates the warning flag"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Nelly)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.lowerFlags([consumer.address])`
$DIR/contracts/test/v0.8/Flags.test.ts: `.getFlag(consumer.address)`
{"emits an event log"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Nelly)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.lowerFlags([consumer.address])`
$DIR/contracts/test/v0.8/Flags.test.ts: `.wait()`
{"respects the access controls of #getFlag"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Nelly)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.enableAccessCheck()`
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Nelly)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.addAccess(consumer.address)`
{"returns the flags in the order they are requested"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.getFlags([
        await personas.Nelly.getAddress(),
        await personas.Neil.getAddress(),
        await personas.Ned.getAddress(),
        await personas.Norbert.getAddress(),
      ])`
$DIR/contracts/test/v0.8/Flags.test.ts: `.Nelly.getAddress()`
$DIR/contracts/test/v0.8/Flags.test.ts: `.Neil.getAddress()`
$DIR/contracts/test/v0.8/Flags.test.ts: `.Ned.getAddress()`
$DIR/contracts/test/v0.8/Flags.test.ts: `.Norbert.getAddress()`
{"updates access control rules"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.Neil.getAddress()`
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Nelly)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.addAccess(neilAddress)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Neil)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.raiseFlags([consumer.address])`
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Nelly)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.setRaisingAccessController(controller2.address)`
{"does not emit a log when there is no change"}
$DIR/contracts/test/v0.8/Flags.test.ts: `.connect(personas.Nelly)`
$DIR/contracts/test/v0.8/Flags.test.ts: `.setRaisingAccessController(controller2.address)`
{"reverts if caller and proxy combination is not allowed"}
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `await requester
        .connect(owner)
        .permitHeartbeat(callerAddress, proxyAddress)`
{"calls corresponding aggregator to request a new round"}
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `aggregatorFactory = await ethers.getContractFactory(
        'MockOffchainAggregator',
      )`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `aggregator = await aggregatorFactory.connect(owner).deploy()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `await aggregator.deployed()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `aggregatorProxyFactory = await ethers.getContractFactory(
        'MockAggregatorProxy',
      )`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `aggregatorProxy = await aggregatorProxyFactory
        .connect(owner)
        .deploy(aggregator.address)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `await aggregatorProxy.deployed()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `await requester
        .connect(owner)
        .permitHeartbeat(await caller1.getAddress(), aggregatorProxy.address)`
{"adds a heartbeat and emits an event"}
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.permitHeartbeat(callerAddress, proxyAddress1)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.permitHeartbeat(callerAddress, proxyAddress2)`
{"reverts when not called by its owner"}
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getAddress()`
{"removes a heartbeat and emits an event"}
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.permitHeartbeat(callerAddress, proxyAddress)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.removeHeartbeat(callerAddress)`
{"reverts if caller and proxy combination is not allowed"}
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.permitHeartbeat(callerAddress, proxyAddress)`
{"calls corresponding aggregator to request a new round"}
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getContractFactory(
        'MockOffchainAggregator',
      )`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.deploy()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.deployed()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getContractFactory(
        'MockAggregatorProxy',
      )`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.deploy(aggregator.address)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.deployed()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.permitHeartbeat(await caller1.getAddress(), aggregatorProxy.address)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.connect(caller1)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getAggregatorAndRequestHeartbeat(aggregatorProxy.address)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.connect(caller1)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.getAggregatorAndRequestHeartbeat(aggregatorProxy.address)`
$DIR/contracts/test/v0.8/HeartbeatRequester.test.ts: `.roundId()`
{"calls target successfully"}
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `await controller
          .connect(personas.Carol)
          .forward(
            counter.address,
            counter.interface.encodeFunctionData('increment'),
          )`
{"adds the permission to the proxy"}
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.connect(personas.Carol)`
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.setPermission(
            await personas.Carol.getAddress(),
            await personas.Eddy.getAddress(),
          )`
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.Carol.getAddress()`
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.wait()`
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.Eddy.getAddress()`
{"removes the permission to the proxy"}
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.connect(personas.Carol)`
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.removePermission(await personas.Carol.getAddress())`
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.Carol.getAddress()`
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.wait()`
{"calls target successfully"}
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.connect(personas.Carol)`
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.forward(
            counter.address,
            counter.interface.encodeFunctionData('increment'),
          )`
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.interface.encodeFunctionData('increment')`
{"reverts when target reverts and bubbles up error"}
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.connect(personas.Carol)`
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.forward(
              counter.address,
              counter.interface.encodeFunctionData('alwaysRevert'),
            )`
$DIR/contracts/test/v0.8/PermissionedForwardProxy.test.ts: `.interface.encodeFunctionData('alwaysRevert')`
{"defaults checkEnabled to true"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.checkEnabled()`
{"allows unauthorized calls originating from the same account"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.connect(personas.Eddy)`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.hasAccess(await personas.Eddy.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.Eddy.getAddress()`
{"blocks unauthorized calls originating from different accounts"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.connect(personas.Eddy)`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.hasAccess(await personas.Carol.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.Carol.getAddress()`
{"adds the address to the controller"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.hasAccess(await personas.Eddy.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.Eddy.getAddress()`
{"announces the change via a log"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.Eddy.getAddress()`
{"does not emit a log"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.addAccess(
            await personas.Eddy.getAddress(),
          )`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.wait()`
{"removes the address from the controller"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.hasAccess(await personas.Eddy.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.Eddy.getAddress()`
{"announces the change via a log"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.Eddy.getAddress()`
{"does not emit a log"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.removeAccess(
            await personas.Eddy.getAddress(),
          )`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.wait()`
{"reverts"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.checkEnabled()`
{"sets checkEnabled to false"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.checkEnabled()`
{"allows users with access"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.hasAccess(await personas.Eddy.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.Eddy.getAddress()`
{"allows users without access"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.hasAccess(await personas.Ned.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.Ned.getAddress()`
{"does not emit a log"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.disableAccessCheck()`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.wait()`
{"allows users with access"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.hasAccess(await personas.Eddy.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.Eddy.getAddress()`
{"does not allow users without access"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.hasAccess(await personas.Ned.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.Ned.getAddress()`
{"does not emit a log"}
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.enableAccessCheck()`
$DIR/contracts/test/v0.8/SimpleReadAccessController.test.ts: `.wait()`
{"defaults checkEnabled to true"}
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.checkEnabled()`
{"allows unauthorized calls originating from the same account"}
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.connect(personas.Eddy)`
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.hasAccess(await personas.Eddy.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.Eddy.getAddress()`
{"blocks unauthorized calls originating from different accounts"}
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.connect(personas.Eddy)`
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.hasAccess(await personas.Carol.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.Carol.getAddress()`
{"adds the address to the controller"}
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.hasAccess(await personas.Eddy.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.Eddy.getAddress()`
{"announces the change via a log"}
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.Eddy.getAddress()`
{"removes the address from the controller"}
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.hasAccess(await personas.Eddy.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.Eddy.getAddress()`
{"announces the change via a log"}
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.Eddy.getAddress()`
{"reverts"}
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.checkEnabled()`
{"sets checkEnabled to false"}
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.checkEnabled()`
{"allows users with access"}
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.hasAccess(await personas.Eddy.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.Eddy.getAddress()`
{"allows users without access"}
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.hasAccess(await personas.Ned.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.Ned.getAddress()`
{"allows users with access"}
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.hasAccess(await personas.Eddy.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.Eddy.getAddress()`
{"does not allow users without access"}
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.hasAccess(await personas.Ned.getAddress(), '0x00')`
$DIR/contracts/test/v0.8/SimpleWriteAccessController.test.ts: `.Ned.getAddress()`
{"should revert if no change in proposal"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `await validatorProxy.proposeNewAggregator(newAggregatorAddress)`
{"should set the correct address and hasProposal is true"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `await validatorProxy.proposeNewAggregator(newAggregatorAddress)`
{"should set a zero address and hasProposal is false"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `await validatorProxy.proposeNewAggregator(newAggregatorAddress)`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `await validatorProxy.proposeNewAggregator(constants.AddressZero)`
{"should upgrade the addresses"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `await validatorProxy.upgradeAggregator()`
{"should revert if no change in proposal"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `await validatorProxy.proposeNewValidator(newValidatorAddress)`
{"should set the correct address and hasProposal is true"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `await validatorProxy.proposeNewValidator(newValidatorAddress)`
{"should set a zero address and hasProposal is false"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `await validatorProxy.proposeNewValidator(newValidatorAddress)`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `await validatorProxy.proposeNewValidator(constants.AddressZero)`
{"should upgrade the addresses"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `await validatorProxy.upgradeValidator()`
{"reverts when there is no validator set"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `validatorProxy = await vpf.deploy(
          aggregatorAddress,
          constants.AddressZero,
        )`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `await validatorProxy.deployed()`
{"should set the aggregator addresses correctly"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.getAggregators()`
{"should set the validator addresses conrrectly"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.getValidators()`
{"should set the owner correctly"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.owner()`
{"should revert if no change in proposal"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.proposeNewAggregator(newAggregatorAddress)`
{"should set the correct address and hasProposal is true"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.proposeNewAggregator(newAggregatorAddress)`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.getAggregators()`
{"should set a zero address and hasProposal is false"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.proposeNewAggregator(newAggregatorAddress)`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.proposeNewAggregator(constants.AddressZero)`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.getAggregators()`
{"should upgrade the addresses"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.upgradeAggregator()`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.getAggregators()`
{"should revert if no change in proposal"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.proposeNewValidator(newValidatorAddress)`
{"should set the correct address and hasProposal is true"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.proposeNewValidator(newValidatorAddress)`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.getValidators()`
{"should set a zero address and hasProposal is false"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.proposeNewValidator(newValidatorAddress)`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.proposeNewValidator(constants.AddressZero)`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.getValidators()`
{"should upgrade the addresses"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.upgradeValidator()`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.getValidators()`
{"reverts when there is no validator set"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.getContractFactory(
          'src/v0.8/ValidatorProxy.sol:ValidatorProxy',
          owner,
        )`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.deploy(
          aggregatorAddress,
          constants.AddressZero,
        )`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.deployed()`
{"uses a specific amount of gas [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.connect(aggregator)`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.validate(200, 300, 400, 500)`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.wait()`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.connect(aggregator)`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.validate(2000, 3000, 4000, 5000)`
$DIR/contracts/test/v0.8/ValidatorProxy.test.ts: `.wait()`
{"Compares gas usage amongst registries / registrars"}
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `await registrar12.setRegistrationConfig(
      autoApproveType,
      autoApproveMaxAllowed,
      registry12.address,
      minUpkeepSpend,
    )`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `await registry20
      .connect(owner)
      .setConfig(signers, transmitters, f, onchainConfig20, 1, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `await registry21
      .connect(owner)
      .setConfigTypeSafe(signers, transmitters, f, onchainConfig21, 1, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `await linkToken.connect(owner).approve(registrar20.address, amount)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `await linkToken.connect(owner).approve(registrar21.address, amount)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `tx = await registrar20.connect(owner).registerUpkeep({
      name,
      encryptedEmail,
      upkeepContract: upkeep.address,
      gasLimit,
      adminAddress: ownerAddress,
      checkData,
      amount,
      offchainConfig,
    })`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `tx = await registrar21.connect(owner).registerUpkeep({
      name,
      encryptedEmail,
      upkeepContract: upkeep.address,
      gasLimit,
      adminAddress: ownerAddress,
      triggerType,
      checkData,
      amount,
      triggerConfig,
      offchainConfig,
    })`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.deploy()`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.deploy(0, gasWei)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.deploy(9, linkEth)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.deploy()`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.deploy(
      linkToken.address,
      autoApproveType,
      autoApproveMaxAllowed,
      ethers.constants.AddressZero, // set later
      minUpkeepSpend,
    )`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.deploy(linkToken.address, linkEthFeed.address, gasPriceFeed.address, {
        paymentPremiumPPB,
        flatFeeMicroLink,
        blockCountPerTurn,
        checkGasLimit,
        stalenessSeconds,
        gasCeilingMultiplier,
        minUpkeepSpend,
        maxPerformGas,
        fallbackGasPrice,
        fallbackLinkPrice,
        transcoder,
        registrar: registrar12.address,
      })`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.setRegistrationConfig(
      autoApproveType,
      autoApproveMaxAllowed,
      registry12.address,
      minUpkeepSpend,
    )`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.deploy(0, linkToken.address, linkEthFeed.address, gasPriceFeed.address)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.deploy(registryLogic20.address)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.deploy(
        linkToken.address,
        autoApproveType,
        autoApproveMaxAllowed,
        registry20.address,
        minUpkeepSpend,
      )`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.utils.defaultAbiCoder.encode(
      [
        'tuple(uint32 paymentPremiumPPB,uint32 flatFeeMicroLink,uint32 checkGasLimit,uint24 stalenessSeconds\
            ,uint16 gasCeilingMultiplier,uint96 minUpkeepSpend,uint32 maxPerformGas,uint32 maxCheckDataSize,\
            uint32 maxPerformDataSize,uint256 fallbackGasPrice,uint256 fallbackLinkPrice,address transcoder,\
            address registrar)',
      ],
      [config20],
    )`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.setConfig(signers, transmitters, f, onchainConfig20, 1, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.deploy()`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.deploy(linkToken.address, registry21.address, minUpkeepSpend, [
        {
          triggerType,
          autoApproveType,
          autoApproveMaxAllowed,
        },
      ])`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.setConfigTypeSafe(signers, transmitters, f, onchainConfig21, 1, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.approve(registrar20.address, amount)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.approve(registrar21.address, amount)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.interface.encodeFunctionData(
      'register',
      [
        name,
        encryptedEmail,
        upkeep.address,
        gasLimit,
        ownerAddress,
        checkData,
        amount,
        source,
        ownerAddress,
      ],
    )`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.transferAndCall(registrar12.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.registerUpkeep({
      name,
      encryptedEmail,
      upkeepContract: upkeep.address,
      gasLimit,
      adminAddress: ownerAddress,
      checkData,
      amount,
      offchainConfig,
    })`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationGasAnalysis.test.ts: `.registerUpkeep({
      name,
      encryptedEmail,
      upkeepContract: upkeep.address,
      gasLimit,
      adminAddress: ownerAddress,
      triggerType,
      checkData,
      amount,
      triggerConfig,
      offchainConfig,
    })`
{"has not changed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_1.test.ts: `.utils.id(AutomationRegistrarFactory.bytecode)`
{"Auto Approve ON - registers an upkeep on KeeperRegistry instantly and emits both RegistrationRequested and RegistrationApproved events"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar
        .connect(registrarOwner)
        .setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_ALL,
          maxAllowedAutoApprove,
        )`
{"Auto Approve ON - ignores the amount passed in and uses the actual amount sent"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar
        .connect(registrarOwner)
        .setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_ALL,
          maxAllowedAutoApprove,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await linkToken
        .connect(requestSender)
        .transferAndCall(registrar.address, amount, abiEncodedBytes)`
{"Auto Approve OFF - does not registers an upkeep on KeeperRegistry, emits only RegistrationRequested event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar
        .connect(registrarOwner)
        .setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_DISABLED,
          maxAllowedAutoApprove,
        )`
{"Auto Approve ON - Throttle max approvals - does not register an upkeep on KeeperRegistry beyond the max limit, emits only RegistrationRequested event after limit is hit"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar
        .connect(registrarOwner)
        .setTriggerConfig(Trigger.CONDITION, autoApproveType_ENABLED_ALL, 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar
        .connect(registrarOwner)
        .setTriggerConfig(Trigger.LOG, autoApproveType_ENABLED_ALL, 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await linkToken
        .connect(requestSender)
        .transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `abiEncodedBytes = encodeRegistrationParams({
        name: upkeepName,
        encryptedEmail: emptyBytes,
        upkeepContract: mock.address,
        gasLimit: performGas.toNumber() + 1, // make unique hash
        adminAddress: await admin.getAddress(),
        checkData: emptyBytes,
        triggerType: Trigger.CONDITION,
        triggerConfig: trigger,
        offchainConfig,
        amount,
        billingToken: linkToken.address,
      })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await linkToken
        .connect(requestSender)
        .transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `abiEncodedBytes = encodeRegistrationParams({
        name: upkeepName,
        encryptedEmail: emptyBytes,
        upkeepContract: mock.address,
        gasLimit: performGas, // make unique hash
        adminAddress: await admin.getAddress(),
        checkData: emptyBytes,
        triggerType: Trigger.LOG,
        triggerConfig: trigger,
        offchainConfig,
        amount,
        billingToken: linkToken.address,
      })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await linkToken
        .connect(requestSender)
        .transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar
        .connect(registrarOwner)
        .setTriggerConfig(Trigger.CONDITION, autoApproveType_ENABLED_ALL, 2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `abiEncodedBytes = encodeRegistrationParams({
        name: upkeepName,
        encryptedEmail: emptyBytes,
        upkeepContract: mock.address,
        gasLimit: performGas.toNumber() + 2, // make unique hash
        adminAddress: await admin.getAddress(),
        checkData: emptyBytes,
        triggerType: Trigger.CONDITION,
        triggerConfig: trigger,
        offchainConfig,
        amount,
        billingToken: linkToken.address,
      })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await linkToken
        .connect(requestSender)
        .transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `abiEncodedBytes = encodeRegistrationParams({
        name: upkeepName,
        encryptedEmail: emptyBytes,
        upkeepContract: mock.address,
        gasLimit: performGas.toNumber() + 3, // make unique hash
        adminAddress: await admin.getAddress(),
        checkData: emptyBytes,
        triggerType: Trigger.CONDITION,
        triggerConfig: trigger,
        offchainConfig,
        amount,
        billingToken: linkToken.address,
      })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await linkToken
        .connect(requestSender)
        .transferAndCall(registrar.address, amount, abiEncodedBytes)`
{"Auto Approve Sender Allowlist - sender in allowlist - registers an upkeep on KeeperRegistry instantly and emits both RegistrationRequested and RegistrationApproved events"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar
        .connect(registrarOwner)
        .setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_SENDER_ALLOWLIST,
          maxAllowedAutoApprove,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar
        .connect(registrarOwner)
        .setAutoApproveAllowedSender(senderAddress, true)`
{"Auto Approve Sender Allowlist - sender NOT in allowlist - does not registers an upkeep on KeeperRegistry, emits only RegistrationRequested event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar
        .connect(registrarOwner)
        .setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_SENDER_ALLOWLIST,
          maxAllowedAutoApprove,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar
        .connect(registrarOwner)
        .setAutoApproveAllowedSender(senderAddress, false)`
{"reverts if the amount passed in data is less than configured minimum"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await linkToken.connect(requestSender).approve(registrar.address, amt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar
        .connect(registrarOwner)
        .setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_ALL,
          maxAllowedAutoApprove,
        )`
{"reverts if the billing token is not supported"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await linkToken
        .connect(requestSender)
        .approve(registrar.address, minimumRegistrationAmount)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar
        .connect(registrarOwner)
        .setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_ALL,
          maxAllowedAutoApprove,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registry
        .connect(owner)
        .setConfigTypeSafe(keepers, keepers, 1, onchainConfig, 1, '0x', [], [])`
{"Auto Approve ON - registers an upkeep on KeeperRegistry instantly and emits both RegistrationRequested and RegistrationApproved events"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar
        .connect(registrarOwner)
        .setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_ALL,
          maxAllowedAutoApprove,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await linkToken.connect(requestSender).approve(registrar.address, amount)`
{"sets the allowed status correctly and emits log"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `tx = await registrar
        .connect(registrarOwner)
        .setAutoApproveAllowedSender(senderAddress, false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `senderAllowedStatus = await registrar
        .connect(owner)
        .getAutoApproveAllowedSender(senderAddress)`
{"changes the config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar.getTriggerRegistrationDetails(Trigger.LOG)`
{"deletes the request afterwards / reverts if the request DNE"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar.connect(registrarOwner).approve({
        name: upkeepName,
        encryptedEmail: emptyBytes,
        upkeepContract: mock.address,
        gasLimit: performGas,
        adminAddress: await admin.getAddress(),
        checkData: emptyBytes,
        triggerType: Trigger.CONDITION,
        triggerConfig: trigger,
        offchainConfig,
        amount,
        billingToken: linkToken.address,
      })`
{"deletes the request hash"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await registrar.connect(registrarOwner).cancel(hash)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `await evmRevertCustomError(tx, registrar, errorMsgs.requestNotFound)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `tx = registrar.connect(registrarOwner).approve({
        name: upkeepName,
        encryptedEmail: emptyBytes,
        upkeepContract: mock.address,
        gasLimit: performGas,
        adminAddress: await admin.getAddress(),
        checkData: emptyBytes,
        triggerType: Trigger.CONDITION,
        triggerConfig: trigger,
        offchainConfig: emptyBytes,
        amount,
        billingToken: linkToken.address,
      })`
{"uses the correct type and version"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.typeAndVersion()`
{"reverts if not called by the LINK token"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(someAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.onTokenTransfer(await someAddress.getAddress(), 0, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
{"reverts if the admin address is 0x0000..."}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.transferAndCall(registrar.address, amount, abiEncodedBytes)`
{"Auto Approve ON - registers an upkeep on KeeperRegistry instantly and emits both RegistrationRequested and RegistrationApproved events"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_ALL,
          maxAllowedAutoApprove,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getActiveUpkeepIDs(0, 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getUpkeep(id)`
{"Auto Approve ON - ignores the amount passed in and uses the actual amount sent"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_ALL,
          maxAllowedAutoApprove,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.mul(10)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getActiveUpkeepIDs(0, 1)`
{"Auto Approve OFF - does not registers an upkeep on KeeperRegistry, emits only RegistrationRequested event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_DISABLED,
          maxAllowedAutoApprove,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getPendingRequest(hash)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.eq(pendingRequest[1])`
{"Auto Approve ON - Throttle max approvals - does not register an upkeep on KeeperRegistry beyond the max limit, emits only RegistrationRequested event after limit is hit"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setTriggerConfig(Trigger.CONDITION, autoApproveType_ENABLED_ALL, 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setTriggerConfig(Trigger.LOG, autoApproveType_ENABLED_ALL, 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setTriggerConfig(Trigger.CONDITION, autoApproveType_ENABLED_ALL, 2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getState()`
{"Auto Approve Sender Allowlist - sender in allowlist - registers an upkeep on KeeperRegistry instantly and emits both RegistrationRequested and RegistrationApproved events"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_SENDER_ALLOWLIST,
          maxAllowedAutoApprove,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setAutoApproveAllowedSender(senderAddress, true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getActiveUpkeepIDs(0, 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getUpkeep(id)`
{"Auto Approve Sender Allowlist - sender NOT in allowlist - does not registers an upkeep on KeeperRegistry, emits only RegistrationRequested event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_SENDER_ALLOWLIST,
          maxAllowedAutoApprove,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setAutoApproveAllowedSender(senderAddress, false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.transferAndCall(registrar.address, amount, abiEncodedBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getPendingRequest(hash)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.eq(pendingRequest[1])`
{"reverts with empty message if amount sent is not available in LINK allowance"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(someAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.registerUpkeep({
          name: upkeepName,
          upkeepContract: mock.address,
          gasLimit: performGas,
          adminAddress: await admin.getAddress(),
          triggerType: Trigger.CONDITION,
          checkData: emptyBytes,
          triggerConfig: trigger,
          offchainConfig: emptyBytes,
          amount,
          encryptedEmail: emptyBytes,
          billingToken: linkToken.address,
        })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
{"reverts if the amount passed in data is less than configured minimum"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.sub(1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.approve(registrar.address, amt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_ALL,
          maxAllowedAutoApprove,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.registerUpkeep({
          name: upkeepName,
          upkeepContract: mock.address,
          gasLimit: performGas,
          adminAddress: await admin.getAddress(),
          triggerType: Trigger.CONDITION,
          checkData: emptyBytes,
          triggerConfig: trigger,
          offchainConfig: emptyBytes,
          amount: amt,
          encryptedEmail: emptyBytes,
          billingToken: linkToken.address,
        })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
{"reverts if the billing token is not supported"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.approve(registrar.address, minimumRegistrationAmount)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_ALL,
          maxAllowedAutoApprove,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setConfigTypeSafe(keepers, keepers, 1, onchainConfig, 1, '0x', [], [])`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.registerUpkeep({
          name: upkeepName,
          upkeepContract: mock.address,
          gasLimit: performGas,
          adminAddress: await admin.getAddress(),
          triggerType: Trigger.CONDITION,
          checkData: emptyBytes,
          triggerConfig: trigger,
          offchainConfig: emptyBytes,
          amount: minimumRegistrationAmount,
          encryptedEmail: emptyBytes,
          billingToken: linkToken.address,
        })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
{"Auto Approve ON - registers an upkeep on KeeperRegistry instantly and emits both RegistrationRequested and RegistrationApproved events"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setTriggerConfig(
          Trigger.CONDITION,
          autoApproveType_ENABLED_ALL,
          maxAllowedAutoApprove,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.approve(registrar.address, amount)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(requestSender)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.registerUpkeep({
        name: upkeepName,
        upkeepContract: mock.address,
        gasLimit: performGas,
        adminAddress: await admin.getAddress(),
        triggerType: Trigger.CONDITION,
        checkData: emptyBytes,
        triggerConfig: trigger,
        offchainConfig,
        amount,
        encryptedEmail: emptyBytes,
        billingToken: linkToken.address,
      })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getActiveUpkeepIDs(0, 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getUpkeep(id)`
{"reverts if not called by the owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setAutoApproveAllowedSender(await admin.getAddress(), false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
{"sets the allowed status correctly and emits log"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setAutoApproveAllowedSender(senderAddress, true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAutoApproveAllowedSender(senderAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setAutoApproveAllowedSender(senderAddress, false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAutoApproveAllowedSender(senderAddress)`
{"reverts if not called by the owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setTriggerConfig(Trigger.LOG, autoApproveType_ENABLED_ALL, 100)`
{"changes the config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.setTriggerConfig(Trigger.LOG, autoApproveType_ENABLED_ALL, 100)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getTriggerRegistrationDetails(Trigger.LOG)`
{"reverts if not called by the owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.approve({
        name: upkeepName,
        encryptedEmail: emptyBytes,
        upkeepContract: mock.address,
        gasLimit: performGas,
        adminAddress: await admin.getAddress(),
        checkData: emptyBytes,
        triggerType: Trigger.CONDITION,
        triggerConfig: trigger,
        offchainConfig: emptyBytes,
        amount,
        billingToken: linkToken.address,
      })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
{"reverts if the hash does not exist"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.approve({
        name: upkeepName,
        encryptedEmail: emptyBytes,
        upkeepContract: mock.address,
        gasLimit: performGas,
        adminAddress: await admin.getAddress(),
        checkData: emptyBytes,
        triggerType: Trigger.CONDITION,
        triggerConfig: trigger,
        offchainConfig: emptyBytes,
        amount,
        billingToken: linkToken.address,
      })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
{"reverts if any member of the payload changes"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.Wallet.createRandom()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.add(1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.add(1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.assign({}, params, field)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.approve(badParams)`
{"approves an existing registration request"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.approve({
        name: upkeepName,
        encryptedEmail: emptyBytes,
        upkeepContract: mock.address,
        gasLimit: performGas,
        adminAddress: await admin.getAddress(),
        checkData: emptyBytes,
        triggerType: Trigger.CONDITION,
        triggerConfig: trigger,
        offchainConfig,
        amount,
        billingToken: linkToken.address,
      })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
{"deletes the request afterwards / reverts if the request DNE"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.approve({
        name: upkeepName,
        encryptedEmail: emptyBytes,
        upkeepContract: mock.address,
        gasLimit: performGas,
        adminAddress: await admin.getAddress(),
        checkData: emptyBytes,
        triggerType: Trigger.CONDITION,
        triggerConfig: trigger,
        offchainConfig,
        amount,
        billingToken: linkToken.address,
      })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.approve({
        name: upkeepName,
        encryptedEmail: emptyBytes,
        upkeepContract: mock.address,
        gasLimit: performGas,
        adminAddress: await admin.getAddress(),
        checkData: emptyBytes,
        triggerType: Trigger.CONDITION,
        triggerConfig: trigger,
        offchainConfig,
        amount,
        billingToken: linkToken.address,
      })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
{"reverts if not called by the admin / owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.cancel(hash)`
{"reverts if the hash does not exist"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.cancel(
          '0x000000000000000000000000322813fd9a801c5507c9de605d63cea4f2ce6c44',
        )`
{"refunds the total request balance to the admin address if owner cancels"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.balanceOf(await admin.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.cancel(hash)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.balanceOf(await admin.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
{"refunds the total request balance to the admin address if admin cancels"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.balanceOf(await admin.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.cancel(hash)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.balanceOf(await admin.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
{"deletes the request hash"}
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.cancel(hash)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.cancel(hash)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.connect(registrarOwner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.approve({
        name: upkeepName,
        encryptedEmail: emptyBytes,
        upkeepContract: mock.address,
        gasLimit: performGas,
        adminAddress: await admin.getAddress(),
        checkData: emptyBytes,
        triggerType: Trigger.CONDITION,
        triggerConfig: trigger,
        offchainConfig: emptyBytes,
        amount,
        billingToken: linkToken.address,
      })`
$DIR/contracts/test/v0.8/automation/AutomationRegistrar2_3.test.ts: `.getAddress()`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).pause()`
{"reverts when report data lengths mismatches"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `upkeepIds.push(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `gasLimits.push(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `triggers.push('0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `performDatas.push('0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `performDatas.push('0x')`
{"performs even when the upkeep has insufficient funds and the upkeep pays out all the remaining balance"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).addFunds(upkeepId, BigNumber.from(10))`
{"returns early when check block number is less than last perform (block)"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await tx.wait()`
{"handles case when check block number is older than 256 blocks"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await ethers.provider.send('evm_mine', [])`
{"allows bypassing reorg protection with reorgProtectionEnabled false config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `newConfig.reorgProtectionEnabled = false`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry // used to test initial configurations
          .connect(owner)
          .setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
          )`
{"allows very old trigger block numbers when bypassing reorg protection with reorgProtectionEnabled config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `newConfig.reorgProtectionEnabled = false`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry // used to test initial configurations
          .connect(owner)
          .setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await ethers.provider.send('evm_mine', [])`
{"allows very old trigger block numbers when bypassing reorg protection with empty blockhash"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await ethers.provider.send('evm_mine', [])`
{"returns early when future block number is provided as trigger, irrespective of blockhash being present"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `tx = await getTransmitTx(registry, keeper1, [id], {
            checkBlockNum: latestBlock.number + 100,
            checkBlockHash: latestBlock.hash,
          })`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `receipt = await tx.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `reorgedUpkeepReportLogs = parseReorgedUpkeepReportLogs(receipt)`
{"returns early when future block number is provided as trigger, irrespective of reorgProtectionEnabled config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `newConfig.reorgProtectionEnabled = false`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry // used to test initial configurations
          .connect(owner)
          .setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `tx = await getTransmitTx(registry, keeper1, [id], {
            checkBlockNum: latestBlock.number + 100,
            checkBlockHash: latestBlock.hash,
          })`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `receipt = await tx.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `reorgedUpkeepReportLogs = parseReorgedUpkeepReportLogs(receipt)`
{"returns early when upkeep is cancelled and cancellation delay has gone"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await ethers.provider.send('evm_mine', [])`
{"does not revert if the target cannot execute"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanPerform(false)`
{"does not revert if the target runs out of gas"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanPerform(false)`
{"executes the data passed to the registry"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `parsedLogs.push(iface.parseLog(log))`
{"uses actual execution price for payment and premium calculation"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanPerform(true)`
{"only pays at a rate up to the gas ceiling [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanPerform(true)`
{"correctly accounts for l payment"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await arbRegistry.connect(owner).addFunds(testUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `tx = await getTransmitTx(
          arbRegistry,
          keeper1,
          [testUpkeepId],

          { gasPrice: gasWei.mul('5') }, // High gas price so that it gets capped
        )`
{"can self cancel"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).addFunds(afUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await autoFunderUpkeep.setIsEligible(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await autoFunderUpkeep.setShouldCancel(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await getTransmitTx(registry, keeper1, [afUpkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `registration = await registry.getUpkeep(afUpkeepId)`
{"has enough perform gas overhead for large batches [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `upkeepIds.push(testUpkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).addFunds(testUpkeepId, toWei('10'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setPerformGasToBurn(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `totalPerformGas = totalPerformGas.add(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await evmRevert(
        getTransmitTx(registry, keeper1, upkeepIds, {
          gasLimit: totalPerformGas,
        }),
      )`
{"splits l2 payment among performed upkeeps according to perform data weight"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `upkeepIds.push(testUpkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await arbRegistry.connect(owner).addFunds(testUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `pd += '11'`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `performDatas.push(pd)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `upkeepCalldataWeights.push(w)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `totalCalldataWeight = totalCalldataWeight.add(w)`
{"allows any funds that have been accidentally transfered to be moved"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).recoverFunds()`
{"calculates the minimum balance appropriately"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).addFunds(upkeepId, tooLow)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).addFunds(upkeepId, oneWei)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `checkUpkeepResult = await registry
        .connect(zeroAddress)
        .callStatic['checkUpkeep(uint256)'](upkeepId)`
{"uses maxPerformData size in checkUpkeep but actual performDataSize in transmit"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).addFunds(upkeepID, minBalance1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `maxPerformData += '11'`
{"allows the admin to withdraw"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).cancelUpkeep(upkeepId)`
{"can be called successively on two upkeeps"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
          .connect(admin)
          .withdrawFunds(upkeepId, await payee1.getAddress())`
{"moves the funds out and updates the balance and emits an event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `registration = await registry.getUpkeep(upkeepId)`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).pause()`
{"returns false and gasUsed when perform fails"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanPerform(false)`
{"returns true, gasUsed, and performGas when perform succeeds"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanPerform(true)`
{"returns correct amount of gasUsed when perform succeeds"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setPerformGasToBurn(performGas)`
{"returns false and error code if the upkeep is cancelled by admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"returns false and error code if the upkeep is cancelled by owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).cancelUpkeep(upkeepId)`
{"returns false and error code if the registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).pause()`
{"returns false and error code if the upkeep is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).pauseUpkeep(upkeepId)`
{"returns false, error code, and revert data if the target check reverts"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setShouldRevertCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCheckRevertReason(
          'custom revert error, clever way to insert offchain data',
        )`
{"returns false, error code, and no revert data if the target check revert data exceeds maxRevertDataSize"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setShouldRevertCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `longRevertReason += 'x'`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCheckRevertReason(longRevertReason)`
{"returns false and error code if the upkeep is not needed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanCheck(false)`
{"returns false and error code if the performData exceeds limit"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `longBytes += '1'`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setPerformData(longBytes)`
{"returns true with gas used if the target can execute"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mock.setPerformData(randomBytes)`
{"calls checkLog for log-trigger upkeeps"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await ltUpkeep.mock.checkLog.withArgs(log, '0x').returns(true, '0x1234')`
{"adds to the balance of the registration"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).addFunds(upkeepId, amount)`
{"lets anyone add funds to an upkeep not just admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await linkToken.connect(owner).transfer(await payee1.getAddress(), amount)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await linkToken.connect(payee1).approve(registry.address, amount)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(payee1).addFunds(upkeepId, amount)`
{"reverts if the upkeep is canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"reverts if startIndex is out of bounds "}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await evmRevertCustomError(
        registry.getActiveUpkeepIDs(numUpkeeps, 0),
        registry,
        'IndexOutOfRange',
      )`
{"returns upkeep IDs bounded by maxCount"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `upkeepIds = await registry.getActiveUpkeepIDs(1, 3)`
{"returns all upkeep IDs if maxCount is 0"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `upkeepIds = await registry.getActiveUpkeepIDs(2, 0)`
{"uses the fallback gas price if the feed has issues"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await gasPriceFeed
        .connect(owner)
        .updateRoundData(roundId, answer, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `roundId = 100`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `updatedAt = now()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `startedAt = 946684799`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await gasPriceFeed
        .connect(owner)
        .updateRoundData(roundId, -100, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `roundId = 101`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `updatedAt = now()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `startedAt = 946684799`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await gasPriceFeed
        .connect(owner)
        .updateRoundData(roundId, 0, updatedAt, startedAt)`
{"uses the fallback link price if the feed has issues"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await linkEthFeed
        .connect(owner)
        .updateRoundData(roundId, answer, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `roundId = 100`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `updatedAt = now()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `startedAt = 946684799`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await linkEthFeed
        .connect(owner)
        .updateRoundData(roundId, -100, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `roundId = 101`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `updatedAt = now()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `startedAt = 946684799`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await linkEthFeed
        .connect(owner)
        .updateRoundData(roundId, 0, updatedAt, startedAt)`
{"reverts if not called with more or less than 32 bytes"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await evmRevert(
        linkToken
          .connect(owner)
          .transferAndCall(registry.address, amount, longData),
      )`
{"reverts if the upkeep is canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"updates the funds of the job id passed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await linkToken
        .connect(owner)
        .transferAndCall(registry.address, amount, data)`
{"reverts if signers or transmitters are the zero address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await evmRevertCustomError(
        registry
          .connect(owner)
          .setConfigTypeSafe(
            [randomAddress(), randomAddress(), randomAddress(), zeroAddress],
            [
              randomAddress(),
              randomAddress(),
              randomAddress(),
              randomAddress(),
            ],
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
          ),
        registry,
        'InvalidSigner',
      )`
{"updates the onchainConfig and configDigest"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
        .connect(owner)
        .setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
        )`
{"maintains paused state when config is changed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.pause()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
        .connect(owner)
        .setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
        )`
{"reverts if too many keeperAddresses set"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `newKeepers.push(randomAddress())`
{"reverts if signers <= 3f"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `newKeepers.pop()`
{"allows the owner to set the peer registries"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.setPeerRegistryMigrationPermission(peer, 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `permission = await registry.getPeerRegistryMigrationPermission(peer)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.setPeerRegistryMigrationPermission(peer, 2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `permission = await registry.getPeerRegistryMigrationPermission(peer)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.setPeerRegistryMigrationPermission(peer, 0)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `permission = await registry.getPeerRegistryMigrationPermission(peer)`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).pause()`
{"reverts if checkData is too long"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `longBytes += '1'`
{"reverts if the upkeep is already canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"reverts if the upkeep is already paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).pauseUpkeep(upkeepId)`
{"reverts if the upkeep is already canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).cancelUpkeep(upkeepId)`
{"marks the contract as paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).pause()`
{"reverts if the caller is not the upkeep admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).pauseUpkeep(upkeepId)`
{"unpauses the upkeep and emits an event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).pauseUpkeep(upkeepId)`
{"reverts if the upkeep is cancelled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"is allowed to update on paused upkeep"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).setUpkeepCheckData(upkeepId, randomBytes)`
{"reverts if new data exceeds limit"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `longBytes += '1'`
{"reverts if the upkeep is canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"reverts if new gas limit is out of bounds"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await evmRevertCustomError(
        registry
          .connect(admin)
          .setUpkeepGasLimit(upkeepId, BigNumber.from('100')),
        registry,
        'GasLimitOutsideRange',
      )`
{"updates the gas limit successfully"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).setUpkeepGasLimit(upkeepId, newGasLimit)`
{"reverts if the upkeep is canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"updates the config successfully"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).setUpkeepOffchainConfig(upkeepId, newConfig)`
{"reverts if the upkeep is canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"reverts when the upkeep is cancelled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"allows cancelling transfer by reverting to zero address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
        .connect(admin)
        .transferUpkeepAdmin(upkeepId, await payee1.getAddress())`
{"does not change the upkeep admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
        .connect(admin)
        .transferUpkeepAdmin(upkeepId, await payee1.getAddress())`
{"does not emit an event when called with the same proposed upkeep admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
        .connect(admin)
        .transferUpkeepAdmin(upkeepId, await payee1.getAddress())`
{"reverts when the upkeep is cancelled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"does change the admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(payee1).acceptUpkeepAdmin(upkeepId)`
{"does not change the payee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
        .connect(payee1)
        .transferPayeeship(
          await keeper1.getAddress(),
          await payee2.getAddress(),
        )`
{"does not emit an event when called with the same proposal"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
        .connect(payee1)
        .transferPayeeship(
          await keeper1.getAddress(),
          await payee2.getAddress(),
        )`
{"does change the payee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(payee2).acceptPayeeship(await keeper1.getAddress())`
{"marks the contract as paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).pause()`
{"Does not allow transmits when paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).pause()`
{"Does not allow creation of new upkeeps when paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).pause()`
{"marks the contract as not paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).unpause()`
{"migrates an upkeep"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
          .connect(admin)
          .setUpkeepOffchainConfig(upkeepId, offchainBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
          .connect(admin)
          .transferUpkeepAdmin(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
          .connect(admin)
          .migrateUpkeeps([upkeepId], mgRegistry.address)`
{"migrates a paused upkeep"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
          .connect(admin)
          .migrateUpkeeps([upkeepId], mgRegistry.address)`
{"reverts"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.setPeerRegistryMigrationPermission(mgRegistry.address, 0)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mgRegistry.setPeerRegistryMigrationPermission(registry.address, 0)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.setPeerRegistryMigrationPermission(mgRegistry.address, 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mgRegistry.setPeerRegistryMigrationPermission(registry.address, 0)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.setPeerRegistryMigrationPermission(mgRegistry.address, 0)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mgRegistry.setPeerRegistryMigrationPermission(registry.address, 2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.setPeerRegistryMigrationPermission(mgRegistry.address, 2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await mgRegistry.setPeerRegistryMigrationPermission(registry.address, 1)`
{"reverts if the payee is the zero address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await blankRegistry.connect(owner).setConfigTypeSafe(...baseConfig)`
{"does not change the payee if IGNORE_ADDRESS is used as payee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await blankRegistry // used to test initial configurations
        .connect(owner)
        .setConfigTypeSafe(
          signers,
          keepers,
          f,
          config,
          offchainVersion,
          offchainBytes,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await blankRegistry.connect(owner).setPayees(payees)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await blankRegistry // used to test initial configurations
        .connect(owner)
        .setConfigTypeSafe(
          [...signers, randomAddress()],
          [...keepers, newTransmitter],
          f,
          config,
          offchainVersion,
          offchainBytes,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await blankRegistry.connect(owner).setPayees(newPayees)`
{"immediately prevents upkeep"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).cancelUpkeep(upkeepId)`
{"does not revert if reverts if called multiple times"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).cancelUpkeep(upkeepId)`
{"reverts if called again by the admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"reverts if called by the owner after the timeout"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await ethers.provider.send('evm_mine', [])`
{"immediately prevents upkeep"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await linkToken.connect(owner).approve(registry.address, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).addFunds(upkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await ethers.provider.send('evm_mine', [])`
{"deducts a cancellation fee from the upkeep and gives to owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              paymentPremiumPPB,
              flatFeeMicroLink,
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              minUpkeepSpend,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: chainModuleBase.address,
              reorgProtectionEnabled: true,
            },
            offchainVersion,
            offchainBytes,
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"deducts up to balance as cancellation fee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              paymentPremiumPPB,
              flatFeeMicroLink,
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              minUpkeepSpend,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: chainModuleBase.address,
              reorgProtectionEnabled: true,
            },
            offchainVersion,
            offchainBytes,
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"does not deduct cancellation fee if more than minUpkeepSpend is spent"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(owner).setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              paymentPremiumPPB,
              flatFeeMicroLink,
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              minUpkeepSpend,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: chainModuleBase.address,
              reorgProtectionEnabled: true,
            },
            offchainVersion,
            offchainBytes,
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"updates the balances"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
        .connect(payee1)
        .withdrawPayment(await keeper1.getAddress(), to)`
{"returns false with appropriate failure reason when target callback reverts"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await streamsLookupUpkeep.setShouldRevertCallback(true)`
{"returns false with appropriate failure reason when target callback returns big performData"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `longBytes += '11'`
{"returns false with appropriate failure reason when target callback returns false"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await streamsLookupUpkeep.setCallbackReturnBool(false)`
{"splits premium evenly across transmitters"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await getTransmitTx(registry, keeper2, [upkeepId])`
{"updates last collected upon payment withdrawn"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `await registry
        .connect(payee1)
        .withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pause()`
{"reverts when report data lengths mismatches"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.push(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.push(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.push('0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.push('0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.push('0x')`
{"returns early when invalid upkeepIds are included in report"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(BigNumber.from('1'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('1')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"performs even when the upkeep has insufficient funds and the upkeep pays out all the remaining balance"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(upkeepId, BigNumber.from(10))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(10)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
{"handles duplicate upkeepIDs"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"handles duplicate log triggers"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.utils.solidityKeccak256(
          ['uint256', 'bytes32', 'bytes32', 'uint32'],
          [logUpkeepId, logBlockHash, txHash, logIndex],
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"returns early when check block number is less than last perform (block)"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.getBlock(lastPerformed)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"handles case when check block hash does not match"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"handles case when check block number is older than 256 blocks"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.getBlock(latestBlock.number - 256)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"allows bypassing reorg protection with empty blockhash"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"allows bypassing reorg protection with reorgProtectionEnabled false config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `// used to test initial configurations
          .connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"allows very old trigger block numbers when bypassing reorg protection with reorgProtectionEnabled config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `// used to test initial configurations
          .connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.getBlock(latestBlock.number - 256)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"allows very old trigger block numbers when bypassing reorg protection with empty blockhash"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"returns early when future block number is provided as trigger, irrespective of blockhash being present"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"returns early when future block number is provided as trigger, irrespective of reorgProtectionEnabled config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `// used to test initial configurations
          .connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"returns early when upkeep is cancelled and cancellation delay has gone"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"does not revert if the target cannot execute"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanPerform(false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"does not revert if the target runs out of gas"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanPerform(false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"executes the data passed to the registry"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.push(iface.parseLog(log))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.parseLog(log)`
{"uses actual execution price for payment and premium calculation"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul(BigNumber.from('1'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('1')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.sub(registryPremiumBefore)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('1')`
{"only pays at a rate up to the gas ceiling [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul(BigNumber.from('10'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('10')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"correctly accounts for l payment"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(1000000)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(testUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul('5')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"can self cancel"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(afUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setIsEligible(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setShouldCancel(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(afUpkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(afUpkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.lt(oldExpiration)`
{"reverts when configDigest mismatches"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.slice(0, f + 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transmit(
              [reportContext[0], reportContext[1], reportContext[2]],
              report,
              sigs.rs,
              sigs.ss,
              sigs.vs,
            )`
{"reverts with incorrect number of signatures"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.slice(0, f + 2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transmit(
              [reportContext[0], reportContext[1], reportContext[2]],
              report,
              sigs.rs,
              sigs.ss,
              sigs.vs,
            )`
{"reverts with invalid signature for inactive signers"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.Wallet.createRandom()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.Wallet.createRandom()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transmit(
              [reportContext[0], reportContext[1], reportContext[2]],
              report,
              sigs.rs,
              sigs.ss,
              sigs.vs,
            )`
{"reverts with invalid signature for duplicated signers"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transmit(
              [reportContext[0], reportContext[1], reportContext[2]],
              report,
              sigs.rs,
              sigs.ss,
              sigs.vs,
            )`
{"has enough perform gas overhead for large batches [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('0')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.deploy()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.push(testUpkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(testUpkeepId, toWei('10'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPerformGasToBurn(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(transmitGasOverhead)`
{"splits l2 payment among performed upkeeps according to perform data weight"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('0')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(1000000)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.deploy()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.push(testUpkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(testUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.push(pd)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(performDataSizes[i])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(registryTransmitCalldataFixedBytesOverhead)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(
            registryTransmitCalldataPerSignerBytesOverhead.mul(
              BigNumber.from(f + 1),
            ),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul(
              BigNumber.from(f + 1),
            )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(f + 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.push(w)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(w)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul('5')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"reverts if not called by owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.recoverFunds()`
{"allows any funds that have been accidentally transfered to be moved"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(await owner.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.recoverFunds()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(await owner.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.eq(ownerBefore.add(sent))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(sent)`
{"calculates the minimum balance appropriately"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getMinBalanceForUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.sub(oneWei)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(upkeepId, tooLow)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(upkeepId, oneWei)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
{"uses maxPerformData size in checkUpkeep but actual performDataSize in transmit"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getMinBalanceForUpkeep(upkeepID)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.sub(
        1,
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(upkeepID, minBalance1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul(gasCeilingMultiplier)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"reverts if called on a non existing ID"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.withdrawFunds(upkeepId.add(1), await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts if called by anyone but the admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.withdrawFunds(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts if called on an uncanceled upkeep"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.withdrawFunds(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts if called with the 0 address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.withdrawFunds(upkeepId, zeroAddress)`
{"allows the admin to withdraw"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getBalance(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
{"can be called successively on two upkeeps"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.withdrawFunds(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"moves the funds out and updates the balance and emits an event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(
          await payee1.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.withdrawFunds(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
{"reverts if called by non zero address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(await owner.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
{"returns false and gasUsed when perform fails"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanPerform(false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('0')`
{"returns true, gasUsed, and performGas when perform succeeds"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('0')`
{"returns correct amount of gasUsed when perform succeeds"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPerformGasToBurn(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.gasUsed.gt(
          performGas.sub(BigNumber.from('1000')),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.sub(BigNumber.from('1000'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('1000')`
{"reverts if called by non zero address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(await owner.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"returns false and error code if the upkeep is cancelled by admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the upkeep is cancelled by owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the upkeep is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
{"returns false and error code if user is out of funds"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
{"returns false, error code, and revert data if the target check reverts"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setShouldRevertCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCheckRevertReason(
          'custom revert error, clever way to insert offchain data',
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.performData.slice(10)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.linkNative.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('0')`
{"returns false, error code, and no revert data if the target check revert data exceeds maxRevertDataSize"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setShouldRevertCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCheckRevertReason(longRevertReason)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the upkeep is not needed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanCheck(false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the performData exceeds limit"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPerformData(longBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
{"returns true with gas used if the target can execute"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPerformData(randomBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.linkNative.eq(linkEth)`
{"calls checkLog for log-trigger upkeeps"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.utils.randomBytes(1000)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mock.checkLog.withArgs(log, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.returns(true, '0x1234')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
{"reverts if the registration does not exist"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(upkeepId.add(1), amount)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(1)`
{"adds to the balance of the registration"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(upkeepId, amount)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.eq(registration.balance)`
{"lets anyone add funds to an upkeep not just admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transfer(await payee1.getAddress(), amount)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.approve(registry.address, amount)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(upkeepId, amount)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.eq(registration.balance)`
{"emits a log"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(upkeepId, amount)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts if the upkeep is canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(upkeepId, amount)`
{"reverts if startIndex is out of bounds "}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getActiveUpkeepIDs(numUpkeeps, 0)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getActiveUpkeepIDs(numUpkeeps + 1, 0)`
{"returns upkeep IDs bounded by maxCount"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getActiveUpkeepIDs(0, 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getActiveUpkeepIDs(1, 3)`
{"returns as many ids as possible if maxCount > num available"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getActiveUpkeepIDs(1, numUpkeeps + 100)`
{"returns all upkeep IDs if maxCount is 0"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getActiveUpkeepIDs(0, 0)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getActiveUpkeepIDs(2, 0)`
{"uses the fallback gas price if the feed has issues"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getGasOverhead()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(registryPerSignerGasOverhead.mul(f + 1))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul(f + 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(
            maxPerformDataSize
              .add(registryTransmitCalldataFixedBytesOverhead)
              .add(
                registryTransmitCalldataPerSignerBytesOverhead.mul(
                  BigNumber.from(f + 1),
                ),
              )
              .mul(
                registryPerPerformByteGasOverhead.add(
                  chainModuleOverheads.chainModulePerByteOverhead,
                ),
              ),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(registryTransmitCalldataFixedBytesOverhead)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(
                registryTransmitCalldataPerSignerBytesOverhead.mul(
                  BigNumber.from(f + 1),
                ),
              )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul(
                  BigNumber.from(f + 1),
                )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(f + 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul(
                registryPerPerformByteGasOverhead.add(
                  chainModuleOverheads.chainModulePerByteOverhead,
                ),
              )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(
                  chainModuleOverheads.chainModulePerByteOverhead,
                )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(chainModuleOverheads.chainModuleFixedOverhead)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul('2')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.updateRoundData(roundId, answer, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.updateRoundData(roundId, -100, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.updateRoundData(roundId, 0, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getMaxPaymentForGas(Trigger.CONDITION, performGas)`
{"uses the fallback link price if the feed has issues"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getGasOverhead()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(registryPerSignerGasOverhead.mul(f + 1))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul(f + 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(
            maxPerformDataSize
              .add(registryTransmitCalldataFixedBytesOverhead)
              .add(
                registryTransmitCalldataPerSignerBytesOverhead.mul(
                  BigNumber.from(f + 1),
                ),
              )
              .mul(
                registryPerPerformByteGasOverhead.add(
                  chainModuleOverheads.chainModulePerByteOverhead,
                ),
              ),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(registryTransmitCalldataFixedBytesOverhead)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(
                registryTransmitCalldataPerSignerBytesOverhead.mul(
                  BigNumber.from(f + 1),
                ),
              )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul(
                  BigNumber.from(f + 1),
                )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(f + 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul(
                registryPerPerformByteGasOverhead.add(
                  chainModuleOverheads.chainModulePerByteOverhead,
                ),
              )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(
                  chainModuleOverheads.chainModulePerByteOverhead,
                )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(chainModuleOverheads.chainModuleFixedOverhead)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.mul('2')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.updateRoundData(roundId, answer, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.updateRoundData(roundId, -100, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.updateRoundData(roundId, 0, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getMaxPaymentForGas(Trigger.CONDITION, performGas)`
{"uses the correct type and version"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.typeAndVersion()`
{"reverts if not called by the LINK token"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.utils.defaultAbiCoder.encode(['uint256'], [upkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.onTokenTransfer(await keeper1.getAddress(), amount, data)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts if not called with more or less than 32 bytes"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.utils.defaultAbiCoder.encode(
        ['uint256', 'uint256'],
        ['33', '34'],
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferAndCall(registry.address, amount, longData)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferAndCall(registry.address, amount, shortData)`
{"reverts if the upkeep is canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(upkeepId, amount)`
{"updates the funds of the job id passed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.utils.defaultAbiCoder.encode(['uint256'], [upkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferAndCall(registry.address, amount, data)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(amount)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.eq(after)`
{"reverts when called by anyone but the proposed owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
          )`
{"reverts if signers or transmitters are the zero address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            [randomAddress(), randomAddress(), randomAddress(), zeroAddress],
            [
              randomAddress(),
              randomAddress(),
              randomAddress(),
              randomAddress(),
            ],
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            [
              randomAddress(),
              randomAddress(),
              randomAddress(),
              randomAddress(),
            ],
            [randomAddress(), randomAddress(), randomAddress(), zeroAddress],
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
          )`
{"updates the onchainConfig and configDigest"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
{"maintains paused state when config is changed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
{"emits an event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
        )`
{"reverts when called by anyone but the owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
          )`
{"reverts if too many keeperAddresses set"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.push(randomAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
          )`
{"reverts if f=0"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newKeepers,
            0,
            config,
            offchainVersion,
            offchainBytes,
          )`
{"reverts if signers != transmitters length"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            signers,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
          )`
{"reverts if signers <= 3f"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pop()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
          )`
{"reverts on repeated signers"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            newSigners,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
          )`
{"reverts on repeated transmitters"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newTransmitters,
            f,
            config,
            offchainVersion,
            offchainBytes,
          )`
{"allows the owner to set the peer registries"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getPeerRegistryMigrationPermission(peer)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPeerRegistryMigrationPermission(peer, 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getPeerRegistryMigrationPermission(peer)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPeerRegistryMigrationPermission(peer, 2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getPeerRegistryMigrationPermission(peer)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPeerRegistryMigrationPermission(peer, 0)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getPeerRegistryMigrationPermission(peer)`
{"reverts if passed an unsupported permission"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPeerRegistryMigrationPermission(peer, 10)`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts if the target is not a contract"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts if called by a non-owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts if execute gas is too low"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts if execute gas is too high"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts if checkData is too long"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"creates a record of the registration"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(testUpkeepId)`
{"reverts if the registration does not exist"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pauseUpkeep(upkeepId.add(1))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(1)`
{"reverts if the upkeep is already canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pauseUpkeep(upkeepId)`
{"reverts if the upkeep is already paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pauseUpkeep(upkeepId)`
{"reverts if the caller is not the upkeep admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pauseUpkeep(upkeepId)`
{"pauses the upkeep and emits an event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
{"reverts if the registration does not exist"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.unpauseUpkeep(upkeepId.add(1))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(1)`
{"reverts if the upkeep is already canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.unpauseUpkeep(upkeepId)`
{"marks the contract as paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
{"reverts if the upkeep is not paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.unpauseUpkeep(upkeepId)`
{"reverts if the caller is not the upkeep admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.unpauseUpkeep(upkeepId)`
{"unpauses the upkeep and emits an event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getActiveUpkeepIDs(0, 0)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.unpauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getActiveUpkeepIDs(0, 0)`
{"reverts if the registration does not exist"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepCheckData(upkeepId.add(1), randomBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(1)`
{"reverts if the caller is not upkeep admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepCheckData(upkeepId, randomBytes)`
{"reverts if the upkeep is cancelled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepCheckData(upkeepId, randomBytes)`
{"is allowed to update on paused upkeep"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepCheckData(upkeepId, randomBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
{"reverts if new data exceeds limit"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepCheckData(upkeepId, longBytes)`
{"updates the upkeep check data and emits an event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepCheckData(upkeepId, randomBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
{"reverts if the registration does not exist"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepGasLimit(upkeepId.add(1), newGasLimit)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(1)`
{"reverts if the upkeep is canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepGasLimit(upkeepId, newGasLimit)`
{"reverts if called by anyone but the admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepGasLimit(upkeepId, newGasLimit)`
{"reverts if new gas limit is out of bounds"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepGasLimit(upkeepId, BigNumber.from('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('100')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepGasLimit(upkeepId, BigNumber.from('6000000'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('6000000')`
{"updates the gas limit successfully"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepGasLimit(upkeepId, newGasLimit)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
{"emits a log"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepGasLimit(upkeepId, newGasLimit)`
{"reverts if the registration does not exist"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepOffchainConfig(upkeepId.add(1), newConfig)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(1)`
{"reverts if the upkeep is canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepOffchainConfig(upkeepId, newConfig)`
{"reverts if called by anyone but the admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepOffchainConfig(upkeepId, newConfig)`
{"updates the config successfully"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepOffchainConfig(upkeepId, newConfig)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
{"emits a log"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepOffchainConfig(upkeepId, newConfig)`
{"reverts if the registration does not exist"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepTriggerConfig(upkeepId.add(1), newConfig)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(1)`
{"reverts if the upkeep is canceled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepTriggerConfig(upkeepId, newConfig)`
{"reverts if called by anyone but the admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepTriggerConfig(upkeepId, newConfig)`
{"emits a log"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepTriggerConfig(upkeepId, newConfig)`
{"reverts when called by anyone but the current upkeep admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferUpkeepAdmin(upkeepId, await payee2.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts when transferring to self"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferUpkeepAdmin(upkeepId, await admin.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts when the upkeep is cancelled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferUpkeepAdmin(upkeepId, await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"allows cancelling transfer by reverting to zero address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferUpkeepAdmin(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferUpkeepAdmin(upkeepId, ethers.constants.AddressZero)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"does not change the upkeep admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferUpkeepAdmin(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"emits an event announcing the new upkeep admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferUpkeepAdmin(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"does not emit an event when called with the same proposed upkeep admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferUpkeepAdmin(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferUpkeepAdmin(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"reverts when not called by the proposed upkeep admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.acceptUpkeepAdmin(upkeepId)`
{"reverts when the upkeep is cancelled"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.acceptUpkeepAdmin(upkeepId)`
{"does change the admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.acceptUpkeepAdmin(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"emits an event announcing the new upkeep admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.acceptUpkeepAdmin(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"can only be called by owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.withdrawOwnerFunds()`
{"reverts when called by anyone but the current payee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferPayeeship(
            await keeper1.getAddress(),
            await payee2.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts when transferring to self"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferPayeeship(
            await keeper1.getAddress(),
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"does not change the payee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferPayeeship(
          await keeper1.getAddress(),
          await payee2.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"emits an event announcing the new payee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferPayeeship(
          await keeper1.getAddress(),
          await payee2.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"does not emit an event when called with the same proposal"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferPayeeship(
          await keeper1.getAddress(),
          await payee2.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferPayeeship(
          await keeper1.getAddress(),
          await payee2.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"reverts when called by anyone but the proposed payee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.acceptPayeeship(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"emits an event announcing the new payee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.acceptPayeeship(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"does change the payee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.acceptPayeeship(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts if called by a non-owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pause()`
{"marks the contract as paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
{"Does not allow transmits when paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pause()`
{"Does not allow creation of new upkeeps when paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts if called by a non-owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.unpause()`
{"marks the contract as not paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.unpause()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
{"migrates an upkeep"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepOffchainConfig(upkeepId, offchainBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getForwarder(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(
          forwarderAddress,
          owner,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.transferUpkeepAdmin(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.migrateUpkeeps([upkeepId], mgRegistry.address)`
{"migrates a paused upkeep"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.migrateUpkeeps([upkeepId], mgRegistry.address)`
{"emits an event on both contracts"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.migrateUpkeeps([upkeepId], mgRegistry.address)`
{"is only migratable by the admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
{"reverts"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPeerRegistryMigrationPermission(mgRegistry.address, 0)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPeerRegistryMigrationPermission(registry.address, 0)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPeerRegistryMigrationPermission(mgRegistry.address, 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPeerRegistryMigrationPermission(registry.address, 0)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPeerRegistryMigrationPermission(mgRegistry.address, 0)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPeerRegistryMigrationPermission(registry.address, 2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPeerRegistryMigrationPermission(mgRegistry.address, 2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPeerRegistryMigrationPermission(registry.address, 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.migrateUpkeeps([upkeepId], mgRegistry.address)`
{"reverts when not called by the owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPayees(payees)`
{"reverts with different numbers of payees than transmitters"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPayees([...payees, randomAddress()])`
{"reverts if the payee is the zero address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(...baseConfig)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `// used to test initial config
          .connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPayees([ethers.constants.AddressZero, ...payees.slice(1)])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.slice(1)`
{"does not change the payee if IGNORE_ADDRESS is used as payee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from({ length: 5 }, randomAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from({ length: 5 }, randomAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from({ length: 5 }, randomAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.fill(IGNORE_ADDRESS)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `// used to test initial configurations
        .connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
          signers,
          keepers,
          f,
          config,
          offchainVersion,
          offchainBytes,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPayees(payees)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `// used to test initial configurations
        .connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
          [...signers, randomAddress()],
          [...keepers, newTransmitter],
          f,
          config,
          offchainVersion,
          offchainBytes,
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPayees(newPayees)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(newTransmitter)`
{"reverts if payee is non zero and owner tries to change payee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.slice(1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPayees(newPayees)`
{"emits events for every payee added and removed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setPayees(payees)`
{"reverts if the ID is not valid"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId.add(1))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(1)`
{"reverts if called by a non-owner/non-admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
{"sets the registration to invalid immediately"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
{"emits an event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(receipt.blockNumber)`
{"immediately prevents upkeep"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"does not revert if reverts if called multiple times"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
{"reverts with proper error"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
{"reverts if called again by the admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
{"reverts if called by the owner after the timeout"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
{"sets the registration to invalid in 50 blocks"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
{"emits an event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(receipt.blockNumber + cancellationDelay)`
{"immediately prevents upkeep"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.approve(registry.address, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.addFunds(upkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.wait()`
{"deducts a cancellation fee from the upkeep and gives to owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              paymentPremiumPPB,
              flatFeeMicroLink,
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              minUpkeepSpend,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: chainModuleBase.address,
              reorgProtectionEnabled: true,
            },
            offchainVersion,
            offchainBytes,
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.sub(upkeepBefore)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.sub(amountSpent)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.sub(ownerBefore)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.eq(cancellationFee)`
{"deducts up to balance as cancellation fee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              paymentPremiumPPB,
              flatFeeMicroLink,
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              minUpkeepSpend,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: chainModuleBase.address,
              reorgProtectionEnabled: true,
            },
            offchainVersion,
            offchainBytes,
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.sub(ownerBefore)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.eq(upkeepBefore)`
{"does not deduct cancellation fee if more than minUpkeepSpend is spent"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(420)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              paymentPremiumPPB,
              flatFeeMicroLink,
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              minUpkeepSpend,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: chainModuleBase.address,
              reorgProtectionEnabled: true,
            },
            offchainVersion,
            offchainBytes,
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.eq(payee1After)`
{"reverts if called by anyone but the payee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.withdrawPayment(
            await keeper1.getAddress(),
            await nonkeeper.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"reverts if called with the 0 address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.withdrawPayment(await keeper1.getAddress(), zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"updates the balances"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(
        await keeper1.getAddress(),
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(to)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.withdrawPayment(await keeper1.getAddress(), to)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(
        await keeper1.getAddress(),
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(to)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.sub(keeperBefore.balance)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.eq(registryLinkAfter)`
{"emits a log announcing the withdrawal"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
{"returns false with appropriate failure reason when target callback reverts"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setShouldRevertCallback(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.callStatic.checkCallback(streamsLookupUpkeepId, values, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('0')`
{"returns false with appropriate failure reason when target callback returns big performData"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.callStatic.checkCallback(streamsLookupUpkeepId, values, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('0')`
{"returns false with appropriate failure reason when target callback returns false"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setCallbackReturnBool(false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.callStatic.checkCallback(streamsLookupUpkeepId, values, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('0')`
{"succeeds with upkeep needed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.callStatic.checkCallback(streamsLookupUpkeepId, values, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.utils.defaultAbiCoder.encode(
        ['bytes[]', 'bytes'],
        [values, '0x'],
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from('0')`
{"reverts when non manager tries to set privilege config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee3)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepPrivilegeConfig(upkeepId, '0x1234')`
{"returns empty bytes for upkeep privilege config before setting"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeepPrivilegeConfig(upkeepId)`
{"allows upkeep manager to set privilege config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(personas.Norbert)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setUpkeepPrivilegeConfig(upkeepId, '0x1234')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getUpkeepPrivilegeConfig(upkeepId)`
{"reverts when non manager tries to set privilege config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee3)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setAdminPrivilegeConfig(admin, '0x1234')`
{"returns empty bytes for upkeep privilege config before setting"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAdminPrivilegeConfig(admin)`
{"allows upkeep manager to set privilege config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(personas.Norbert)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.setAdminPrivilegeConfig(admin, '0x1234')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAdminPrivilegeConfig(admin)`
{"splits premium evenly across transmitters"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.div(
        BigNumber.from(keeperAddresses.length),
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(keeperAddresses.length)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.sub(premiumPerTransmitter)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(await keeper2.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.div(
        BigNumber.from(keeperAddresses.length),
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(keeperAddresses.length)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.sub(
        premiumPerTransmitter,
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(await keeper2.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.gt(k2Balance.add(additionalPremium))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.add(additionalPremium)`
{"updates last collected upon payment withdrawn"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(await keeper2.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(
        await keeper1.getAddress(),
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getTransmitterInfo(
        await keeper2.getAddress(),
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.lastCollected.eq(BigNumber.from(0))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_2.test.ts: `.from(0)`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).pause()`
{"reverts when report data lengths mismatches"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `upkeepIds.push(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `gasLimits.push(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `triggers.push('0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `performDatas.push('0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `performDatas.push('0x')`
{"performs even when the upkeep has insufficient funds and the upkeep pays out all the remaining balance"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(admin).addFunds(upkeepId, BigNumber.from(10))`
{"returns early when check block number is less than last perform (block)"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await tx.wait()`
{"handles case when check block number is older than 256 blocks"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await ethers.provider.send('evm_mine', [])`
{"allows bypassing reorg protection with reorgProtectionEnabled false config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `newConfig.reorgProtectionEnabled = false`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry // used to test initial configurations
          .connect(owner)
          .setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"allows very old trigger block numbers when bypassing reorg protection with reorgProtectionEnabled config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `newConfig.reorgProtectionEnabled = false`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry // used to test initial configurations
          .connect(owner)
          .setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await ethers.provider.send('evm_mine', [])`
{"allows very old trigger block numbers when bypassing reorg protection with empty blockhash"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await ethers.provider.send('evm_mine', [])`
{"returns early when future block number is provided as trigger, irrespective of blockhash being present"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `tx = await getTransmitTx(registry, keeper1, [id], {
            checkBlockNum: latestBlock.number + 100,
            checkBlockHash: latestBlock.hash,
          })`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `receipt = await tx.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `reorgedUpkeepReportLogs = parseReorgedUpkeepReportLogs(receipt)`
{"returns early when future block number is provided as trigger, irrespective of reorgProtectionEnabled config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `newConfig.reorgProtectionEnabled = false`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry // used to test initial configurations
          .connect(owner)
          .setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `tx = await getTransmitTx(registry, keeper1, [id], {
            checkBlockNum: latestBlock.number + 100,
            checkBlockHash: latestBlock.hash,
          })`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `receipt = await tx.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `reorgedUpkeepReportLogs = parseReorgedUpkeepReportLogs(receipt)`
{"returns early when upkeep is cancelled and cancellation delay has gone"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await ethers.provider.send('evm_mine', [])`
{"does not revert if the target cannot execute"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanPerform(false)`
{"does not revert if the target runs out of gas"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanPerform(false)`
{"executes the data passed to the registry"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `parsedLogs.push(iface.parseLog(log))`
{"uses actual execution price for payment and premium calculation"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
{"only pays at a rate up to the gas ceiling [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
{"correctly accounts for l payment"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await arbRegistry.connect(owner).addFunds(testUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `tx = await getTransmitTx(
          arbRegistry,
          keeper1,
          [testUpkeepId],

          { gasPrice: gasWei.mul('5') }, // High gas price so that it gets capped
        )`
{"can self cancel"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).addFunds(afUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await autoFunderUpkeep.setIsEligible(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await autoFunderUpkeep.setShouldCancel(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper1, [afUpkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `registration = await registry.getUpkeep(afUpkeepId)`
{"has enough perform gas overhead for large batches [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `upkeepIds.push(testUpkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).addFunds(testUpkeepId, toWei('10'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setPerformGasToBurn(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `totalPerformGas = totalPerformGas.add(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await evmRevert(
          getTransmitTx(registry, keeper1, upkeepIds, {
            gasLimit: totalPerformGas,
          }),
        )`
{"splits l2 payment among performed upkeeps according to perform data weight"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `upkeepIds.push(testUpkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await arbRegistry.connect(owner).addFunds(testUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `pd += '11'`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `performDatas.push(pd)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `upkeepCalldataWeights.push(w)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `totalCalldataWeight = totalCalldataWeight.add(w)`
{"calculates the minimum balance appropriately"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(admin).addFunds(upkeepId, tooLow)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(admin).addFunds(upkeepId, oneWei)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `checkUpkeepResult = await registry
        .connect(zeroAddress)
        .callStatic['checkUpkeep(uint256)'](upkeepId)`
{"uses maxPerformData size in checkUpkeep but actual performDataSize in transmit"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).addFunds(upkeepID, minBalance1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `maxPerformData += '11'`
{"allows the admin to withdraw"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(admin).pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).cancelUpkeep(upkeepId)`
{"can be called successively on two upkeeps"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry
          .connect(admin)
          .withdrawFunds(upkeepId, await payee1.getAddress())`
{"moves the funds out and updates the balance and emits an event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `registration = await registry.getUpkeep(upkeepId)`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).pause()`
{"returns false and gasUsed when perform fails"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanPerform(false)`
{"returns true, gasUsed, and performGas when perform succeeds"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
{"returns correct amount of gasUsed when perform succeeds"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setPerformGasToBurn(performGas)`
{"returns false and error code if the upkeep is cancelled by admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"returns false and error code if the upkeep is cancelled by owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).cancelUpkeep(upkeepId)`
{"returns false and error code if the registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).pause()`
{"returns false and error code if the upkeep is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(admin).pauseUpkeep(upkeepId)`
{"returns false, error code, and revert data if the target check reverts"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setShouldRevertCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCheckRevertReason(
          'custom revert error, clever way to insert offchain data',
        )`
{"returns false, error code, and no revert data if the target check revert data exceeds maxRevertDataSize"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setShouldRevertCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `longRevertReason += 'x'`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCheckRevertReason(longRevertReason)`
{"returns false and error code if the upkeep is not needed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanCheck(false)`
{"returns false and error code if the performData exceeds limit"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `longBytes += '1'`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setPerformData(longBytes)`
{"returns true with gas used if the target can execute"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await mock.setPerformData(randomBytes)`
{"calls checkLog for log-trigger upkeeps"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await ltUpkeep.mock.checkLog.withArgs(log, '0x').returns(true, '0x1234')`
{"uses the fallback gas price if the feed has issues"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await gasPriceFeed
        .connect(owner)
        .updateRoundData(roundId, answer, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `roundId = 100`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `updatedAt = now()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `startedAt = 946684799`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await gasPriceFeed
        .connect(owner)
        .updateRoundData(roundId, -100, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `roundId = 101`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `updatedAt = now()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `startedAt = 946684799`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await gasPriceFeed
        .connect(owner)
        .updateRoundData(roundId, 0, updatedAt, startedAt)`
{"uses the fallback link price if the feed has issues"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await linkUSDFeed
        .connect(owner)
        .updateRoundData(roundId, answer, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `roundId = 100`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `updatedAt = now()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `startedAt = 946684799`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await linkUSDFeed
        .connect(owner)
        .updateRoundData(roundId, -100, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `roundId = 101`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `updatedAt = now()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `startedAt = 946684799`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await linkUSDFeed
        .connect(owner)
        .updateRoundData(roundId, 0, updatedAt, startedAt)`
{"reverts if signers or transmitters are the zero address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await evmRevertCustomError(
        registry
          .connect(owner)
          .setConfigTypeSafe(
            [randomAddress(), randomAddress(), randomAddress(), zeroAddress],
            [
              randomAddress(),
              randomAddress(),
              randomAddress(),
              randomAddress(),
            ],
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          ),
        registry,
        'InvalidSigner',
      )`
{"updates the onchainConfig and configDigest"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry
        .connect(owner)
        .setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
          [],
          [],
        )`
{"maintains paused state when config is changed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.pause()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry
        .connect(owner)
        .setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
          [],
          [],
        )`
{"reverts if too many keeperAddresses set"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `newKeepers.push(randomAddress())`
{"reverts if signers <= 3f"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `newKeepers.pop()`
{"immediately prevents upkeep"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await linkToken.connect(owner).approve(registry.address, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).addFunds(upkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await ethers.provider.send('evm_mine', [])`
{"deducts a cancellation fee from the upkeep and adds to reserve"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              fallbackNativePrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: chainModuleBase.address,
              reorgProtectionEnabled: true,
              financeAdmin: financeAdminAddress,
            },
            offchainVersion,
            offchainBytes,
            [linkToken.address],
            [
              {
                gasFeePPB: paymentPremiumPPB,
                flatFeeMilliCents,
                priceFeed: linkUSDFeed.address,
                fallbackPrice: fallbackLinkPrice,
                minSpend: newMinUpkeepSpend,
                decimals: 18,
              },
            ],
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"deducts up to balance as cancellation fee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              fallbackNativePrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: chainModuleBase.address,
              reorgProtectionEnabled: true,
              financeAdmin: financeAdminAddress,
            },
            offchainVersion,
            offchainBytes,
            [linkToken.address],
            [
              {
                gasFeePPB: paymentPremiumPPB,
                flatFeeMilliCents,
                priceFeed: linkUSDFeed.address,
                fallbackPrice: fallbackLinkPrice,
                minSpend: newMinUpkeepSpend,
                decimals: 18,
              },
            ],
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"does not deduct cancellation fee if more than minUpkeepSpendDollars is spent"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              fallbackNativePrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: chainModuleBase.address,
              reorgProtectionEnabled: true,
              financeAdmin: financeAdminAddress,
            },
            offchainVersion,
            offchainBytes,
            [linkToken.address],
            [
              {
                gasFeePPB: paymentPremiumPPB,
                flatFeeMilliCents,
                priceFeed: linkUSDFeed.address,
                fallbackPrice: fallbackLinkPrice,
                minSpend: newMinUpkeepSpend,
                decimals: 18,
              },
            ],
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"updates the balances"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry
        .connect(payee1)
        .withdrawPayment(await keeper1.getAddress(), to)`
{"returns false with appropriate failure reason when target callback reverts"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await streamsLookupUpkeep.setShouldRevertCallback(true)`
{"returns false with appropriate failure reason when target callback returns big performData"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `longBytes += '11'`
{"returns false with appropriate failure reason when target callback returns false"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await streamsLookupUpkeep.setCallbackReturnBool(false)`
{"splits premium evenly across transmitters"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper2, [upkeepId])`
{"updates last collected upon payment withdrawn"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry
        .connect(payee1)
        .withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
{"maintains consistent balance information across all parties"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `maxAllowedSpareChange = maxAllowedSpareChange.add(BigNumber.from('31'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry
        .connect(payee1)
        .withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry
        .connect(payee2)
        .withdrawPayment(
          await keeper2.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `maxAllowedSpareChange = maxAllowedSpareChange.add(BigNumber.from('31'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).setConfigTypeSafe(
        signerAddresses.slice(2, 15), // only use 2-14th index keepers
        keeperAddresses.slice(2, 15),
        f,
        config,
        offchainVersion,
        offchainBytes,
        baseConfig[6],
        baseConfig[7],
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper3, [upkeepId], {
        startingSignerIndex: 2,
      })`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `maxAllowedSpareChange = maxAllowedSpareChange.add(BigNumber.from('13'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry
        .connect(payee1)
        .withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry
        .connect(payee3)
        .withdrawPayment(
          await keeper3.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry.connect(owner).setConfigTypeSafe(
        signerAddresses.slice(0, 4), // only use 0-3rd index keepers
        keeperAddresses.slice(0, 4),
        f,
        config,
        offchainVersion,
        offchainBytes,
        baseConfig[6],
        baseConfig[7],
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `maxAllowedSpareChange = maxAllowedSpareChange.add(BigNumber.from('4'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper3, [upkeepId])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `maxAllowedSpareChange = maxAllowedSpareChange.add(BigNumber.from('4'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry
        .connect(payee5)
        .withdrawPayment(
          await keeper5.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `await registry
        .connect(payee1)
        .withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.pause()`
{"reverts when report data lengths mismatches"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.push(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.push(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.push('0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.push('0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.push('0x')`
{"returns early when invalid upkeepIds are included in report"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(BigNumber.from('1'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('1')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"performs even when the upkeep has insufficient funds and the upkeep pays out all the remaining balance"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.addFunds(upkeepId, BigNumber.from(10))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from(10)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
{"handles duplicate upkeepIDs"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"handles duplicate log triggers"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.utils.solidityKeccak256(
          ['uint256', 'bytes32', 'bytes32', 'uint32'],
          [logUpkeepId, logBlockHash, txHash, logIndex],
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"returns early when check block number is less than last perform (block)"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.getBlock(lastPerformed)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"handles case when check block hash does not match"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"handles case when check block number is older than 256 blocks"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.getBlock(latestBlock.number - 256)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"allows bypassing reorg protection with empty blockhash"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"allows bypassing reorg protection with reorgProtectionEnabled false config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `// used to test initial configurations
          .connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"allows very old trigger block numbers when bypassing reorg protection with reorgProtectionEnabled config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `// used to test initial configurations
          .connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.getBlock(latestBlock.number - 256)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"allows very old trigger block numbers when bypassing reorg protection with empty blockhash"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"returns early when future block number is provided as trigger, irrespective of blockhash being present"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"returns early when future block number is provided as trigger, irrespective of reorgProtectionEnabled config"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `// used to test initial configurations
          .connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"returns early when upkeep is cancelled and cancellation delay has gone"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"does not revert if the target cannot execute"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanPerform(false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"does not revert if the target runs out of gas"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanPerform(false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"executes the data passed to the registry"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.push(iface.parseLog(log))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.parseLog(log)`
{"uses actual execution price for payment and premium calculation"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.sub(registryPremiumBefore)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('1')`
{"only pays at a rate up to the gas ceiling [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mul(BigNumber.from('10'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('10')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"correctly accounts for l payment"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from(1000000)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.registerUpkeep(
            mock.address,
            performGas,
            await admin.getAddress(),
            Trigger.CONDITION,
            linkToken.address,
            '0x',
            '0x',
            '0x',
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.addFunds(testUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mul('5')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"can self cancel"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.addFunds(afUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setIsEligible(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setShouldCancel(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(afUpkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(afUpkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.lt(oldExpiration)`
{"reverts when configDigest mismatches"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.slice(0, f + 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.transmit(
              [reportContext[0], reportContext[1], reportContext[2]],
              report,
              sigs.rs,
              sigs.ss,
              sigs.vs,
            )`
{"reverts with incorrect number of signatures"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.slice(0, f + 2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.transmit(
              [reportContext[0], reportContext[1], reportContext[2]],
              report,
              sigs.rs,
              sigs.ss,
              sigs.vs,
            )`
{"reverts with invalid signature for inactive signers"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.Wallet.createRandom()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.Wallet.createRandom()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.transmit(
              [reportContext[0], reportContext[1], reportContext[2]],
              report,
              sigs.rs,
              sigs.ss,
              sigs.vs,
            )`
{"reverts with invalid signature for duplicated signers"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.transmit(
              [reportContext[0], reportContext[1], reportContext[2]],
              report,
              sigs.rs,
              sigs.ss,
              sigs.vs,
            )`
{"has enough perform gas overhead for large batches [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('0')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.deploy()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.registerUpkeep(
              mock.address,
              performGas,
              await admin.getAddress(),
              Trigger.CONDITION,
              linkToken.address,
              '0x',
              '0x',
              '0x',
            )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.push(testUpkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.addFunds(testUpkeepId, toWei('10'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setPerformGasToBurn(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(transmitGasOverhead)`
{"splits l2 payment among performed upkeeps according to perform data weight"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('0')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from(1000000)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.deploy()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.registerUpkeep(
              mock.address,
              performGas,
              await admin.getAddress(),
              Trigger.CONDITION,
              linkToken.address,
              '0x',
              '0x',
              '0x',
            )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.push(testUpkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.addFunds(testUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.push(pd)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from(performDataSizes[i])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(registryTransmitCalldataFixedBytesOverhead)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(
              registryTransmitCalldataPerSignerBytesOverhead.mul(
                BigNumber.from(f + 1),
              ),
            )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mul(
                BigNumber.from(f + 1),
              )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from(f + 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.push(w)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(w)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mul('5')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"calculates the minimum balance appropriately"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from(1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getMinBalanceForUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.sub(oneWei)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.addFunds(upkeepId, tooLow)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.addFunds(upkeepId, oneWei)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"uses maxPerformData size in checkUpkeep but actual performDataSize in transmit"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.registerUpkeep(
          mock.address,
          performGas,
          await admin.getAddress(),
          Trigger.CONDITION,
          linkToken.address,
          '0x',
          '0x',
          '0x',
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getMinBalanceForUpkeep(upkeepID)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.sub(
        1,
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.addFunds(upkeepID, minBalance1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mul(gasCeilingMultiplier)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"allows the admin to withdraw"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getBalance(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
{"can be called successively on two upkeeps"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.withdrawFunds(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
{"moves the funds out and updates the balance and emits an event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(
          await payee1.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.withdrawFunds(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
{"reverts if called by non zero address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(await owner.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
{"returns false and gasUsed when perform fails"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanPerform(false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('0')`
{"returns true, gasUsed, and performGas when perform succeeds"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('0')`
{"returns correct amount of gasUsed when perform succeeds"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setPerformGasToBurn(performGas)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.gasUsed.gt(
          performGas.sub(BigNumber.from('1000')),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.sub(BigNumber.from('1000'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('1000')`
{"reverts if called by non zero address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(await owner.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
{"returns false and error code if the upkeep is cancelled by admin"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the upkeep is cancelled by owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the registry is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the upkeep is paused"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false and error code if user is out of funds"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false, error code, and revert data if the target check reverts"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setShouldRevertCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCheckRevertReason(
          'custom revert error, clever way to insert offchain data',
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.performData.slice(10)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.linkUSD.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('0')`
{"returns false, error code, and no revert data if the target check revert data exceeds maxRevertDataSize"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setShouldRevertCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCheckRevertReason(longRevertReason)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the upkeep is not needed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanCheck(false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the performData exceeds limit"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setPerformData(longBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns true with gas used if the target can execute"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setPerformData(randomBytes)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.linkUSD.eq(linkUSD)`
{"calls checkLog for log-trigger upkeeps"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.utils.randomBytes(1000)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mock.checkLog.withArgs(log, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.returns(true, '0x1234')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"uses the fallback gas price if the feed has issues"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getGasOverhead()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(registryPerSignerGasOverhead.mul(f + 1))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mul(f + 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(
            maxPerformDataSize
              .add(registryTransmitCalldataFixedBytesOverhead)
              .add(
                registryTransmitCalldataPerSignerBytesOverhead.mul(
                  BigNumber.from(f + 1),
                ),
              )
              .mul(
                registryPerPerformByteGasOverhead.add(
                  chainModuleOverheads.chainModulePerByteOverhead,
                ),
              ),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(registryTransmitCalldataFixedBytesOverhead)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(
                registryTransmitCalldataPerSignerBytesOverhead.mul(
                  BigNumber.from(f + 1),
                ),
              )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mul(
                  BigNumber.from(f + 1),
                )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from(f + 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mul(
                registryPerPerformByteGasOverhead.add(
                  chainModuleOverheads.chainModulePerByteOverhead,
                ),
              )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(
                  chainModuleOverheads.chainModulePerByteOverhead,
                )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(chainModuleOverheads.chainModuleFixedOverhead)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mul('2')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.updateRoundData(roundId, answer, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.updateRoundData(roundId, -100, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.updateRoundData(roundId, 0, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getMaxPaymentForGas(
            upkeepId,
            Trigger.CONDITION,
            performGas,
            linkToken.address,
          )`
{"uses the fallback link price if the feed has issues"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getGasOverhead()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(registryPerSignerGasOverhead.mul(f + 1))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mul(f + 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(
            maxPerformDataSize
              .add(registryTransmitCalldataFixedBytesOverhead)
              .add(
                registryTransmitCalldataPerSignerBytesOverhead.mul(
                  BigNumber.from(f + 1),
                ),
              )
              .mul(
                registryPerPerformByteGasOverhead.add(
                  chainModuleOverheads.chainModulePerByteOverhead,
                ),
              ),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(registryTransmitCalldataFixedBytesOverhead)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(
                registryTransmitCalldataPerSignerBytesOverhead.mul(
                  BigNumber.from(f + 1),
                ),
              )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mul(
                  BigNumber.from(f + 1),
                )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from(f + 1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mul(
                registryPerPerformByteGasOverhead.add(
                  chainModuleOverheads.chainModulePerByteOverhead,
                ),
              )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(
                  chainModuleOverheads.chainModulePerByteOverhead,
                )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(chainModuleOverheads.chainModuleFixedOverhead)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.mul('2')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.updateRoundData(roundId, answer, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.updateRoundData(roundId, -100, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.updateRoundData(roundId, 0, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getMaxPaymentForGas(
            upkeepId,
            Trigger.CONDITION,
            performGas,
            linkToken.address,
          )`
{"uses the correct type and version"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.typeAndVersion()`
{"reverts when called by anyone but the proposed owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts if signers or transmitters are the zero address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            [randomAddress(), randomAddress(), randomAddress(), zeroAddress],
            [
              randomAddress(),
              randomAddress(),
              randomAddress(),
              randomAddress(),
            ],
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            [
              randomAddress(),
              randomAddress(),
              randomAddress(),
              randomAddress(),
            ],
            [randomAddress(), randomAddress(), randomAddress(), zeroAddress],
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"updates the onchainConfig and configDigest"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getConfig()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
          [],
          [],
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
{"maintains paused state when config is changed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
          [],
          [],
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
{"emits an event"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
          [],
          [],
        )`
{"reverts when called by anyone but the owner"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts if too many keeperAddresses set"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.push(randomAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts if f=0"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newKeepers,
            0,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts if signers != transmitters length"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signers,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts if signers <= 3f"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.pop()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts on repeated signers"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            newSigners,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts on repeated transmitters"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newTransmitters,
            f,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"immediately prevents upkeep"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.approve(registry.address, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.addFunds(upkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.wait()`
{"deducts a cancellation fee from the upkeep and adds to reserve"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              fallbackNativePrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: chainModuleBase.address,
              reorgProtectionEnabled: true,
              financeAdmin: financeAdminAddress,
            },
            offchainVersion,
            offchainBytes,
            [linkToken.address],
            [
              {
                gasFeePPB: paymentPremiumPPB,
                flatFeeMilliCents,
                priceFeed: linkUSDFeed.address,
                fallbackPrice: fallbackLinkPrice,
                minSpend: newMinUpkeepSpend,
                decimals: 18,
              },
            ],
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.sub(upkeepBefore)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.sub(amountSpent)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.sub(ownerBefore)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.eq(cancellationFee)`
{"deducts up to balance as cancellation fee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              fallbackNativePrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: chainModuleBase.address,
              reorgProtectionEnabled: true,
              financeAdmin: financeAdminAddress,
            },
            offchainVersion,
            offchainBytes,
            [linkToken.address],
            [
              {
                gasFeePPB: paymentPremiumPPB,
                flatFeeMilliCents,
                priceFeed: linkUSDFeed.address,
                fallbackPrice: fallbackLinkPrice,
                minSpend: newMinUpkeepSpend,
                decimals: 18,
              },
            ],
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.sub(ownerBefore)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.eq(upkeepBefore)`
{"does not deduct cancellation fee if more than minUpkeepSpendDollars is spent"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from(420)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              fallbackNativePrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: chainModuleBase.address,
              reorgProtectionEnabled: true,
              financeAdmin: financeAdminAddress,
            },
            offchainVersion,
            offchainBytes,
            [linkToken.address],
            [
              {
                gasFeePPB: paymentPremiumPPB,
                flatFeeMilliCents,
                priceFeed: linkUSDFeed.address,
                fallbackPrice: fallbackLinkPrice,
                minSpend: newMinUpkeepSpend,
                decimals: 18,
              },
            ],
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.eq(payee1After)`
{"reverts if called by anyone but the payee"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(payee2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.withdrawPayment(
            await keeper1.getAddress(),
            await nonkeeper.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
{"reverts if called with the 0 address"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(payee2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.withdrawPayment(await keeper1.getAddress(), zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
{"updates the balances"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getTransmitterInfo(
        await keeper1.getAddress(),
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(to)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.withdrawPayment(await keeper1.getAddress(), to)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getTransmitterInfo(
        await keeper1.getAddress(),
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(to)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.sub(keeperBefore.balance)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.eq(registryLinkAfter)`
{"emits a log announcing the withdrawal"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
{"returns false with appropriate failure reason when target callback reverts"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setShouldRevertCallback(true)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.callStatic.checkCallback(streamsLookupUpkeepId, values, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('0')`
{"returns false with appropriate failure reason when target callback returns big performData"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.callStatic.checkCallback(streamsLookupUpkeepId, values, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('0')`
{"returns false with appropriate failure reason when target callback returns false"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setCallbackReturnBool(false)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.callStatic.checkCallback(streamsLookupUpkeepId, values, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('0')`
{"succeeds with upkeep needed"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.callStatic.checkCallback(streamsLookupUpkeepId, values, '0x')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.utils.defaultAbiCoder.encode(
        ['bytes[]', 'bytes'],
        [values, '0x'],
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('0')`
{"splits premium evenly across transmitters"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.div(
        BigNumber.from(keeperAddresses.length),
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from(keeperAddresses.length)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.sub(premiumPerTransmitter)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper2.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.div(
        BigNumber.from(keeperAddresses.length),
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from(keeperAddresses.length)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.sub(
        premiumPerTransmitter,
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper2.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.gt(k2Balance.add(additionalPremium))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(additionalPremium)`
{"updates last collected upon payment withdrawn"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper2.getAddress())`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getTransmitterInfo(
        await keeper1.getAddress(),
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getTransmitterInfo(
        await keeper2.getAddress(),
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.lastCollected.eq(BigNumber.from(0))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from(0)`
{"maintains consistent balance information across all parties"}
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('0')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(BigNumber.from('31'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('31')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(payee2)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper2.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(BigNumber.from('31'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('31')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
        signerAddresses.slice(2, 15), // only use 2-14th index keepers
        keeperAddresses.slice(2, 15),
        f,
        config,
        offchainVersion,
        offchainBytes,
        baseConfig[6],
        baseConfig[7],
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.slice(2, 15)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.slice(2, 15)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(BigNumber.from('13'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('13')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(payee3)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper3.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
        signerAddresses.slice(0, 4), // only use 0-3rd index keepers
        keeperAddresses.slice(0, 4),
        f,
        config,
        offchainVersion,
        offchainBytes,
        baseConfig[6],
        baseConfig[7],
      )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.slice(0, 4)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.slice(0, 4)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(BigNumber.from('4'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('4')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.add(BigNumber.from('4'))`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.from('4')`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(payee5)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper5.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/AutomationRegistry2_3.test.ts: `.getAddress()`
{"optionally creates a first job"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `cron = (
        await cronFactory.deploy(
          owner.address,
          cronDelegate.address,
          5,
          payload,
        )
      ).connect(owner)`
{"returns the id of eligible cron jobs"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await h.fastForward(moment.duration(11, 'minutes').asSeconds())`
{"cycles through the cron IDs based on block number"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await h.fastForward(moment.duration(1, 'year').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await h.mineBlock(ethers.provider)
          ;`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `[_, payload] = await cron
            .connect(AddressZero)
            .callStatic.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await h.mineBlock(ethers.provider)
          ;`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `[_, payload] = await cron
            .connect(AddressZero)
            .callStatic.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await h.mineBlock(ethers.provider)
          ;`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `[_, payload] = await cron
            .connect(AddressZero)
            .callStatic.checkUpkeep('0x')`
{"forwards the call to the appropriate target/handler"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await h.fastForward(moment.duration(11, 'minutes').asSeconds())`
{"emits an event"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await h.fastForward(moment.duration(11, 'minutes').asSeconds())`
{"succeeds even if the call to the target fails"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.deleteCronJob(2)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await h.fastForward(moment.duration(21, 'minutes').asSeconds())`
{"is only callable by anyone"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await h.fastForward(moment.duration(11, 'minutes').asSeconds())`
{"is only callable once for a given tick"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await h.fastForward(moment.duration(10, 'minutes').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.performUpkeep(payload)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await h.fastForward(moment.duration(1, 'minute').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await h.fastForward(moment.duration(10, 'minute').asSeconds())`
{"creates jobs with sequential IDs"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.createCronJobFromEncodedSpec(
        cronReceiver1.address,
        handler1Sig,
        encodedSpec1,
      )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await assertJobIDsEqual([1])`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.createCronJobFromEncodedSpec(
        cronReceiver1.address,
        handler2Sig,
        encodedSpec1,
      )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await assertJobIDsEqual([1, 2])`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.createCronJobFromEncodedSpec(
        cronReceiver2.address,
        handler1Sig,
        encodedSpec2,
      )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await assertJobIDsEqual([1, 2, 3])`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.createCronJobFromEncodedSpec(
        cronReceiver2.address,
        handler2Sig,
        encodedSpec2,
      )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await assertJobIDsEqual([1, 2, 3, 4])`
{"errors if trying to create more jobs than allowed"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await createBasicCron()`
{"updates a cron job"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.updateCronJob(
        1,
        cronReceiver2.address,
        handler2Sig,
        newEncodedSpec,
      )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `cron1 = await cron.getCronJob(1)`
{"deletes a jobs by it's ID"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await createBasicCron()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await createBasicCron()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await createBasicCron()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await createBasicCron()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await assertJobIDsEqual([1, 2, 3, 4])`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.deleteCronJob(2)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await assertJobIDsEqual([1, 3, 4])`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.deleteCronJob(1)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await assertJobIDsEqual([3, 4])`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.deleteCronJob(4)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await assertJobIDsEqual([3])`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.deleteCronJob(3)`
{"emits an event"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await createBasicCron()`
{"reverts if trying to delete a non-existent ID"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await createBasicCron()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await createBasicCron()`
{"pauses / unpauses the contract"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.pause()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.unpause()`
{"uses gas"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.createCronJobFromString(
          cronReceiver1.address,
          handler1Sig,
          cronString,
        )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await h.fastForward(moment.duration(100, 'years').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.txCheckUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.performUpkeep(data)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `await cron.deleteCronJob(cronID)`
{"optionally creates a first job"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.encodeCronJob(
        cronReceiver1.address,
        handler1Sig,
        basicCronString,
      )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.deploy(
          owner.address,
          cronDelegate.address,
          5,
          payload,
        )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.getCronJob(1)`
{"returns false if no one is elligible"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(AddressZero)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.callStatic.checkUpkeep('0x')`
{"returns the id of eligible cron jobs"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.fastForward(moment.duration(11, 'minutes').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.duration(11, 'minutes')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.asSeconds()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(AddressZero)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.callStatic.checkUpkeep('0x')`
{"cycles through the cron IDs based on block number"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.fastForward(moment.duration(1, 'year').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.duration(1, 'year')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.asSeconds()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(AddressZero)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.callStatic.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.mineBlock(ethers.provider)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(AddressZero)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.callStatic.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.mineBlock(ethers.provider)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(AddressZero)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.callStatic.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.mineBlock(ethers.provider)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(AddressZero)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.callStatic.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.map((n) => n.toNumber())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.sort()`
{"forwards the call to the appropriate target/handler"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.fastForward(moment.duration(11, 'minutes').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.duration(11, 'minutes')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.asSeconds()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(AddressZero)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.callStatic.checkUpkeep('0x')`
{"emits an event"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.fastForward(moment.duration(11, 'minutes').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.duration(11, 'minutes')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.asSeconds()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(AddressZero)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.callStatic.checkUpkeep('0x')`
{"succeeds even if the call to the target fails"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.deleteCronJob(2)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.fastForward(moment.duration(21, 'minutes').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.duration(21, 'minutes')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.asSeconds()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.unix(timeStamp)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.add(20, 'minutes')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.unix()`
{"is only callable by anyone"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.fastForward(moment.duration(11, 'minutes').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.duration(11, 'minutes')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.asSeconds()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(AddressZero)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.callStatic.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(stranger)`
{"is only callable once for a given tick"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.fastForward(moment.duration(10, 'minutes').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.duration(10, 'minutes')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.asSeconds()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(AddressZero)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.callStatic.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.unix(timeStamp)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.add(10, 'minutes')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.add(59, 'seconds')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.unix()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.performUpkeep(payload)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.fastForward(moment.duration(1, 'minute').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.duration(1, 'minute')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.asSeconds()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.fastForward(moment.duration(10, 'minute').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.duration(10, 'minute')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.asSeconds()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.performUpkeep(maliciousPayload)`
{"creates jobs with sequential IDs"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.encodeCronString(cronString1)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.encodeCronString(cronString2)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.calculateNextTick(cronString1)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.calculateNextTick(cronString2)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.createCronJobFromEncodedSpec(
        cronReceiver1.address,
        handler1Sig,
        encodedSpec1,
      )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.createCronJobFromEncodedSpec(
        cronReceiver1.address,
        handler2Sig,
        encodedSpec1,
      )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.createCronJobFromEncodedSpec(
        cronReceiver2.address,
        handler1Sig,
        encodedSpec2,
      )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.createCronJobFromEncodedSpec(
        cronReceiver2.address,
        handler2Sig,
        encodedSpec2,
      )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.getCronJob(1)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.getCronJob(2)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.getCronJob(3)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.getCronJob(4)`
{"updates a cron job"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.getCronJob(1)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.updateCronJob(
        1,
        cronReceiver2.address,
        handler2Sig,
        newEncodedSpec,
      )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.getCronJob(1)`
{"deletes a jobs by it's ID"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.deleteCronJob(2)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.deleteCronJob(1)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.deleteCronJob(4)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.deleteCronJob(3)`
{"is only callable by the owner"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.unpause()`
{"pauses / unpauses the contract"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.unpause()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.paused()`
{"uses gas"}
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.createCronJobFromString(
          cronReceiver1.address,
          handler1Sig,
          cronString,
        )`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.fastForward(moment.duration(100, 'years').asSeconds())`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.duration(100, 'years')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.asSeconds()`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.connect(AddressZero)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.callStatic.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.txCheckUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.performUpkeep(data)`
$DIR/contracts/test/v0.8/automation/CronUpkeep.test.ts: `.deleteCronJob(cronID)`
{"sets the max jobs value"}
$DIR/contracts/test/v0.8/automation/CronUpkeepFactory.test.ts: `await factory.setMaxJobs(6)`
{"deploys a delegate contract"}
$DIR/contracts/test/v0.8/automation/CronUpkeepFactory.test.ts: `.cronDelegateAddress()`
{"sets the deployer as the owner"}
$DIR/contracts/test/v0.8/automation/CronUpkeepFactory.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/CronUpkeepFactory.test.ts: `.newCronUpkeep()`
$DIR/contracts/test/v0.8/automation/CronUpkeepFactory.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/CronUpkeepFactory.test.ts: `.getContractFactory('CronUpkeep', {
        libraries: { Cron: cronExternalLib.address },
      })`
$DIR/contracts/test/v0.8/automation/CronUpkeepFactory.test.ts: `.attach(upkeepAddress)`
$DIR/contracts/test/v0.8/automation/CronUpkeepFactory.test.ts: `.owner()`
{"sets the max jobs value"}
$DIR/contracts/test/v0.8/automation/CronUpkeepFactory.test.ts: `.setMaxJobs(6)`
{"Should allow anyone to add funds"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await lt.transfer(bm.address, oneLINK)`
{"Should allow the owner to withdraw"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await tx.wait()`
{"Should allow the owner to withdraw to anyone"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await tx.wait()`
{"Should allow owner to pause / unpause"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await pauseTx.wait()`
{"Should not allow strangers to pause / unpause"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await pauseTxOwner.wait()`
{"Should allow owner to set the watchlist"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await setTx.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `setTx = await bm
        .connect(owner)
        .setWatchList(
          [watchAddress1, watchAddress2, watchAddress3],
          [oneLINK, twoLINK, threeLINK],
          [twoLINK, threeLINK, fiveLINK],
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await setTx.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `watchList = await bm.getWatchList()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `setTx = await bm
        .connect(owner)
        .setWatchList(
          [watchAddress3, watchAddress1],
          [threeLINK, oneLINK],
          [fiveLINK, twoLINK],
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await setTx.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `watchList = await bm.getWatchList()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `accountInfo1 = await bm.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `accountInfo2 = await bm.getAccountInfo(watchAddress2)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `accountInfo3 = await bm.getAccountInfo(watchAddress3)`
{"Should not allow larger than maximum watchlist size"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `Array.from(Array(301).keys()).forEach(() => {
        watchlist[0].push(owner.address)
        watchlist[1].push(oneLINK)
        watchlist[2].push(twoLINK)
      })`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `watchlist[0].push(owner.address)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `watchlist[1].push(oneLINK)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `watchlist[2].push(twoLINK)`
{"Should revert if the list lengths differ"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `tx = bm.connect(owner).setWatchList([watchAddress1], [oneLINK], [])`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `tx = bm.connect(owner).setWatchList([], [oneLINK], [twoLINK])`
{"Should allow the owner to set the registry address"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await setTx.wait()`
{"Should allow owner to set the wait period"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await setTx.wait()`
{"Should return list of address that are underfunded"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await fundTx.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `addresses = await bm.getUnderfundedAddresses()`
{"Should return some results even if contract cannot fund all eligible targets"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await fundTx.wait()`
{"Should omit addresses that have been funded recently"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await Promise.all([setWaitPdTx.wait(), fundTx.wait()])`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await setTopUpTx.wait()`
{"Should revert when paused"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await tx.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await pauseTx.wait()`
{"Should fund as many addresses as possible"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await fundTx.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await assertWatchlistBalances(
          zeroLINK,
          zeroLINK,
          zeroLINK,
          zeroLINK,
          oneHundredLINK,
          oneHundredLINK,
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await assertWatchlistBalances(
          twoLINK,
          twoLINK,
          zeroLINK,
          zeroLINK,
          oneHundredLINK,
          oneHundredLINK,
        )`
{"Should fund the appropriate addresses"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await assertWatchlistBalances(
          zeroLINK,
          zeroLINK,
          zeroLINK,
          zeroLINK,
          oneHundredLINK,
          oneHundredLINK,
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await performTx.wait()`
{"Should only fund active, underfunded addresses"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await assertWatchlistBalances(
          zeroLINK,
          zeroLINK,
          zeroLINK,
          zeroLINK,
          oneHundredLINK,
          oneHundredLINK,
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await performTx.wait()`
{"Should not fund addresses that have been funded recently"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await setWaitPdTx.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await setTopUpTx.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await assertWatchlistBalances(
          zeroLINK,
          zeroLINK,
          zeroLINK,
          zeroLINK,
          oneHundredLINK,
          oneHundredLINK,
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await performTx.wait()`
{"Should only be callable by the keeper registry contract"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `performTx = bm.connect(stranger).performUpkeep(validPayload)`
{"Should protect against running out of gas"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await assertWatchlistBalances(
          zeroLINK,
          zeroLINK,
          zeroLINK,
          zeroLINK,
          oneHundredLINK,
          oneHundredLINK,
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await performTx.wait()`
{"Should provide enough gas to support receive and fallback functions"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await setTx.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await h.assertLinkTokenBalance(
          lt,
          receiveEmitter.address,
          reBalanceBefore.add(twoLINK),
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await h.assertLinkTokenBalance(
          lt,
          receiveFallbackEmitter.address,
          rfeBalanceBefore.add(twoLINK),
        )`
{"Should be callable by anyone"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await bm.connect(user).topUp([])`
{"Should be callable by no one"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `await bm.connect(owner).pause()`
{"Should allow anyone to add funds"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.transfer(bm.address, oneLINK)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(stranger)`
{"Should allow the owner to withdraw"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.balanceOf(owner.address)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.withdraw(oneLINK, owner.address)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.balanceOf(owner.address)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.gt(beforeBalance)`
{"Should emit an event"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.withdraw(oneLINK, owner.address)`
{"Should allow the owner to withdraw to anyone"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.balanceOf(stranger.address)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.withdraw(oneLINK, stranger.address)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.balanceOf(stranger.address)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.add(oneLINK)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.eq(afterBalance)`
{"Should not allow strangers to withdraw"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.withdraw(oneLINK, owner.address)`
{"Should allow owner to pause / unpause"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.unpause()`
{"Should not allow strangers to pause / unpause"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.unpause()`
{"Should allow owner to set the watchlist"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setWatchList([watchAddress1], [oneLINK], [twoLINK])`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setWatchList(
          [watchAddress1, watchAddress2, watchAddress3],
          [oneLINK, twoLINK, threeLINK],
          [twoLINK, threeLINK, fiveLINK],
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getAccountInfo(watchAddress2)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getAccountInfo(watchAddress3)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setWatchList(
          [watchAddress3, watchAddress1],
          [threeLINK, oneLINK],
          [fiveLINK, twoLINK],
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getAccountInfo(watchAddress2)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getAccountInfo(watchAddress3)`
{"Should not allow duplicates in the watchlist"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setWatchList(
          [watchAddress1, watchAddress2, watchAddress1],
          [oneLINK, twoLINK, threeLINK],
          [twoLINK, threeLINK, fiveLINK],
        )`
{"Should not allow a topUpLevel les than or equal to minBalance in the watchlist"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setWatchList(
          [watchAddress1, watchAddress2, watchAddress1],
          [oneLINK, twoLINK, threeLINK],
          [zeroLINK, twoLINK, threeLINK],
        )`
{"Should not allow larger than maximum watchlist size"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.from(Array(301).keys())`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.keys()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.forEach(() => {
        watchlist[0].push(owner.address)
        watchlist[1].push(oneLINK)
        watchlist[2].push(twoLINK)
      })`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.push(owner.address)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.push(oneLINK)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.push(twoLINK)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setWatchList(watchlist[0], watchlist[1], watchlist[2])`
{"Should not allow strangers to set the watchlist"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setWatchList([watchAddress1], [oneLINK], [twoLINK])`
{"Should revert if the list lengths differ"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setWatchList([watchAddress1], [], [twoLINK])`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setWatchList([watchAddress1], [oneLINK], [])`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setWatchList([], [oneLINK], [twoLINK])`
{"Should revert if any of the addresses are empty"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setWatchList(
          [watchAddress1, ethers.constants.AddressZero],
          [oneLINK, oneLINK],
          [twoLINK, twoLINK],
        )`
{"Should revert if any of the top up amounts are 0"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setWatchList(
          [watchAddress1, watchAddress2],
          [oneLINK, oneLINK],
          [twoLINK, zeroLINK],
        )`
{"Should initialize with the registry address provided to the constructor"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getKeeperRegistryAddress()`
{"Should allow the owner to set the registry address"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setKeeperRegistryAddress(newAddress)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getKeeperRegistryAddress()`
{"Should not allow strangers to set the registry address"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setKeeperRegistryAddress(newAddress)`
{"Should emit an event"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setKeeperRegistryAddress(newAddress)`
{"Should initialize with the wait period provided to the constructor"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getMinWaitPeriodSeconds()`
{"Should allow owner to set the wait period"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setMinWaitPeriodSeconds(newWaitPeriod)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getMinWaitPeriodSeconds()`
{"Should not allow strangers to set the wait period"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setMinWaitPeriodSeconds(newWaitPeriod)`
{"Should emit an event"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setMinWaitPeriodSeconds(newWaitPeriod)`
{"Should return list of address that are underfunded"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.transfer(
        bm.address,
        sixLINK, // needs 6 total
      )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.utils.defaultAbiCoder.decode(
        ['address[]'],
        payload,
      )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.getUnderfundedAddresses()`
{"Should return some results even if contract cannot fund all eligible targets"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.transfer(
        bm.address,
        fiveLINK, // needs 6 total
      )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.utils.defaultAbiCoder.decode(
        ['address[]'],
        payload,
      )`
{"Should omit addresses that have been funded recently"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setMinWaitPeriodSeconds(3600)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.transfer(bm.address, sixLINK)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.all([setWaitPdTx.wait(), fundTx.wait()])`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setLastTopUpXXXTestOnly(
        watchAddress2,
        block.timestamp - 100,
      )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.utils.defaultAbiCoder.decode(
        ['address[]'],
        payload,
      )`
{"Should revert when paused"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.performUpkeep(validPayload)`
{"Should fund as many addresses as possible"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.transfer(
          bm.address,
          fiveLINK, // only enough LINK to fund 2 addresses
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.performUpkeep(validPayload)`
{"Should fund the appropriate addresses"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.performUpkeep(validPayload, { gasLimit: 2_500_000 })`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
{"Should only fund active, underfunded addresses"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.performUpkeep(invalidPayload, { gasLimit: 2_500_000 })`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
{"Should not fund addresses that have been funded recently"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setMinWaitPeriodSeconds(3600)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setLastTopUpXXXTestOnly(
          watchAddress2,
          block.timestamp - 100,
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.performUpkeep(validPayload, { gasLimit: 2_500_000 })`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
{"Should only be callable by the keeper registry contract"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.performUpkeep(validPayload)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.performUpkeep(validPayload)`
{"Should protect against running out of gas"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.performUpkeep(validPayload, { gasLimit: 130_000 })`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.balanceOf(watchAddress1)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.balanceOf(watchAddress2)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.balanceOf(watchAddress3)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.map((n) => n.toString())`
{"Should provide enough gas to support receive and fallback functions"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.utils.defaultAbiCoder.encode(
          ['address[]'],
          [addresses],
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.setWatchList(
            addresses,
            new Array(2).fill(oneLINK),
            new Array(2).fill(twoLINK),
          )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.fill(oneLINK)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.fill(twoLINK)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.balanceOf(receiveEmitter.address)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.balanceOf(
          receiveFallbackEmitter.address,
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.performUpkeep(payload, { gasLimit: 2_500_000 })`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.assertLinkTokenBalance(
          lt,
          receiveEmitter.address,
          reBalanceBefore.add(twoLINK),
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.add(twoLINK)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.assertLinkTokenBalance(
          lt,
          receiveFallbackEmitter.address,
          rfeBalanceBefore.add(twoLINK),
        )`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.add(twoLINK)`
{"Should be callable by anyone"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(user)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.topUp([])`
{"Should be callable by no one"}
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.connect(user)`
$DIR/contracts/test/v0.8/automation/ERC20BalanceMonitor.test.ts: `.topUp([])`
{"Should allow anyone to add funds"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await owner.sendTransaction({
        to: bm.address,
        value: oneEth,
      })`
{"Should emit an event"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await owner.sendTransaction({
        to: bm.address,
        value: oneEth,
      })`
{"Should allow the owner to withdraw"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await tx.wait()`
{"Should allow the owner to withdraw to anyone"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await tx.wait()`
{"Should allow owner to pause / unpause"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await pauseTx.wait()`
{"Should not allow strangers to pause / unpause"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await pauseTxOwner.wait()`
{"Should allow owner to set the watchlist"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await setTx.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `setTx = await bm
        .connect(owner)
        .setWatchList(
          [watchAddress1, watchAddress2, watchAddress3],
          [oneEth, twoEth, threeEth],
          [oneEth, twoEth, threeEth],
        )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await setTx.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `watchList = await bm.getWatchList()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `setTx = await bm
        .connect(owner)
        .setWatchList(
          [watchAddress3, watchAddress1],
          [threeEth, oneEth],
          [threeEth, oneEth],
        )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await setTx.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `watchList = await bm.getWatchList()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `accountInfo1 = await bm.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `accountInfo2 = await bm.getAccountInfo(watchAddress2)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `accountInfo3 = await bm.getAccountInfo(watchAddress3)`
{"Should revert if the list lengths differ"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `tx = bm.connect(owner).setWatchList([watchAddress1], [oneEth], [])`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `tx = bm.connect(owner).setWatchList([], [oneEth], [twoEth])`
{"Should allow the owner to set the registry address"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await setTx.wait()`
{"Should allow owner to set the wait period"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await setTx.wait()`
{"Should return list of address that are underfunded"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await fundTx.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `addresses = await bm.getUnderfundedAddresses()`
{"Should return some results even if contract cannot fund all eligible targets"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await fundTx.wait()`
{"Should omit addresses that have been funded recently"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await Promise.all([setWaitPdTx.wait(), fundTx.wait()])`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await setTopUpTx.wait()`
{"Should revert when paused"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await tx.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await pauseTx.wait()`
{"Should fund as many addresses as possible"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await fundTx.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await assertWatchlistBalances(0, 0, 0, 0, 10_000, 10_000)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await assertWatchlistBalances(2, 2, 0, 0, 10_000, 10_000)`
{"Should fund the appropriate addresses"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await assertWatchlistBalances(0, 0, 0, 0, 10_000, 10_000)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await performTx.wait()`
{"Should only fund active, underfunded addresses"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await assertWatchlistBalances(0, 0, 0, 0, 10_000, 10_000)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await performTx.wait()`
{"Should continue funding addresses even if one reverts"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await assertWatchlistBalances(0, 0, 0, 0, 10_000, 10_000)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await setTx.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await performTx.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await assertWatchlistBalances(2, 2, 0, 0, 10_000, 10_000)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await h.assertBalance(receiveReverter.address, 0)`
{"Should not fund addresses that have been funded recently"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await setWaitPdTx.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await setTopUpTx.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await assertWatchlistBalances(0, 0, 0, 0, 10_000, 10_000)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await performTx.wait()`
{"Should only be callable by the keeper registry contract"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `performTx = bm.connect(stranger).performUpkeep(validPayload)`
{"Should protect against running out of gas"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await assertWatchlistBalances(0, 0, 0, 0, 10_000, 10_000)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await performTx.wait()`
{"Should provide enough gas to support receive and fallback functions"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await setTx.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await h.assertBalance(
          receiveEmitter.address,
          reBalanceBefore.add(twoEth),
        )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await h.assertBalance(
          receiveFallbackEmitter.address,
          rfeBalanceBefore.add(twoEth),
        )`
{"Should be callable by anyone"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await bm.connect(user).topUp([])`
{"Should be callable by no one"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `await bm.connect(owner).pause()`
{"Should allow anyone to add funds"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.sendTransaction({
        to: bm.address,
        value: oneEth,
      })`
{"Should emit an event"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.sendTransaction({
        to: bm.address,
        value: oneEth,
      })`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.sendTransaction({
        to: bm.address,
        value: oneEth,
      })`
{"Should allow the owner to withdraw"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getBalance()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.withdraw(oneEth, owner.address)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getBalance()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.gt(beforeBalance)`
{"Should emit an event"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.withdraw(oneEth, owner.address)`
{"Should allow the owner to withdraw to anyone"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getBalance()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.withdraw(oneEth, stranger.address)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getBalance()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.add(oneEth)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.eq(afterBalance)`
{"Should not allow strangers to withdraw"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.withdraw(oneEth, owner.address)`
{"Should allow owner to pause / unpause"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.unpause()`
{"Should not allow strangers to pause / unpause"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.unpause()`
{"Should allow owner to set the watchlist"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setWatchList([watchAddress1], [oneEth], [twoEth])`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setWatchList(
          [watchAddress1, watchAddress2, watchAddress3],
          [oneEth, twoEth, threeEth],
          [oneEth, twoEth, threeEth],
        )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getAccountInfo(watchAddress2)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getAccountInfo(watchAddress3)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setWatchList(
          [watchAddress3, watchAddress1],
          [threeEth, oneEth],
          [threeEth, oneEth],
        )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getAccountInfo(watchAddress2)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getAccountInfo(watchAddress3)`
{"Should not allow duplicates in the watchlist"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setWatchList(
          [watchAddress1, watchAddress2, watchAddress1],
          [oneEth, twoEth, threeEth],
          [oneEth, twoEth, threeEth],
        )`
{"Should not allow strangers to set the watchlist"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setWatchList([watchAddress1], [oneEth], [twoEth])`
{"Should revert if the list lengths differ"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setWatchList([watchAddress1], [], [twoEth])`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setWatchList([watchAddress1], [oneEth], [])`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setWatchList([], [oneEth], [twoEth])`
{"Should revert if any of the addresses are empty"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setWatchList(
          [watchAddress1, ethers.constants.AddressZero],
          [oneEth, oneEth],
          [twoEth, twoEth],
        )`
{"Should revert if any of the top up amounts are 0"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setWatchList(
          [watchAddress1, watchAddress2],
          [oneEth, oneEth],
          [twoEth, zeroEth],
        )`
{"Should initialize with the registry address provided to the constructor"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getKeeperRegistryAddress()`
{"Should allow the owner to set the registry address"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setKeeperRegistryAddress(newAddress)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getKeeperRegistryAddress()`
{"Should not allow strangers to set the registry address"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setKeeperRegistryAddress(newAddress)`
{"Should emit an event"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setKeeperRegistryAddress(newAddress)`
{"Should initialize with the wait period provided to the constructor"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getMinWaitPeriodSeconds()`
{"Should allow owner to set the wait period"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setMinWaitPeriodSeconds(newWaitPeriod)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getMinWaitPeriodSeconds()`
{"Should not allow strangers to set the wait period"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setMinWaitPeriodSeconds(newWaitPeriod)`
{"Should emit an event"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setMinWaitPeriodSeconds(newWaitPeriod)`
{"Should return list of address that are underfunded"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.sendTransaction({
        to: bm.address,
        value: sixEth, // needs 6 total
      })`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.utils.defaultAbiCoder.decode(
        ['address[]'],
        payload,
      )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.getUnderfundedAddresses()`
{"Should return some results even if contract cannot fund all eligible targets"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.sendTransaction({
        to: bm.address,
        value: fiveEth, // needs 6 total
      })`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.utils.defaultAbiCoder.decode(
        ['address[]'],
        payload,
      )`
{"Should omit addresses that have been funded recently"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setMinWaitPeriodSeconds(3600)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.sendTransaction({
        to: bm.address,
        value: sixEth,
      })`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.all([setWaitPdTx.wait(), fundTx.wait()])`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setLastTopUpXXXTestOnly(
        watchAddress2,
        block.timestamp - 100,
      )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.utils.defaultAbiCoder.decode(
        ['address[]'],
        payload,
      )`
{"Should revert when paused"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.performUpkeep(validPayload)`
{"Should fund as many addresses as possible"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.sendTransaction({
          to: bm.address,
          value: fiveEth, // only enough eth to fund 2 addresses
        })`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.performUpkeep(validPayload)`
{"Should fund the appropriate addresses"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.performUpkeep(validPayload, { gasLimit: 2_500_000 })`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
{"Should only fund active, underfunded addresses"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.performUpkeep(invalidPayload, { gasLimit: 2_500_000 })`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
{"Should continue funding addresses even if one reverts"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setWatchList(
            addresses,
            new Array(3).fill(oneEth),
            new Array(3).fill(twoEth),
          )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.fill(oneEth)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.fill(twoEth)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.utils.defaultAbiCoder.encode(
          ['address[]'],
          [addresses],
        )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.performUpkeep(payload, { gasLimit: 2_500_000 })`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.assertBalance(receiveReverter.address, 0)`
{"Should not fund addresses that have been funded recently"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setMinWaitPeriodSeconds(3600)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setLastTopUpXXXTestOnly(
          watchAddress2,
          block.timestamp - 100,
        )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.performUpkeep(validPayload, { gasLimit: 2_500_000 })`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
{"Should only be callable by the keeper registry contract"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.performUpkeep(validPayload)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.performUpkeep(validPayload)`
{"Should protect against running out of gas"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.performUpkeep(validPayload, { gasLimit: 130_000 })`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.provider.getBalance(watchAddress1)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.provider.getBalance(watchAddress2)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.provider.getBalance(watchAddress3)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.map((n) => n.toString())`
{"Should provide enough gas to support receive and fallback functions"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.utils.defaultAbiCoder.encode(
          ['address[]'],
          [addresses],
        )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.setWatchList(
            addresses,
            new Array(2).fill(oneEth),
            new Array(2).fill(twoEth),
          )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.fill(oneEth)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.fill(twoEth)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.provider.getBalance(
          receiveEmitter.address,
        )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.provider.getBalance(
          receiveFallbackEmitter.address,
        )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.performUpkeep(payload, { gasLimit: 2_500_000 })`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.assertBalance(
          receiveEmitter.address,
          reBalanceBefore.add(twoEth),
        )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.add(twoEth)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.assertBalance(
          receiveFallbackEmitter.address,
          rfeBalanceBefore.add(twoEth),
        )`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.add(twoEth)`
{"Should be callable by anyone"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(user)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.topUp([])`
{"Should be callable by no one"}
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.connect(user)`
$DIR/contracts/test/v0.8/automation/EthBalanceMonitor.test.ts: `.topUp([])`
{"is generated from composite contracts without competing definitions"}
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_2.test.ts: `sharedSet.add(entryID(entry))`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_2.test.ts: `abiSet.add(id)`
{"is up to date"}
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_2.test.ts: `.utils.id(compositeABIs.join(''))`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_2.test.ts: `.join('')`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_2.test.ts: `.readFileSync(
        'src/v0.8/automation/interfaces/v2_2/IAutomationRegistryMaster.sol',
      )`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_2.test.ts: `.slice(17, 83)`
{"is generated from composite contracts without competing definitions"}
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_2.test.ts: `.add(entryID(entry))`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_2.test.ts: `.has(id)`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_2.test.ts: `.add(id)`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_2.test.ts: `.has(id)`
{"is generated from composite contracts without competing definitions"}
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_3.test.ts: `sharedSet.add(entryID(entry))`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_3.test.ts: `abiSet.add(id)`
{"is up to date"}
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_3.test.ts: `.utils.id(compositeABIs.join(''))`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_3.test.ts: `.join('')`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_3.test.ts: `.readFileSync(
        'src/v0.8/automation/interfaces/v2_3/IAutomationRegistryMaster2_3.sol',
      )`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_3.test.ts: `.slice(17, 83)`
{"is generated from composite contracts without competing definitions"}
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_3.test.ts: `.add(entryID(entry))`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_3.test.ts: `.has(id)`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_3.test.ts: `.add(id)`
$DIR/contracts/test/v0.8/automation/IAutomationRegistryMaster2_3.test.ts: `.has(id)`
{"prevents execution of protected functions"}
$DIR/contracts/test/v0.8/automation/KeeperCompatible.test.ts: `await contract
          .connect(ethers.constants.AddressZero)
          .verifyCannotExecute()`
$DIR/contracts/test/v0.8/automation/KeeperCompatible.test.ts: `.connect(ethers.constants.AddressZero)`
$DIR/contracts/test/v0.8/automation/KeeperCompatible.test.ts: `.verifyCannotExecute()`
$DIR/contracts/test/v0.8/automation/KeeperCompatible.test.ts: `.verifyCannotExecute()`
{"should allow anyone to add funds"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await lt.transfer(labm.address, oneLINK)`
{"configures the top-up amount"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm
        .connect(owner)
        .setTopUpAmount(directTarget1.address, BigNumber.from(100))`
{"configures the min balance"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm
        .connect(owner)
        .setMinBalance(proxy1.address, BigNumber.from(100))`
{"configures the MaxPerform"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.connect(owner).setMaxPerform(BigNumber.from(100))`
{"configures the MaxCheck"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.connect(owner).setMaxCheck(BigNumber.from(100))`
{"configures the UpkeepInterval"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.connect(owner).setUpkeepInterval(BigNumber.from(100))`
{"should allow the owner to withdraw"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await tx.wait()`
{"should allow the owner to withdraw to anyone"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await tx.wait()`
{"should allow owner to pause / unpause"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await pauseTx.wait()`
{"should not allow strangers to pause / unpause"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await pauseTxOwner.wait()`
{"should allow owner to adjust the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm
        .connect(owner)
        .setWatchList([watchAddress1], [oneLINK], [oneLINK], [0])`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await tx.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `watchList = await labm.getWatchList()`
{"should allow owner to add multiple addresses with dstChainSelector 0 to the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await tx.wait`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `tx = await labm
        .connect(owner)
        .addToWatchListOrDecommission(watchAddress2, 0)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await tx.wait`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `watchList = await labm.getWatchList()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `tx = await labm
        .connect(owner)
        .addToWatchListOrDecommission(watchAddress3, 0)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await tx.wait`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `watchList = await labm.getWatchList()`
{"should allow owner to add only one address with an unique non-zero dstChainSelector 0 to the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await tx.wait`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `tx = await labm
        .connect(owner)
        .addToWatchListOrDecommission(watchAddress2, 1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await tx.wait`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `watchList = await labm.getWatchList()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `report = await labm.getAccountInfo(watchAddress2)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `report = await labm.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `tx = await labm
        .connect(owner)
        .addToWatchListOrDecommission(watchAddress3, 1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await tx.wait`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `watchList = await labm.getWatchList()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `report = await labm.getAccountInfo(watchAddress3)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `report = await labm.getAccountInfo(watchAddress2)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `report = await labm.getAccountInfo(watchAddress1)`
{"should not add address 0 to the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm
        .connect(owner)
        .addToWatchListOrDecommission(ethers.constants.AddressZero, 1)`
{"should allow owner to remove addresses from the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await tx.wait`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.connect(owner).removeFromWatchList(watchAddress1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `report = await labm.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `watchList = await labm.getWatchList()`
{"should allow only one address per dstChainSelector"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.connect(owner).addToWatchListOrDecommission(watchAddress1, 1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.connect(owner).addToWatchListOrDecommission(watchAddress2, 1)`
{"should delete the onRamp address on a zero-address with same dstChainSelector"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.connect(owner).addToWatchListOrDecommission(watchAddress1, 1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm
        .connect(owner)
        .addToWatchListOrDecommission(ethers.constants.AddressZero, 1)`
{"should return list of address that are underfunded"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await fundTx.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.setWatchList(
        watchListAddresses,
        watchListMinBalances,
        watchListTopUpAmounts,
        watchListDstChainSelectors,
      )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `addresses = await labm.sampleUnderfundedAddresses()`
{"should return false because the monitor is underfunded"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await fundTx.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.setWatchList(
        watchListAddresses,
        watchListMinBalances,
        watchListTopUpAmounts,
        watchListDstChainSelectors,
      )`
{"should omit aggregators that have sufficient funding"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await fundTx.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.setWatchList(
        [aggregator2.address, directTarget1.address, directTarget2.address],
        [oneLINK, twoLINK, twoLINK],
        [oneLINK, oneLINK, oneLINK],
        [1, 2, 3],
      )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator2.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget1.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget2.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator2.mock.linkAvailableForPayment.returns(oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget1.mock.linkAvailableForPayment.returns(oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget2.mock.linkAvailableForPayment.returns(oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `addresses = await labm.sampleUnderfundedAddresses()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget1.mock.linkAvailableForPayment.returns(tenLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `addresses = await labm.sampleUnderfundedAddresses()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget2.mock.linkAvailableForPayment.returns(tenLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `addresses = await labm.sampleUnderfundedAddresses()`
{"should revert when paused"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await tx.wait()`
{"should sample from the list of addresses pseudorandomly"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `firstAddress.push(addresses[0])`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await mineBlock(ethers.provider)`
{"can check MAX_CHECK upkeeps within the allotted gas limit"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator.mock.linkAvailableForPayment.returns(tenLINK)`
{"should revert when paused"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.connect(owner).pause()`
{"should fund the appropriate addresses"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator1.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator2.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator3.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget1.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget2.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await fundTx.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, aggregator1.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, aggregator2.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, aggregator3.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, directTarget1.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, directTarget2.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await performTx.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, aggregator1.address, twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, aggregator2.address, twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, aggregator3.address, twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, directTarget1.address, twoLINK)`
{"can handle MAX_PERFORM proxies within gas limit"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await proxy.mock.aggregator.returns(aggregator.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator.mock.linkAvailableForPayment.returns(0)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `proxyAddresses.push(proxy.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `minBalances.push(oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `topUpAmount.push(oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `dstChainSelectors.push(0)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.setWatchList(
        proxyAddresses,
        minBalances,
        topUpAmount,
        dstChainSelectors,
      )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `fundsNeeded.add(targetTopUpAmount)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await lt.connect(owner).transfer(labm.address, fundsNeeded)`
{"should be callable by anyone"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.connect(user).topUp([])`
{"should be callable by no one"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm.connect(owner).pause()`
{"should fund the appropriate addresses"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator1.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator2.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator3.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget1.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget2.mock.linkAvailableForPayment.returns(twoLINK)`
{"should only fund the addresses provided"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm
          .connect(keeperRegistry)
          .topUp([proxy1.address, directTarget1.address])`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator1.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator2.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator3.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget1.mock.linkAvailableForPayment.returns(twoLINK)`
{"should skip un-approved addresses"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm
          .connect(owner)
          .setWatchList(
            [proxy1.address, directTarget1.address],
            [oneLINK, oneLINK],
            [oneLINK, oneLINK],
            [1, 2],
          )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, aggregator1.address, oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, aggregator2.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, aggregator3.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, directTarget1.address, oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await h.assertLinkTokenBalance(lt, directTarget2.address, zeroLINK)`
{"should skip an address if the proxy is invalid and it is not a direct target"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm
          .connect(owner)
          .setWatchList(
            [proxy1.address, proxy4.address],
            [oneLINK, oneLINK],
            [oneLINK, oneLINK],
            [1, 2],
          )`
{"should skip an address if the aggregator is invalid"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await proxy4.mock.aggregator.returns(aggregator4.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm
          .connect(owner)
          .setWatchList(
            [proxy1.address, proxy4.address],
            [oneLINK, oneLINK],
            [oneLINK, oneLINK],
            [1, 2],
          )`
{"should skip an address if the aggregator has sufficient funding"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await proxy4.mock.aggregator.returns(aggregator4.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator4.mock.linkAvailableForPayment.returns(tenLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm
          .connect(owner)
          .setWatchList(
            [proxy1.address, proxy4.address],
            [oneLINK, oneLINK],
            [oneLINK, oneLINK],
            [1, 2],
          )`
{"should skip an address if the direct target has sufficient funding"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget1.mock.linkAvailableForPayment.returns(tenLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await labm
          .connect(owner)
          .setWatchList(
            [proxy1.address, directTarget1.address],
            [oneLINK, oneLINK],
            [oneLINK, oneLINK],
            [1, 2],
          )`
{"should fund as many addresses as possible"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await lt.connect(owner).transfer(
          labm.address,
          fourLINK, // only enough LINK to fund 2 addresses
        )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator1.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator2.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await aggregator3.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget1.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `await directTarget2.mock.linkAvailableForPayment.returns(zeroLINK)`
{"should allow anyone to add funds"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.transfer(labm.address, oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(stranger)`
{"configures the top-up amount"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setTopUpAmount(directTarget1.address, BigNumber.from(100))`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.from(100)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(directTarget1.address)`
{"is only callable by the owner"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setTopUpAmount(directTarget1.address, 100)`
{"configures the min balance"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setMinBalance(proxy1.address, BigNumber.from(100))`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.from(100)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(proxy1.address)`
{"reverts if address is not in the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setMinBalance(proxy4.address, 100)`
{"is only callable by the owner"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setMinBalance(proxy1.address, 100)`
{"configures the MaxPerform"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setMaxPerform(BigNumber.from(100))`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.from(100)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getMaxPerform()`
{"is only callable by the owner"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setMaxPerform(100)`
{"configures the MaxCheck"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setMaxCheck(BigNumber.from(100))`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.from(100)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getMaxCheck()`
{"is only callable by the owner"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setMaxCheck(100)`
{"configures the UpkeepInterval"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setUpkeepInterval(BigNumber.from(100))`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.from(100)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getUpkeepInterval()`
{"is only callable by the owner"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setUpkeepInterval(100)`
{"should allow the owner to withdraw"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.balanceOf(owner.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.withdraw(oneLINK, owner.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.balanceOf(owner.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.gt(beforeBalance)`
{"should emit an event"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.withdraw(oneLINK, owner.address)`
{"should allow the owner to withdraw to anyone"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.balanceOf(stranger.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.withdraw(oneLINK, stranger.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.balanceOf(stranger.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.add(oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.eq(afterBalance)`
{"should not allow strangers to withdraw"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.withdraw(oneLINK, owner.address)`
{"should allow owner to pause / unpause"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.unpause()`
{"should not allow strangers to pause / unpause"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.unpause()`
{"should allow owner to adjust the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList([watchAddress1], [oneLINK], [oneLINK], [0])`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList(
          [watchAddress1, watchAddress2, watchAddress3],
          [oneLINK, oneLINK, oneLINK],
          [oneLINK, oneLINK, oneLINK],
          [1, 2, 3],
        )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
{"should not allow different length arrays in the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList(
          [watchAddress1, watchAddress2, watchAddress1],
          [oneLINK, oneLINK],
          [oneLINK, oneLINK],
          [1, 2],
        )`
{"should not allow duplicates in the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList(
          [watchAddress1, watchAddress2, watchAddress1],
          [oneLINK, oneLINK, oneLINK],
          [oneLINK, oneLINK, oneLINK],
          [1, 2, 3],
        )`
{"should not allow strangers to set the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList([watchAddress1], [oneLINK], [oneLINK], [0])`
{"should revert if any of the addresses are empty"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList(
          [watchAddress1, ethers.constants.AddressZero],
          [oneLINK, oneLINK],
          [oneLINK, oneLINK],
          [1, 2],
        )`
{"should allow owner to add multiple addresses with dstChainSelector 0 to the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.addToWatchListOrDecommission(watchAddress1, 0)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.addToWatchListOrDecommission(watchAddress2, 0)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.addToWatchListOrDecommission(watchAddress3, 0)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
{"should allow owner to add only one address with an unique non-zero dstChainSelector 0 to the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.addToWatchListOrDecommission(watchAddress1, 1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.addToWatchListOrDecommission(watchAddress2, 1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(watchAddress2)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.addToWatchListOrDecommission(watchAddress3, 1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(watchAddress3)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(watchAddress2)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(watchAddress1)`
{"should not add address 0 to the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.addToWatchListOrDecommission(ethers.constants.AddressZero, 1)`
{"should not allow stangers to add addresses to the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(stranger)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.addToWatchListOrDecommission(watchAddress1, 1)`
{"should allow owner to remove addresses from the watchlist"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.addToWatchListOrDecommission(watchAddress1, 1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.removeFromWatchList(watchAddress1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(watchAddress1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
{"should allow only one address per dstChainSelector"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.addToWatchListOrDecommission(watchAddress1, 1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.addToWatchListOrDecommission(watchAddress2, 1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
{"should delete the onRamp address on a zero-address with same dstChainSelector"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.addToWatchListOrDecommission(watchAddress1, 1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.addToWatchListOrDecommission(ethers.constants.AddressZero, 1)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
{"should return list of address that are underfunded"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.transfer(labm.address, oneHundredLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList(
        watchListAddresses,
        watchListMinBalances,
        watchListTopUpAmounts,
        watchListDstChainSelectors,
      )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.utils.defaultAbiCoder.decode(
        ['address[]'],
        payload,
      )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.sampleUnderfundedAddresses()`
{"should return false because the monitor is underfunded"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.transfer(labm.address, fourLINK.add(fourLINK))`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.add(fourLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList(
        watchListAddresses,
        watchListMinBalances,
        watchListTopUpAmounts,
        watchListDstChainSelectors,
      )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.checkUpkeep('0x')`
{"should omit aggregators that have sufficient funding"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.transfer(
        labm.address,
        oneHundredLINK, // enough for anything that needs funding
      )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList(
        [aggregator2.address, directTarget1.address, directTarget2.address],
        [oneLINK, twoLINK, twoLINK],
        [oneLINK, oneLINK, oneLINK],
        [1, 2, 3],
      )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.sampleUnderfundedAddresses()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.sampleUnderfundedAddresses()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(tenLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.sampleUnderfundedAddresses()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(tenLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.sampleUnderfundedAddresses()`
{"should revert when paused"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.checkUpkeep('0x')`
{"should not include more than MAX_PERFORM addresses"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.sampleUnderfundedAddresses()`
{"should sample from the list of addresses pseudorandomly"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.sampleUnderfundedAddresses()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.push(addresses[0])`
{"can check MAX_CHECK upkeeps within the allotted gas limit"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(tenLINK)`
{"should revert when paused"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.performUpkeep(validPayload)`
{"should fund the appropriate addresses"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.transfer(labm.address, tenLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, aggregator1.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, aggregator2.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, aggregator3.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, directTarget1.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, directTarget2.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.performUpkeep(validPayload, { gasLimit: 1_500_000 })`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, aggregator1.address, twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, aggregator2.address, twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, aggregator3.address, twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, directTarget1.address, twoLINK)`
{"can handle MAX_PERFORM proxies within gas limit"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getMaxPerform()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.aggregator.returns(aggregator.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(0)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.push(proxy.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.push(oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.push(oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.push(0)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList(
        proxyAddresses,
        minBalances,
        topUpAmount,
        dstChainSelectors,
      )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getWatchList()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.from(0)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(wl[idx])`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.add(targetTopUpAmount)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.transfer(labm.address, fundsNeeded)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.utils.defaultAbiCoder.encode(
        ['address[]'],
        [proxyAddresses],
      )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(keeperRegistry)`
{"should revert topUp address(0)"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.topUp([ethers.constants.AddressZero])`
{"should be callable by anyone"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(user)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.topUp([])`
{"should be callable by no one"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(user)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.topUp([])`
{"should fund the appropriate addresses"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(proxy1.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(directTarget1.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.topUp(watchListAddresses)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(proxy1.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(directTarget1.address)`
{"should only fund the addresses provided"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.topUp([proxy1.address, directTarget1.address])`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(twoLINK)`
{"should skip un-approved addresses"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList(
            [proxy1.address, directTarget1.address],
            [oneLINK, oneLINK],
            [oneLINK, oneLINK],
            [1, 2],
          )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.topUp([
            proxy1.address,
            proxy2.address,
            proxy3.address,
            directTarget1.address,
            directTarget2.address,
          ])`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, aggregator1.address, oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, aggregator2.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, aggregator3.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, directTarget1.address, oneLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.assertLinkTokenBalance(lt, directTarget2.address, zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(proxy1.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.getAccountInfo(directTarget2.address)`
{"should skip an address if the proxy is invalid and it is not a direct target"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList(
            [proxy1.address, proxy4.address],
            [oneLINK, oneLINK],
            [oneLINK, oneLINK],
            [1, 2],
          )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.topUp([proxy1.address, proxy4.address])`
{"should skip an address if the aggregator is invalid"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.aggregator.returns(aggregator4.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList(
            [proxy1.address, proxy4.address],
            [oneLINK, oneLINK],
            [oneLINK, oneLINK],
            [1, 2],
          )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.topUp([proxy1.address, proxy4.address])`
{"should skip an address if the aggregator has sufficient funding"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.aggregator.returns(aggregator4.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(tenLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList(
            [proxy1.address, proxy4.address],
            [oneLINK, oneLINK],
            [oneLINK, oneLINK],
            [1, 2],
          )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.topUp([proxy1.address, proxy4.address])`
{"should skip an address if the direct target has sufficient funding"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(tenLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.setWatchList(
            [proxy1.address, directTarget1.address],
            [oneLINK, oneLINK],
            [oneLINK, oneLINK],
            [1, 2],
          )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.topUp([proxy1.address, directTarget1.address])`
{"should fund as many addresses as possible"}
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.transfer(
          labm.address,
          fourLINK, // only enough LINK to fund 2 addresses
        )`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(twoLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.mock.linkAvailableForPayment.returns(zeroLINK)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.connect(keeperRegistry)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.topUp(watchListAddresses)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.balanceOf(directTarget1.address)`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.toBigInt()`
$DIR/contracts/test/v0.8/automation/LinkAvailableBalanceMonitor.test.ts: `.toBigInt()`
{"should set config correctly"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await upkeepBalanceMonitor.connect(owner).setConfig(newConfig)`
{"should set the forwarder correctly"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await upkeepBalanceMonitor.connect(owner).setForwarder(newForwarder)`
{"should add addresses to the watchlist"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await upkeepBalanceMonitor
        .connect(owner)
        .setWatchList(registry.address, newWatchList)`
{"should withdraw funds to a payee"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await upkeepBalanceMonitor.connect(owner).withdraw(withdrawAmount, payee)`
{"should pause and unpause the contract"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await upkeepBalanceMonitor.connect(owner).pause()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await upkeepBalanceMonitor.connect(owner).unpause()`
{"cannot be called by a non-owner"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await upkeepBalanceMonitor.connect(owner).pause()`
{"should find the underfunded upkeeps"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await registry.mock.getBalance.withArgs(2).returns(120)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await registry.mock.getBalance.withArgs(4).returns(15)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await registry.mock.getBalance.withArgs(5).returns(0)
      ;`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `[upkeepIDs, registries, topUpAmounts] =
        await upkeepBalanceMonitor.getUnderfundedUpkeeps()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `[upkeepNeeded, performData] =
        await upkeepBalanceMonitor.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await registry.mock.getBalance.withArgs(i).returns(0)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await registry2.mock.getBalance.withArgs(i).returns(0)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `;`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `[upkeepIDs, registries, topUpAmounts] =
        await upkeepBalanceMonitor.getUnderfundedUpkeeps()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await registry.mock.getBalance.withArgs(0).returns(300)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await registry.mock.getBalance.withArgs(5).returns(300)
      ;`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `[upkeepIDs, registries, topUpAmounts] =
        await upkeepBalanceMonitor.getUnderfundedUpkeeps()`
{"should revert if the contract is paused"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await upkeepBalanceMonitor.connect(owner).pause()`
{"works round-trip"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await registry.mock.getBalance.withArgs(1).returns(100)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await registry.mock.getBalance.withArgs(7).returns(0)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await registry.mock.onTokenTransfer
        .withArgs(
          upkeepBalanceMonitor.address,
          200,
          ethers.utils.defaultAbiCoder.encode(['uint256'], [1]),
        )
        .returns()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await registry.mock.onTokenTransfer
        .withArgs(
          upkeepBalanceMonitor.address,
          300,
          ethers.utils.defaultAbiCoder.encode(['uint256'], [7]),
        )
        .returns()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `await upkeepBalanceMonitor.connect(owner).performUpkeep(performData)`
{"should set the initial values correctly"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.getConfig()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.utils.parseEther('100')`
{"should set config correctly"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.setConfig(newConfig)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.getConfig()`
{"should set the forwarder correctly"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.setForwarder(newForwarder)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.getForwarder()`
{"should add addresses to the watchlist"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.setWatchList(registry.address, newWatchList)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.getWatchList()`
{"should withdraw funds to a payee"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.balanceOf(
        upkeepBalanceMonitor.address,
      )`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.withdraw(withdrawAmount, payee)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.balanceOf(
        upkeepBalanceMonitor.address,
      )`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.balanceOf(payee)`
{"should pause and unpause the contract"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.unpause()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.paused()`
{"cannot be called by a non-owner"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.pause()`
{"should find the underfunded upkeeps"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.getUnderfundedUpkeeps()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.mock.getBalance.withArgs(2)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.returns(120)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.mock.getBalance.withArgs(4)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.returns(15)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.mock.getBalance.withArgs(5)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.returns(0)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.getUnderfundedUpkeeps()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.mock.getBalance.withArgs(i)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.returns(0)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.mock.getBalance.withArgs(i)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.returns(0)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.getUnderfundedUpkeeps()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.mock.getBalance.withArgs(0)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.returns(300)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.mock.getBalance.withArgs(5)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.returns(300)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.getUnderfundedUpkeeps()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.fill(300)`
{"should revert if the contract is paused"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.pause()`
{"tops up the upkeeps by the amounts provided"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.topUp([1, 7], [registry.address, registry.address], [100, 50])`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.balanceOf(registry.address)`
{"does not abort if one top-up fails"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.topUp(
          [1, 7, 100],
          [registry.address, registry.address, registry.address],
          [100, 50, 100],
        )`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.balanceOf(registry.address)`
{"works round-trip"}
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.mock.getBalance.withArgs(1)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.returns(100)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.mock.getBalance.withArgs(7)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.returns(0)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.mock.onTokenTransfer
        .withArgs(
          upkeepBalanceMonitor.address,
          200,
          ethers.utils.defaultAbiCoder.encode(['uint256'], [1]),
        )`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.utils.defaultAbiCoder.encode(['uint256'], [1])`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.returns()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.mock.onTokenTransfer
        .withArgs(
          upkeepBalanceMonitor.address,
          300,
          ethers.utils.defaultAbiCoder.encode(['uint256'], [7]),
        )`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.utils.defaultAbiCoder.encode(['uint256'], [7])`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.returns()`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.checkUpkeep('0x')`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.performUpkeep(performData)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/UpkeepBalanceMonitor.test.ts: `.add(500)`
{"reverts if the from type is not V1 or V2"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `await evmRevert(
        transcoder.transcodeUpkeeps(
          UpkeepFormat.V3,
          UpkeepFormat.V1,
          encodedData,
        ),
      )`
{"transcodes V1 upkeeps to V3 properly, regardless of toVersion value"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `upkeepsV1 = [
          [
            balance,
            lastKeeper0,
            executeGas,
            2 ** 32,
            target0,
            amountSpent,
            await admin0.getAddress(),
          ],
          [
            balance,
            lastKeeper1,
            executeGas,
            2 ** 32,
            target1,
            amountSpent,
            await admin1.getAddress(),
          ],
        ]`
{"transcodes V2 upkeeps to V3 properly, regardless of toVersion value"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `upkeepsV2 = [
          [
            balance,
            lastKeeper0,
            amountSpent,
            await admin0.getAddress(),
            executeGas,
            2 ** 32 - 1,
            target0,
            false,
          ],
          [
            balance,
            lastKeeper1,
            amountSpent,
            await admin1.getAddress(),
            executeGas,
            2 ** 32 - 1,
            target1,
            false,
          ],
        ]`
{"migrates upkeeps from 1.2 registry to 2.0"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `await linkToken
          .connect(owner)
          .approve(legacyRegistry.address, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `await legacyRegistry.connect(owner).addFunds(id, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `await legacyRegistry.setPeerRegistryMigrationPermission(
          Registry2_0.address,
          1,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `await Registry2_0.setPeerRegistryMigrationPermission(
          legacyRegistry.address,
          2,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `await legacyRegistry
          .connect(admin0)
          .migrateUpkeeps([id], Registry2_0.address)`
{"migrates upkeeps from 1.3 registry to 2.0"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `await linkToken
          .connect(owner)
          .approve(legacyRegistry.address, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `await legacyRegistry.connect(owner).addFunds(id, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `await legacyRegistry.setPeerRegistryMigrationPermission(
          Registry2_0.address,
          1,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `await Registry2_0.setPeerRegistryMigrationPermission(
          legacyRegistry.address,
          2,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `await legacyRegistry
          .connect(admin0)
          .migrateUpkeeps([id], Registry2_0.address)`
{"uses the correct type and version"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.typeAndVersion()`
{"reverts if the from type is not V1 or V2"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.transcodeUpkeeps(
          UpkeepFormat.V3,
          UpkeepFormat.V1,
          encodedData,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.transcodeUpkeeps(
          UpkeepFormat.V4,
          UpkeepFormat.V1,
          encodedData,
        )`
{"transcodes V1 upkeeps to V3 properly, regardless of toVersion value"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.transcodeUpkeeps(
          UpkeepFormat.V1,
          UpkeepFormat.V1,
          encodeUpkeepV1(idx, upkeepsV1, ['0xabcd', '0xffff']),
        )`
{"transcodes V2 upkeeps to V3 properly, regardless of toVersion value"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.transcodeUpkeeps(
          UpkeepFormat.V2,
          UpkeepFormat.V2,
          encodeUpkeepV2(idx, upkeepsV2, ['0xabcd', '0xffff']),
        )`
{"migrates upkeeps from 1.2 registry to 2.0"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.approve(legacyRegistry.address, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.addFunds(id, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.setPeerRegistryMigrationPermission(
          Registry2_0.address,
          1,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.setPeerRegistryMigrationPermission(
          legacyRegistry.address,
          2,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.connect(admin0)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.migrateUpkeeps([id], Registry2_0.address)`
{"migrates upkeeps from 1.3 registry to 2.0"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.approve(legacyRegistry.address, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.addFunds(id, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.setPeerRegistryMigrationPermission(
          Registry2_0.address,
          1,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.setPeerRegistryMigrationPermission(
          legacyRegistry.address,
          2,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.connect(admin0)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder3_0.test.ts: `.migrateUpkeeps([id], Registry2_0.address)`
{"migrates upkeeps from 1.2 registry to 2.1"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await linkToken
          .connect(owner)
          .approve(registry12.address, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await registry12.connect(owner).addFunds(id12, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await registry12.setPeerRegistryMigrationPermission(
          registry21.address,
          1,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await registry21.setPeerRegistryMigrationPermission(
          registry12.address,
          2,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await registry12
          .connect(admin0)
          .migrateUpkeeps([id12], registry21.address)`
{"migrates upkeeps from 1.3 registry to 2.1"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await linkToken
          .connect(owner)
          .approve(registry13.address, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await registry13.connect(owner).addFunds(id13, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await registry13.setPeerRegistryMigrationPermission(
          registry21.address,
          1,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await registry21.setPeerRegistryMigrationPermission(
          registry13.address,
          2,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await registry13
          .connect(admin0)
          .migrateUpkeeps([id13], registry21.address)`
{"migrates upkeeps from 2.0 registry to 2.1"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await linkToken
          .connect(owner)
          .approve(registry20.address, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await registry20.connect(owner).addFunds(id20, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await registry20.setPeerRegistryMigrationPermission(
          registry21.address,
          1,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await registry21.setPeerRegistryMigrationPermission(
          registry20.address,
          2,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `await registry20
          .connect(admin0)
          .migrateUpkeeps([id20], registry21.address)`
{"has not changed"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.utils.id(UpkeepTranscoderFactory.bytecode)`
{"uses the correct type and version"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.typeAndVersion()`
{"reverts if the from type is not v1.2, v1.3, v2.0, or v2.1"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.transcodeUpkeeps(
          UpkeepFormat.V30,
          UpkeepFormat.V12,
          encodedData,
        )`
{"transcodes to v2.1, regardless of toVersion value"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.transcodeUpkeeps(
          UpkeepFormat.V12,
          UpkeepFormat.V12,
          encodeUpkeepV12(idx, upkeepsV12, ['0xabcd', '0xffff']),
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.transcodeUpkeeps(
          UpkeepFormat.V12,
          UpkeepFormat.V13,
          encodeUpkeepV12(idx, upkeepsV12, ['0xabcd', '0xffff']),
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.transcodeUpkeeps(
          UpkeepFormat.V12,
          100,
          encodeUpkeepV12(idx, upkeepsV12, ['0xabcd', '0xffff']),
        )`
{"migrates upkeeps from 1.2 registry to 2.1"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.approve(registry12.address, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.addFunds(id12, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.setPeerRegistryMigrationPermission(
          registry21.address,
          1,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.setPeerRegistryMigrationPermission(
          registry12.address,
          2,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.connect(admin0)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.migrateUpkeeps([id12], registry21.address)`
{"migrates upkeeps from 1.3 registry to 2.1"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.approve(registry13.address, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.addFunds(id13, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.setPeerRegistryMigrationPermission(
          registry21.address,
          1,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.setPeerRegistryMigrationPermission(
          registry13.address,
          2,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.connect(admin0)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.migrateUpkeeps([id13], registry21.address)`
{"migrates upkeeps from 2.0 registry to 2.1"}
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.approve(registry20.address, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.addFunds(id20, toWei('1000'))`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.setPeerRegistryMigrationPermission(
          registry21.address,
          1,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.setPeerRegistryMigrationPermission(
          registry20.address,
          2,
        )`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.connect(admin0)`
$DIR/contracts/test/v0.8/automation/UpkeepTranscoder4_0.test.ts: `.migrateUpkeeps([id20], registry21.address)`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(owner).pause()`
{"reverts when report data lengths mismatches"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `upkeepIds.push(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `gasLimits.push(performGas)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `triggers.push('0x')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `performDatas.push('0x')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `performDatas.push('0x')`
{"performs even when the upkeep has insufficient funds and the upkeep pays out all the remaining balance"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(admin).addFunds(upkeepId, BigNumber.from(10))`
{"returns early when check block number is less than last perform (block)"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await tx.wait()`
{"handles case when check block number is older than 256 blocks"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await ethers.provider.send('evm_mine', [])`
{"allows bypassing reorg protection with reorgProtectionEnabled false config"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `newConfig.reorgProtectionEnabled = false`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry // used to test initial configurations
          .connect(owner)
          .setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"allows very old trigger block numbers when bypassing reorg protection with reorgProtectionEnabled config"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `newConfig.reorgProtectionEnabled = false`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry // used to test initial configurations
          .connect(owner)
          .setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await ethers.provider.send('evm_mine', [])`
{"allows very old trigger block numbers when bypassing reorg protection with empty blockhash"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await ethers.provider.send('evm_mine', [])`
{"returns early when future block number is provided as trigger, irrespective of blockhash being present"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `tx = await getTransmitTx(registry, keeper1, [id], {
            checkBlockNum: latestBlock.number + 100,
            checkBlockHash: latestBlock.hash,
          })`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `receipt = await tx.wait()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `reorgedUpkeepReportLogs = parseReorgedUpkeepReportLogs(receipt)`
{"returns early when future block number is provided as trigger, irrespective of reorgProtectionEnabled config"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `newConfig.reorgProtectionEnabled = false`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry // used to test initial configurations
          .connect(owner)
          .setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `tx = await getTransmitTx(registry, keeper1, [id], {
            checkBlockNum: latestBlock.number + 100,
            checkBlockHash: latestBlock.hash,
          })`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `receipt = await tx.wait()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `reorgedUpkeepReportLogs = parseReorgedUpkeepReportLogs(receipt)`
{"returns early when upkeep is cancelled and cancellation delay has gone"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await ethers.provider.send('evm_mine', [])`
{"does not revert if the target cannot execute"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanPerform(false)`
{"does not revert if the target runs out of gas"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanPerform(false)`
{"reverts if not enough gas supplied"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
{"executes the data passed to the registry"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `parsedLogs.push(iface.parseLog(log))`
{"uses actual execution price for payment and premium calculation"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
{"only pays at a rate up to the gas ceiling [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
{"can self cancel"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(owner).addFunds(afUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await autoFunderUpkeep.setIsEligible(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await autoFunderUpkeep.setShouldCancel(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper1, [afUpkeepId])`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `registration = await registry.getUpkeep(afUpkeepId)`
{"has enough perform gas overhead for large batches [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `upkeepIds.push(testUpkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(owner).addFunds(testUpkeepId, toWei('10'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setPerformGasToBurn(performGas)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `totalPerformGas = totalPerformGas.add(performGas)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await evmRevert(
          getTransmitTx(registry, keeper1, upkeepIds, {
            gasLimit: totalPerformGas,
          }),
        )`
{"calculates the minimum balance appropriately"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(admin).addFunds(upkeepId, tooLow)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(admin).addFunds(upkeepId, oneWei)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `checkUpkeepResult = await registry
        .connect(zeroAddress)
        .callStatic['checkUpkeep(uint256)'](upkeepId)`
{"uses maxPerformData size in checkUpkeep but actual performDataSize in transmit"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(owner).addFunds(upkeepID, minBalance1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `maxPerformData += '11'`
{"allows the admin to withdraw"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(admin).pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(owner).cancelUpkeep(upkeepId)`
{"can be called successively on two upkeeps"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry
          .connect(admin)
          .withdrawFunds(upkeepId, await payee1.getAddress())`
{"moves the funds out and updates the balance and emits an event"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `registration = await registry.getUpkeep(upkeepId)`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(owner).pause()`
{"returns false and gasUsed when perform fails"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanPerform(false)`
{"returns true, gasUsed, and performGas when perform succeeds"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
{"returns correct amount of gasUsed when perform succeeds"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setPerformGasToBurn(performGas)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry
        .connect(admin)
        .setUpkeepGasLimit(upkeepId, BigNumber.from(2000000))`
{"returns false and error code if the upkeep is cancelled by admin"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"returns false and error code if the upkeep is cancelled by owner"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(owner).cancelUpkeep(upkeepId)`
{"returns false and error code if the registry is paused"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(owner).pause()`
{"returns false and error code if the upkeep is paused"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(admin).pauseUpkeep(upkeepId)`
{"returns false, error code, and revert data if the target check reverts"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setShouldRevertCheck(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCheckRevertReason(
          'custom revert error, clever way to insert offchain data',
        )`
{"returns false, error code, and no revert data if the target check revert data exceeds maxRevertDataSize"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setShouldRevertCheck(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `longRevertReason += 'x'`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCheckRevertReason(longRevertReason)`
{"returns false and error code if the upkeep is not needed"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanCheck(false)`
{"returns false and error code if the performData exceeds limit"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `longBytes += '1'`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setPerformData(longBytes)`
{"returns true with gas used if the target can execute"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await mock.setPerformData(randomBytes)`
{"calls checkLog for log-trigger upkeeps"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await ltUpkeep.mock.checkLog.withArgs(log, '0x').returns(true, '0x1234')`
{"uses the fallback gas price if the feed has issues in ZKSync"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await gasPriceFeed
        .connect(owner)
        .updateRoundData(roundId, answer, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `roundId = 100`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `updatedAt = now()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `startedAt = 946684799`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await gasPriceFeed
        .connect(owner)
        .updateRoundData(roundId, -100, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `roundId = 101`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `updatedAt = now()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `startedAt = 946684799`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await gasPriceFeed
        .connect(owner)
        .updateRoundData(roundId, 0, updatedAt, startedAt)`
{"uses the fallback link price if the feed has issues in ZKSync"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await linkUSDFeed
        .connect(owner)
        .updateRoundData(roundId, answer, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `roundId = 100`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `updatedAt = now()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `startedAt = 946684799`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await linkUSDFeed
        .connect(owner)
        .updateRoundData(roundId, -100, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `roundId = 101`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `updatedAt = now()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `startedAt = 946684799`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await linkUSDFeed
        .connect(owner)
        .updateRoundData(roundId, 0, updatedAt, startedAt)`
{"reverts if signers or transmitters are the zero address"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await evmRevertCustomError(
        registry
          .connect(owner)
          .setConfigTypeSafe(
            [randomAddress(), randomAddress(), randomAddress(), zeroAddress],
            [
              randomAddress(),
              randomAddress(),
              randomAddress(),
              randomAddress(),
            ],
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          ),
        registry,
        'InvalidSigner',
      )`
{"updates the onchainConfig and configDigest"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry
        .connect(owner)
        .setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
          [],
          [],
        )`
{"maintains paused state when config is changed"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.pause()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry
        .connect(owner)
        .setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
          [],
          [],
        )`
{"reverts if too many keeperAddresses set"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `newKeepers.push(randomAddress())`
{"reverts if signers <= 3f"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `newKeepers.pop()`
{"deducts a cancellation fee from the upkeep and adds to reserve"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(owner).setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              fallbackNativePrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: moduleBase.address,
              reorgProtectionEnabled: true,
              financeAdmin: financeAdminAddress,
            },
            offchainVersion,
            offchainBytes,
            [linkToken.address],
            [
              {
                gasFeePPB: paymentPremiumPPB,
                flatFeeMilliCents,
                priceFeed: linkUSDFeed.address,
                fallbackPrice: fallbackLinkPrice,
                minSpend: newMinUpkeepSpend,
                decimals: 18,
              },
            ],
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"deducts up to balance as cancellation fee"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(owner).setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              fallbackNativePrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: moduleBase.address,
              reorgProtectionEnabled: true,
              financeAdmin: financeAdminAddress,
            },
            offchainVersion,
            offchainBytes,
            [linkToken.address],
            [
              {
                gasFeePPB: paymentPremiumPPB,
                flatFeeMilliCents,
                priceFeed: linkUSDFeed.address,
                fallbackPrice: fallbackLinkPrice,
                minSpend: newMinUpkeepSpend,
                decimals: 18,
              },
            ],
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"does not deduct cancellation fee if more than minUpkeepSpendDollars is spent"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(owner).setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              fallbackNativePrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: moduleBase.address,
              reorgProtectionEnabled: true,
              financeAdmin: financeAdminAddress,
            },
            offchainVersion,
            offchainBytes,
            [linkToken.address],
            [
              {
                gasFeePPB: paymentPremiumPPB,
                flatFeeMilliCents,
                priceFeed: linkUSDFeed.address,
                fallbackPrice: fallbackLinkPrice,
                minSpend: newMinUpkeepSpend,
                decimals: 18,
              },
            ],
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(admin).cancelUpkeep(upkeepId)`
{"updates the balances"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry
        .connect(payee1)
        .withdrawPayment(await keeper1.getAddress(), to)`
{"returns false with appropriate failure reason when target callback reverts"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await streamsLookupUpkeep.setShouldRevertCallback(true)`
{"returns false with appropriate failure reason when target callback returns big performData"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `longBytes += '11'`
{"returns false with appropriate failure reason when target callback returns false"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await streamsLookupUpkeep.setCallbackReturnBool(false)`
{"splits premium evenly across transmitters"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper2, [upkeepId])`
{"updates last collected upon payment withdrawn"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry
        .connect(payee1)
        .withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
{"maintains consistent balance information across all parties"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `maxAllowedSpareChange = maxAllowedSpareChange.add(BigNumber.from('31'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry
        .connect(payee1)
        .withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry
        .connect(payee2)
        .withdrawPayment(
          await keeper2.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `maxAllowedSpareChange = maxAllowedSpareChange.add(BigNumber.from('31'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(owner).setConfigTypeSafe(
        signerAddresses.slice(2, 15), // only use 2-14th index keepers
        keeperAddresses.slice(2, 15),
        f,
        config,
        offchainVersion,
        offchainBytes,
        baseConfig[6],
        baseConfig[7],
      )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper3, [upkeepId], {
        startingSignerIndex: 2,
      })`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `maxAllowedSpareChange = maxAllowedSpareChange.add(BigNumber.from('13'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry
        .connect(payee1)
        .withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry
        .connect(payee3)
        .withdrawPayment(
          await keeper3.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry.connect(owner).setConfigTypeSafe(
        signerAddresses.slice(0, 4), // only use 0-3rd index keepers
        keeperAddresses.slice(0, 4),
        f,
        config,
        offchainVersion,
        offchainBytes,
        baseConfig[6],
        baseConfig[7],
      )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper1, [upkeepId])`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `maxAllowedSpareChange = maxAllowedSpareChange.add(BigNumber.from('4'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await getTransmitTx(registry, keeper3, [upkeepId])`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `maxAllowedSpareChange = maxAllowedSpareChange.add(BigNumber.from('4'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry
        .connect(payee5)
        .withdrawPayment(
          await keeper5.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await verifyConsistentAccounting(maxAllowedSpareChange)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `await registry
        .connect(payee1)
        .withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.pause()`
{"reverts when report data lengths mismatches"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.push(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.push(performGas)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.push('0x')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.push('0x')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.push('0x')`
{"returns early when invalid upkeepIds are included in report"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(BigNumber.from('1'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('1')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"performs even when the upkeep has insufficient funds and the upkeep pays out all the remaining balance"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.addFunds(upkeepId, BigNumber.from(10))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from(10)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
{"handles duplicate upkeepIDs"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"handles duplicate log triggers"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.utils.solidityKeccak256(
          ['uint256', 'bytes32', 'bytes32', 'uint32'],
          [logUpkeepId, logBlockHash, txHash, logIndex],
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"returns early when check block number is less than last perform (block)"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.getBlock(lastPerformed)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"handles case when check block hash does not match"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"handles case when check block number is older than 256 blocks"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.getBlock(latestBlock.number - 256)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"allows bypassing reorg protection with empty blockhash"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"allows bypassing reorg protection with reorgProtectionEnabled false config"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `// used to test initial configurations
          .connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"allows very old trigger block numbers when bypassing reorg protection with reorgProtectionEnabled config"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `// used to test initial configurations
          .connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.getBlock(latestBlock.number - 256)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"allows very old trigger block numbers when bypassing reorg protection with empty blockhash"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"returns early when future block number is provided as trigger, irrespective of blockhash being present"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"returns early when future block number is provided as trigger, irrespective of reorgProtectionEnabled config"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `// used to test initial configurations
          .connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"returns early when upkeep is cancelled and cancellation delay has gone"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.send('evm_mine', [])`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"does not revert if the target cannot execute"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanPerform(false)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"does not revert if the target runs out of gas"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanPerform(false)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"reverts if not enough gas supplied"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from(150000)`
{"executes the data passed to the registry"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.push(iface.parseLog(log))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.parseLog(log)`
{"uses actual execution price for payment and premium calculation"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.sub(registryPremiumBefore)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('1')`
{"only pays at a rate up to the gas ceiling [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.mul(BigNumber.from('10'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('10')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"can self cancel"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.addFunds(afUpkeepId, toWei('100'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setIsEligible(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setShouldCancel(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(afUpkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(afUpkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.lt(oldExpiration)`
{"reverts when configDigest mismatches"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.slice(0, f + 1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.transmit(
              [reportContext[0], reportContext[1], reportContext[2]],
              report,
              sigs.rs,
              sigs.ss,
              sigs.vs,
            )`
{"reverts with incorrect number of signatures"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.slice(0, f + 2)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.transmit(
              [reportContext[0], reportContext[1], reportContext[2]],
              report,
              sigs.rs,
              sigs.ss,
              sigs.vs,
            )`
{"reverts with invalid signature for inactive signers"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.Wallet.createRandom()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.Wallet.createRandom()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.transmit(
              [reportContext[0], reportContext[1], reportContext[2]],
              report,
              sigs.rs,
              sigs.ss,
              sigs.vs,
            )`
{"reverts with invalid signature for duplicated signers"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(keeper1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.transmit(
              [reportContext[0], reportContext[1], reportContext[2]],
              report,
              sigs.rs,
              sigs.ss,
              sigs.vs,
            )`
{"has enough perform gas overhead for large batches [ @skip-coverage ]"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('0')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.deploy()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.registerUpkeep(
              mock.address,
              performGas,
              await admin.getAddress(),
              Trigger.CONDITION,
              linkToken.address,
              '0x',
              '0x',
              '0x',
            )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.push(testUpkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.addFunds(testUpkeepId, toWei('10'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setPerformGasToBurn(performGas)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(performGas)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(transmitGasOverhead)`
{"calculates the minimum balance appropriately"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from(1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getMinBalanceForUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.sub(oneWei)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.addFunds(upkeepId, tooLow)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.addFunds(upkeepId, oneWei)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"uses maxPerformData size in checkUpkeep but actual performDataSize in transmit"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.registerUpkeep(
          mock.address,
          performGas,
          await admin.getAddress(),
          Trigger.CONDITION,
          linkToken.address,
          '0x',
          '0x',
          '0x',
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getMinBalanceForUpkeep(upkeepID)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.sub(
        1,
      )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.addFunds(upkeepID, minBalance1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.mul(gasCeilingMultiplier)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.wait()`
{"allows the admin to withdraw"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getBalance(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
{"can be called successively on two upkeeps"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.withdrawFunds(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
{"moves the funds out and updates the balance and emits an event"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(
          await payee1.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.withdrawFunds(upkeepId, await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(await payee1.getAddress())`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
{"reverts if called by non zero address"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(await owner.getAddress())`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
{"reverts when registry is paused"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
{"returns false and gasUsed when perform fails"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanPerform(false)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('0')`
{"returns true, gasUsed, and performGas when perform succeeds"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('0')`
{"returns correct amount of gasUsed when perform succeeds"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanPerform(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setPerformGasToBurn(performGas)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setUpkeepGasLimit(upkeepId, BigNumber.from(2000000))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from(2000000)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.callStatic.simulatePerformUpkeep(upkeepId, '0x')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.gasUsed.gt(
          performGas.add(pubdataGas).sub(BigNumber.from('1000')),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(pubdataGas)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.sub(BigNumber.from('1000'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('1000')`
{"reverts if called by non zero address"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(await owner.getAddress())`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
{"returns false and error code if the upkeep is cancelled by admin"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the upkeep is cancelled by owner"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the registry is paused"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the upkeep is paused"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.pauseUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false and error code if user is out of funds"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false, error code, and revert data if the target check reverts"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setShouldRevertCheck(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCheckRevertReason(
          'custom revert error, clever way to insert offchain data',
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.performData.slice(10)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.linkUSD.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('0')`
{"returns false, error code, and no revert data if the target check revert data exceeds maxRevertDataSize"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setShouldRevertCheck(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCheckRevertReason(longRevertReason)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the upkeep is not needed"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanCheck(false)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns false and error code if the performData exceeds limit"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setPerformData(longBytes)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"returns true with gas used if the target can execute"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCanCheck(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setPerformData(randomBytes)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.provider.getBlock('latest')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.linkUSD.eq(linkUSD)`
{"calls checkLog for log-trigger upkeeps"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.utils.randomBytes(32)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.utils.randomBytes(1000)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.mock.checkLog.withArgs(log, '0x')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.returns(true, '0x1234')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
{"uses the fallback gas price if the feed has issues in ZKSync"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getGasOverhead()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(registryPerSignerGasOverhead.mul(f + 1))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.mul(f + 1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(chainModuleOverheads.chainModuleFixedOverhead)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.mul('2')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.updateRoundData(roundId, answer, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.updateRoundData(roundId, -100, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.updateRoundData(roundId, 0, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getMaxPaymentForGas(
            upkeepId,
            Trigger.CONDITION,
            performGas,
            linkToken.address,
          )`
{"uses the fallback link price if the feed has issues in ZKSync"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getGasOverhead()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(registryPerSignerGasOverhead.mul(f + 1))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.mul(f + 1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(chainModuleOverheads.chainModuleFixedOverhead)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.mul('2')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.updateRoundData(roundId, answer, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.updateRoundData(roundId, -100, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.updateRoundData(roundId, 0, updatedAt, startedAt)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getMaxPaymentForGas(
            upkeepId,
            Trigger.CONDITION,
            performGas,
            linkToken.address,
          )`
{"uses the correct type and version"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.typeAndVersion()`
{"reverts when called by anyone but the proposed owner"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts if signers or transmitters are the zero address"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            [randomAddress(), randomAddress(), randomAddress(), zeroAddress],
            [
              randomAddress(),
              randomAddress(),
              randomAddress(),
              randomAddress(),
            ],
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            [
              randomAddress(),
              randomAddress(),
              randomAddress(),
              randomAddress(),
            ],
            [randomAddress(), randomAddress(), randomAddress(), zeroAddress],
            f,
            newConfig,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"updates the onchainConfig and configDigest"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getConfig()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
          [],
          [],
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
{"maintains paused state when config is changed"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.pause()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
          [],
          [],
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
{"emits an event"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
          signerAddresses,
          keeperAddresses,
          f,
          newConfig,
          offchainVersion,
          offchainBytes,
          [],
          [],
        )`
{"reverts when called by anyone but the owner"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts if too many keeperAddresses set"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.push(randomAddress())`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts if f=0"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newKeepers,
            0,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts if signers != transmitters length"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signers,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts if signers <= 3f"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.pop()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts on repeated signers"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            newSigners,
            newKeepers,
            f,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"reverts on repeated transmitters"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.Eddy.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            newKeepers,
            newTransmitters,
            f,
            config,
            offchainVersion,
            offchainBytes,
            baseConfig[6],
            baseConfig[7],
          )`
{"deducts a cancellation fee from the upkeep and adds to reserve"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              fallbackNativePrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: moduleBase.address,
              reorgProtectionEnabled: true,
              financeAdmin: financeAdminAddress,
            },
            offchainVersion,
            offchainBytes,
            [linkToken.address],
            [
              {
                gasFeePPB: paymentPremiumPPB,
                flatFeeMilliCents,
                priceFeed: linkUSDFeed.address,
                fallbackPrice: fallbackLinkPrice,
                minSpend: newMinUpkeepSpend,
                decimals: 18,
              },
            ],
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.sub(upkeepBefore)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.sub(amountSpent)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.sub(ownerBefore)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.eq(cancellationFee)`
{"deducts up to balance as cancellation fee"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              fallbackNativePrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: moduleBase.address,
              reorgProtectionEnabled: true,
              financeAdmin: financeAdminAddress,
            },
            offchainVersion,
            offchainBytes,
            [linkToken.address],
            [
              {
                gasFeePPB: paymentPremiumPPB,
                flatFeeMilliCents,
                priceFeed: linkUSDFeed.address,
                fallbackPrice: fallbackLinkPrice,
                minSpend: newMinUpkeepSpend,
                decimals: 18,
              },
            ],
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.sub(ownerBefore)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.eq(upkeepBefore)`
{"does not deduct cancellation fee if more than minUpkeepSpendDollars is spent"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from(420)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
            signerAddresses,
            keeperAddresses,
            f,
            {
              checkGasLimit,
              stalenessSeconds,
              gasCeilingMultiplier,
              maxCheckDataSize,
              maxPerformDataSize,
              maxRevertDataSize,
              maxPerformGas,
              fallbackGasPrice,
              fallbackLinkPrice,
              fallbackNativePrice,
              transcoder: transcoder.address,
              registrars: [],
              upkeepPrivilegeManager: upkeepManager,
              chainModule: moduleBase.address,
              reorgProtectionEnabled: true,
              financeAdmin: financeAdminAddress,
            },
            offchainVersion,
            offchainBytes,
            [linkToken.address],
            [
              {
                gasFeePPB: paymentPremiumPPB,
                flatFeeMilliCents,
                priceFeed: linkUSDFeed.address,
                fallbackPrice: fallbackLinkPrice,
                minSpend: newMinUpkeepSpend,
                decimals: 18,
              },
            ],
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(admin)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.cancelUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(
            await payee1.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.eq(payee1After)`
{"reverts if called by anyone but the payee"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(payee2)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.withdrawPayment(
            await keeper1.getAddress(),
            await nonkeeper.getAddress(),
          )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
{"reverts if called with the 0 address"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(payee2)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.withdrawPayment(await keeper1.getAddress(), zeroAddress)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
{"updates the balances"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getTransmitterInfo(
        await keeper1.getAddress(),
      )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(to)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.withdrawPayment(await keeper1.getAddress(), to)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getTransmitterInfo(
        await keeper1.getAddress(),
      )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getUpkeep(upkeepId)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(to)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.balanceOf(registry.address)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.linkAvailableForPayment()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.sub(keeperBefore.balance)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.eq(registryLinkAfter)`
{"emits a log announcing the withdrawal"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
{"returns false with appropriate failure reason when target callback reverts"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setShouldRevertCallback(true)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.callStatic.checkCallback(streamsLookupUpkeepId, values, '0x')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('0')`
{"returns false with appropriate failure reason when target callback returns big performData"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.callStatic.checkCallback(streamsLookupUpkeepId, values, '0x')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('0')`
{"returns false with appropriate failure reason when target callback returns false"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setCallbackReturnBool(false)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.callStatic.checkCallback(streamsLookupUpkeepId, values, '0x')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('0')`
{"succeeds with upkeep needed"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(zeroAddress)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.callStatic.checkCallback(streamsLookupUpkeepId, values, '0x')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.utils.defaultAbiCoder.encode(
        ['bytes[]', 'bytes'],
        [values, '0x'],
      )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.gasUsed.gt(BigNumber.from('0'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('0')`
{"splits premium evenly across transmitters"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.div(
        BigNumber.from(keeperAddresses.length),
      )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from(keeperAddresses.length)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.sub(premiumPerTransmitter)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper2.getAddress())`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.div(
        BigNumber.from(keeperAddresses.length),
      )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from(keeperAddresses.length)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.sub(
        premiumPerTransmitter,
      )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper2.getAddress())`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.gt(k2Balance.add(additionalPremium))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(additionalPremium)`
{"updates last collected upon payment withdrawn"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getState()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper1.getAddress())`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getTransmitterInfo(await keeper2.getAddress())`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getTransmitterInfo(
        await keeper1.getAddress(),
      )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getTransmitterInfo(
        await keeper2.getAddress(),
      )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.lastCollected.eq(BigNumber.from(0))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from(0)`
{"maintains consistent balance information across all parties"}
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('0')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(BigNumber.from('31'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('31')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(payee2)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper2.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(BigNumber.from('31'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('31')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
        signerAddresses.slice(2, 15), // only use 2-14th index keepers
        keeperAddresses.slice(2, 15),
        f,
        config,
        offchainVersion,
        offchainBytes,
        baseConfig[6],
        baseConfig[7],
      )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.slice(2, 15)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.slice(2, 15)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(BigNumber.from('13'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('13')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(payee3)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper3.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.setConfigTypeSafe(
        signerAddresses.slice(0, 4), // only use 0-3rd index keepers
        keeperAddresses.slice(0, 4),
        f,
        config,
        offchainVersion,
        offchainBytes,
        baseConfig[6],
        baseConfig[7],
      )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.slice(0, 4)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.slice(0, 4)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(BigNumber.from('4'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('4')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.add(BigNumber.from('4'))`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.from('4')`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(payee5)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper5.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.connect(payee1)`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.withdrawPayment(
          await keeper1.getAddress(),
          await nonkeeper.getAddress(),
        )`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/automation/ZKSyncAutomationRegistry2_3.test.ts: `.getAddress()`
{"Should not have a file or directory starting with a number in contracts/src"}
$DIR/contracts/test/v0.8/directory.test.ts: `throw new Error(
            `${path.join(dirPath, entry.name)} starts with a number`,
          )`
$DIR/contracts/test/v0.8/directory.test.ts: `noNumbersAsFirstChar(newPath)`
$DIR/contracts/test/v0.8/directory.test.ts: `.join(__dirname, '..', '..', 'src')`
$DIR/contracts/test/v0.8/directory.test.ts: `.readdirSync(dirPath, { withFileTypes: true })`
$DIR/contracts/test/v0.8/directory.test.ts: `.test(entry.name)`
$DIR/contracts/test/v0.8/directory.test.ts: `.join(dirPath, entry.name)`
$DIR/contracts/test/v0.8/directory.test.ts: `.isDirectory()`
$DIR/contracts/test/v0.8/directory.test.ts: `.join(dirPath, entry.name)`
{"forwards the data"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `await tx.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `await tx.wait()`
{"return revert message"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `await evmRevert(
              forwarder
                .connect(roles.defaultAccount)
                .multiForward(
                  [brokenMock.address, mock.address],
                  [brokenMsgPayload, payload],
                ),
              'Failure message',
            )`
{"return silent failure message"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `await evmRevert(
              // first
              forwarder
                .connect(roles.defaultAccount)
                .multiForward(
                  [brokenMock.address, mock.address],
                  [brokenPayload, payload],
                ),
              'Forwarded call reverted without reason',
            )`
{"forwards the data"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `await tx.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `await tx.wait()`
{"describes the authorized forwarder"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.typeAndVersion()`
{"sets the correct link token"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.linkToken()`
{"reverts on zeroAddress value for link token"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.deploy(
          zeroAddress, // Link Address
          await roles.defaultAccount.getAddress(),
          zeroAddress,
          '0x',
        )`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.defaultAccount.getAddress()`
{"sets no authorized senders"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.getAuthorizedSenders()`
{"reverts with a must not have duplicate senders message"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.setAuthorizedSenders(newSenders)`
{"adds the authorized nodes"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.getAuthorizedSenders()`
{"emits an event"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.utils.defaultAbiCoder.encode(
            ['address[]', 'address'],
            [newSenders, await roles.defaultAccount.getAddress()],
          )`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.defaultAccount.getAddress()`
{"replaces the authorized nodes"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.getAuthorizedSenders()`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.oracleNode.getAddress()`
{"reverts with a minimum senders message"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.setAuthorizedSenders(newSenders)`
{"cannot add an authorized node"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.setAuthorizedSenders([await roles.stranger.getAddress()])`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.stranger.getAddress()`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.forward(mock.address, payload)`
{"return revert message"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.forward(brokenMock.address, brokenMsgPayload)`
{"return silent failure message"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.forward(brokenMock.address, brokenPayload)`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.forward(zeroAddress, payload)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.interface.getSighash('name')`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.forward(link.address, sighash)`
{"forwards the data"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.forward(mock.address, payload)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.getBytes()`
{"perceives the message is sent by the AuthorizedForwarder"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.forward(mock.address, payload)`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward([mock.address], [payload])`
{"return revert message"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward([brokenMock.address], [brokenMsgPayload])`
{"return silent failure message"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward([brokenMock.address], [brokenPayload])`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward([zeroAddress], [payload])`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.interface.getSighash('name')`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward([link.address], [sighash])`
{"forwards the data"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward([mock.address], [payload])`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.getBytes()`
{"perceives the message is sent by the AuthorizedForwarder"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward([mock.address], [payload])`
{"return revert message"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward([brokenMock.address], [brokenMsgPayload])`
{"return silent failure message"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward([brokenMock.address], [brokenPayload])`
{"return revert message"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward(
                  [brokenMock.address, mock.address],
                  [brokenMsgPayload, payload],
                )`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward(
                  [mock.address, brokenMock.address],
                  [payload, brokenMsgPayload],
                )`
{"return silent failure message"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward(
                  [brokenMock.address, mock.address],
                  [brokenPayload, payload],
                )`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward(
                  [mock.address, brokenMock.address],
                  [payload, brokenPayload],
                )`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward([zeroAddress], [payload])`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.interface.getSighash('name')`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward([link.address], [sighash])`
{"forwards the data"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward([mock.address], [payload])`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.getBytes()`
{"perceives the message is sent by the AuthorizedForwarder"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.multiForward([mock.address], [payload])`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.transferOwnershipWithMessage(
              await roles.stranger.getAddress(),
              message,
            )`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.stranger.getAddress()`
{"calls the normal ownership transfer proposal"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.transferOwnershipWithMessage(
            await roles.stranger.getAddress(),
            message,
          )`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.stranger.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.stranger.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.transferOwnershipWithMessage(
            await roles.stranger.getAddress(),
            message,
          )`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.stranger.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.wait()`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.ownerForward(mock.address, payload)`
{"does not revert"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.interface.getSighash('name')`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
{"forwards the data"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.ownerForward(mock.address, payload)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.getBytes()`
{"reverts when sending to a non-contract address"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.ownerForward(zeroAddress, payload)`
{"perceives the message is sent by the Operator"}
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/AuthorizedForwarder.test.ts: `.ownerForward(mock.address, payload)`
{"assigns ownership to the deployer"}
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.all([
        owner.getAddress(),
        confirmedOwner.owner(),
      ])`
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.owner()`
{"reverts if assigned to the zero address"}
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.deploy(ethers.constants.AddressZero)`
{"successfully calls the method"}
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.modifierOnlyOwner()`
{"emits a log"}
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.transferOwnership(await newOwner.getAddress())`
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.getAddress()`
{"does not allow ownership transfer to self"}
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.transferOwnership(await owner.getAddress())`
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.getAddress()`
{"allows the recipient to call it"}
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.connect(newOwner)`
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.acceptOwnership()`
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/ConfirmedOwner.test.ts: `.getAddress()`
{"does not revert"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
          .connect(roles.defaultAccount)
          .setAuthorizedSenders([await roles.oracleNode1.getAddress()])`
{"updates the balances"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
          .connect(roles.defaultAccount)
          .distributeFunds(receivers, amounts, { value: totalAmount })`
{"cannot withdraw from oracle"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(mock.maliciousWithdraw())`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(operatorOriginalBalance, operatorNewBalance)`
{"the target requester can still create valid requests"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `requester = await basicConsumerFactory
            .connect(roles.defaultAccount)
            .deploy(link.address, operator.address, specId)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await link.transfer(requester.address, paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await mock.maliciousTargetConsumer(requester.address)`
{"raises an error if the request ID does not exist"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request.requestId = ethers.utils.formatBytes32String('DOESNOTEXIST')`
{"sets the value on the requested contract"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(...convertFufillParams(request, response))`
{"does not allow a request to be fulfilled twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
            operator
              .connect(roles.oracleNode)
              .fulfillOracleRequest(...convertFufillParams(request, response2)),
          )`
{"does not allow the oracle to withdraw the payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
            operator.connect(roles.oracleNode).fulfillOracleRequest(
              ...convertFufillParams(request, response, {
                gasLimit: 70000,
              }),
            ),
          )`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(balance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.defaultAccount)
            .withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(...convertFufillParams(request, response))`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(balance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.defaultAccount)
            .withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(mockBalance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(balance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.defaultAccount)
            .withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(...convertFufillParams(request, response))`
{"is not successful with call"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request = decodeRunRequest(receipt.logs?.[3])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(...convertFufillParams(request, response))`
{"is not successful with send"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request = decodeRunRequest(receipt.logs?.[3])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(...convertFufillParams(request, response))`
{"is not successful with transfer"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request = decodeRunRequest(receipt.logs?.[3])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(...convertFufillParams(request, response))`
{"does not allow the contract to callback to owned contracts"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `responseParams[2] = forwarder1.address`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.defaultAccount)
            .acceptOwnableContracts([forwarder1.address])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
            operator
              .connect(roles.oracleNode)
              .fulfillOracleRequest(...responseParams),
            'Cannot call owned contract',
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.defaultAccount)
            .transferOwnableContracts([forwarder1.address], link.address)`
{"raises an error if the request ID does not exist"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request.requestId = ethers.utils.formatBytes32String('DOESNOTEXIST')`
{"sets the value on the requested contract"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.oracleNode)
              .fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
{"does not allow a request to be fulfilled twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.oracleNode)
              .fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
              operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    response2Values,
                  ),
                ),
            )`
{"does not allow the oracle to withdraw the payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
              operator.connect(roles.oracleNode).fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                  {
                    gasLimit: 70000,
                  },
                ),
              ),
            )`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.oracleNode)
              .fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(balance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.defaultAccount)
              .withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.oracleNode)
              .fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.oracleNode)
              .fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(balance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.defaultAccount)
              .withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.oracleNode)
              .fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(mockBalance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(balance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.defaultAccount)
              .withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.oracleNode)
              .fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
{"is not successful with call"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request = decodeRunRequest(receipt.logs?.[3])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.oracleNode)
              .fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
{"is not successful with send"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request = decodeRunRequest(receipt.logs?.[3])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.oracleNode)
              .fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
{"is not successful with transfer"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request = decodeRunRequest(receipt.logs?.[3])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.oracleNode)
              .fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
{"does not allow the contract to callback to owned contracts"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `responseParams[2] = forwarder1.address`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.defaultAccount)
              .acceptOwnableContracts([forwarder1.address])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
              operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(...responseParams),
              'Cannot call owned contract',
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.defaultAccount)
              .transferOwnableContracts([forwarder1.address], link.address)`
{"matches the consumer's request ID"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request = decodeRunRequest(receipt.logs?.[3])`
{"raises an error if the request ID does not exist"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request.requestId =
                ethers.utils.formatBytes32String('DOESNOTEXIST')`
{"sets the value on the requested contract"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"does not allow a request to be fulfilled twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
                operator
                  .connect(roles.oracleNode)
                  .fulfillOracleRequest2(
                    ...convertFulfill2Params(
                      request,
                      responseTypes,
                      response2Values,
                    ),
                  ),
              )`
{"does not allow the oracle to withdraw the payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
                operator.connect(roles.oracleNode).fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                    {
                      gasLimit: 70000,
                    },
                  ),
                ),
              )`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(balance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.defaultAccount)
                .withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(balance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.defaultAccount)
                .withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(mockBalance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(balance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.defaultAccount)
                .withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"is not successful with call"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request = decodeRunRequest(receipt.logs?.[3])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"is not successful with send"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request = decodeRunRequest(receipt.logs?.[3])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"is not successful with transfer"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request = decodeRunRequest(receipt.logs?.[3])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"raises an error if the request ID does not exist"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request.requestId =
                ethers.utils.formatBytes32String('DOESNOTEXIST')`
{"sets the value on the requested contract"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"does not allow a request to be fulfilled twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
                operator
                  .connect(roles.oracleNode)
                  .fulfillOracleRequest2(
                    ...convertFulfill2Params(
                      request,
                      responseTypes,
                      repeatedResponseValues,
                    ),
                  ),
              )`
{"does not allow the oracle to withdraw the payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
                operator.connect(roles.oracleNode).fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                    {
                      gasLimit: 70000,
                    },
                  ),
                ),
              )`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(balance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.defaultAccount)
                .withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(balance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.defaultAccount)
                .withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(mockBalance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(balance, 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.defaultAccount)
                .withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"is not successful with call"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request = decodeRunRequest(receipt.logs?.[3])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"is not successful with send"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request = decodeRunRequest(receipt.logs?.[3])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"is not successful with transfer"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `request = decodeRunRequest(receipt.logs?.[3])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
                .connect(roles.oracleNode)
                .fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await link.transfer(basicConsumer.address, paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `fulfillParams[5] = '0x'`
{"does nothing"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
          operator
            .connect(roles.defaultAccount)
            .withdraw(await roles.oracleNode.getAddress(), toWei('1')),
        )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `balance = await link.balanceOf(await roles.oracleNode.getAddress())`
{"withdraws funds"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.defaultAccount)
            .withdraw(await roles.defaultAccount.getAddress(), paid)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(operatorDifference, paid)`
{"does not transfer funds"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
            operator
              .connect(roles.defaultAccount)
              .withdraw(await roles.oracleNode.getAddress(), payment),
          )`
{"withdraws funds"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.defaultAccount)
              .withdraw(await roles.defaultAccount.getAddress(), paid)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(operatorDifference, paid)`
{"does not allow input greater than the balance"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
            operator
              .connect(roles.defaultAccount)
              .withdraw(await roles.stranger.getAddress(), withdrawalAmount),
          )`
{"allows transfer of partial balance by owner to specified address"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.defaultAccount)
            .withdraw(await roles.stranger.getAddress(), partialAmount)`
{"allows transfer of entire balance by owner to specified address"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.defaultAccount)
            .withdraw(await roles.stranger.getAddress(), payment)`
{"does not allow a transfer of funds by non-owner"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await evmRevert(
            operator
              .connect(roles.stranger)
              .withdraw(await roles.stranger.getAddress(), payment),
          )`
{"withdraws funds"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
              .connect(roles.defaultAccount)
              .withdraw(await roles.defaultAccount.getAddress(), paid)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(operatorDifference, paid)`
{"reverts with owner error message"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await link.transfer(operator.address, startingBalance)`
{"transfers the tokens"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(
            requesterBalanceBefore.sub(requesterBalanceAfter),
            payment,
          )`
{"fails"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await increaseTime5Minutes(ethers.provider)`
{"refunds the correct amount"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await increaseTime5Minutes(ethers.provider)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.consumer)
            .cancelOracleRequestByRequester(
              ...convertCancelByRequesterParams(request, nonce),
            )`
{"triggers a cancellation event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await increaseTime5Minutes(ethers.provider)`
{"fails when called twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await increaseTime5Minutes(ethers.provider)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.consumer)
            .cancelOracleRequestByRequester(
              ...convertCancelByRequesterParams(request, nonce),
            )`
{"fails"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await increaseTime5Minutes(ethers.provider)`
{"has correct initial balances"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `bigNumEquals(request.payment, oracleBalance)`
{"refunds the correct amount"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await increaseTime5Minutes(ethers.provider)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.consumer)
            .cancelOracleRequest(...convertCancelParams(request))`
{"triggers a cancellation event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await increaseTime5Minutes(ethers.provider)`
{"fails when called twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await increaseTime5Minutes(ethers.provider)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await operator
            .connect(roles.consumer)
            .cancelOracleRequest(...convertCancelParams(request))`
{"forwards the data"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `await tx.wait()`
{"describes the operator"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.typeAndVersion()`
{"cannot transfer to self"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transferOwnableContracts([forwarder1.address], operator.address)`
{"emits an ownership transfer request event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(owner)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transferOwnableContracts(
            [forwarder1.address, forwarder2.address],
            await roles.oracleNode1.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode1.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode1.getAddress()`
{"reverts with message"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transferOwnableContracts(
              [forwarder1.address],
              await roles.oracleNode2.getAddress(),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode2.getAddress()`
{"sets the new owner on the forwarder"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.owner()`
{"does not revert"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.setAuthorizedSenders([await roles.oracleNode1.getAddress()])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode1.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode1)`
{"reverts with message"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.acceptOwnableContracts([await roles.oracleNode2.getAddress()])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode2.getAddress()`
{"reverts with invalid array message"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.distributeFunds([], [])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode2.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode3.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.distributeFunds(receivers, amounts)`
{"reverts with too much ETH message"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.distributeFunds(
              [await roles.oracleNode2.getAddress()],
              [amountToSend],
              {
                value: ethSent,
              },
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode2.getAddress()`
{"updates the balances"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode2.getBalance()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode3.getBalance()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode2.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode3.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.distributeFunds(receivers, amounts, { value: totalAmount })`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode2.getBalance()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode3.getBalance()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.sub(node3BalanceBefore)`
{"adds the authorized nodes"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.getAuthorizedSenders()`
{"emits an event on the Operator"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.defaultAbiCoder.encode(
            ['address[]', 'address'],
            [newSenders, await roles.defaultAccount.getAddress()],
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.defaultAccount.getAddress()`
{"replaces the authorized nodes"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.isAuthorizedSender(await roles.oracleNode.getAddress())`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
{"reverts with a minimum senders message"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.setAuthorizedSenders(newSenders)`
{"succeeds"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.stranger.getAddress()`
{"cannot add an authorized node"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.setAuthorizedSenders([await roles.stranger.getAddress()])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.stranger.getAddress()`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.setAuthorizedSendersOn(newSenders, [forwarder1.address])`
{"does not revert"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode1)`
{"does revert with 0 senders"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode1)`
{"emits a log announcing the change and who made it"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode1)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.setAuthorizedSendersOn(targets, newSenders)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.defaultAbiCoder.encode(
          ['address[]', 'address[]', 'address'],
          [targets, newSenders, await roles.oracleNode1.getAddress()],
        )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode1.getAddress()`
{"updates the sender list on each of the targets"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode1)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.setAuthorizedSendersOn(
            [forwarder1.address, forwarder2.address],
            newSenders,
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.defaultAbiCoder.encode(
          ['address[]', 'address'],
          [newSenders, operator.address],
        )`
{"sets the new owner on the forwarder"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.owner()`
{"emits ownership transferred events"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.defaultAbiCoder.encode(
          ['address[]', 'address'],
          [newSenders, operator2.address],
        )`
{"reverts with message"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.acceptAuthorizedReceivers(
              [forwarder1.address, forwarder2.address],
              newSenders,
            )`
{"triggers the intended method"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.onTokenTransfer(
            await roles.defaultAccount.getAddress(),
            0,
            callData,
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.defaultAccount.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transferAndCall(operator.address, 0, callData, {
          value: 0,
        })`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transferAndCall(operator.address, 0, '0x', {
              value: 0,
            })`
{"cannot withdraw from oracle"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(operator.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(mock.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.maliciousWithdraw()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(operator.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(mock.address)`
{"the requesters ID will not match with the oracle contract"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.maliciousTargetConsumer(to)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
{"the target requester can still create valid requests"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.deploy(link.address, operator.address, specId)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transfer(requester.address, paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.maliciousTargetConsumer(requester.address)`
{"does not allow recursive calls of onTokenTransfer"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.interface.getSighash('onTokenTransfer')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.slice(2)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transferAndCall(operator.address, 0, maliciousPayload, {
          value: 0,
        })`
{"does not allow the same requestId to be used twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transferAndCall(operator.address, paid, args2)`
{"throws an error"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.interface.getSighash('oracleRequest')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transferAndCall(operator.address, paid, maliciousData)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transferAndCall(operator.address, paid, args)`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleRequest(
              '0x0000000000000000000000000000000000000000',
              0,
              specId,
              to,
              fHash,
              1,
              1,
              '0x',
            )`
{"does not allow the same requestId to be used twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transferAndCall(operator.address, paid, args2)`
{"throws an error"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transferAndCall(operator.address, paid, args)`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleRequest(
              '0x0000000000000000000000000000000000000000',
              0,
              specId,
              to,
              fHash,
              1,
              1,
              '0x',
            )`
{"emits an OracleResponse event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...fulfillParams)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
{"raises an error"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response))`
{"raises an error if the request ID does not exist"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.formatBytes32String('DOESNOTEXIST')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response))`
{"sets the value on the requested contract"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.getCurrentPrice()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.parseBytes32String(currentValue)`
{"emits an OracleResponse event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...fulfillParams)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
{"does not allow a request to be fulfilled twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response2))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.getCurrentPrice()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.parseBytes32String(currentValue)`
{"does not allow the oracle to withdraw the payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(
              ...convertFufillParams(request, response, {
                gasLimit: 70000,
              }),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdrawable()`
{"cannot cancel before the expiration"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.maliciousRequestCancel(
            specId,
            ethers.utils.toUtf8Bytes('doesNothing(bytes32,bytes32)'),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('doesNothing(bytes32,bytes32)')`
{"the oracle uses the amount of LINK actually paid"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.maliciousPrice(specId)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.eq(req.payment)`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.oracleNode.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.oracleNode.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response2))`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.oracleNode.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.oracleNode.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(maliciousConsumer.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.oracleNode.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.oracleNode.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response2))`
{"is not successful with call"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
            specId,
            ethers.utils.toUtf8Bytes('stealEthCall(bytes32,bytes32)'),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('stealEthCall(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.provider.getBalance(maliciousConsumer.address)`
{"is not successful with send"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
            specId,
            ethers.utils.toUtf8Bytes('stealEthSend(bytes32,bytes32)'),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('stealEthSend(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.provider.getBalance(maliciousConsumer.address)`
{"is not successful with transfer"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
            specId,
            ethers.utils.toUtf8Bytes('stealEthTransfer(bytes32,bytes32)'),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('stealEthTransfer(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...convertFufillParams(request, response))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.provider.getBalance(maliciousConsumer.address)`
{"does not allow the contract to callback to owned contracts"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
            specId,
            ethers.utils.toUtf8Bytes('whatever(bytes32,bytes32)'),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('whatever(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.acceptOwnableContracts([forwarder1.address])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...responseParams)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transferOwnableContracts([forwarder1.address], link.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...responseParams)`
{"emits an OracleResponse2 event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(...fulfillParams)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
{"raises an error"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"raises an error if the request ID does not exist"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.formatBytes32String('DOESNOTEXIST')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
{"sets the value on the requested contract"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.getCurrentPrice()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.parseBytes32String(currentValue)`
{"emits an OracleResponse2 event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(...fulfillParams)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
{"does not allow a request to be fulfilled twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    response2Values,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.getCurrentPrice()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.parseBytes32String(currentValue)`
{"does not allow the oracle to withdraw the payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                  {
                    gasLimit: 70000,
                  },
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdrawable()`
{"cannot spoof requestId in response data by moving calldata offset"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestId.slice(2)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestId.slice(2)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestId.slice(2)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.payment.slice(2)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.padStart(64, '0')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.callbackAddr.slice(2)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.padStart(64, '0')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.callbackFunc.slice(2)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.padEnd(64, '0')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.expiration.slice(2)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.padStart(64, '0')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.signer.sendTransaction({
              to: operator.address,
              data,
            })`
{"cannot cancel before the expiration"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.maliciousRequestCancel(
              specId,
              ethers.utils.toUtf8Bytes('doesNothing(bytes32,bytes32)'),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('doesNothing(bytes32,bytes32)')`
{"the oracle uses the amount of LINK actually paid"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.maliciousPrice(specId)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.eq(req.payment)`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
              await roles.oracleNode.getAddress(),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
              await roles.oracleNode.getAddress(),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    response2Values,
                  ),
                )`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
              await roles.oracleNode.getAddress(),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
              await roles.oracleNode.getAddress(),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(maliciousConsumer.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
              await roles.oracleNode.getAddress(),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
              await roles.oracleNode.getAddress(),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    response2Values,
                  ),
                )`
{"is not successful with call"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
              specId,
              ethers.utils.toUtf8Bytes('stealEthCall(bytes32,bytes32)'),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('stealEthCall(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.provider.getBalance(maliciousConsumer.address)`
{"is not successful with send"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
              specId,
              ethers.utils.toUtf8Bytes('stealEthSend(bytes32,bytes32)'),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('stealEthSend(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.provider.getBalance(maliciousConsumer.address)`
{"is not successful with transfer"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
              specId,
              ethers.utils.toUtf8Bytes('stealEthTransfer(bytes32,bytes32)'),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('stealEthTransfer(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                ...convertFulfill2Params(
                  request,
                  responseTypes,
                  responseValues,
                ),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.provider.getBalance(maliciousConsumer.address)`
{"does not allow the contract to callback to owned contracts"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
              specId,
              ethers.utils.toUtf8Bytes('whatever(bytes32,bytes32)'),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('whatever(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.acceptOwnableContracts([forwarder1.address])`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(...responseParams)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transferOwnableContracts([forwarder1.address], link.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest(...responseParams)`
{"emits an OracleResponse2 event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(...fulfillParams)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
{"matches the consumer's request ID"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.publicGetNextRequestCount()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestEthereumPrice('USD', 0)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.solidityPack(
              ['address', 'uint256'],
              [multiConsumer.address, nonce],
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.keccak256(packed)`
{"raises an error"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                    ...convertFulfill2Params(
                      request,
                      responseTypes,
                      responseValues,
                    ),
                  )`
{"raises an error if the request ID does not exist"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.formatBytes32String('DOESNOTEXIST')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                    ...convertFulfill2Params(
                      request,
                      responseTypes,
                      responseValues,
                    ),
                  )`
{"sets the value on the requested contract"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.getCurrentPrice()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8String(currentValue)`
{"emits an OracleResponse2 event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(...fulfillParams)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
{"does not allow a request to be fulfilled twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                    ...convertFulfill2Params(
                      request,
                      responseTypes,
                      response2Values,
                    ),
                  )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.getCurrentPrice()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8String(currentValue)`
{"does not allow the oracle to withdraw the payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                    {
                      gasLimit: 70000,
                    },
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdrawable()`
{"cannot cancel before the expiration"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.maliciousRequestCancel(
                specId,
                ethers.utils.toUtf8Bytes('doesNothing(bytes32,bytes32)'),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('doesNothing(bytes32,bytes32)')`
{"the oracle uses the amount of LINK actually paid"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.maliciousPrice(specId)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.eq(req.payment)`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                await roles.oracleNode.getAddress(),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                await roles.oracleNode.getAddress(),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                    ...convertFulfill2Params(
                      request,
                      responseTypes,
                      response2Values,
                    ),
                  )`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                await roles.oracleNode.getAddress(),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                await roles.oracleNode.getAddress(),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                maliciousConsumer.address,
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                await roles.oracleNode.getAddress(),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                await roles.oracleNode.getAddress(),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                    ...convertFulfill2Params(
                      request,
                      responseTypes,
                      response2Values,
                    ),
                  )`
{"is not successful with call"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
                specId,
                ethers.utils.toUtf8Bytes('stealEthCall(bytes32,bytes32)'),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('stealEthCall(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.provider.getBalance(maliciousConsumer.address)`
{"is not successful with send"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
                specId,
                ethers.utils.toUtf8Bytes('stealEthSend(bytes32,bytes32)'),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('stealEthSend(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.provider.getBalance(maliciousConsumer.address)`
{"is not successful with transfer"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
                specId,
                ethers.utils.toUtf8Bytes('stealEthTransfer(bytes32,bytes32)'),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('stealEthTransfer(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.provider.getBalance(maliciousConsumer.address)`
{"emits an OracleResponse2 event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(...fulfillParams)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
{"raises an error"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                    ...convertFulfill2Params(
                      request,
                      responseTypes,
                      responseValues,
                    ),
                  )`
{"raises an error if the request ID does not exist"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.formatBytes32String('DOESNOTEXIST')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                    ...convertFulfill2Params(
                      request,
                      responseTypes,
                      responseValues,
                    ),
                  )`
{"sets the value on the requested contract"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.usd()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.eur()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.jpy()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.parseBytes32String(thirdValue)`
{"emits an OracleResponse2 event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(...fulfillParams)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
{"does not allow a request to be fulfilled twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                    ...convertFulfill2Params(
                      request,
                      responseTypes,
                      repeatedResponseValues,
                    ),
                  )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.usd()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.eur()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.jpy()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.parseBytes32String(thirdValue)`
{"does not allow the oracle to withdraw the payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                    {
                      gasLimit: 70000,
                    },
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdrawable()`
{"cannot cancel before the expiration"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.maliciousRequestCancel(
                specId,
                ethers.utils.toUtf8Bytes('doesNothing(bytes32,bytes32)'),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('doesNothing(bytes32,bytes32)')`
{"the oracle uses the amount of LINK actually paid"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.maliciousPrice(specId)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.eq(req.payment)`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                await roles.oracleNode.getAddress(),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                await roles.oracleNode.getAddress(),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                    ...convertFulfill2Params(
                      request,
                      responseTypes,
                      repeatedResponseValues,
                    ),
                  )`
{"allows the oracle node to receive their payment"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                await roles.oracleNode.getAddress(),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                await roles.oracleNode.getAddress(),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                maliciousConsumer.address,
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                await roles.oracleNode.getAddress(),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
                await roles.oracleNode.getAddress(),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
{"can't fulfill the data again"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                    ...convertFulfill2Params(
                      request,
                      responseTypes,
                      repeatedResponseValues,
                    ),
                  )`
{"is not successful with call"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
                specId,
                ethers.utils.toUtf8Bytes('stealEthCall(bytes32,bytes32)'),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('stealEthCall(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.provider.getBalance(maliciousConsumer.address)`
{"is not successful with send"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
                specId,
                ethers.utils.toUtf8Bytes('stealEthSend(bytes32,bytes32)'),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('stealEthSend(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.provider.getBalance(maliciousConsumer.address)`
{"is not successful with transfer"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestData(
                specId,
                ethers.utils.toUtf8Bytes('stealEthTransfer(bytes32,bytes32)'),
              )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.toUtf8Bytes('stealEthTransfer(bytes32,bytes32)')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(
                  ...convertFulfill2Params(
                    request,
                    responseTypes,
                    responseValues,
                  ),
                )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.provider.getBalance(maliciousConsumer.address)`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.deploy(link.address, operator.address, specId)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transfer(basicConsumer.address, paymentAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.requestEthereumPrice(
          'USD',
          paymentAmount,
        )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.oracleNode)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.fulfillOracleRequest2(...fulfillParams)`
{"does nothing"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(await roles.oracleNode.getAddress())`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), toWei('1'))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(await roles.oracleNode.getAddress())`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
{"withdraws funds"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(operator.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.defaultAccount.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.defaultAccount.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.defaultAccount.getAddress(), paid)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.defaultAccount.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(operator.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.defaultAccount.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.defaultAccount.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.sub(accountBalanceBefore)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.sub(operatorBalanceAfter)`
{"does not transfer funds"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.oracleNode.getAddress(), payment)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.oracleNode.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.oracleNode.getAddress()`
{"withdraws funds"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(operator.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
              await roles.defaultAccount.getAddress(),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.defaultAccount.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.defaultAccount.getAddress(), paid)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.defaultAccount.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(operator.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
              await roles.defaultAccount.getAddress(),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.defaultAccount.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.sub(accountBalanceBefore)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.sub(operatorBalanceAfter)`
{"does not allow input greater than the balance"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(operator.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.stranger.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.stranger.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.stranger.getAddress(), withdrawalAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.stranger.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(operator.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.stranger.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.stranger.getAddress()`
{"allows transfer of partial balance by owner to specified address"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.stranger.getAddress(), partialAmount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.stranger.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.stranger.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.stranger.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(operator.address)`
{"allows transfer of entire balance by owner to specified address"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.stranger.getAddress(), payment)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.stranger.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.stranger.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.stranger.getAddress()`
{"does not allow a transfer of funds by non-owner"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.stranger.getAddress(), payment)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.stranger.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.stranger.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.stranger.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.constants.Zero.eq(balance)`
{"withdraws funds"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(operator.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
              await roles.defaultAccount.getAddress(),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.defaultAccount.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdraw(await roles.defaultAccount.getAddress(), paid)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.defaultAccount.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(operator.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
              await roles.defaultAccount.getAddress(),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.defaultAccount.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.sub(accountBalanceBefore)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.sub(operatorBalanceAfter)`
{"returns the correct value"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdrawable()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.withdrawable()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.add(paid)`
{"reverts with owner error message"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.transfer(operator.address, startingBalance)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.ownerTransferAndCall(to, payment, args)`
{"reverts with funds message"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.ownerTransferAndCall(to, tooMuch, args)`
{"emits an event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.interface.parseLog({
            data: transferLog.data,
            topics: transferLog.topics,
          })`
{"transfers the tokens"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.sub(requesterBalanceAfter)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.sub(receiverBalanceBefore)`
{"fails"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.formatBytes32String('1337')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.interface.getSighash('requestedBytes32')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.from('')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.cancelOracleRequestByRequester(
              ...convertCancelByRequesterParams(fakeRequest, nonce),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.consumer)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.cancelOracleRequestByRequester(
                ...convertCancelByRequesterParams(request, nonce),
              )`
{"refunds the correct amount"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.consumer)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.cancelOracleRequestByRequester(
              ...convertCancelByRequesterParams(request, nonce),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.consumer.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.consumer.getAddress()`
{"triggers a cancellation event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.consumer)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.cancelOracleRequestByRequester(
              ...convertCancelByRequesterParams(request, nonce),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
{"fails when called twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.consumer)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.cancelOracleRequestByRequester(
              ...convertCancelByRequesterParams(request, nonce),
            )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.consumer)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.cancelOracleRequestByRequester(...convertCancelParams(request))`
{"fails"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.formatBytes32String('1337')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.interface.getSighash('requestedBytes32')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.from('')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.cancelOracleRequest(...convertCancelParams(fakeRequest))`
{"has correct initial balances"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(operator.address)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
          await roles.consumer.getAddress(),
        )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.consumer.getAddress()`
{"fails"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.consumer)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.cancelOracleRequest(...convertCancelParams(request))`
{"refunds the correct amount"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.consumer)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.cancelOracleRequest(...convertCancelParams(request))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.balanceOf(
            await roles.consumer.getAddress(),
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.consumer.getAddress()`
{"triggers a cancellation event"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.consumer)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.cancelOracleRequest(...convertCancelParams(request))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
{"fails when called twice"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.consumer)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.cancelOracleRequest(...convertCancelParams(request))`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.consumer)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.cancelOracleRequest(...convertCancelParams(request))`
{"reverts"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.stranger)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.ownerForward(mock.address, payload)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.interface.getSighash('name')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.ownerForward(link.address, sighash)`
{"forwards the data"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.ownerForward(mock.address, payload)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.getBytes()`
{"reverts when sending to a non-contract address"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.ownerForward(zeroAddress, payload)`
{"perceives the message is sent by the Operator"}
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.ownerForward(mock.address, payload)`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.wait()`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.interface.decodeEventLog(
            mock.interface.getEvent('SetBytes'),
            log.data,
            log.topics,
          )`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.interface.getEvent('SetBytes')`
$DIR/contracts/test/v0.8/operatorforwarder/Operator.test.ts: `.utils.getAddress(logData.from)`
{"sets the correct owner"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `operator = await operatorFactory
        .connect(roles.defaultAccount)
        .attach(emittedOperator)`
{"sets the correct owner on the operator"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `operator = await operatorFactory
        .connect(roles.defaultAccount)
        .attach(receipt?.events?.[0]?.args?.[0])`
{"sets the operator as the owner of the forwarder"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `forwarder = await forwarderFactory
        .connect(roles.defaultAccount)
        .attach(emittedForwarder)`
{"sets the caller as the owner"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `forwarder = await forwarderFactory
        .connect(roles.defaultAccount)
        .attach(emittedForwarder)`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `forwarder = await forwarderFactory
        .connect(roles.defaultAccount)
        .attach(emittedForwarder)`
{"describes the authorized forwarder"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.typeAndVersion()`
{"emits an event"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.oracleNode.getAddress()`
{"sets the correct owner"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.attach(emittedOperator)`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.owner()`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.oracleNode.getAddress()`
{"records that it deployed that address"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.created(emittedOperator)`
{"emits an event recording that the operator was deployed"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.oracleNode.getAddress()`
{"emits an event recording that the forwarder was deployed"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.oracleNode.getAddress()`
{"sets the correct owner on the operator"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.attach(receipt?.events?.[0]?.args?.[0])`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.oracleNode.getAddress()`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.owner()`
{"sets the operator as the owner of the forwarder"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.attach(emittedForwarder)`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.owner()`
{"records that it deployed that address"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.created(emittedForwarder)`
{"emits an event"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.oracleNode.getAddress()`
{"sets the caller as the owner"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.attach(emittedForwarder)`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.owner()`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.oracleNode.getAddress()`
{"records that it deployed that address"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.created(emittedForwarder)`
{"emits an event"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.oracleNode.getAddress()`
{"sets the caller as the owner"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.connect(roles.defaultAccount)`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.attach(emittedForwarder)`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.owner()`
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.oracleNode.getAddress()`
{"proposes a transfer to the recipient"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.stranger.getAddress()`
{"proposes a transfer to the recipient with the specified message"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.utils.defaultAbiCoder.encode(
        ['bytes'],
        [message],
      )`
{"records that it deployed that address"}
$DIR/contracts/test/v0.8/operatorforwarder/OperatorFactory.test.ts: `.created(emittedForwarder)`
