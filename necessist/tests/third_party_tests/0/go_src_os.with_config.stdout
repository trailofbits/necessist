357 candidates in 71 tests in 1 source file
$DIR/src/os/os_test.go: dry running
$DIR/src/os/os_test.go: mutilating
$DIR/src/os/os_test.go: `testenv.MustHaveSymlink(t)` passed
$DIR/src/os/os_test.go: `err = Symlink(path, link)` failed
$DIR/src/os/os_test.go: `fi, err = Stat(link)` failed
$DIR/src/os/os_test.go: `testenv.MustHaveSymlink(t)` passed
$DIR/src/os/os_test.go: `err = Symlink("y", "x")` passed
$DIR/src/os/os_test.go: `_, err = Stat("x")` failed
$DIR/src/os/os_test.go: `b = make([]byte, 100)` failed
$DIR/src/os/os_test.go: `n, err = f.Read(b)` failed
$DIR/src/os/os_test.go: `_, err = file.Read(b)` failed
$DIR/src/os/os_test.go: `t.Run(".", testReaddirnames(".", dot))` passed
$DIR/src/os/os_test.go: `t.Run("sysdir", testReaddirnames(sysdir.name, sysdir.files))` passed
$DIR/src/os/os_test.go: `t.Run(".", testReaddir(".", dot))` passed
$DIR/src/os/os_test.go: `t.Run("sysdir", testReaddir(sysdir.name, sysdir.files))` passed
$DIR/src/os/os_test.go: `t.Run(".", testReadDir(".", dot))` passed
$DIR/src/os/os_test.go: `t.Run("sysdir", testReadDir(sysdir.name, sysdir.files))` passed
$DIR/src/os/os_test.go: `f.Write([]byte(strings.Repeat("X", i)))` passed
$DIR/src/os/os_test.go: `d, err = Open(dir)` failed
$DIR/src/os/os_test.go: `openDir()` failed
$DIR/src/os/os_test.go: `fn(0, 105, nil)` failed
$DIR/src/os/os_test.go: `fn(0, 0, nil)` passed
$DIR/src/os/os_test.go: `openDir()` failed
$DIR/src/os/os_test.go: `fn(-1, 105, nil)` failed
$DIR/src/os/os_test.go: `fn(-2, 0, nil)` passed
$DIR/src/os/os_test.go: `fn(0, 0, nil)` passed
$DIR/src/os/os_test.go: `openDir()` failed
$DIR/src/os/os_test.go: `fn(1, 1, nil)` failed
$DIR/src/os/os_test.go: `fn(2, 2, nil)` failed
$DIR/src/os/os_test.go: `fn(105, 102, nil)` failed
$DIR/src/os/os_test.go: `fn(3, 0, io.EOF)` passed
$DIR/src/os/os_test.go: `f.Write([]byte("foo"))` passed
$DIR/src/os/os_test.go: `testenv.MustHaveLink(t)` passed
$DIR/src/os/os_test.go: `err = Link(to, from)` failed
$DIR/src/os/os_test.go: `err = Link(none, none)` failed
$DIR/src/os/os_test.go: `err = Link(to, from)` failed
$DIR/src/os/os_test.go: `testenv.MustHaveSymlink(t)` passed
$DIR/src/os/os_test.go: `err = Symlink(to, from)` failed
$DIR/src/os/os_test.go: `fromstat, err = Lstat(from)` failed
$DIR/src/os/os_test.go: `fromstat, err = Stat(from)` failed
$DIR/src/os/os_test.go: `file, err = Open(from)` passed
$DIR/src/os/os_test.go: `testenv.MustHaveSymlink(t)` passed
$DIR/src/os/os_test.go: `s = s + s + s + s + s + s + s + s + s + s + s + s + s + s + s` passed
$DIR/src/os/os_test.go: `err = Rename(from, to)` failed
$DIR/src/os/os_test.go: `_, err = Stat(to)` passed
$DIR/src/os/os_test.go: `err = WriteFile(from, fromData, 0777)` failed
$DIR/src/os/os_test.go: `err = Rename(from, to)` failed
$DIR/src/os/os_test.go: `_, err = Stat(from)` failed
$DIR/src/os/os_test.go: `Mkdir(to, 0777)` passed
$DIR/src/os/os_test.go: `Mkdir(from, 0777)` passed
$DIR/src/os/os_test.go: `Mkdir(to, 0777)` failed
$DIR/src/os/os_test.go: `pt.Run(test.name, func(t *testing.T) {
			defer chtmpdir(t)()

			if err := test.create(); err != nil {
				t.Fatalf("failed to create test file: %s", err)
			}

			if _, err := Stat(to); err != nil {
				// Sanity check that the underlying filesystem is not case sensitive.
				if IsNotExist(err) {
					t.Skipf("case sensitive filesystem")
				}
				t.Fatalf("stat %q, got: %q", to, err)
			}

			if err := Rename(from, to); err != nil {
				t.Fatalf("unexpected error when renaming from %q to %q: %s", from, to, err)
			}

			fd, err := Open(".")
			if err != nil {
				t.Fatalf("Open .: %s", err)
			}

			// Stat does not return the real case of the file (it returns what the called asked for)
			// So we have to use readdir to get the real name of the file.
			dirNames, err := fd.Readdirnames(-1)
			fd.Close()
			if err != nil {
				t.Fatalf("readdirnames: %s", err)
			}

			if dirNamesLen := len(dirNames); dirNamesLen != 1 {
				t.Fatalf("unexpected dirNames len, got %q, want %q", dirNamesLen, 1)
			}

			if dirNames[0] != to {
				t.Errorf("unexpected name, got %q, want %q", dirNames[0], to)
			}
		})` passed
$DIR/src/os/os_test.go: `fm = FileMode(0444)` passed
$DIR/src/os/os_test.go: `checkMode(t, f.Name(), fm)` passed
$DIR/src/os/os_test.go: `fm = FileMode(0123)` passed
$DIR/src/os/os_test.go: `fm = FileMode(0666)` passed
$DIR/src/os/os_test.go: `checkSize(t, f, 0)` passed
$DIR/src/os/os_test.go: `f.Write([]byte("hello, world\n"))` failed
$DIR/src/os/os_test.go: `checkSize(t, f, 13)` passed
$DIR/src/os/os_test.go: `f.Truncate(10)` failed
$DIR/src/os/os_test.go: `checkSize(t, f, 10)` passed
$DIR/src/os/os_test.go: `f.Truncate(1024)` failed
$DIR/src/os/os_test.go: `checkSize(t, f, 1024)` passed
$DIR/src/os/os_test.go: `f.Truncate(0)` failed
$DIR/src/os/os_test.go: `checkSize(t, f, 0)` passed
$DIR/src/os/os_test.go: `checkSize(t, f, 13+9)` passed
$DIR/src/os/os_test.go: `checkSize(t, f, 0)` passed
$DIR/src/os/os_test.go: `f.Write([]byte("hello, world\n"))` failed
$DIR/src/os/os_test.go: `checkSize(t, f, 13)` passed
$DIR/src/os/os_test.go: `Truncate(f.Name(), 10)` failed
$DIR/src/os/os_test.go: `checkSize(t, f, 10)` passed
$DIR/src/os/os_test.go: `Truncate(f.Name(), 1024)` failed
$DIR/src/os/os_test.go: `checkSize(t, f, 1024)` passed
$DIR/src/os/os_test.go: `Truncate(f.Name(), 0)` failed
$DIR/src/os/os_test.go: `checkSize(t, f, 0)` passed
$DIR/src/os/os_test.go: `checkSize(t, f, 13+9)` passed
$DIR/src/os/os_test.go: `assertPathError(t, path, err)` passed
$DIR/src/os/os_test.go: `_, err = Stat(path)` passed
$DIR/src/os/os_test.go: `f.Write([]byte("hello, world\n"))` passed
$DIR/src/os/os_test.go: `testChtimesOmit(t, true, false)` passed
$DIR/src/os/os_test.go: `testChtimesOmit(t, false, true)` passed
$DIR/src/os/os_test.go: `testChtimesOmit(t, true, true)` passed
$DIR/src/os/os_test.go: `io.WriteString(f, data)` failed
$DIR/src/os/os_test.go: `_, err = r.Seek(0, 0)` failed
$DIR/src/os/os_test.go: `_, err = w.Seek(0, 0)` passed
$DIR/src/os/os_test.go: `testWindowsHostname(t, hostname)` passed
$DIR/src/os/os_test.go: `testenv.MustHaveExec(t)` passed
$DIR/src/os/os_test.go: `io.WriteString(f, data)` failed
$DIR/src/os/os_test.go: `io.WriteString(f, data)` failed
$DIR/src/os/os_test.go: `f.Seek(0, 0)` failed
$DIR/src/os/os_test.go: `n, err = f.Read(b)` failed
$DIR/src/os/os_test.go: `io.WriteString(f, data)` passed
$DIR/src/os/os_test.go: `f.Seek(0, 0)` passed
$DIR/src/os/os_test.go: `io.WriteString(f, data)` failed
$DIR/src/os/os_test.go: `_, err = f.WriteAt([]byte(""), 1)` failed
$DIR/src/os/os_test.go: `s = writeFile(t, f, O_APPEND|O_RDWR, "|append")` failed
$DIR/src/os/os_test.go: `s = writeFile(t, f, O_CREATE|O_APPEND|O_RDWR, "|append")` failed
$DIR/src/os/os_test.go: `s = writeFile(t, f, O_CREATE|O_APPEND|O_RDWR, "new&append")` failed
$DIR/src/os/os_test.go: `s = writeFile(t, f, O_CREATE|O_RDWR, "old")` failed
$DIR/src/os/os_test.go: `s = writeFile(t, f, O_CREATE|O_TRUNC|O_RDWR, "new")` failed
$DIR/src/os/os_test.go: `path += "/"` passed
$DIR/src/os/os_test.go: `testDevNullFile(t, DevNull)` passed
$DIR/src/os/os_test.go: `testDevNullFile(t, "./nul")` passed
$DIR/src/os/os_test.go: `testDevNullFile(t, "//./nul")` passed
$DIR/src/os/os_test.go: `b[i] = '.'` passed
$DIR/src/os/os_test.go: `b[len(b)-1] = '\n'` passed
$DIR/src/os/os_test.go: `n, err = Stderr.Write(b)` passed
$DIR/src/os/os_test.go: `testenv.MustHaveSymlink(t)` passed
$DIR/src/os/os_test.go: `err = Symlink(filepath.Base(target), link)` failed
$DIR/src/os/os_test.go: `Remove(link)` passed
$DIR/src/os/os_test.go: `err = Symlink(target[len(filepath.VolumeName(target)):], link)` passed
$DIR/src/os/os_test.go: `tmpdir += "/dir3456789"` timed-out
$DIR/src/os/os_test.go: `t.Run(fmt.Sprintf("length=%d", sz), func(t *testing.T) {
			sizedTempDir := tmpdir[:sz-1] + "x" // Ensure it does not end with a slash.

			// The various sized runs are for this call to trigger the boundary
			// condition.
			if err := MkdirAll(sizedTempDir, 0755); err != nil {
				t.Fatalf("MkdirAll failed: %v", err)
			}
			data := []byte("hello world\n")
			if err := WriteFile(sizedTempDir+"/foo.txt", data, 0644); err != nil {
				t.Fatalf("os.WriteFile() failed: %v", err)
			}
			if err := Rename(sizedTempDir+"/foo.txt", sizedTempDir+"/bar.txt"); err != nil {
				t.Fatalf("Rename failed: %v", err)
			}
			mtime := time.Now().Truncate(time.Minute)
			if err := Chtimes(sizedTempDir+"/bar.txt", mtime, mtime); err != nil {
				t.Fatalf("Chtimes failed: %v", err)
			}
			names := []string{"bar.txt"}
			if testenv.HasSymlink() {
				if err := Symlink(sizedTempDir+"/bar.txt", sizedTempDir+"/symlink.txt"); err != nil {
					t.Fatalf("Symlink failed: %v", err)
				}
				names = append(names, "symlink.txt")
			}
			if testenv.HasLink() {
				if err := Link(sizedTempDir+"/bar.txt", sizedTempDir+"/link.txt"); err != nil {
					t.Fatalf("Link failed: %v", err)
				}
				names = append(names, "link.txt")
			}
			for _, wantSize := range []int64{int64(len(data)), 0} {
				for _, name := range names {
					path := sizedTempDir + "/" + name
					dir, err := Stat(path)
					if err != nil {
						t.Fatalf("Stat(%q) failed: %v", path, err)
					}
					filesize := size(path, t)
					if dir.Size() != filesize || filesize != wantSize {
						t.Errorf("Size(%q) is %d, len(ReadFile()) is %d, want %d", path, dir.Size(), filesize, wantSize)
					}
					if runtime.GOOS != "wasip1" { // Chmod is not supported on wasip1
						err = Chmod(path, dir.Mode())
						if err != nil {
							t.Fatalf("Chmod(%q) failed: %v", path, err)
						}
					}
				}
				if err := Truncate(sizedTempDir+"/bar.txt", 0); err != nil {
					t.Fatalf("Truncate failed: %v", err)
				}
			}
		})` passed
thread 'main' panicked at core/src/core.rs:344:29:
Instrumentation failed to build after it was verified to
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
