{"Contract Orders (standard)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
{"Contract Orders (offer extended)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderWithoutOffer.parameters.offer = [];`
{"Contract Orders (offer amount increased)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderWithSmallerOfferAmount.parameters.offer[0].startAmount =
        order.parameters.offer[0].startAmount.sub(1);`
$DIR/test/advanced.spec.ts: `orderWithSmallerOfferAmount.parameters.offer[0].endAmount =
        order.parameters.offer[0].endAmount.sub(1);`
{"Contract Orders (criteria-based offer item: ERC1155 wildcard)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderWithCriteriaOffer.parameters.offer[0].itemType = 5;`
$DIR/test/advanced.spec.ts: `orderWithCriteriaOffer.parameters.offer[0].identifierOrCriteria = 0;`
{"Contract Orders (criteria-based offer item: ERC1155 non-wildcard)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].itemType = 3;`
$DIR/test/advanced.spec.ts: `offer[0].identifier = nftId;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `offer[0].itemType = 5;`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `order.parameters.offer[0].identifier = nftId;`
{"Contract Orders (offer extended with supplied offer)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderWithSmallerOffer.parameters.offer[0].startAmount =
        order.parameters.offer[0].startAmount.div(2);`
$DIR/test/advanced.spec.ts: `orderWithSmallerOffer.parameters.offer[0].endAmount =
        order.parameters.offer[0].endAmount.div(2);`
$DIR/test/advanced.spec.ts: `order.parameters.offer[0].startAmount =
        order.parameters.offer[0].startAmount.div(2);`
$DIR/test/advanced.spec.ts: `order.parameters.offer[0].endAmount =
        order.parameters.offer[0].endAmount.div(2);`
$DIR/test/advanced.spec.ts: `order.parameters.offer.push(order.parameters.offer[0]);`
$DIR/test/advanced.spec.ts: `await offererContract.connect(seller).extendAvailable();`
{"Contract Orders (consideration reduced)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderWithExtraConsideration.parameters.consideration.push(
        JSON.parse(
          JSON.stringify(
            orderWithExtraConsideration.parameters.consideration[0]
          )
        )
      );`
$DIR/test/advanced.spec.ts: `orderWithExtraConsideration.parameters.consideration[1].itemType = 1;`
$DIR/test/advanced.spec.ts: `orderWithExtraConsideration.parameters.consideration[1].token =
        "0x".padEnd(42, "1");`
$DIR/test/advanced.spec.ts: `orderWithExtraConsideration.parameters.totalOriginalConsiderationItems++;`
{"Contract Orders (consideration amount reduced)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderWithIncreasedConsideration.parameters.consideration[0].startAmount =
        order.parameters.consideration[0].startAmount.add(1);`
$DIR/test/advanced.spec.ts: `orderWithIncreasedConsideration.parameters.consideration[0].endAmount =
        order.parameters.consideration[0].endAmount.add(1);`
{"Contract Orders (criteria-based consideration item)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderWithCriteriaConsideration.parameters.consideration[0].itemType = 5;`
$DIR/test/advanced.spec.ts: `orderWithCriteriaConsideration.parameters.consideration[0].identifierOrCriteria = 0;`
{"Contract Orders (native token offer items)"}
$DIR/test/advanced.spec.ts: `await faucet(offererContract.address, provider);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
{"Reverts on contract orders where offer endAmount is greater than offer amount (branch 2)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `offer[0].endAmount = offer[0].amount.add(1);`
$DIR/test/advanced.spec.ts: `offer[0].startAmount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
{"Reverts on contract orders where offer itemType is different from generated itemType"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `order.parameters.offer[0].itemType = 1;`
{"Reverts on contract orders where offer token address is different from generated token address"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `order.parameters.offer[0].token = testERC1155Two.address;`
{"Reverts on contract orders where offer identifier is different from generated identifier"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `order.parameters.offer[0].identifierOrCriteria =
        offer[0].identifier.add(1);`
{"Reverts on contract orders where consideration itemType is different from generated itemType"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `order.parameters.consideration[0].itemType = 1;`
{"Reverts on contract orders where consideration token address is different from generated token address"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `order.parameters.consideration[0].token = testERC1155Two.address;`
{"Reverts on contract orders where consideration identifier is different from generated identifier"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `order.parameters.consideration[0].identifierOrCriteria =
        consideration[0].identifier.add(1);`
{"Reverts on contract orders where consideration recipient is different from generated recipient"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `order.parameters.consideration[0].recipient = owner.address;`
{"Reverts on contract orders where consideration is omitted"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderWithNoConsideration.parameters.consideration = [];`
$DIR/test/advanced.spec.ts: `orderWithNoConsideration.parameters.totalOriginalConsiderationItems = 0;`
{"Reverts on contract orders where offer and consideration omitted"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderWithoutOfferOrConsideration.parameters.offer = [];`
$DIR/test/advanced.spec.ts: `orderWithoutOfferOrConsideration.parameters.consideration = [];`
$DIR/test/advanced.spec.ts: `orderWithoutOfferOrConsideration.parameters.totalOriginalConsiderationItems = 0;`
{"Reverts on contract orders where offer is reduced by contract offerer"}
$DIR/test/advanced.spec.ts: `await testERC1155Two.mint(seller.address, secondNftId, secondAmount);`
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderWithExtraOffer.parameters.offer.push(
        JSON.parse(JSON.stringify(orderWithExtraOffer.parameters.offer[0]))
      );`
$DIR/test/advanced.spec.ts: `orderWithExtraOffer.parameters.offer[1].token = testERC1155Two.address;`
$DIR/test/advanced.spec.ts: `orderWithExtraOffer.parameters.offer[1].identifierOrCriteria =
        secondNftId;`
$DIR/test/advanced.spec.ts: `orderWithExtraOffer.parameters.offer[1].amount = secondAmount;`
{"Reverts on contract orders where consideration is extended by contract offerer"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `await offererContract.connect(seller).extendRequired();`
{"Reverts on contract orders where offer amount is reduced by contract offerer"}
$DIR/test/advanced.spec.ts: `await testERC1155Two.mint(seller.address, secondNftId, secondAmount);`
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `order.parameters.offer[0].startAmount =
        order.parameters.offer[0].startAmount.add(1);`
$DIR/test/advanced.spec.ts: `order.parameters.offer[0].endAmount =
        order.parameters.offer[0].startAmount.add(1);`
{"Reverts on contract orders where consideration amount is increased by contract offerer"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `consideration[0].startAmount = consideration[0].startAmount.sub(1);`
$DIR/test/advanced.spec.ts: `consideration[0].endAmount = consideration[0].endAmount.sub(1);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
{"Reverts on contract orders that supply a bad fraction"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 2;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
{"Reverts on contract orders that supply a bad fraction (numerator != 1)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 2;`
$DIR/test/advanced.spec.ts: `order.denominator = 2;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
{"Reverts on contract orders where call to generateOrders throws and reverts aren't skipped"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, invalidContractOfferer.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await invalidContractOfferer
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `consideration[0].startAmount = consideration[0].startAmount.sub(1);`
$DIR/test/advanced.spec.ts: `consideration[0].endAmount = consideration[0].endAmount.sub(1);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = invalidContractOfferer.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
{"Reverts on contract orders where call to generateOrders throws and reverts are skipped"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `consideration[0].startAmount = consideration[0].startAmount.sub(1);`
$DIR/test/advanced.spec.ts: `consideration[0].endAmount = consideration[0].endAmount.sub(1);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
{"Reverts on contract orders where call to ratifyOrders returns incorrect magic value"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(
        seller,
        invalidContractOffererRatifyOrder.address,
        true
      );`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await invalidContractOffererRatifyOrder
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = invalidContractOffererRatifyOrder.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
{"Reverts on contract orders where consideration length does not match totalOriginalConsiderationItems"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/advanced.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/advanced.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContract
        .connect(seller)
        .activate(offer[0], consideration[0]);`
$DIR/test/advanced.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `order.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderWithMismatchedTotalOriginal.parameters
        .totalOriginalConsiderationItems++;`
{"Can fulfill and aggregate contract orders via fulfillAvailableAdvancedOrders with failing orders due to reverts"}
$DIR/test/advanced.spec.ts: `await mintAndApprove1155(seller, marketplaceContract.address, 10000);`
$DIR/test/advanced.spec.ts: `await mintAndApprove1155(seller, marketplaceContract.address, 10000);`
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContractOne.address, true);`
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContractTwo.address, true);`
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContractThree.address, true);`
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContractFour.address, true);`
$DIR/test/advanced.spec.ts: `offerOne[0].identifier = offerOne[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offerOne[0].amount = offerOne[0].endAmount;`
$DIR/test/advanced.spec.ts: `considerationOne[0].identifier = considerationOne[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `considerationOne[0].amount = considerationOne[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContractOne
        .connect(seller)
        .activate(offerOne[0], considerationOne[0]);`
$DIR/test/advanced.spec.ts: `orderOne.parameters.offerer = offererContractOne.address;`
$DIR/test/advanced.spec.ts: `orderOne.numerator = 1;`
$DIR/test/advanced.spec.ts: `orderOne.denominator = 1;`
$DIR/test/advanced.spec.ts: `orderOne.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderOne.extraData = ethers.utils.defaultAbiCoder.encode(
        ["bytes32[]"],
        [[orderHashOne, ethers.constants.HashZero]]
      );`
$DIR/test/advanced.spec.ts: `offerTwo[0].identifier = offerTwo[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offerTwo[0].amount = offerTwo[0].endAmount;`
$DIR/test/advanced.spec.ts: `considerationTwo[0].identifier = considerationTwo[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `considerationTwo[0].amount = considerationTwo[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContractTwo
        .connect(seller)
        .activate(offerTwo[0], considerationTwo[0]);`
$DIR/test/advanced.spec.ts: `orderTwo.parameters.offerer = offererContractTwo.address;`
$DIR/test/advanced.spec.ts: `orderTwo.numerator = 1;`
$DIR/test/advanced.spec.ts: `orderTwo.denominator = 1;`
$DIR/test/advanced.spec.ts: `orderTwo.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderTwo.extraData = "0x1234";`
{"Cannot fulfill and aggregate contract orders via fulfillAvailableAdvancedOrders with failing orders due to bad data"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContractOne.address, true);`
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContractTwo.address, true);`
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContractThree.address, true);`
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, offererContractFour.address, true);`
$DIR/test/advanced.spec.ts: `offerOne[0].identifier = offerOne[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offerOne[0].amount = offerOne[0].endAmount;`
$DIR/test/advanced.spec.ts: `considerationOne[0].identifier = considerationOne[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `considerationOne[0].amount = considerationOne[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContractOne
        .connect(seller)
        .activate(offerOne[0], considerationOne[0]);`
$DIR/test/advanced.spec.ts: `orderOne.parameters.offerer = offererContractOne.address;`
$DIR/test/advanced.spec.ts: `orderOne.numerator = 1;`
$DIR/test/advanced.spec.ts: `orderOne.denominator = 1;`
$DIR/test/advanced.spec.ts: `orderOne.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderOne.extraData = ethers.utils.defaultAbiCoder.encode(
        ["bytes32[]"],
        [
          [
            orderHashOne,
            ethers.constants.HashZero,
            ethers.constants.HashZero,
            ethers.constants.HashZero,
          ],
        ]
      );`
$DIR/test/advanced.spec.ts: `offerTwo[0].identifier = offerTwo[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offerTwo[0].amount = offerTwo[0].endAmount;`
$DIR/test/advanced.spec.ts: `considerationTwo[0].identifier = considerationTwo[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `considerationTwo[0].amount = considerationTwo[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContractTwo
        .connect(seller)
        .activate(offerTwo[0], considerationTwo[0]);`
$DIR/test/advanced.spec.ts: `orderTwo.parameters.offerer = offererContractTwo.address;`
$DIR/test/advanced.spec.ts: `orderTwo.numerator = 1;`
$DIR/test/advanced.spec.ts: `orderTwo.denominator = 1;`
$DIR/test/advanced.spec.ts: `orderTwo.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderTwo.extraData = "0x1234";`
$DIR/test/advanced.spec.ts: `offerThree[0].identifier = offerThree[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offerThree[0].amount = offerThree[0].endAmount;`
$DIR/test/advanced.spec.ts: `offerThree[1].identifier = offerThree[1].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offerThree[1].amount = offerThree[1].endAmount;`
$DIR/test/advanced.spec.ts: `considerationThree[0].identifier =
        considerationThree[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `considerationThree[0].amount = considerationThree[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContractThree
        .connect(seller)
        .activate(offerThree[0], considerationThree[0]);`
$DIR/test/advanced.spec.ts: `orderThree.parameters.offerer = offererContractThree.address;`
$DIR/test/advanced.spec.ts: `orderThree.numerator = 1;`
$DIR/test/advanced.spec.ts: `orderThree.denominator = 1;`
$DIR/test/advanced.spec.ts: `orderThree.signature = "0x";`
$DIR/test/advanced.spec.ts: `offerFour[0].identifier = offerFour[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `offerFour[0].amount = offerFour[0].endAmount;`
$DIR/test/advanced.spec.ts: `considerationFour[0].identifier =
        considerationFour[0].identifierOrCriteria;`
$DIR/test/advanced.spec.ts: `considerationFour[0].amount = considerationFour[0].endAmount;`
$DIR/test/advanced.spec.ts: `await offererContractFour
        .connect(seller)
        .activate(offerFour[0], considerationFour[0]);`
$DIR/test/advanced.spec.ts: `orderFour.parameters.offerer = offererContractFour.address;`
$DIR/test/advanced.spec.ts: `orderFour.numerator = 1;`
$DIR/test/advanced.spec.ts: `orderFour.denominator = 1;`
$DIR/test/advanced.spec.ts: `orderFour.signature = "0x";`
$DIR/test/advanced.spec.ts: `orderFour.parameters.consideration[0].startAmount =
        orderFour.parameters.consideration[0].startAmount.sub(1);`
$DIR/test/advanced.spec.ts: `orderFour.parameters.consideration[0].endAmount =
        orderFour.parameters.consideration[0].endAmount.sub(1);`
{"Partial fills (standard)"}
$DIR/test/advanced.spec.ts: `order.numerator = 2;`
$DIR/test/advanced.spec.ts: `order.denominator = 10;`
$DIR/test/advanced.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 2;`
$DIR/test/advanced.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 2;`
$DIR/test/advanced.spec.ts: `clonedOrder.parameters.startTime = order.parameters.startTime;`
$DIR/test/advanced.spec.ts: `clonedOrder.parameters.endTime = order.parameters.endTime;`
$DIR/test/advanced.spec.ts: `offerItem.startAmount = order.parameters.offer[+j].startAmount;`
$DIR/test/advanced.spec.ts: `offerItem.endAmount = order.parameters.offer[+j].endAmount;`
$DIR/test/advanced.spec.ts: `considerationItem.startAmount =
            order.parameters.consideration[+j].startAmount;`
$DIR/test/advanced.spec.ts: `considerationItem.endAmount =
            order.parameters.consideration[+j].endAmount;`
$DIR/test/advanced.spec.ts: `ordersClone[0].numerator = 3;`
$DIR/test/advanced.spec.ts: `ordersClone[0].denominator = 10;`
$DIR/test/advanced.spec.ts: `await withBalanceChecks(ordersClone, 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order: ordersClone[0],
              orderHash,
              fulfiller: buyer.address,
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Partial fills (standard, additional permutations)"}
$DIR/test/advanced.spec.ts: `order.numerator = 2;`
$DIR/test/advanced.spec.ts: `order.denominator = 10;`
$DIR/test/advanced.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 10;`
$DIR/test/advanced.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 1;`
$DIR/test/advanced.spec.ts: `clonedOrder.parameters.startTime = order.parameters.startTime;`
$DIR/test/advanced.spec.ts: `clonedOrder.parameters.endTime = order.parameters.endTime;`
$DIR/test/advanced.spec.ts: `offerItem.startAmount = order.parameters.offer[+j].startAmount;`
$DIR/test/advanced.spec.ts: `offerItem.endAmount = order.parameters.offer[+j].endAmount;`
$DIR/test/advanced.spec.ts: `considerationItem.startAmount =
            order.parameters.consideration[+j].startAmount;`
$DIR/test/advanced.spec.ts: `considerationItem.endAmount =
            order.parameters.consideration[+j].endAmount;`
$DIR/test/advanced.spec.ts: `ordersClone[0].numerator = 7;`
$DIR/test/advanced.spec.ts: `ordersClone[0].denominator = 10;`
$DIR/test/advanced.spec.ts: `await withBalanceChecks(ordersClone, 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order: ordersClone[0],
              orderHash,
              fulfiller: buyer.address,
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Partial fills (match)"}
$DIR/test/advanced.spec.ts: `order.numerator = 2;`
$DIR/test/advanced.spec.ts: `order.denominator = 10;`
$DIR/test/advanced.spec.ts: `mirrorObject = await createMirrorBuyNowOrder(buyer, zone, order);`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = 10;`
$DIR/test/advanced.spec.ts: `mirrorObject = await createMirrorBuyNowOrder(buyer, zone, order);`
$DIR/test/advanced.spec.ts: `executions = await simulateAdvancedMatchOrders(
        marketplaceContract,
        [order, mirrorObject.mirrorOrder],
        [], // no criteria resolvers
        fulfillments,
        owner,
        value
      );`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/advanced.spec.ts: `order.numerator = 7;`
$DIR/test/advanced.spec.ts: `order.denominator = 10;`
$DIR/test/advanced.spec.ts: `mirrorObject = await createMirrorBuyNowOrder(buyer, zone, order);`
$DIR/test/advanced.spec.ts: `executions = await simulateAdvancedMatchOrders(
        marketplaceContract,
        [order, mirrorObject.mirrorOrder],
        [], // no criteria resolvers
        fulfillments,
        owner,
        value
      );`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Simplifies fraction when numerator/denominator would overflow"}
$DIR/test/advanced.spec.ts: `await mintAndApproveERC20(buyer, marketplaceContract.address, amt);`
$DIR/test/advanced.spec.ts: `order.numerator = numer1 as any;`
$DIR/test/advanced.spec.ts: `order.denominator = denom1 as any;`
$DIR/test/advanced.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(order, [], toKey(0), buyer.address, {
            value,
          });
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/advanced.spec.ts: `order.numerator = +numer2;`
$DIR/test/advanced.spec.ts: `order.denominator = +denom2;`
$DIR/test/advanced.spec.ts: `await marketplaceContract
        .connect(buyer)
        .fulfillAdvancedOrder(order, [], toKey(0), buyer.address, {
          value,
        });`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Reverts when numerator/denominator overflow"}
$DIR/test/advanced.spec.ts: `await mintAndApproveERC20(buyer, marketplaceContract.address, amt);`
$DIR/test/advanced.spec.ts: `order.numerator = 1;`
$DIR/test/advanced.spec.ts: `order.denominator = prime2 as any;`
$DIR/test/advanced.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(order, [], toKey(0), buyer.address, {
            value,
          });
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/advanced.spec.ts: `order.numerator = prime1 as any;`
$DIR/test/advanced.spec.ts: `order.denominator = prime3 as any;`
{"Criteria-based offer item ERC721 (standard)"}
$DIR/test/advanced.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
{"Criteria-based offer item ERC1155 (standard)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
{"Criteria-based offer item (standard, collection-level)"}
$DIR/test/advanced.spec.ts: `await testERC721.mint(seller.address, nftId);`
$DIR/test/advanced.spec.ts: `await testERC721.mint(seller.address, secondNFTId);`
$DIR/test/advanced.spec.ts: `await testERC721.mint(seller.address, thirdNFTId);`
$DIR/test/advanced.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
{"Criteria-based offer item ERC721 (match)"}
$DIR/test/advanced.spec.ts: `await testERC721.mint(seller.address, nftId);`
$DIR/test/advanced.spec.ts: `await testERC721.mint(seller.address, secondNFTId);`
$DIR/test/advanced.spec.ts: `await testERC721.mint(seller.address, thirdNFTId);`
$DIR/test/advanced.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
{"Criteria-based offer item ERC1155 (match)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
{"Criteria-based offer item (match, collection-level)"}
$DIR/test/advanced.spec.ts: `await testERC721.mint(seller.address, nftId);`
$DIR/test/advanced.spec.ts: `await testERC721.mint(seller.address, secondNFTId);`
$DIR/test/advanced.spec.ts: `await testERC721.mint(seller.address, thirdNFTId);`
$DIR/test/advanced.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
{"Criteria-based consideration item (standard)"}
$DIR/test/advanced.spec.ts: `await testERC721.mint(buyer.address, nftId);`
$DIR/test/advanced.spec.ts: `await testERC721.mint(buyer.address, secondNFTId);`
$DIR/test/advanced.spec.ts: `await testERC721.mint(buyer.address, thirdNFTId);`
$DIR/test/advanced.spec.ts: `await set721ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/advanced.spec.ts: `await mintAndApproveERC20(
        seller,
        marketplaceContract.address,
        tokenAmount
      );`
{"Criteria-based consideration item ERC1155 (standard)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/advanced.spec.ts: `await mintAndApproveERC20(
        seller,
        marketplaceContract.address,
        tokenAmount
      );`
{"Criteria-based wildcard consideration item (standard)"}
$DIR/test/advanced.spec.ts: `await mintAndApproveERC20(
        seller,
        marketplaceContract.address,
        tokenAmount
      );`
{"Criteria-based consideration item ERC721 (match)"}
$DIR/test/advanced.spec.ts: `await set721ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/advanced.spec.ts: `await mintAndApproveERC20(
        seller,
        marketplaceContract.address,
        tokenAmount
      );`
$DIR/test/advanced.spec.ts: `await mintAndApproveERC20(
        buyer,
        marketplaceContract.address,
        tokenAmount
      );`
{"Criteria-based consideration item ERC1155 (match)"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/advanced.spec.ts: `await mintAndApproveERC20(
        seller,
        marketplaceContract.address,
        tokenAmount
      );`
$DIR/test/advanced.spec.ts: `await mintAndApproveERC20(
        buyer,
        marketplaceContract.address,
        tokenAmount
      );`
{"Criteria-based offer item with junk criteria proof"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
{"Can sign for a bulk signature"}
$DIR/test/advanced.spec.ts: `order.numerator = 2;`
$DIR/test/advanced.spec.ts: `order.denominator = 10;`
{"Can sign for a bulk signature with index 9 in 32 node tree"}
$DIR/test/advanced.spec.ts: `order.numerator = 2;`
$DIR/test/advanced.spec.ts: `order.denominator = 10;`
{"Can sign for a compact bulk signature"}
$DIR/test/advanced.spec.ts: `order.numerator = 2;`
$DIR/test/advanced.spec.ts: `order.denominator = 10;`
{"Ascending offer amount (standard)"}
$DIR/test/advanced.spec.ts: `await testERC1155.mint(seller.address, nftId, endAmount.mul(10));`
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/advanced.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Ascending consideration amount (standard)"}
$DIR/test/advanced.spec.ts: `await mintAndApproveERC20(
        seller,
        marketplaceContract.address,
        tokenAmount
      );`
$DIR/test/advanced.spec.ts: `await testERC1155.mint(buyer.address, nftId, endAmount.mul(10));`
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/advanced.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Ascending offer amount (match)"}
$DIR/test/advanced.spec.ts: `await testERC1155.mint(seller.address, nftId, endAmount.mul(10));`
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/advanced.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Multiple offer components at once"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/advanced.spec.ts: `await mintAndApproveERC20(
        buyer,
        marketplaceContract.address,
        tokenAmount.mul(2)
      );`
{"Multiple consideration components at once"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/advanced.spec.ts: `await mintAndApproveERC20(
        buyer,
        marketplaceContract.address,
        tokenAmount.mul(2)
      );`
{"Multiple consideration components at once, various OOR offer/consideration items"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/advanced.spec.ts: `await mintAndApproveERC20(
        buyer,
        marketplaceContract.address,
        tokenAmount.mul(2)
      );`
{"ERC1155 <=> ETH (match, two different 1155 contracts)"}
$DIR/test/advanced.spec.ts: `await testERC1155Two.mint(seller.address, secondNftId, secondAmount);`
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
{"ERC1155 <=> ETH (match, one single and one with two 1155's)"}
$DIR/test/advanced.spec.ts: `await testERC1155Two.mint(seller.address, secondNftId, secondAmount);`
{"ERC1155 <=> ETH (match, two different groups of 1155's)"}
$DIR/test/advanced.spec.ts: `await testERC1155Two.mint(seller.address, secondNftId, secondAmount);`
$DIR/test/advanced.spec.ts: `await testERC1155Two.mint(seller.address, fourthNftId, fourthAmount);`
{"Can fulfill and aggregate multiple orders via fulfillAvailableAdvancedOrders including restricted orders"}
$DIR/test/advanced.spec.ts: `orderOne.extraData = ethers.utils.defaultAbiCoder.encode(
        ["bytes32[]"],
        [[orderHashOne, orderHashTwo]]
      );`
{"Can fulfill and aggregate multiple orders via fulfillAvailableOrders with failing orders"}
$DIR/test/advanced.spec.ts: `await withBalanceChecks([orderFour], 0, undefined, async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillOrder(orderFour, toKey(0), {
            value,
          });
        const receipt = await (await tx).wait();
        await checkExpectedEvents(tx, receipt, [
          {
            order: orderFour,
            orderHash: orderHashFour,
            fulfiller: buyer.address,
          },
        ]);

        return receipt;
      });`
{"Can fulfill and aggregate multiple orders via fulfillAvailableAdvancedOrders with failing orders"}
$DIR/test/advanced.spec.ts: `await withBalanceChecks([orderFour], 0, undefined, async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillOrder(orderFour, toKey(0), {
            value,
          });
        const receipt = await (await tx).wait();
        await checkExpectedEvents(tx, receipt, [
          {
            order: orderFour,
            orderHash: orderHashFour,
            fulfiller: buyer.address,
          },
        ]);

        return receipt;
      });`
{"Can fulfill and aggregate multiple orders via fulfillAvailableAdvancedOrders with failing components including criteria"}
$DIR/test/advanced.spec.ts: `await testERC721.mint(seller.address, criteriaNftId);`
$DIR/test/advanced.spec.ts: `await testERC721.mint(seller.address, secondCriteriaNFTId);`
$DIR/test/advanced.spec.ts: `await testERC721.mint(seller.address, thirdCriteriaNFTId);`
$DIR/test/advanced.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
{"Return unspent offer items to caller"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
{"Return unspent offer items to specified recipient"}
$DIR/test/advanced.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
{"Contract Orders (standard)"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Contract Orders (offer extended)"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.parse(JSON.stringify(order))`
$DIR/test/advanced.spec.ts: `.stringify(order)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            orderWithoutOffer,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Contract Orders (offer amount increased)"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.parse(JSON.stringify(order))`
$DIR/test/advanced.spec.ts: `.stringify(order)`
$DIR/test/advanced.spec.ts: `.startAmount.sub(1)`
$DIR/test/advanced.spec.ts: `.endAmount.sub(1)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            orderWithSmallerOfferAmount,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Contract Orders (criteria-based offer item: ERC1155 wildcard)"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.parse(JSON.stringify(order))`
$DIR/test/advanced.spec.ts: `.stringify(order)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            orderWithCriteriaOffer,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Contract Orders (criteria-based offer item: ERC1155 non-wildcard)"}
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.parse(JSON.stringify(order))`
$DIR/test/advanced.spec.ts: `.stringify(order)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            orderWithCriteriaOffer,
            criteriaResolvers,
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(
          orderHash
        )`
{"Contract Orders (offer extended with supplied offer)"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.parse(JSON.stringify(order))`
$DIR/test/advanced.spec.ts: `.stringify(order)`
$DIR/test/advanced.spec.ts: `.startAmount.div(2)`
$DIR/test/advanced.spec.ts: `.endAmount.div(2)`
$DIR/test/advanced.spec.ts: `.startAmount.div(2)`
$DIR/test/advanced.spec.ts: `.endAmount.div(2)`
$DIR/test/advanced.spec.ts: `.parameters.offer.push(order.parameters.offer[0])`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.extendAvailable()`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
          orderWithSmallerOffer,
          [],
          toKey(0),
          ethers.constants.AddressZero,
          {
            value,
          }
        )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Contract Orders (consideration reduced)"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.parse(JSON.stringify(order))`
$DIR/test/advanced.spec.ts: `.stringify(order)`
$DIR/test/advanced.spec.ts: `.parameters.consideration.push(
        JSON.parse(
          JSON.stringify(
            orderWithExtraConsideration.parameters.consideration[0]
          )
        )
      )`
$DIR/test/advanced.spec.ts: `.parse(
          JSON.stringify(
            orderWithExtraConsideration.parameters.consideration[0]
          )
        )`
$DIR/test/advanced.spec.ts: `.stringify(
            orderWithExtraConsideration.parameters.consideration[0]
          )`
$DIR/test/advanced.spec.ts: `.padEnd(42, "1")`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            orderWithExtraConsideration,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Contract Orders (consideration amount reduced)"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.parse(JSON.stringify(order))`
$DIR/test/advanced.spec.ts: `.stringify(order)`
$DIR/test/advanced.spec.ts: `.startAmount.add(1)`
$DIR/test/advanced.spec.ts: `.endAmount.add(1)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            orderWithIncreasedConsideration,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Contract Orders (criteria-based consideration item)"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.parse(JSON.stringify(order))`
$DIR/test/advanced.spec.ts: `.stringify(order)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            orderWithCriteriaConsideration,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Contract Orders (native token offer items)"}
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Reverts on contract orders where offer endAmount is greater than offer amount (branch 2)"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.amount.add(1)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on contract orders where offer itemType is different from generated itemType"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on contract orders where offer token address is different from generated token address"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on contract orders where offer identifier is different from generated identifier"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.identifier.add(1)`
{"Reverts on contract orders where consideration itemType is different from generated itemType"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on contract orders where consideration token address is different from generated token address"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on contract orders where consideration identifier is different from generated identifier"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.identifier.add(1)`
{"Reverts on contract orders where consideration recipient is different from generated recipient"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on contract orders where consideration is omitted"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.parse(JSON.stringify(order))`
$DIR/test/advanced.spec.ts: `.stringify(order)`
{"Reverts on contract orders where offer and consideration omitted"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.parse(
        JSON.stringify(order)
      )`
$DIR/test/advanced.spec.ts: `.stringify(order)`
{"Reverts on contract orders where offer is reduced by contract offerer"}
$DIR/test/advanced.spec.ts: `.mint(seller.address, secondNftId, secondAmount)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.parse(JSON.stringify(order))`
$DIR/test/advanced.spec.ts: `.stringify(order)`
$DIR/test/advanced.spec.ts: `.parameters.offer.push(
        JSON.parse(JSON.stringify(orderWithExtraOffer.parameters.offer[0]))
      )`
$DIR/test/advanced.spec.ts: `.parse(JSON.stringify(orderWithExtraOffer.parameters.offer[0]))`
$DIR/test/advanced.spec.ts: `.stringify(orderWithExtraOffer.parameters.offer[0])`
{"Reverts on contract orders where consideration is extended by contract offerer"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.extendRequired()`
{"Reverts on contract orders where offer amount is reduced by contract offerer"}
$DIR/test/advanced.spec.ts: `.mint(seller.address, secondNftId, secondAmount)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.startAmount.add(1)`
$DIR/test/advanced.spec.ts: `.startAmount.add(1)`
{"Reverts on contract orders where consideration amount is increased by contract offerer"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.startAmount.sub(1)`
$DIR/test/advanced.spec.ts: `.endAmount.sub(1)`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on contract orders that supply a bad fraction"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on contract orders that supply a bad fraction (numerator != 1)"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on contract orders where call to generateOrders throws and reverts aren't skipped"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.startAmount.sub(1)`
$DIR/test/advanced.spec.ts: `.endAmount.sub(1)`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          invalidContractOfferer.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(order, [], toKey(0), buyer.address, {
            value,
          })`
{"Reverts on contract orders where call to generateOrders throws and reverts are skipped"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.startAmount.sub(1)`
$DIR/test/advanced.spec.ts: `.endAmount.sub(1)`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableOrders(
            orders,
            offerComponents,
            considerationComponents,
            toKey(0),
            100,
            {
              value,
            }
          )`
{"Reverts on contract orders where call to ratifyOrders returns incorrect magic value"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          invalidContractOffererRatifyOrder.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on contract orders where consideration length does not match totalOriginalConsiderationItems"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offer[0], consideration[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.parse(
        JSON.stringify(order)
      )`
$DIR/test/advanced.spec.ts: `.stringify(order)`
{"Can fulfill and aggregate contract orders via fulfillAvailableAdvancedOrders with failing orders due to reverts"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offerOne[0], considerationOne[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContractOne.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.utils.defaultAbiCoder.encode(
        ["bytes32[]"],
        [[orderHashOne, ethers.constants.HashZero]]
      )`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offerTwo[0], considerationTwo[0])`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableAdvancedOrders(
            [orderOne, orderTwo],
            [],
            offerComponents,
            considerationComponents,
            toKey(0),
            ethers.constants.AddressZero,
            100,
            {
              value: value.add(valueTwo).mul(2),
            }
          )`
$DIR/test/advanced.spec.ts: `.add(valueTwo)`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.wait()`
{"Cannot fulfill and aggregate contract orders via fulfillAvailableAdvancedOrders with failing orders due to bad data"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offerOne[0], considerationOne[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContractOne.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.utils.defaultAbiCoder.encode(
        ["bytes32[]"],
        [
          [
            orderHashOne,
            ethers.constants.HashZero,
            ethers.constants.HashZero,
            ethers.constants.HashZero,
          ],
        ]
      )`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offerTwo[0], considerationTwo[0])`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offerThree[0], considerationThree[0])`
$DIR/test/advanced.spec.ts: `.getContractOffererNonce(
          offererContractThree.address
        )`
$DIR/test/advanced.spec.ts: `.address.toLowerCase()`
$DIR/test/advanced.spec.ts: `.toHexString()`
$DIR/test/advanced.spec.ts: `.slice(2)`
$DIR/test/advanced.spec.ts: `.padStart(24, "0")`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.connect(seller)`
$DIR/test/advanced.spec.ts: `.activate(offerFour[0], considerationFour[0])`
$DIR/test/advanced.spec.ts: `.startAmount.sub(1)`
$DIR/test/advanced.spec.ts: `.endAmount.sub(1)`
{"Partial fills (standard)"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(20)`
$DIR/test/advanced.spec.ts: `.mul(20)`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.entries(ordersClone)`
$DIR/test/advanced.spec.ts: `.entries(
          clonedOrder.parameters.offer
        )`
$DIR/test/advanced.spec.ts: `.entries(
          clonedOrder.parameters.consideration
        )`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Partial fills (standard, additional permutations)"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(20)`
$DIR/test/advanced.spec.ts: `.mul(20)`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.entries(ordersClone)`
$DIR/test/advanced.spec.ts: `.entries(
          clonedOrder.parameters.offer
        )`
$DIR/test/advanced.spec.ts: `.entries(
          clonedOrder.parameters.consideration
        )`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Partial fills (match)"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(20)`
$DIR/test/advanced.spec.ts: `.mul(20)`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchAdvancedOrders(
        [order, mirrorObject.mirrorOrder],
        [], // no criteria resolvers
        fulfillments,
        ethers.constants.AddressZero,
        {
          value,
        }
      )`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchAdvancedOrders(
        [order, mirrorObject.mirrorOrder],
        [], // no criteria resolvers
        fulfillments,
        ethers.constants.AddressZero,
        {
          value,
        }
      )`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchAdvancedOrders(
        [order, mirrorObject.mirrorOrder],
        [], // no criteria resolvers
        fulfillments,
        ethers.constants.AddressZero,
        {
          value,
        }
      )`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Simplifies fraction when numerator/denominator would overflow"}
$DIR/test/advanced.spec.ts: `.pow(50)`
$DIR/test/advanced.spec.ts: `.pow(51)`
$DIR/test/advanced.spec.ts: `.pow(20)`
$DIR/test/advanced.spec.ts: `.pow(22)`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(order, [], toKey(0), buyer.address, {
            value,
          })`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(order, [], toKey(0), buyer.address, {
          value,
        })`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts when numerator/denominator overflow"}
$DIR/test/advanced.spec.ts: `.pow(7)`
$DIR/test/advanced.spec.ts: `.sub(1)`
$DIR/test/advanced.spec.ts: `.pow(61)`
$DIR/test/advanced.spec.ts: `.sub(1)`
$DIR/test/advanced.spec.ts: `.pow(107)`
$DIR/test/advanced.spec.ts: `.sub(1)`
$DIR/test/advanced.spec.ts: `.mul(prime2)`
$DIR/test/advanced.spec.ts: `.mul(prime3)`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(order, [], toKey(0), buyer.address, {
            value,
          })`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Criteria-based offer item ERC721 (standard)"}
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            criteriaResolvers,
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Criteria-based offer item ERC1155 (standard)"}
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            criteriaResolvers,
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Criteria-based offer item (standard, collection-level)"}
$DIR/test/advanced.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/advanced.spec.ts: `.mint(seller.address, secondNFTId)`
$DIR/test/advanced.spec.ts: `.mint(seller.address, thirdNFTId)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            criteriaResolvers,
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Criteria-based offer item ERC721 (match)"}
$DIR/test/advanced.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/advanced.spec.ts: `.mint(seller.address, secondNFTId)`
$DIR/test/advanced.spec.ts: `.mint(seller.address, thirdNFTId)`
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchAdvancedOrders(
          [order, mirrorOrder],
          criteriaResolvers,
          fulfillments,
          ethers.constants.AddressZero,
          {
            value,
          }
        )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Criteria-based offer item ERC1155 (match)"}
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchAdvancedOrders(
          [order, mirrorOrder],
          criteriaResolvers,
          fulfillments,
          ethers.constants.AddressZero,
          {
            value,
          }
        )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Criteria-based offer item (match, collection-level)"}
$DIR/test/advanced.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/advanced.spec.ts: `.mint(seller.address, secondNFTId)`
$DIR/test/advanced.spec.ts: `.mint(seller.address, thirdNFTId)`
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchAdvancedOrders(
          [order, mirrorOrder],
          criteriaResolvers,
          fulfillments,
          ethers.constants.AddressZero,
          {
            value,
          }
        )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Criteria-based consideration item (standard)"}
$DIR/test/advanced.spec.ts: `.mint(buyer.address, nftId)`
$DIR/test/advanced.spec.ts: `.mint(buyer.address, secondNFTId)`
$DIR/test/advanced.spec.ts: `.mint(buyer.address, thirdNFTId)`
$DIR/test/advanced.spec.ts: `.mul(-1)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
              order,
              criteriaResolvers,
              toKey(0),
              ethers.constants.AddressZero,
              {
                value,
              }
            )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Criteria-based consideration item ERC1155 (standard)"}
$DIR/test/advanced.spec.ts: `.mul(-1)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
              order,
              criteriaResolvers,
              toKey(0),
              ethers.constants.AddressZero,
              {
                value,
              }
            )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Criteria-based wildcard consideration item (standard)"}
$DIR/test/advanced.spec.ts: `.mul(-1)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
              order,
              criteriaResolvers,
              toKey(0),
              ethers.constants.AddressZero,
              {
                value,
              }
            )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Criteria-based consideration item ERC721 (match)"}
$DIR/test/advanced.spec.ts: `.sub(100)`
$DIR/test/advanced.spec.ts: `.sub(100)`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchAdvancedOrders(
          [order, mirrorOrder],
          criteriaResolvers,
          fulfillments,
          ethers.constants.AddressZero,
          {
            value,
          }
        )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Criteria-based consideration item ERC1155 (match)"}
$DIR/test/advanced.spec.ts: `.sub(100)`
$DIR/test/advanced.spec.ts: `.sub(100)`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchAdvancedOrders(
          [order, mirrorOrder],
          criteriaResolvers,
          fulfillments,
          ethers.constants.AddressZero,
          {
            value,
          }
        )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can sign for a bulk signature"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(20)`
$DIR/test/advanced.spec.ts: `.mul(20)`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can sign for a bulk signature with index 9 in 32 node tree"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(20)`
$DIR/test/advanced.spec.ts: `.mul(20)`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can sign for a compact bulk signature"}
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(1000)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.mul(20)`
$DIR/test/advanced.spec.ts: `.mul(20)`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Ascending offer amount (standard)"}
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mint(seller.address, nftId, endAmount.mul(10))`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Ascending consideration amount (standard)"}
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mint(buyer.address, nftId, endAmount.mul(10))`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Ascending offer amount (match)"}
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mint(seller.address, nftId, endAmount.mul(10))`
$DIR/test/advanced.spec.ts: `.mul(10)`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.getOrderStatus(orderHash)`
{"Match A => B => C => A"}
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchAdvancedOrders(
          [orderOne, orderTwo, orderThree],
          [],
          fulfillments,
          ethers.constants.AddressZero,
          {
            value: 0,
          }
        )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Does not filter native tokens"}
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Multiple offer components at once"}
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.matchAdvancedOrders(
          [orderOne, orderTwo, orderThree],
          [],
          fulfillments,
          ethers.constants.AddressZero,
          {
            value: 0,
          }
        )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Multiple consideration components at once"}
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.matchAdvancedOrders(
          [orderOne, orderTwo, orderThree],
          [],
          fulfillments,
          ethers.constants.AddressZero,
          {
            value: 0,
          }
        )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Multiple consideration components at once, various OOR offer/consideration items"}
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.matchAdvancedOrders(
          [orderOne, orderTwo, orderThree],
          [],
          fulfillments,
          ethers.constants.AddressZero,
          {
            value: 0,
          }
        )`
$DIR/test/advanced.spec.ts: `.wait()`
{"ERC1155 <=> ETH (match)"}
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/advanced.spec.ts: `.wait()`
{"ERC1155 <=> ETH (match, three items)"}
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/advanced.spec.ts: `.wait()`
{"ERC1155 <=> ETH (match, initial OOR offer/consideration items skipped)"}
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/advanced.spec.ts: `.wait()`
{"ERC1155 <=> ETH (match, subsequent OOR offer/consideration items skipped)"}
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/advanced.spec.ts: `.wait()`
{"ERC1155 <=> ETH (match, offer aggregation skipped if no available consideration items)"}
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/advanced.spec.ts: `.wait()`
{"ERC1155 <=> ETH (match via conduit)"}
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/advanced.spec.ts: `.wait()`
{"ERC1155 <=> ETH (match, single item)"}
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/advanced.spec.ts: `.wait()`
{"ERC1155 <=> ETH (match, single 1155)"}
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/advanced.spec.ts: `.wait()`
{"ERC1155 <=> ETH (match, two different 1155 contracts)"}
$DIR/test/advanced.spec.ts: `.mint(seller.address, secondNftId, secondAmount)`
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
{"ERC1155 <=> ETH (match, one single and one with two 1155's)"}
$DIR/test/advanced.spec.ts: `.mint(seller.address, secondNftId, secondAmount)`
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
{"ERC1155 <=> ETH (match, two different groups of 1155's)"}
$DIR/test/advanced.spec.ts: `.mint(seller.address, secondNftId, secondAmount)`
$DIR/test/advanced.spec.ts: `.mint(seller.address, fourthNftId, fourthAmount)`
$DIR/test/advanced.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/advanced.spec.ts: `.connect(owner)`
{"Can fulfill a single order via fulfillAvailableOrders"}
$DIR/test/advanced.spec.ts: `.map(
        toFulfillmentComponents
      )`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableOrders(
            [order],
            offerComponents,
            considerationComponents,
            toKey(0),
            100,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can fulfill a single order via fulfillAvailableAdvancedOrders"}
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableAdvancedOrders(
            [order],
            [],
            offerComponents,
            considerationComponents,
            toKey(0),
            ethers.constants.AddressZero,
            100,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can fulfill a single order via fulfillAvailableAdvancedOrders with recipient specified"}
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableAdvancedOrders(
            [order],
            [],
            offerComponents,
            considerationComponents,
            toKey(0),
            owner.address,
            100,
            {
              value,
            }
          )`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can fulfill and aggregate multiple orders via fulfillAvailableOrders"}
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.map(toFulfillmentComponents)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableOrders(
              [orderOne, orderTwo],
              offerComponents,
              considerationComponents,
              toKey(0),
              100,
              {
                value: value.mul(2),
              }
            )`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can fulfill and aggregate multiple orders via fulfillAvailableAdvancedOrders including restricted orders"}
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.utils.defaultAbiCoder.encode(
        ["bytes32[]"],
        [[orderHashOne, orderHashTwo]]
      )`
$DIR/test/advanced.spec.ts: `.map(toFulfillmentComponents)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableAdvancedOrders(
              [orderOne, orderTwo],
              [],
              offerComponents,
              considerationComponents,
              toKey(0),
              ethers.constants.AddressZero,
              100,
              {
                value: value.mul(2),
              }
            )`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can fulfill and aggregate multiple orders via fulfillAvailableOrders with OOR offer / consideration items"}
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.map(toFulfillmentComponents)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableOrders(
              [orderOne, orderTwo],
              offerComponents,
              considerationComponents,
              toKey(0),
              100,
              {
                value: value.mul(2),
              }
            )`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can fulfill and aggregate multiple orders via fulfillAvailableOrders with OOR initial offer / consideration items"}
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.map(toFulfillmentComponents)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableOrders(
              [orderOne, orderTwo],
              offerComponents,
              considerationComponents,
              toKey(0),
              100,
              {
                value: value.mul(2),
              }
            )`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can fulfill and aggregate multiple orders via fulfillAvailableAdvancedOrders"}
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.map(toFulfillmentComponents)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableAdvancedOrders(
              [orderOne, orderTwo],
              [],
              offerComponents,
              considerationComponents,
              toKey(0),
              ethers.constants.AddressZero,
              100,
              {
                value: value.mul(2),
              }
            )`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can fulfill and aggregate a max number of multiple orders via fulfillAvailableOrders"}
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.callStatic.fulfillAvailableOrders(
              [orderOne, orderTwo],
              offerComponents,
              considerationComponents,
              toKey(0),
              1,
              {
                value: value.mul(2),
              }
            )`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableOrders(
              [orderOne, orderTwo],
              offerComponents,
              considerationComponents,
              toKey(0),
              1,
              {
                value: value.mul(2),
              }
            )`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can fulfill and aggregate a max number of multiple orders via fulfillAvailableAdvancedOrders"}
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableAdvancedOrders(
              [orderOne, orderTwo],
              [],
              offerComponents,
              considerationComponents,
              toKey(0),
              ethers.constants.AddressZero,
              1,
              {
                value: value.mul(2),
              }
            )`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can fulfill and aggregate multiple orders via fulfillAvailableOrders with failing orders"}
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillOrder(orderFour, toKey(0), {
            value,
          })`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableOrders(
            [orderOne, orderTwo, orderThree, orderFour],
            offerComponents,
            considerationComponents,
            toKey(0),
            100,
            {
              value: value.mul(4),
            }
          )`
$DIR/test/advanced.spec.ts: `.mul(4)`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can fulfill and aggregate multiple orders via fulfillAvailableAdvancedOrders with failing orders"}
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.div(2)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillOrder(orderFour, toKey(0), {
            value,
          })`
$DIR/test/advanced.spec.ts: `.wait()`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableAdvancedOrders(
            [orderOne, orderTwo, orderThree, orderFour],
            [],
            offerComponents,
            considerationComponents,
            toKey(0),
            ethers.constants.AddressZero,
            100,
            {
              value: value.mul(4),
            }
          )`
$DIR/test/advanced.spec.ts: `.mul(4)`
$DIR/test/advanced.spec.ts: `.wait()`
{"Can fulfill and aggregate multiple orders via fulfillAvailableAdvancedOrders with failing components including criteria"}
$DIR/test/advanced.spec.ts: `.mint(seller.address, criteriaNftId)`
$DIR/test/advanced.spec.ts: `.mint(seller.address, secondCriteriaNFTId)`
$DIR/test/advanced.spec.ts: `.mint(seller.address, thirdCriteriaNFTId)`
$DIR/test/advanced.spec.ts: `.connect(buyer)`
$DIR/test/advanced.spec.ts: `.fulfillAvailableAdvancedOrders(
            [orderOne, orderTwo],
            criteriaResolvers,
            offerComponents,
            considerationComponents,
            toKey(0),
            ethers.constants.AddressZero,
            100,
            {
              value: value.mul(2),
            }
          )`
$DIR/test/advanced.spec.ts: `.mul(2)`
$DIR/test/advanced.spec.ts: `.wait()`
{"Return unspent offer items to caller"}
$DIR/test/advanced.spec.ts: `.getCounter(buyer.address)`
$DIR/test/advanced.spec.ts: `.sub(unspentAmount)`
$DIR/test/advanced.spec.ts: `.sub(unspentAmount)`
$DIR/test/advanced.spec.ts: `.padEnd(66, "0")`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/advanced.spec.ts: `.wait()`
{"Return unspent offer items to specified recipient"}
$DIR/test/advanced.spec.ts: `.getCounter(buyer.address)`
$DIR/test/advanced.spec.ts: `.sub(unspentAmount)`
$DIR/test/advanced.spec.ts: `.sub(unspentAmount)`
$DIR/test/advanced.spec.ts: `.padEnd(66, "0")`
$DIR/test/advanced.spec.ts: `.connect(owner)`
$DIR/test/advanced.spec.ts: `.matchAdvancedOrders(
          [order, mirrorOrder],
          [],
          fulfillments,
          seller.address,
          {
            value,
          }
        )`
$DIR/test/advanced.spec.ts: `.wait()`
{"ERC721 <=> ETH (standard with tip)"}
$DIR/test/basic.spec.ts: `order.parameters.consideration.push(
          getItemETH(parseEther("1"), parseEther("1"), owner.address)
        );`
{"ERC721 <=> ETH (standard with restricted order and extra data)"}
$DIR/test/basic.spec.ts: `order.extraData = "0x1234";`
{"ERC721 <=> ETH (standard with restricted order, specified recipient and extra data)"}
$DIR/test/basic.spec.ts: `order.extraData = "0x1234";`
{"ERC721 <=> ETH (basic with tips)"}
$DIR/test/basic.spec.ts: `order.parameters.consideration.push(
          getItemETH(
            parseEther("2"),
            parseEther("2"),
            "0x0000000000000000000000000000000000000001"
          )
        );`
$DIR/test/basic.spec.ts: `order.parameters.consideration.push(
          getItemETH(
            parseEther("3"),
            parseEther("3"),
            "0x0000000000000000000000000000000000000002"
          )
        );`
$DIR/test/basic.spec.ts: `order.parameters.consideration.push(
          getItemETH(
            parseEther("4"),
            parseEther("4"),
            "0x0000000000000000000000000000000000000003"
          )
        );`
{"ERC721 <=> ETH (basic with partial restricted order)"}
$DIR/test/basic.spec.ts: `await testERC721.mint(seller.address, nftId);`
{"ERC721 <=> ETH (basic, EIP-2098 signature)"}
$DIR/test/basic.spec.ts: `order.signature = convertSignatureToEIP2098(order.signature);`
{"ERC721 <=> ERC20 (standard)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ERC20 (standard via conduit)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ERC20 (basic)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ERC20 (basic via conduit)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ERC20 (basic, EIP-1271 signature)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ERC20 (EIP-1271 signature on non-ECDSA 64 bytes)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ERC20 (EIP-1271 signature on non-ECDSA 65 bytes)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
$DIR/test/basic.spec.ts: `await sellerContract.registerDigest(digest, true);`
$DIR/test/basic.spec.ts: `await withBalanceChecks([order], 0, undefined, async () => {
          const tx = marketplaceContract
            .connect(buyer)
            .fulfillBasicOrder(basicOrderParameters);
          const receipt = await (await tx).wait();
          await checkExpectedEvents(tx, receipt, [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
            },
          ]);

          return receipt;
        });`
{"ERC721 <=> ERC20 (basic, EIP-1271 signature w/ non-standard length)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
$DIR/test/basic.spec.ts: `await sellerContract.connect(seller).registerDigest(digest, true);`
{"ERC721 <=> ERC20 (match)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ERC20 (match via conduit)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ERC20 (standard)"}
$DIR/test/basic.spec.ts: `await set721ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ETH (restricted order checked post-execution)"}
$DIR/test/basic.spec.ts: `await set721ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
$DIR/test/basic.spec.ts: `order.extraData = "0x1234";`
{"ERC721 <=> ERC20 (standard, via conduit)"}
$DIR/test/basic.spec.ts: `await set721ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(seller, conduitOne.address, tokenAmount);`
{"ERC721 <=> ERC20 (standard, fulfilled via conduit)"}
$DIR/test/basic.spec.ts: `await set721ApprovalForAll(buyer, conduitOne.address, true);`
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ERC20 (basic)"}
$DIR/test/basic.spec.ts: `await set721ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ETH (basic simple with restricted order checked post-execution)"}
$DIR/test/basic.spec.ts: `await set721ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ETH (basic with restricted order checked post-execution and tips)"}
$DIR/test/basic.spec.ts: `await set721ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
$DIR/test/basic.spec.ts: `order.parameters.consideration.push(
          getTestItem20(50, 50, zone.address)
        );`
$DIR/test/basic.spec.ts: `basicOrderParameters.totalOriginalAdditionalRecipients = toBN(0);`
{"ERC721 <=> ETH (basic with restricted order checked post-execution)"}
$DIR/test/basic.spec.ts: `await set721ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ERC20 (basic, many via conduit)"}
$DIR/test/basic.spec.ts: `await set721ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(seller, conduitOne.address, tokenAmount);`
$DIR/test/basic.spec.ts: `consideration.push(getTestItem20(i, i, toAddress(i + 10000)));`
{"ERC721 <=> ERC20 (basic, fulfilled via conduit)"}
$DIR/test/basic.spec.ts: `await set721ApprovalForAll(buyer, conduitOne.address, true);`
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ERC20 (match)"}
$DIR/test/basic.spec.ts: `await set721ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ERC20 (restriced match checked post-execution)"}
$DIR/test/basic.spec.ts: `await set721ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
$DIR/test/basic.spec.ts: `order.extraData = "0x1234";`
{"ERC721 <=> ERC20 (match via conduit)"}
$DIR/test/basic.spec.ts: `await set721ApprovalForAll(buyer, conduitOne.address, true);`
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC1155 <=> ERC20 (standard)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC1155 <=> ERC20 (standard via conduit)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC1155 <=> ERC20 (basic)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC1155 <=> ERC20 (basic via conduit)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC1155 <=> ERC20 (match)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC1155 <=> ERC20 (match via conduit)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          buyer,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC1155 <=> ERC20 (standard)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC1155 <=> ERC20 (standard, fulfilled via conduit)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC1155 <=> ERC20 (basic)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC1155 <=> ERC20 (basic, fulfilled via conduit)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC1155 <=> ERC20 (match)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC1155 <=> ERC20 (match via conduit)"}
$DIR/test/basic.spec.ts: `await mintAndApproveERC20(
          seller,
          marketplaceContract.address,
          tokenAmount
        );`
{"ERC721 <=> ETH (standard)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0), {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (standard via conduit)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0), {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (standard with tip)"}
$DIR/test/basic.spec.ts: `.parameters.consideration.push(
          getItemETH(parseEther("1"), parseEther("1"), owner.address)
        )`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0), {
              value: value.add(parseEther("1")),
            })`
$DIR/test/basic.spec.ts: `.add(parseEther("1"))`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (standard with restricted order)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0), {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (standard with restricted order and extra data)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillAdvancedOrder(
              order,
              [],
              toKey(0),
              ethers.constants.AddressZero,
              {
                value,
              }
            )`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (standard with restricted order, specified recipient and extra data)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillAdvancedOrder(order, [], toKey(0), owner.address, {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic, minimal and listed off-chain)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic, minimal and listed off-chain, efficient endpoint)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder_efficient_6GL6yc(basicOrderParameters, {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic, minimal and verified on-chain)"}
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.validate([order])`
$DIR/test/basic.spec.ts: `.wait()`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic, minimal and verified on-chain, efficient endpoint)"}
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.validate([order])`
$DIR/test/basic.spec.ts: `.wait()`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder_efficient_6GL6yc(basicOrderParameters, {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (standard, minimal and listed off-chain)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0), {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (standard, minimal and verified on-chain)"}
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.validate([order])`
$DIR/test/basic.spec.ts: `.wait()`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0), {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (advanced, minimal and listed off-chain)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillAdvancedOrder(
              order,
              [],
              toKey(0),
              ethers.constants.AddressZero,
              {
                value,
              }
            )`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (advanced, minimal and verified on-chain)"}
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.validate([order])`
$DIR/test/basic.spec.ts: `.wait()`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillAdvancedOrder(
              order,
              [],
              toKey(0),
              ethers.constants.AddressZero,
              {
                value,
              }
            )`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic with tips)"}
$DIR/test/basic.spec.ts: `.parameters.consideration.push(
          getItemETH(
            parseEther("2"),
            parseEther("2"),
            "0x0000000000000000000000000000000000000001"
          )
        )`
$DIR/test/basic.spec.ts: `.parameters.consideration.push(
          getItemETH(
            parseEther("3"),
            parseEther("3"),
            "0x0000000000000000000000000000000000000002"
          )
        )`
$DIR/test/basic.spec.ts: `.parameters.consideration.push(
          getItemETH(
            parseEther("4"),
            parseEther("4"),
            "0x0000000000000000000000000000000000000003"
          )
        )`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
              value: value.add(parseEther("9")),
            })`
$DIR/test/basic.spec.ts: `.add(parseEther("9"))`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic via conduit)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic with restricted order)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic with partial restricted order)"}
$DIR/test/basic.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/basic.spec.ts: `.utils.parseEther("10")`
$DIR/test/basic.spec.ts: `.utils.parseEther("10")`
$DIR/test/basic.spec.ts: `.utils.parseEther("1")`
$DIR/test/basic.spec.ts: `.utils.parseEther("1")`
$DIR/test/basic.spec.ts: `.utils.parseEther("1")`
$DIR/test/basic.spec.ts: `.utils.parseEther("1")`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters, { value })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic, already validated)"}
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.validate([order])`
$DIR/test/basic.spec.ts: `.wait()`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic, EIP-2098 signature)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic, extra ether supplied and returned to caller)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
              value: value.add(1),
            })`
$DIR/test/basic.spec.ts: `.add(1)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (match)"}
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
            value,
          })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (match via conduit)"}
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
            value,
          })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (match, extra eth supplied and returned to caller)"}
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
            value: value.add(101),
          })`
$DIR/test/basic.spec.ts: `.add(101)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (standard)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0))`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (standard via conduit)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0))`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (basic)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (basic via conduit)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (basic, EIP-1271 signature)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (EIP-1271 signature on non-ECDSA 64 bytes)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.padEnd(130, "f")`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (EIP-1271 signature on non-ECDSA 65 bytes)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.information()`
$DIR/test/basic.spec.ts: `.slice(2)`
$DIR/test/basic.spec.ts: `.slice(2)`
$DIR/test/basic.spec.ts: `.registerDigest(digest, true)`
$DIR/test/basic.spec.ts: `.padEnd(132, "f")`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (basic, EIP-1271 signature w/ non-standard length)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.information()`
$DIR/test/basic.spec.ts: `.slice(2)`
$DIR/test/basic.spec.ts: `.slice(2)`
$DIR/test/basic.spec.ts: `.connect(seller)`
$DIR/test/basic.spec.ts: `.registerDigest(digest, true)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (match)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (match via conduit)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (standard)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0))`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (restricted order checked post-execution)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillAdvancedOrder(
              order,
              [],
              toKey(0),
              ethers.constants.AddressZero
            )`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (standard, via conduit)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0))`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (standard, fulfilled via conduit)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, conduitKeyOne)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (basic)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic simple with restricted order checked post-execution)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic with restricted order checked post-execution and tips)"}
$DIR/test/basic.spec.ts: `.parameters.consideration.push(
          getTestItem20(50, 50, zone.address)
        )`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ETH (basic with restricted order checked post-execution)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (basic, many via conduit)"}
$DIR/test/basic.spec.ts: `.push(getTestItem20(i, i, toAddress(i + 10000)))`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (basic, fulfilled via conduit)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (match)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (restriced match checked post-execution)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchAdvancedOrders(
            [order, mirrorOrder],
            [],
            fulfillments,
            ethers.constants.AddressZero
          )`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC721 <=> ERC20 (match via conduit)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ETH (standard)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0), {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ETH (standard via conduit)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0), {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ETH (basic)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ETH (basic via conduit)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
              value,
            })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ETH (match)"}
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
            value,
          })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ETH (match via conduit)"}
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
            value,
          })`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ERC20 (standard)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0))`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ERC20 (standard via conduit)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0))`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ERC20 (basic)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ERC20 (basic via conduit)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ERC20 (match)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ERC20 (match via conduit)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ERC20 (standard)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, toKey(0))`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ERC20 (standard, fulfilled via conduit)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillOrder(order, conduitKeyOne)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ERC20 (basic)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ERC20 (basic, fulfilled via conduit)"}
$DIR/test/basic.spec.ts: `.connect(buyer)`
$DIR/test/basic.spec.ts: `.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ERC20 (match)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments)`
$DIR/test/basic.spec.ts: `.wait()`
{"ERC1155 <=> ERC20 (match via conduit)"}
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.sub(100)`
$DIR/test/basic.spec.ts: `.connect(owner)`
$DIR/test/basic.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments)`
$DIR/test/basic.spec.ts: `.wait()`
{"Adds a channel, and executes transfers (ERC1155 with batch)"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(tempConduit.address, seller.address, true);`
$DIR/test/conduit.spec.ts: `await testERC1155.mint(seller.address, nftId, amount.mul(2));`
$DIR/test/conduit.spec.ts: `await testERC1155.mint(seller.address, secondNftId, secondAmount.mul(2));`
$DIR/test/conduit.spec.ts: `await set1155ApprovalForAll(seller, tempConduit.address, true);`
{"Adds a channel, and executes only batch transfers (ERC1155 with batch)"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(tempConduit.address, seller.address, true);`
$DIR/test/conduit.spec.ts: `await testERC1155.mint(seller.address, nftId, amount.mul(2));`
$DIR/test/conduit.spec.ts: `await testERC1155.mint(seller.address, secondNftId, secondAmount.mul(2));`
$DIR/test/conduit.spec.ts: `await set1155ApprovalForAll(seller, tempConduit.address, true);`
{"Adds a channel, and executes transfers (ERC721)"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(tempConduit.address, seller.address, true);`
$DIR/test/conduit.spec.ts: `await testERC721.mint(seller.address, nftId);`
$DIR/test/conduit.spec.ts: `await testERC721.mint(seller.address, secondNftId);`
$DIR/test/conduit.spec.ts: `await tempConduit.connect(seller).execute([
      {
        itemType: 2, // ERC721
        token: testERC721.address,
        from: seller.address,
        to: buyer.address,
        identifier: nftId,
        amount: ethers.BigNumber.from(1),
      },
      {
        itemType: 2, // ERC721
        token: testERC721.address,
        from: seller.address,
        to: buyer.address,
        identifier: secondNftId,
        amount: ethers.BigNumber.from(1),
      },
    ]);`
{"Adds a channel, and executes transfers (ERC721 + ERC20)"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(tempConduit.address, seller.address, true);`
$DIR/test/conduit.spec.ts: `await testERC721.mint(seller.address, nftId);`
$DIR/test/conduit.spec.ts: `await testERC20.mint(seller.address, tokenAmount);`
$DIR/test/conduit.spec.ts: `await tempConduit.connect(seller).execute([
      {
        itemType: 2, // ERC721
        token: testERC721.address,
        from: seller.address,
        to: buyer.address,
        identifier: nftId,
        amount: ethers.BigNumber.from(1),
      },
      {
        itemType: 1, // ERC20
        token: testERC20.address,
        from: seller.address,
        to: buyer.address,
        identifier: 0,
        amount: tokenAmount.sub(100),
      },
    ]);`
{"Adds a channel, and executes transfers (ERC721 + ERC1155)"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(tempConduit.address, seller.address, true);`
$DIR/test/conduit.spec.ts: `await testERC721.mint(seller.address, nftId);`
$DIR/test/conduit.spec.ts: `await testERC1155.mint(seller.address, secondNftId, amount);`
$DIR/test/conduit.spec.ts: `await tempConduit.connect(seller).execute([
      {
        itemType: 2, // ERC721
        token: testERC721.address,
        from: seller.address,
        to: buyer.address,
        identifier: nftId,
        amount: ethers.BigNumber.from(1),
      },
      {
        itemType: 3, // ERC1155
        token: testERC1155.address,
        from: seller.address,
        to: buyer.address,
        identifier: secondNftId,
        amount: amount.sub(10),
      },
    ]);`
{"Adds a channel, and executes transfers (ERC20 + ERC1155)"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(tempConduit.address, seller.address, true);`
$DIR/test/conduit.spec.ts: `await testERC20.mint(seller.address, tokenAmount);`
$DIR/test/conduit.spec.ts: `await testERC1155.mint(seller.address, nftId, erc1155amount);`
$DIR/test/conduit.spec.ts: `await tempConduit.connect(seller).execute([
      {
        itemType: 1, // ERC20
        token: testERC20.address,
        from: seller.address,
        to: buyer.address,
        identifier: 0,
        amount: tokenAmount.sub(100),
      },
      {
        itemType: 3, // ERC1155
        token: testERC1155.address,
        from: seller.address,
        to: buyer.address,
        identifier: nftId,
        amount: erc1155amount.sub(10),
      },
    ]);`
{"Adds a channel, and executes transfers (ERC20 + ERC721 + ERC1155)"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(tempConduit.address, seller.address, true);`
$DIR/test/conduit.spec.ts: `await tempConduit
      .connect(seller)
      .execute([erc20Transfer, erc721Transfer, erc1155Transfer]);`
{"Adds a channel, and executes transfers (many token types)"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(tempConduit.address, seller.address, true);`
$DIR/test/conduit.spec.ts: `erc20Contracts[i] = tempERC20Contract;`
$DIR/test/conduit.spec.ts: `erc20Transfers[i] = erc20Transfer;`
$DIR/test/conduit.spec.ts: `erc721Contracts[i] = tempERC721Contract;`
$DIR/test/conduit.spec.ts: `erc721Transfers[i] = erc721Transfer;`
$DIR/test/conduit.spec.ts: `erc1155Contracts[i] = tempERC1155Contract;`
$DIR/test/conduit.spec.ts: `erc1155Transfers[i] = erc1155Transfer;`
$DIR/test/conduit.spec.ts: `await tempConduit.connect(seller).execute(transfers);`
{"Reverts on calls to batch transfer 1155 items with no contract on a conduit"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(tempConduit.address, owner.address, true);`
$DIR/test/conduit.spec.ts: `await set1155ApprovalForAll(owner, tempConduit.address, true);`
{"Reverts on calls to only batch transfer 1155 items with no contract on a conduit"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(tempConduit.address, owner.address, true);`
$DIR/test/conduit.spec.ts: `await set1155ApprovalForAll(owner, tempConduit.address, true);`
{"ERC1155 batch transfer reverts with revert data if it has sufficient gas"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(tempConduit.address, seller.address, true);`
{"ERC1155 batch transfer sends no data"}
$DIR/test/conduit.spec.ts: `await conduitController
        .connect(owner)
        .updateChannel(tempConduit.address, seller.address, true);`
$DIR/test/conduit.spec.ts: `await testERC1155.mint(seller.address, nftId, amount.mul(2));`
$DIR/test/conduit.spec.ts: `await testERC1155.mint(seller.address, secondNftId, secondAmount.mul(2));`
$DIR/test/conduit.spec.ts: `await testERC1155.mint(seller.address, thirdNftId, thirdAmount.mul(2));`
$DIR/test/conduit.spec.ts: `await set1155ApprovalForAll(seller, tempConduit.address, true);`
{"ERC1155 batch transfer reverts with generic error if it has insufficient gas to copy revert data"}
$DIR/test/conduit.spec.ts: `await conduitController
        .connect(owner)
        .updateChannel(tempConduit.address, seller.address, true);`
{"Makes batch transfer 1155 items through a conduit"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .createConduit(tempConduitKey, owner.address);`
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(tempConduit.address, owner.address, true);`
$DIR/test/conduit.spec.ts: `await set1155ApprovalForAll(owner, tempConduit.address, true);`
{"Performs complex batch transfer through a conduit"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .createConduit(tempConduitKey, owner.address);`
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(tempConduit.address, owner.address, true);`
$DIR/test/conduit.spec.ts: `await mintAndApproveERC20(owner, tempConduit.address, amount9.mul(2));`
$DIR/test/conduit.spec.ts: `await set1155ApprovalForAll(owner, tempConduit.address, true);`
$DIR/test/conduit.spec.ts: `await set721ApprovalForAll(owner, tempConduit.address, true);`
$DIR/test/conduit.spec.ts: `await tempConduit.connect(owner).executeWithBatch1155(
      [
        {
          itemType: 1,
          token: testERC20.address,
          from: owner.address,
          to: newAddress,
          identifier: toBN(0),
          amount: amount9,
        },
        {
          itemType: 2,
          token: testERC721.address,
          from: owner.address,
          to: newAddress,
          identifier: nftId10,
          amount: toBN(1),
        },
      ],
      [
        {
          token: testERC1155.address,
          from: owner.address,
          to: newAddress,
          ids: [nftId, secondNftId, thirdNftId, nftId4],
          amounts: [amount, secondAmount, thirdAmount, amount4],
        },
        {
          token: testERC1155Two.address,
          from: owner.address,
          to: newAddress,
          ids: [nftId5, nftId6, nftId7, nftId8],
          amounts: [amount5, amount6, amount7, amount8],
        },
      ]
    );`
{"ERC1155 <=> ETH (match, two different groups of 1155's)"}
$DIR/test/conduit.spec.ts: `await testERC1155Two.mint(seller.address, secondNftId, secondAmount);`
$DIR/test/conduit.spec.ts: `await testERC1155Two.mint(seller.address, fourthNftId, fourthAmount);`
$DIR/test/conduit.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
{"Retrieves the status of a conduit channel"}
$DIR/test/conduit.spec.ts: `isOpen = await conduitController.getChannelStatus(
      conduitOne.address,
      seller.address
    );`
{"Adds and removes channels"}
$DIR/test/conduit.spec.ts: `isOpen = await conduitController.getChannelStatus(
      conduitOne.address,
      marketplaceContract.address
    );`
$DIR/test/conduit.spec.ts: `totalChannels = await conduitController.getTotalChannels(
      conduitOne.address
    );`
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(conduitOne.address, seller.address, true);`
$DIR/test/conduit.spec.ts: `isOpen = await conduitController.getChannelStatus(
      conduitOne.address,
      seller.address
    );`
$DIR/test/conduit.spec.ts: `totalChannels = await conduitController.getTotalChannels(
      conduitOne.address
    );`
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(conduitOne.address, marketplaceContract.address, false);`
$DIR/test/conduit.spec.ts: `isOpen = await conduitController.getChannelStatus(
      conduitOne.address,
      marketplaceContract.address
    );`
$DIR/test/conduit.spec.ts: `await faucet(conduitController.address, provider);`
$DIR/test/conduit.spec.ts: `await network.provider.request({
      method: "hardhat_impersonateAccount",
      params: [conduitController.address],
    });`
$DIR/test/conduit.spec.ts: `await conduitOne
      .connect(conduitControllerSigner)
      .updateChannel(marketplaceContract.address, true);`
$DIR/test/conduit.spec.ts: `await network.provider.request({
      method: "hardhat_stopImpersonatingAccount",
      params: [conduitController.address],
    });`
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(conduitOne.address, marketplaceContract.address, false);`
$DIR/test/conduit.spec.ts: `isOpen = await conduitController.getChannelStatus(
      conduitOne.address,
      marketplaceContract.address
    );`
$DIR/test/conduit.spec.ts: `totalChannels = await conduitController.getTotalChannels(
      conduitOne.address
    );`
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(conduitOne.address, seller.address, false);`
$DIR/test/conduit.spec.ts: `isOpen = await conduitController.getChannelStatus(
      conduitOne.address,
      seller.address
    );`
$DIR/test/conduit.spec.ts: `totalChannels = await conduitController.getTotalChannels(
      conduitOne.address
    );`
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(conduitOne.address, marketplaceContract.address, true);`
$DIR/test/conduit.spec.ts: `isOpen = await conduitController.getChannelStatus(
      conduitOne.address,
      marketplaceContract.address
    );`
$DIR/test/conduit.spec.ts: `totalChannels = await conduitController.getTotalChannels(
      conduitOne.address
    );`
{"Reverts on an attempt to move an unsupported item"}
$DIR/test/conduit.spec.ts: `await conduitController
      .connect(owner)
      .updateChannel(conduitOne.address, seller.address, true);`
{"Lets the owner transfer ownership via a two-stage process"}
$DIR/test/conduit.spec.ts: `await conduitController.transferOwnership(
      conduitOne.address,
      buyer.address
    );`
$DIR/test/conduit.spec.ts: `potentialOwner = await conduitController.getPotentialOwner(
      conduitOne.address
    );`
$DIR/test/conduit.spec.ts: `await conduitController.cancelOwnershipTransfer(conduitOne.address);`
$DIR/test/conduit.spec.ts: `potentialOwner = await conduitController.getPotentialOwner(
      conduitOne.address
    );`
$DIR/test/conduit.spec.ts: `await conduitController.transferOwnership(
      conduitOne.address,
      buyer.address
    );`
$DIR/test/conduit.spec.ts: `potentialOwner = await conduitController.getPotentialOwner(
      conduitOne.address
    );`
$DIR/test/conduit.spec.ts: `await conduitController.connect(buyer).acceptOwnership(conduitOne.address);`
$DIR/test/conduit.spec.ts: `potentialOwner = await conduitController.getPotentialOwner(
      conduitOne.address
    );`
{"Adds a channel, and executes transfers (ERC1155 with batch)"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, seller.address, true)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, nftId, amount.mul(2))`
$DIR/test/conduit.spec.ts: `.mul(2)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, secondNftId, secondAmount.mul(2))`
$DIR/test/conduit.spec.ts: `.mul(2)`
$DIR/test/conduit.spec.ts: `.connect(seller)`
{"Adds a channel, and executes only batch transfers (ERC1155 with batch)"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, seller.address, true)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, nftId, amount.mul(2))`
$DIR/test/conduit.spec.ts: `.mul(2)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, secondNftId, secondAmount.mul(2))`
$DIR/test/conduit.spec.ts: `.mul(2)`
$DIR/test/conduit.spec.ts: `.connect(seller)`
{"Adds a channel, and executes transfers (ERC721)"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, seller.address, true)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, secondNftId)`
$DIR/test/conduit.spec.ts: `.connect(seller)`
$DIR/test/conduit.spec.ts: `.execute([
      {
        itemType: 2, // ERC721
        token: testERC721.address,
        from: seller.address,
        to: buyer.address,
        identifier: nftId,
        amount: ethers.BigNumber.from(1),
      },
      {
        itemType: 2, // ERC721
        token: testERC721.address,
        from: seller.address,
        to: buyer.address,
        identifier: secondNftId,
        amount: ethers.BigNumber.from(1),
      },
    ])`
$DIR/test/conduit.spec.ts: `.BigNumber.from(1)`
$DIR/test/conduit.spec.ts: `.BigNumber.from(1)`
{"Adds a channel, and executes transfers (ERC721 + ERC20)"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, seller.address, true)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, tokenAmount)`
$DIR/test/conduit.spec.ts: `.connect(seller)`
$DIR/test/conduit.spec.ts: `.execute([
      {
        itemType: 2, // ERC721
        token: testERC721.address,
        from: seller.address,
        to: buyer.address,
        identifier: nftId,
        amount: ethers.BigNumber.from(1),
      },
      {
        itemType: 1, // ERC20
        token: testERC20.address,
        from: seller.address,
        to: buyer.address,
        identifier: 0,
        amount: tokenAmount.sub(100),
      },
    ])`
$DIR/test/conduit.spec.ts: `.BigNumber.from(1)`
$DIR/test/conduit.spec.ts: `.sub(100)`
$DIR/test/conduit.spec.ts: `.sub(100)`
{"Adds a channel, and executes transfers (ERC721 + ERC1155)"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, seller.address, true)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/conduit.spec.ts: `.add(1)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, secondNftId, amount)`
$DIR/test/conduit.spec.ts: `.connect(seller)`
$DIR/test/conduit.spec.ts: `.execute([
      {
        itemType: 2, // ERC721
        token: testERC721.address,
        from: seller.address,
        to: buyer.address,
        identifier: nftId,
        amount: ethers.BigNumber.from(1),
      },
      {
        itemType: 3, // ERC1155
        token: testERC1155.address,
        from: seller.address,
        to: buyer.address,
        identifier: secondNftId,
        amount: amount.sub(10),
      },
    ])`
$DIR/test/conduit.spec.ts: `.BigNumber.from(1)`
$DIR/test/conduit.spec.ts: `.sub(10)`
$DIR/test/conduit.spec.ts: `.sub(10)`
{"Adds a channel, and executes transfers (ERC20 + ERC1155)"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, seller.address, true)`
$DIR/test/conduit.spec.ts: `.div(100)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, tokenAmount)`
$DIR/test/conduit.spec.ts: `.add(1)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, nftId, erc1155amount)`
$DIR/test/conduit.spec.ts: `.connect(seller)`
$DIR/test/conduit.spec.ts: `.execute([
      {
        itemType: 1, // ERC20
        token: testERC20.address,
        from: seller.address,
        to: buyer.address,
        identifier: 0,
        amount: tokenAmount.sub(100),
      },
      {
        itemType: 3, // ERC1155
        token: testERC1155.address,
        from: seller.address,
        to: buyer.address,
        identifier: nftId,
        amount: erc1155amount.sub(10),
      },
    ])`
$DIR/test/conduit.spec.ts: `.sub(100)`
$DIR/test/conduit.spec.ts: `.sub(10)`
$DIR/test/conduit.spec.ts: `.sub(10)`
{"Adds a channel, and executes transfers (ERC20 + ERC721 + ERC1155)"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, seller.address, true)`
$DIR/test/conduit.spec.ts: `.connect(seller)`
$DIR/test/conduit.spec.ts: `.execute([erc20Transfer, erc721Transfer, erc1155Transfer])`
{"Adds a channel, and executes transfers (many token types)"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, seller.address, true)`
$DIR/test/conduit.spec.ts: `.max(1, randomInt(itemsToCreate - 2))`
$DIR/test/conduit.spec.ts: `.max(1, randomInt(itemsToCreate - numERC20s - 1))`
$DIR/test/conduit.spec.ts: `.max(1, itemsToCreate - numERC20s - numERC721s)`
$DIR/test/conduit.spec.ts: `.connect(seller)`
$DIR/test/conduit.spec.ts: `.execute(transfers)`
{"Reverts on calls to batch transfer 1155 items with no contract on a conduit"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, owner.address, true)`
{"Reverts on calls to only batch transfer 1155 items with no contract on a conduit"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, owner.address, true)`
{"ERC1155 batch transfer reverts with revert data if it has sufficient gas"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, seller.address, true)`
{"ERC1155 batch transfer sends no data"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, seller.address, true)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, nftId, amount.mul(2))`
$DIR/test/conduit.spec.ts: `.mul(2)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, secondNftId, secondAmount.mul(2))`
$DIR/test/conduit.spec.ts: `.mul(2)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, thirdNftId, thirdAmount.mul(2))`
$DIR/test/conduit.spec.ts: `.mul(2)`
$DIR/test/conduit.spec.ts: `.connect(seller)`
{"ERC1155 batch transfer reverts with generic error if it has insufficient gas to copy revert data"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, seller.address, true)`
{"Makes batch transfer 1155 items through a conduit"}
$DIR/test/conduit.spec.ts: `.getConduit(
      tempConduitKey
    )`
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.createConduit(tempConduitKey, owner.address)`
$DIR/test/conduit.spec.ts: `.attach(tempConduitAddress)`
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, owner.address, true)`
$DIR/test/conduit.spec.ts: `.connect(owner)`
{"Performs complex batch transfer through a conduit"}
$DIR/test/conduit.spec.ts: `.getConduit(
      tempConduitKey
    )`
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.createConduit(tempConduitKey, owner.address)`
$DIR/test/conduit.spec.ts: `.attach(tempConduitAddress)`
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(tempConduit.address, owner.address, true)`
$DIR/test/conduit.spec.ts: `.add(1)`
$DIR/test/conduit.spec.ts: `.mul(2)`
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.executeWithBatch1155(
      [
        {
          itemType: 1,
          token: testERC20.address,
          from: owner.address,
          to: newAddress,
          identifier: toBN(0),
          amount: amount9,
        },
        {
          itemType: 2,
          token: testERC721.address,
          from: owner.address,
          to: newAddress,
          identifier: nftId10,
          amount: toBN(1),
        },
      ],
      [
        {
          token: testERC1155.address,
          from: owner.address,
          to: newAddress,
          ids: [nftId, secondNftId, thirdNftId, nftId4],
          amounts: [amount, secondAmount, thirdAmount, amount4],
        },
        {
          token: testERC1155Two.address,
          from: owner.address,
          to: newAddress,
          ids: [nftId5, nftId6, nftId7, nftId8],
          amounts: [amount5, amount6, amount7, amount8],
        },
      ]
    )`
{"ERC1155 <=> ETH (match, two different groups of 1155's)"}
$DIR/test/conduit.spec.ts: `.mint(seller.address, secondNftId, secondAmount)`
$DIR/test/conduit.spec.ts: `.mint(seller.address, fourthNftId, fourthAmount)`
$DIR/test/conduit.spec.ts: `.map(([offerArr, considerationArr]) =>
      toFulfillment(offerArr, considerationArr)
    )`
$DIR/test/conduit.spec.ts: `.connect(owner)`
{"Reverts when attempting to execute transfers on a conduit when not called from a channel"}
$DIR/test/conduit.spec.ts: `.address.slice(2)`
$DIR/test/conduit.spec.ts: `.padStart(64, "0")`
$DIR/test/conduit.spec.ts: `.toLowerCase()`
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.populateTransaction.execute([])`
$DIR/test/conduit.spec.ts: `.call(tx)`
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.execute([])`
{"Retrieves the owner of a conduit"}
$DIR/test/conduit.spec.ts: `.ownerOf(conduitOne.address)`
{"Retrieves the key of a conduit"}
$DIR/test/conduit.spec.ts: `.getKey(conduitOne.address)`
{"Retrieves the status of a conduit channel"}
$DIR/test/conduit.spec.ts: `.getChannelStatus(
      conduitOne.address,
      marketplaceContract.address
    )`
$DIR/test/conduit.spec.ts: `.getChannelStatus(
      conduitOne.address,
      seller.address
    )`
{"Retrieves conduit channels from the controller"}
$DIR/test/conduit.spec.ts: `.getTotalChannels(
      conduitOne.address
    )`
$DIR/test/conduit.spec.ts: `.getChannel(
      conduitOne.address,
      0
    )`
$DIR/test/conduit.spec.ts: `.getChannels(conduitOne.address)`
{"Adds and removes channels"}
$DIR/test/conduit.spec.ts: `.getTotalChannels(
      conduitOne.address
    )`
$DIR/test/conduit.spec.ts: `.getChannelStatus(
      conduitOne.address,
      marketplaceContract.address
    )`
$DIR/test/conduit.spec.ts: `.getChannelStatus(
      conduitOne.address,
      marketplaceContract.address
    )`
$DIR/test/conduit.spec.ts: `.getTotalChannels(
      conduitOne.address
    )`
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(conduitOne.address, seller.address, true)`
$DIR/test/conduit.spec.ts: `.getChannelStatus(
      conduitOne.address,
      seller.address
    )`
$DIR/test/conduit.spec.ts: `.getTotalChannels(
      conduitOne.address
    )`
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(conduitOne.address, marketplaceContract.address, false)`
$DIR/test/conduit.spec.ts: `.getChannelStatus(
      conduitOne.address,
      marketplaceContract.address
    )`
$DIR/test/conduit.spec.ts: `.provider.request({
      method: "hardhat_impersonateAccount",
      params: [conduitController.address],
    })`
$DIR/test/conduit.spec.ts: `.getSigner(
      conduitController.address
    )`
$DIR/test/conduit.spec.ts: `.connect(conduitControllerSigner)`
$DIR/test/conduit.spec.ts: `.updateChannel(marketplaceContract.address, true)`
$DIR/test/conduit.spec.ts: `.provider.request({
      method: "hardhat_stopImpersonatingAccount",
      params: [conduitController.address],
    })`
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(conduitOne.address, marketplaceContract.address, false)`
$DIR/test/conduit.spec.ts: `.getChannelStatus(
      conduitOne.address,
      marketplaceContract.address
    )`
$DIR/test/conduit.spec.ts: `.getTotalChannels(
      conduitOne.address
    )`
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(conduitOne.address, seller.address, false)`
$DIR/test/conduit.spec.ts: `.getChannelStatus(
      conduitOne.address,
      seller.address
    )`
$DIR/test/conduit.spec.ts: `.getTotalChannels(
      conduitOne.address
    )`
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(conduitOne.address, marketplaceContract.address, true)`
$DIR/test/conduit.spec.ts: `.getChannelStatus(
      conduitOne.address,
      marketplaceContract.address
    )`
$DIR/test/conduit.spec.ts: `.getTotalChannels(
      conduitOne.address
    )`
{"Reverts on an attempt to move an unsupported item"}
$DIR/test/conduit.spec.ts: `.connect(owner)`
$DIR/test/conduit.spec.ts: `.updateChannel(conduitOne.address, seller.address, true)`
$DIR/test/conduit.spec.ts: `.getChannelStatus(
      conduitOne.address,
      seller.address
    )`
{"Retrieves no initial potential owner for new conduit"}
$DIR/test/conduit.spec.ts: `.getPotentialOwner(
      conduitOne.address
    )`
{"Lets the owner transfer ownership via a two-stage process"}
$DIR/test/conduit.spec.ts: `.getPotentialOwner(
      conduitOne.address
    )`
$DIR/test/conduit.spec.ts: `.transferOwnership(
      conduitOne.address,
      buyer.address
    )`
$DIR/test/conduit.spec.ts: `.getPotentialOwner(
      conduitOne.address
    )`
$DIR/test/conduit.spec.ts: `.cancelOwnershipTransfer(conduitOne.address)`
$DIR/test/conduit.spec.ts: `.getPotentialOwner(
      conduitOne.address
    )`
$DIR/test/conduit.spec.ts: `.transferOwnership(
      conduitOne.address,
      buyer.address
    )`
$DIR/test/conduit.spec.ts: `.getPotentialOwner(
      conduitOne.address
    )`
$DIR/test/conduit.spec.ts: `.connect(buyer)`
$DIR/test/conduit.spec.ts: `.acceptOwnership(conduitOne.address)`
$DIR/test/conduit.spec.ts: `.getPotentialOwner(
      conduitOne.address
    )`
$DIR/test/conduit.spec.ts: `.ownerOf(conduitOne.address)`
{"Validate signed order and fill it with no signature"}
$DIR/test/counter.spec.ts: `order.signature = "0x";`
$DIR/test/counter.spec.ts: `tx = await marketplaceContract
          .connect(owner)
          .populateTransaction.fulfillOrder(order, toKey(0), {
            value,
          });`
$DIR/test/counter.spec.ts: `returnData = await provider.call(tx);`
$DIR/test/counter.spec.ts: `order.signature = signature;`
$DIR/test/counter.spec.ts: `await marketplaceContract.connect(owner).validate([order, order]);`
$DIR/test/counter.spec.ts: `order.signature = "0x";`
$DIR/test/counter.spec.ts: `await withBalanceChecks([order], 0, undefined, async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillOrder(order, toKey(0), {
            value,
          });
        const receipt = await (await tx).wait();
        await checkExpectedEvents(tx, receipt, [
          {
            order,
            orderHash,
            fulfiller: buyer.address,
            fulfillerConduitKey: toKey(0),
          },
        ]);

        return receipt;
      });`
{"Validate unsigned order from offerer and fill it with no signature"}
$DIR/test/counter.spec.ts: `order.signature = "0x";`
$DIR/test/counter.spec.ts: `tx = await marketplaceContract
          .connect(owner)
          .populateTransaction.validate([order]);`
$DIR/test/counter.spec.ts: `returnData = await provider.call(tx);`
$DIR/test/counter.spec.ts: `order.signature = "0x";`
$DIR/test/counter.spec.ts: `await withBalanceChecks([order], 0, undefined, async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillOrder(order, toKey(0), {
            value,
          });
        const receipt = await (await tx).wait();
        await checkExpectedEvents(tx, receipt, [
          {
            order,
            orderHash,
            fulfiller: buyer.address,
            fulfillerConduitKey: toKey(0),
          },
        ]);

        return receipt;
      });`
{"Cannot validate a cancelled order"}
$DIR/test/counter.spec.ts: `order.signature = "0x";`
$DIR/test/counter.spec.ts: `tx = await marketplaceContract
          .connect(owner)
          .populateTransaction.validate([order]);`
$DIR/test/counter.spec.ts: `returnData = await provider.call(tx);`
$DIR/test/counter.spec.ts: `order.signature = signature;`
{"Skip validation for contract order"}
$DIR/test/counter.spec.ts: `await set721ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/counter.spec.ts: `contractOrderOffer[0].identifier =
        contractOrderOffer[0].identifierOrCriteria;`
$DIR/test/counter.spec.ts: `contractOrderOffer[0].amount = contractOrderOffer[0].endAmount;`
$DIR/test/counter.spec.ts: `contractOrderConsideration[0].identifier =
        contractOrderConsideration[0].identifierOrCriteria;`
$DIR/test/counter.spec.ts: `contractOrderConsideration[0].amount =
        contractOrderConsideration[0].endAmount;`
$DIR/test/counter.spec.ts: `await offererContract
        .connect(seller)
        .activate(contractOrderOffer[0], contractOrderOffer[0]);`
{"Reverts on validate when consideration array length doesn't match totalOriginalConsiderationItems"}
$DIR/test/counter.spec.ts: `order.parameters.totalOriginalConsiderationItems = 2;`
{"Reverts when trying to cancel contract order"}
$DIR/test/counter.spec.ts: `await createOrder(
        seller,
        zone,
        offer,
        consideration,
        0 // FULL_OPEN
      );`
$DIR/test/counter.spec.ts: `await set721ApprovalForAll(seller, offererContract.address, true);`
$DIR/test/counter.spec.ts: `contractOrderOffer[0].identifier =
        contractOrderOffer[0].identifierOrCriteria;`
$DIR/test/counter.spec.ts: `contractOrderOffer[0].amount = contractOrderOffer[0].endAmount;`
$DIR/test/counter.spec.ts: `contractOrderConsideration[0].identifier =
        contractOrderConsideration[0].identifierOrCriteria;`
$DIR/test/counter.spec.ts: `contractOrderConsideration[0].amount =
        contractOrderConsideration[0].endAmount;`
$DIR/test/counter.spec.ts: `await offererContract
        .connect(seller)
        .activate(contractOrderOffer[0], contractOrderOffer[0]);`
{"Can increment the counter"}
$DIR/test/counter.spec.ts: `order = newOrderDetails.order;`
$DIR/test/counter.spec.ts: `orderHash = newOrderDetails.orderHash;`
$DIR/test/counter.spec.ts: `value = newOrderDetails.value;`
$DIR/test/counter.spec.ts: `orderComponents = newOrderDetails.orderComponents;`
{"Can increment the counter and implicitly cancel a validated order"}
$DIR/test/counter.spec.ts: `order = newOrderDetails.order;`
$DIR/test/counter.spec.ts: `orderHash = newOrderDetails.orderHash;`
$DIR/test/counter.spec.ts: `value = newOrderDetails.value;`
$DIR/test/counter.spec.ts: `orderComponents = newOrderDetails.orderComponents;`
{"Can increment the counter as the offerer and implicitly cancel a validated order"}
$DIR/test/counter.spec.ts: `order = newOrderDetails.order;`
$DIR/test/counter.spec.ts: `orderHash = newOrderDetails.orderHash;`
$DIR/test/counter.spec.ts: `value = newOrderDetails.value;`
$DIR/test/counter.spec.ts: `orderComponents = newOrderDetails.orderComponents;`
{"Validate signed order and fill it with no signature"}
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/counter.spec.ts: `.connect(buyer)`
$DIR/test/counter.spec.ts: `.populateTransaction.fulfillOrder(order, toKey(0), {
            value,
          })`
$DIR/test/counter.spec.ts: `.call(tx)`
$DIR/test/counter.spec.ts: `.connect(owner)`
$DIR/test/counter.spec.ts: `.populateTransaction.fulfillOrder(order, toKey(0), {
            value,
          })`
$DIR/test/counter.spec.ts: `.call(tx)`
$DIR/test/counter.spec.ts: `.connect(owner)`
$DIR/test/counter.spec.ts: `.validate([order])`
$DIR/test/counter.spec.ts: `.wait()`
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/counter.spec.ts: `.connect(owner)`
$DIR/test/counter.spec.ts: `.validate([order, order])`
$DIR/test/counter.spec.ts: `.connect(buyer)`
$DIR/test/counter.spec.ts: `.fulfillOrder(order, toKey(0), {
            value,
          })`
$DIR/test/counter.spec.ts: `.wait()`
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
{"Validate unsigned order from offerer and fill it with no signature"}
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/counter.spec.ts: `.connect(buyer)`
$DIR/test/counter.spec.ts: `.populateTransaction.fulfillOrder(order, toKey(0), {
            value,
          })`
$DIR/test/counter.spec.ts: `.call(tx)`
$DIR/test/counter.spec.ts: `.connect(owner)`
$DIR/test/counter.spec.ts: `.populateTransaction.validate([order])`
$DIR/test/counter.spec.ts: `.call(tx)`
$DIR/test/counter.spec.ts: `.connect(seller)`
$DIR/test/counter.spec.ts: `.validate([order])`
$DIR/test/counter.spec.ts: `.wait()`
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/counter.spec.ts: `.connect(buyer)`
$DIR/test/counter.spec.ts: `.fulfillOrder(order, toKey(0), {
            value,
          })`
$DIR/test/counter.spec.ts: `.wait()`
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
{"Cannot validate a cancelled order"}
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/counter.spec.ts: `.connect(buyer)`
$DIR/test/counter.spec.ts: `.populateTransaction.fulfillOrder(order, toKey(0), {
            value,
          })`
$DIR/test/counter.spec.ts: `.call(tx)`
$DIR/test/counter.spec.ts: `.connect(owner)`
$DIR/test/counter.spec.ts: `.populateTransaction.validate([order])`
$DIR/test/counter.spec.ts: `.call(tx)`
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
{"Skip validation for contract order"}
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/counter.spec.ts: `.connect(seller)`
$DIR/test/counter.spec.ts: `.activate(contractOrderOffer[0], contractOrderOffer[0])`
$DIR/test/counter.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/counter.spec.ts: `.address.toLowerCase()`
$DIR/test/counter.spec.ts: `.toHexString()`
$DIR/test/counter.spec.ts: `.slice(2)`
$DIR/test/counter.spec.ts: `.padStart(24, "0")`
$DIR/test/counter.spec.ts: `.getOrderStatus(
        contractOrderHash
      )`
$DIR/test/counter.spec.ts: `.connect(seller)`
$DIR/test/counter.spec.ts: `.validate([order, contractOrder])`
$DIR/test/counter.spec.ts: `.wait()`
{"Can cancel an order"}
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
{"Can cancel a validated order"}
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/counter.spec.ts: `.connect(owner)`
$DIR/test/counter.spec.ts: `.validate([order])`
$DIR/test/counter.spec.ts: `.wait()`
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
{"Can cancel an order from the zone"}
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
{"Can cancel a validated order from a zone"}
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/counter.spec.ts: `.connect(owner)`
$DIR/test/counter.spec.ts: `.validate([order])`
$DIR/test/counter.spec.ts: `.wait()`
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/counter.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts when trying to cancel contract order"}
$DIR/test/counter.spec.ts: `.connect(seller)`
$DIR/test/counter.spec.ts: `.activate(contractOrderOffer[0], contractOrderOffer[0])`
$DIR/test/counter.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/counter.spec.ts: `.address.toLowerCase()`
$DIR/test/counter.spec.ts: `.toHexString()`
$DIR/test/counter.spec.ts: `.slice(2)`
$DIR/test/counter.spec.ts: `.padStart(24, "0")`
$DIR/test/counter.spec.ts: `.getOrderStatus(
        contractOrderHash
      )`
$DIR/test/counter.spec.ts: `.getOrderStatus(
        contractOrderHash
      )`
{"Can increment the counter"}
$DIR/test/counter.spec.ts: `.getCounter(seller.address)`
$DIR/test/counter.spec.ts: `.getBlock("latest")`
$DIR/test/counter.spec.ts: `.shr(128)`
$DIR/test/counter.spec.ts: `.getCounter(seller.address)`
$DIR/test/counter.spec.ts: `.connect(buyer)`
$DIR/test/counter.spec.ts: `.populateTransaction.fulfillOrder(order, toKey(0), {
            value,
          })`
$DIR/test/counter.spec.ts: `.call(tx)`
$DIR/test/counter.spec.ts: `.connect(buyer)`
$DIR/test/counter.spec.ts: `.fulfillOrder(order, toKey(0), {
            value,
          })`
$DIR/test/counter.spec.ts: `.wait()`
{"Can increment the counter and implicitly cancel a validated order"}
$DIR/test/counter.spec.ts: `.getCounter(seller.address)`
$DIR/test/counter.spec.ts: `.connect(owner)`
$DIR/test/counter.spec.ts: `.validate([order])`
$DIR/test/counter.spec.ts: `.wait()`
$DIR/test/counter.spec.ts: `.getBlock("latest")`
$DIR/test/counter.spec.ts: `.shr(128)`
$DIR/test/counter.spec.ts: `.getCounter(seller.address)`
$DIR/test/counter.spec.ts: `.connect(buyer)`
$DIR/test/counter.spec.ts: `.populateTransaction.fulfillOrder(order, toKey(0), {
            value,
          })`
$DIR/test/counter.spec.ts: `.call(tx)`
$DIR/test/counter.spec.ts: `.connect(buyer)`
$DIR/test/counter.spec.ts: `.fulfillOrder(order, toKey(0), {
            value,
          })`
$DIR/test/counter.spec.ts: `.wait()`
{"Can increment the counter as the offerer and implicitly cancel a validated order"}
$DIR/test/counter.spec.ts: `.getCounter(seller.address)`
$DIR/test/counter.spec.ts: `.connect(owner)`
$DIR/test/counter.spec.ts: `.validate([order])`
$DIR/test/counter.spec.ts: `.wait()`
$DIR/test/counter.spec.ts: `.getBlock("latest")`
$DIR/test/counter.spec.ts: `.shr(128)`
$DIR/test/counter.spec.ts: `.getCounter(seller.address)`
$DIR/test/counter.spec.ts: `.connect(buyer)`
$DIR/test/counter.spec.ts: `.populateTransaction.fulfillOrder(order, toKey(0), {
            value,
          })`
$DIR/test/counter.spec.ts: `.call(tx)`
$DIR/test/counter.spec.ts: `.connect(buyer)`
$DIR/test/counter.spec.ts: `.fulfillOrder(order, toKey(0), {
            value,
          })`
$DIR/test/counter.spec.ts: `.wait()`
{"Alice offers to sell an NFT for 1000 DAI plus 100 in fees for Carol"}
$DIR/test/findings/AdditionalRecipientsOffByOne.spec.ts: `order = results.order;`
$DIR/test/findings/AdditionalRecipientsOffByOne.spec.ts: `orderHash = results.orderHash;`
$DIR/test/findings/AdditionalRecipientsOffByOne.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/findings/AdditionalRecipientsOffByOne.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/findings/AdditionalRecipientsOffByOne.spec.ts: `.connect(bob)`
$DIR/test/findings/AdditionalRecipientsOffByOne.spec.ts: `.validate([order])`
$DIR/test/findings/AdditionalRecipientsOffByOne.spec.ts: `.wait()`
$DIR/test/findings/AdditionalRecipientsOffByOne.spec.ts: `.getOrderStatus(orderHash)`
{"Carol mints a new NFT with its identifier set to the merkle tree's root hash"}
$DIR/test/findings/CriteriaResolverUnhashedLeaves.spec.ts: `await testERC721.mint(carol.address, root);`
$DIR/test/findings/CriteriaResolverUnhashedLeaves.spec.ts: `.mint(carol.address, root)`
{"Carol fills Alice's order, giving the merkle root as the token ID and an empty proof"}
$DIR/test/findings/CriteriaResolverUnhashedLeaves.spec.ts: `.connect(carol)`
{"Bob constructs a malicious order with one empty consideration and one which will overflow Alice's"}
$DIR/test/findings/FulfillmentOverflowWithMissingItems.spec.ts: `.MaxUint256.sub(998)`
$DIR/test/findings/FulfillmentOverflowWithMissingItems.spec.ts: `.MaxUint256.sub(998)`
{"Bob is able to match Alice's order with his malicious one"}
$DIR/test/findings/FulfillmentOverflowWithMissingItems.spec.ts: `.connect(bob)`
{"Alice creates a partially fillable order to sell two 1155 tokens for 1000 DAI"}
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `order = results.order;`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `orderHash = results.orderHash;`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Bob receives one 1155 token"}
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `order.numerator = 1;`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `order.denominator = 2;`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `await marketplaceContract
        .connect(bob)
        .fulfillAdvancedOrder(order, [], toKey(0), bob.address);`
{"Carol fills the order with a fraction that overflows"}
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `order.numerator = toBN(2).pow(118);`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `order.denominator = toBN(2).pow(119);`
{"Carol fills the same order multiple times"}
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `order.numerator = toBN(2).pow(1);`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `order.denominator = toBN(2).pow(2);`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `await marketplaceContract
            .connect(carol)
            .fulfillAdvancedOrder(order, [], toKey(0), carol.address);`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `order.numerator = toBN(2).pow(118);`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `order.denominator = toBN(2).pow(119);`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `await marketplaceContract
            .connect(carol)
            .fulfillAdvancedOrder(order, [], toKey(0), carol.address);`
{"Alice creates a partially fillable order to sell two 1155 tokens for 1000 DAI"}
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.connect(bob)`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.validate([order])`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.wait()`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.getOrderStatus(orderHash)`
{"Bob receives one 1155 token"}
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.connect(bob)`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.fulfillAdvancedOrder(order, [], toKey(0), bob.address)`
{"Carol fills the order with a fraction that overflows"}
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.pow(118)`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.pow(119)`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.connect(carol)`
{"Alice's order is reset and marked as 0% filled"}
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.getOrderStatus(orderHash)`
{"Carol fills the same order multiple times"}
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.pow(1)`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.pow(2)`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.connect(carol)`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.fulfillAdvancedOrder(order, [], toKey(0), carol.address)`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.pow(118)`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.pow(119)`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.connect(carol)`
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.fulfillAdvancedOrder(order, [], toKey(0), carol.address)`
{"Alice's order is marked as completely filled"}
$DIR/test/findings/PartialFillFractionOverflow.spec.ts: `.getOrderStatus(orderHash)`
{"gets correct name"}
$DIR/test/getter.spec.ts: `.name()`
$DIR/test/getter.spec.ts: `.name()`
{"gets correct version, domain separator and conduit controller"}
$DIR/test/getter.spec.ts: `.information()`
$DIR/test/getter.spec.ts: `.getNetwork()`
$DIR/test/getter.spec.ts: `.address
      .slice(2)`
$DIR/test/getter.spec.ts: `.padStart(64, "0")`
{"Reverts on bad fraction amounts"}
$DIR/test/revert.spec.ts: `order.numerator = 0;`
$DIR/test/revert.spec.ts: `order.denominator = 10;`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 0;`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/revert.spec.ts: `order.numerator = 2;`
$DIR/test/revert.spec.ts: `order.denominator = 1;`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 2;`
$DIR/test/revert.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Reverts on inexact fraction amounts"}
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 8191;`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 2;`
$DIR/test/revert.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Reverts on partial fill attempt when not supported by order"}
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 2;`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 1;`
$DIR/test/revert.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Reverts on partially filled order via basic fulfillment"}
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 2;`
$DIR/test/revert.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Reverts on fully filled order"}
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 1;`
$DIR/test/revert.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Reverts on non-zero unused item parameters (identifier set on native, basic, ERC721)"}
$DIR/test/revert.spec.ts: `consideration[0].identifierOrCriteria = minRandom(1);`
{"Reverts on non-zero unused item parameters (identifier set on ERC20, basic, ERC721)"}
$DIR/test/revert.spec.ts: `await mintAndApproveERC20(seller, marketplaceContract.address, 1000);`
$DIR/test/revert.spec.ts: `offer[0].identifierOrCriteria = minRandom(1);`
{"Reverts on non-zero unused item parameters (identifier set on native, basic, ERC1155)"}
$DIR/test/revert.spec.ts: `consideration[0].identifierOrCriteria = amount;`
{"Reverts on non-zero unused item parameters (identifier set on ERC20, basic)"}
$DIR/test/revert.spec.ts: `consideration[0].identifierOrCriteria = amount;`
{"Reverts on non-zero unused item parameters (token set on native, standard)"}
$DIR/test/revert.spec.ts: `consideration[0].token = seller.address;`
{"Reverts on non-zero unused item parameters (identifier set on native, standard)"}
$DIR/test/revert.spec.ts: `consideration[0].identifierOrCriteria = amount;`
{"Reverts on non-zero unused item parameters (identifier set on ERC20, standard)"}
$DIR/test/revert.spec.ts: `consideration[0].identifierOrCriteria = amount;`
{"Reverts on inadequate consideration items"}
$DIR/test/revert.spec.ts: `order.parameters.consideration.pop();`
{"Reverts on invalid signatures"}
$DIR/test/revert.spec.ts: `order.signature = order.signature.slice(0, -2) + "01";`
$DIR/test/revert.spec.ts: `basicOrderParameters.signature = "0x".padEnd(130, "f") + "1c";`
$DIR/test/revert.spec.ts: `expectedRevertReason = getCustomRevertSelector("InvalidSigner()");`
$DIR/test/revert.spec.ts: `tx = await marketplaceContract
        .connect(buyer)
        .populateTransaction.fulfillBasicOrder(basicOrderParameters, {
          value,
        });`
$DIR/test/revert.spec.ts: `basicOrderParameters.signature = originalSignature;`
{"Reverts on invalid 1271 signature"}
$DIR/test/revert.spec.ts: `await testERC20.mint(buyer.address, tokenAmount);`
{"Reverts on invalid contract 1271 signature and contract does not supply a revert reason"}
$DIR/test/revert.spec.ts: `await sellerContract.connect(owner).revertWithMessage(false);`
$DIR/test/revert.spec.ts: `await testERC20.mint(buyer.address, tokenAmount);`
{"Reverts on invalid contract 1271 signature and contract does not return magic value"}
$DIR/test/revert.spec.ts: `await sellerContract.connect(owner).setValid(false);`
$DIR/test/revert.spec.ts: `await testERC20.mint(buyer.address, tokenAmount);`
{"Reverts on restricted order where isValidOrder reverts with no data"}
$DIR/test/revert.spec.ts: `order.extraData = "0x0102030405";`
{"Reverts on restricted order where isValidOrder returns non-magic value"}
$DIR/test/revert.spec.ts: `order.extraData = "0x01";`
{"Reverts on missing offer or consideration components"}
$DIR/test/revert.spec.ts: `fulfillments = [
        {
          offerComponents: [],
          considerationComponents: [
            {
              orderIndex: 0,
              itemIndex: 0,
            },
          ],
        },
      ];`
$DIR/test/revert.spec.ts: `fulfillments = [
        {
          offerComponents: [
            {
              orderIndex: 0,
              itemIndex: 0,
            },
          ],
          considerationComponents: [],
        },
      ];`
$DIR/test/revert.spec.ts: `fulfillments = defaultBuyNowMirrorFulfillment;`
{"Reverts on mismatched offer and consideration components"}
$DIR/test/revert.spec.ts: `fulfillments = defaultBuyNowMirrorFulfillment;`
{"Reverts on mismatched offer components"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
{"Reverts on mismatched offer components (branch coverage 1)"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
{"Reverts on invalid matching offerer (branch coverage 2)"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `offer2[0].identifierOrCriteria = secondNFTId;`
{"Reverts on invalid matching conduit key (branch coverage 3)"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `offer2[0].identifierOrCriteria = secondNFTId;`
{"Reverts on invalid matching itemType (branch coverage 4)"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `offer2[0].identifierOrCriteria = secondNFTId;`
$DIR/test/revert.spec.ts: `offer2[0].itemType = 1;`
{"Reverts on invalid matching token"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `offer2[0].identifierOrCriteria = secondNFTId;`
$DIR/test/revert.spec.ts: `offer2[0].token = testERC1155.address;`
{"Reverts on invalid matching recipient"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `consideration2[0].recipient = owner.address;`
{"Reverts on invalid matching itemType"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `consideration2[0].itemType = 1;`
{"Reverts on invalid matching token"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `consideration2[0].token = testERC1155.address;`
{"Reverts on invalid matching identifier"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `consideration2[0].identifierOrCriteria = nftId;`
{"Reverts on mismatched consideration components"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
{"Reverts on fulfillAvailableAdvancedOrders with out-of-range initial offer order"}
$DIR/test/revert.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
{"Reverts on fulfillAvailableAdvancedOrders with out-of-range offer order"}
$DIR/test/revert.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
{"Reverts on fulfillAvailableAdvancedOrders no available components"}
$DIR/test/revert.spec.ts: `await withBalanceChecks([orderThree], 0, undefined, async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillOrder(orderThree, toKey(0), {
            value,
          });
        const receipt = await (await tx).wait();
        await checkExpectedEvents(tx, receipt, [
          {
            order: orderThree,
            orderHash: orderHashThree,
            fulfiller: buyer.address,
          },
        ]);

        return receipt;
      });`
{"Reverts on out-of-range criteria resolvers"}
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, nftId);`
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, secondNFTId);`
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, thirdNFTId);`
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `criteriaResolvers = [
        buildResolver(0, 0, 5, nftId, proofs[nftId.toString()]),
      ];`
$DIR/test/revert.spec.ts: `criteriaResolvers = [
        buildResolver(0, 1, 5, nftId, proofs[nftId.toString()]),
      ];`
$DIR/test/revert.spec.ts: `criteriaResolvers = [
        buildResolver(0, 0, 0, nftId, proofs[nftId.toString()]),
      ];`
{"Reverts on out-of-range criteria resolver (match)"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `criteriaResolvers = [
          buildResolver(0, 0, 5, nftId, proofs[nftId.toString()]),
        ];`
$DIR/test/revert.spec.ts: `criteriaResolvers = [
          buildResolver(0, 1, 5, nftId, proofs[nftId.toString()]),
        ];`
{"Reverts on unresolved criteria items"}
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, nftId);`
$DIR/test/revert.spec.ts: `await testERC721.mint(buyer.address, secondNFTId);`
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(buyer, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `criteriaResolvers = [
        buildResolver(0, 0, 0, nftId, proofs[nftId.toString()]),
      ];`
$DIR/test/revert.spec.ts: `criteriaResolvers = [
        buildResolver(0, 1, 0, secondNFTId, proofs[secondNFTId.toString()]),
      ];`
$DIR/test/revert.spec.ts: `criteriaResolvers = [
        buildResolver(0, 0, 0, nftId, proofs[nftId.toString()]),
        buildResolver(0, 1, 0, secondNFTId, proofs[secondNFTId.toString()]),
      ];`
{"Reverts on unresolved criteria items (match)"}
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, nftId);`
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, secondNFTId);`
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `criteriaResolvers = [
          buildResolver(0, 0, 0, nftId, proofs[nftId.toString()]),
        ];`
$DIR/test/revert.spec.ts: `criteriaResolvers = [
          buildResolver(0, 1, 0, secondNFTId, proofs[secondNFTId.toString()]),
        ];`
{"Reverts on attempts to resolve criteria for non-criteria item"}
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, nftId);`
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, secondNFTId);`
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, thirdNFTId);`
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
{"Reverts on attempts to resolve criteria for non-criteria item (match)"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
{"Reverts on offer amount overflow"}
$DIR/test/revert.spec.ts: `await testERC20Two.mint(seller.address, ethers.constants.MaxUint256);`
$DIR/test/revert.spec.ts: `await testERC20Two
        .connect(seller)
        .approve(marketplaceContract.address, ethers.constants.MaxUint256);`
{"Reverts on offer amount overflow when another amount is 0"}
$DIR/test/revert.spec.ts: `await testERC20Two.mint(seller.address, ethers.constants.MaxUint256);`
$DIR/test/revert.spec.ts: `await testERC20Two
        .connect(seller)
        .approve(marketplaceContract.address, ethers.constants.MaxUint256);`
{"Reverts on consideration amount overflow"}
$DIR/test/revert.spec.ts: `await testERC20Two.mint(seller.address, ethers.constants.MaxUint256);`
$DIR/test/revert.spec.ts: `await testERC20Two
        .connect(seller)
        .approve(marketplaceContract.address, ethers.constants.MaxUint256);`
{"Reverts on consideration amount overflow when another amount is 0"}
$DIR/test/revert.spec.ts: `await testERC20Two.mint(buyer.address, ethers.constants.MaxUint256);`
$DIR/test/revert.spec.ts: `await testERC20Two
        .connect(buyer)
        .approve(marketplaceContract.address, ethers.constants.MaxUint256);`
{"Reverts on supplying a criteria proof to a collection-wide criteria item"}
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, nftId);`
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, secondNFTId);`
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, thirdNFTId);`
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `criteriaResolvers[0].criteriaProof = [];`
{"Reverts on supplying a criteria proof to a collection-wide criteria item (aggregate)"}
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, nftId);`
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, secondNFTId);`
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, thirdNFTId);`
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
{"Reverts on invalid criteria proof"}
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, nftId);`
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, secondNFTId);`
$DIR/test/revert.spec.ts: `await testERC721.mint(seller.address, thirdNFTId);`
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
$DIR/test/revert.spec.ts: `criteriaResolvers[0].identifier = criteriaResolvers[0].identifier.add(1);`
$DIR/test/revert.spec.ts: `criteriaResolvers[0].identifier = criteriaResolvers[0].identifier.sub(1);`
{"Reverts when not enough ether is supplied (standard + advanced)"}
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
$DIR/test/revert.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value: value.add(1),
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Reverts when ether transfer fails (basic)"}
$DIR/test/revert.spec.ts: `await testERC20.mint(buyer.address, tokenAmount);`
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, marketplaceContract.address, true);`
{"Reverts when tokens are not approved"}
$DIR/test/revert.spec.ts: `await testERC20.mint(buyer.address, tokenAmount);`
$DIR/test/revert.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Reverts when 1155 token transfer reverts (via conduit, returndata)"}
$DIR/test/revert.spec.ts: `await testERC20.mint(seller.address, tokenAmount);`
$DIR/test/revert.spec.ts: `await testERC1155.mint(buyer.address, nftId, amount.mul(10000));`
$DIR/test/revert.spec.ts: `await recipient.setRevertDataSize(1);`
{"Reverts when transferred item amount is zero"}
$DIR/test/revert.spec.ts: `await testERC20.mint(buyer.address, tokenAmount);`
{"Reverts when aggregating zero-amount items"}
$DIR/test/revert.spec.ts: `await testERC20.mint(buyer.address, 1000);`
{"Reverts when ERC20 tokens return falsey values"}
$DIR/test/revert.spec.ts: `await testERC20.mint(buyer.address, tokenAmount);`
$DIR/test/revert.spec.ts: `await testERC20.blockTransfer(true);`
$DIR/test/revert.spec.ts: `await testERC20.blockTransfer(false);`
$DIR/test/revert.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Works when ERC20 tokens return falsey values"}
$DIR/test/revert.spec.ts: `await testERC20.mint(buyer.address, tokenAmount);`
$DIR/test/revert.spec.ts: `await testERC20.setNoReturnData(true);`
$DIR/test/revert.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: toKey(0),
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/revert.spec.ts: `await testERC20.setNoReturnData(false);`
{"Reverts when ERC20 tokens return falsey values (via conduit)"}
$DIR/test/revert.spec.ts: `await set1155ApprovalForAll(seller, conduitOne.address, true);`
$DIR/test/revert.spec.ts: `await testERC20.mint(buyer.address, tokenAmount);`
$DIR/test/revert.spec.ts: `await testERC20.blockTransfer(true);`
$DIR/test/revert.spec.ts: `success = receipt.status === 1;`
$DIR/test/revert.spec.ts: `await testERC20.blockTransfer(false);`
$DIR/test/revert.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            conduitKeyOne,
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: conduitKeyOne,
            },
          ],
          undefined,
          []
        );

        return receipt;
      });`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Reverts when providing non-existent conduit"}
$DIR/test/revert.spec.ts: `await set1155ApprovalForAll(seller, conduitOne.address, true);`
$DIR/test/revert.spec.ts: `await testERC20.mint(buyer.address, tokenAmount);`
$DIR/test/revert.spec.ts: `await withBalanceChecks([order], 0, [], async () => {
        const tx = marketplaceContract
          .connect(buyer)
          .fulfillAdvancedOrder(
            order,
            [],
            conduitKeyOne,
            ethers.constants.AddressZero,
            {
              value,
            }
          );
        const receipt = await (await tx).wait();
        await checkExpectedEvents(
          tx,
          receipt,
          [
            {
              order,
              orderHash,
              fulfiller: buyer.address,
              fulfillerConduitKey: conduitKeyOne,
            },
          ],
          undefined,
          undefined
        );
        return receipt;
      });`
$DIR/test/revert.spec.ts: `orderStatus = await marketplaceContract.getOrderStatus(orderHash);`
{"Reverts when 1155 tokens are not approved"}
$DIR/test/revert.spec.ts: `await set1155ApprovalForAll(seller, marketplaceContract.address, true);`
{"Reverts if BasicOrderParameters has non-default offset"}
$DIR/test/revert.spec.ts: `calldata = calldata as string;`
{"Reverts if additionalRecipients has non-default offset"}
$DIR/test/revert.spec.ts: `calldata = calldata as string;`
{"Reverts if signature has non-default offset"}
$DIR/test/revert.spec.ts: `calldata = calldata as string;`
{"Reverts on a reentrant call to fulfillOrder"}
$DIR/test/revert.spec.ts: `await tx.wait();`
{"Reverts on a reentrant call to fulfillBasicOrder"}
$DIR/test/revert.spec.ts: `await tx.wait();`
{"Reverts on a reentrant call to fulfillBasicOrder_efficient_6GL6yc"}
$DIR/test/revert.spec.ts: `await tx.wait();`
{"Reverts on a reentrant call to fulfillAdvancedOrder"}
$DIR/test/revert.spec.ts: `order.numerator = 2;`
$DIR/test/revert.spec.ts: `order.denominator = 10;`
$DIR/test/revert.spec.ts: `await tx.wait();`
{"Reverts on a reentrant call to fulfillAvailableOrders"}
$DIR/test/revert.spec.ts: `await tx.wait();`
{"Reverts on a reentrant call to fulfillAvailableAdvancedOrders"}
$DIR/test/revert.spec.ts: `await tx.wait();`
{"Reverts on a reentrant call to matchOrders"}
$DIR/test/revert.spec.ts: `await tx.wait();`
{"Reverts on a reentrant call to matchAdvancedOrders"}
$DIR/test/revert.spec.ts: `order.numerator = 2;`
$DIR/test/revert.spec.ts: `order.denominator = 10;`
$DIR/test/revert.spec.ts: `await tx.wait();`
{"Reverts on a reentrant call to cancel"}
$DIR/test/revert.spec.ts: `await tx.wait();`
{"Reverts on a reentrant call to validate"}
$DIR/test/revert.spec.ts: `await tx.wait();`
{"Reverts on a reentrant call to incrementCounter"}
$DIR/test/revert.spec.ts: `await tx.wait();`
{"matchOrders allows fulfilling with native offer items"}
$DIR/test/revert.spec.ts: `await mintAndApproveERC20(
        buyer,
        marketplaceContract.address,
        tokenAmount
      );`
{"matchAdvancedOrders allows fulfilling with native offer items"}
$DIR/test/revert.spec.ts: `await mintAndApproveERC20(
        buyer,
        marketplaceContract.address,
        tokenAmount
      );`
{"Fulfillment reverts if contract offerer is an EOA"}
$DIR/test/revert.spec.ts: `await set721ApprovalForAll(seller, offererContract.address);`
$DIR/test/revert.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/revert.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/revert.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/revert.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/revert.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 1;`
$DIR/test/revert.spec.ts: `order.signature = "0x";`
{"Fulfillment does not revert when valid"}
$DIR/test/revert.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/revert.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/revert.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/revert.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/revert.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 1;`
$DIR/test/revert.spec.ts: `order.signature = "0x";`
{"Fulfillment reverts if contract offerer returns no data"}
$DIR/test/revert.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/revert.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/revert.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/revert.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/revert.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 1;`
$DIR/test/revert.spec.ts: `order.signature = "0x";`
{"Fulfillment bubbles up error if contract offerer reverts with data"}
$DIR/test/revert.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/revert.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/revert.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/revert.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/revert.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 1;`
$DIR/test/revert.spec.ts: `order.signature = "0x";`
{"Fulfillment reverts if contract offerer returns with garbage data"}
$DIR/test/revert.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/revert.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/revert.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/revert.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/revert.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 1;`
$DIR/test/revert.spec.ts: `order.signature = "0x";`
{"Fulfillment reverts when valid order included with contract order where offerer returns bad data"}
$DIR/test/revert.spec.ts: `offer[0].identifier = offer[0].identifierOrCriteria;`
$DIR/test/revert.spec.ts: `offer[0].amount = offer[0].endAmount;`
$DIR/test/revert.spec.ts: `consideration[0].identifier = consideration[0].identifierOrCriteria;`
$DIR/test/revert.spec.ts: `consideration[0].amount = consideration[0].endAmount;`
$DIR/test/revert.spec.ts: `order.parameters.offerer = offererContract.address;`
$DIR/test/revert.spec.ts: `order.numerator = 1;`
$DIR/test/revert.spec.ts: `order.denominator = 1;`
$DIR/test/revert.spec.ts: `order.signature = "0x";`
{"Reverts on bad fraction amounts"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on inexact fraction amounts"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on partial fill attempt when not supported by order"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on partially filled order via basic fulfillment"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on fully filled order"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on non-zero unused item parameters (identifier set on native, basic, ERC721)"}
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on non-zero unused item parameters (identifier set on ERC20, basic, ERC721)"}
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on non-zero unused item parameters (identifier set on native, basic, ERC1155)"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on non-zero unused item parameters (identifier set on ERC20, basic)"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on non-zero unused item parameters (token set on native, standard)"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on non-zero unused item parameters (identifier set on native, standard)"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on non-zero unused item parameters (identifier set on ERC20, standard)"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on inadequate consideration items"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.parameters.consideration.pop()`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts on invalid submitter when required by order"}
$DIR/test/revert.spec.ts: `.connect(zone)`
$DIR/test/revert.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on invalid signatures"}
$DIR/test/revert.spec.ts: `.signature.slice(0, -2)`
$DIR/test/revert.spec.ts: `.padStart(64, "0")`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.populateTransaction.fulfillBasicOrder(basicOrderParameters, {
          value,
        })`
$DIR/test/revert.spec.ts: `.call(tx)`
$DIR/test/revert.spec.ts: `.padEnd(130, "f")`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.populateTransaction.fulfillBasicOrder(basicOrderParameters, {
          value,
        })`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
            value,
          })`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on invalid 1271 signature"}
$DIR/test/revert.spec.ts: `.mint(buyer.address, tokenAmount)`
$DIR/test/revert.spec.ts: `.sub(100)`
$DIR/test/revert.spec.ts: `.sub(100)`
{"Reverts on invalid contract 1271 signature and contract does not supply a revert reason"}
$DIR/test/revert.spec.ts: `.connect(owner)`
$DIR/test/revert.spec.ts: `.revertWithMessage(false)`
$DIR/test/revert.spec.ts: `.mint(buyer.address, tokenAmount)`
$DIR/test/revert.spec.ts: `.sub(100)`
$DIR/test/revert.spec.ts: `.sub(100)`
{"Reverts on invalid contract 1271 signature and contract does not return magic value"}
$DIR/test/revert.spec.ts: `.connect(owner)`
$DIR/test/revert.spec.ts: `.setValid(false)`
$DIR/test/revert.spec.ts: `.mint(buyer.address, tokenAmount)`
$DIR/test/revert.spec.ts: `.sub(100)`
$DIR/test/revert.spec.ts: `.sub(100)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.populateTransaction.fulfillBasicOrder(basicOrderParameters)`
$DIR/test/revert.spec.ts: `.call(tx)`
$DIR/test/revert.spec.ts: `.connect(owner)`
{"Reverts on restricted order where isValidOrder reverts with no data"}
$DIR/test/revert.spec.ts: `.padEnd(65, "0")`
{"Reverts on restricted order where isValidOrder returns non-magic value"}
$DIR/test/revert.spec.ts: `.padEnd(65, "0")`
{"Reverts on missing offer or consideration components"}
$DIR/test/revert.spec.ts: `.connect(owner)`
$DIR/test/revert.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on mismatched offer and consideration components"}
$DIR/test/revert.spec.ts: `.connect(owner)`
$DIR/test/revert.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on mismatched offer components"}
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Reverts on mismatched offer components (branch coverage 1)"}
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Reverts on invalid matching offerer (branch coverage 2)"}
$DIR/test/revert.spec.ts: `.map((o) => ({ ...o }))`
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Reverts on invalid matching conduit key (branch coverage 3)"}
$DIR/test/revert.spec.ts: `.map((o) => ({ ...o }))`
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Reverts on invalid matching itemType (branch coverage 4)"}
$DIR/test/revert.spec.ts: `.map((o) => ({ ...o }))`
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Reverts on invalid matching token"}
$DIR/test/revert.spec.ts: `.map((o) => ({ ...o }))`
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Reverts on invalid matching recipient"}
$DIR/test/revert.spec.ts: `.map((o) => ({ ...o }))`
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Reverts on invalid matching itemType"}
$DIR/test/revert.spec.ts: `.map((o) => ({ ...o }))`
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Reverts on invalid matching token"}
$DIR/test/revert.spec.ts: `.map((o) => ({ ...o }))`
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Reverts on invalid matching identifier"}
$DIR/test/revert.spec.ts: `.map((o) => ({ ...o }))`
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Reverts on mismatched consideration components"}
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Reverts on fulfillment component with out-of-range order"}
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Reverts on fulfillment component with out-of-range initial order on fulfillAvailableOrders"}
$DIR/test/revert.spec.ts: `.div(2)`
$DIR/test/revert.spec.ts: `.div(2)`
$DIR/test/revert.spec.ts: `.div(2)`
$DIR/test/revert.spec.ts: `.div(2)`
{"Reverts on unmet consideration items"}
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
{"Reverts on fulfillAvailableAdvancedOrders no available components"}
$DIR/test/revert.spec.ts: `.div(2)`
$DIR/test/revert.spec.ts: `.div(2)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillOrder(orderThree, toKey(0), {
            value,
          })`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on out-of-range criteria resolvers"}
$DIR/test/revert.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/revert.spec.ts: `.mint(seller.address, secondNFTId)`
$DIR/test/revert.spec.ts: `.mint(seller.address, thirdNFTId)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            criteriaResolvers,
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on unresolved criteria items"}
$DIR/test/revert.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/revert.spec.ts: `.mint(buyer.address, secondNFTId)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            criteriaResolvers,
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on unresolved criteria items (match)"}
$DIR/test/revert.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/revert.spec.ts: `.mint(seller.address, secondNFTId)`
{"Reverts on attempts to resolve criteria for non-criteria item"}
$DIR/test/revert.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/revert.spec.ts: `.mint(seller.address, secondNFTId)`
$DIR/test/revert.spec.ts: `.mint(seller.address, thirdNFTId)`
{"Reverts on offer amount overflow"}
$DIR/test/revert.spec.ts: `.mint(seller.address, ethers.constants.MaxUint256)`
$DIR/test/revert.spec.ts: `.connect(seller)`
$DIR/test/revert.spec.ts: `.approve(marketplaceContract.address, ethers.constants.MaxUint256)`
{"Reverts on offer amount overflow when another amount is 0"}
$DIR/test/revert.spec.ts: `.mint(seller.address, ethers.constants.MaxUint256)`
$DIR/test/revert.spec.ts: `.connect(seller)`
$DIR/test/revert.spec.ts: `.approve(marketplaceContract.address, ethers.constants.MaxUint256)`
{"Reverts on consideration amount overflow"}
$DIR/test/revert.spec.ts: `.mint(seller.address, ethers.constants.MaxUint256)`
$DIR/test/revert.spec.ts: `.connect(seller)`
$DIR/test/revert.spec.ts: `.approve(marketplaceContract.address, ethers.constants.MaxUint256)`
{"Reverts on consideration amount overflow when another amount is 0"}
$DIR/test/revert.spec.ts: `.mint(buyer.address, ethers.constants.MaxUint256)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.approve(marketplaceContract.address, ethers.constants.MaxUint256)`
{"Reverts on supplying a criteria proof to a collection-wide criteria item"}
$DIR/test/revert.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/revert.spec.ts: `.mint(seller.address, secondNFTId)`
$DIR/test/revert.spec.ts: `.mint(seller.address, thirdNFTId)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            criteriaResolvers,
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on supplying a criteria proof to a collection-wide criteria item (aggregate)"}
$DIR/test/revert.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/revert.spec.ts: `.mint(seller.address, secondNFTId)`
$DIR/test/revert.spec.ts: `.mint(seller.address, thirdNFTId)`
$DIR/test/revert.spec.ts: `.map(toFulfillmentComponents)`
{"Reverts on invalid criteria proof"}
$DIR/test/revert.spec.ts: `.mint(seller.address, nftId)`
$DIR/test/revert.spec.ts: `.mint(seller.address, secondNFTId)`
$DIR/test/revert.spec.ts: `.mint(seller.address, thirdNFTId)`
$DIR/test/revert.spec.ts: `.identifier.add(1)`
$DIR/test/revert.spec.ts: `.identifier.sub(1)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            criteriaResolvers,
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts when no ether is supplied (basic)"}
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
            value,
          })`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts when not enough ether is supplied (basic)"}
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillBasicOrder(basicOrderParameters, {
            value,
          })`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts when not enough ether is supplied as offer item (match)"}
$DIR/test/revert.spec.ts: `.connect(buyer)`
{"Reverts when not enough ether is supplied (standard + advanced)"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value: value.add(1),
            }
          )`
$DIR/test/revert.spec.ts: `.add(1)`
$DIR/test/revert.spec.ts: `.wait()`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts when not enough ether is supplied (match)"}
$DIR/test/revert.spec.ts: `.connect(owner)`
$DIR/test/revert.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts when ether transfer fails (basic)"}
$DIR/test/revert.spec.ts: `.mint(buyer.address, tokenAmount)`
{"Reverts when tokens are not approved"}
$DIR/test/revert.spec.ts: `.mint(buyer.address, tokenAmount)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts when 1155 token transfer reverts"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
{"Reverts when 1155 token transfer reverts (via conduit)"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
{"Reverts when 1155 token transfer reverts (via conduit, returndata)"}
$DIR/test/revert.spec.ts: `.getContractFactory("ExcessReturnDataRecipient")`
$DIR/test/revert.spec.ts: `.deploy()`
$DIR/test/revert.spec.ts: `.mint(seller.address, tokenAmount)`
$DIR/test/revert.spec.ts: `.mint(buyer.address, nftId, amount.mul(10000))`
$DIR/test/revert.spec.ts: `.mul(10000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.estimateGas.fulfillAdvancedOrder(
            initialOrder,
            [],
            conduitKeyOne,
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.setRevertDataSize(1)`
{"Reverts when transferred item amount is zero"}
$DIR/test/revert.spec.ts: `.mint(buyer.address, tokenAmount)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
{"Reverts when aggregating zero-amount items"}
$DIR/test/revert.spec.ts: `.mint(buyer.address, 1000)`
$DIR/test/revert.spec.ts: `.mul(100)`
$DIR/test/revert.spec.ts: `.mul(100)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.map(toFulfillmentComponents)`
{"Reverts when ERC20 tokens return falsey values"}
$DIR/test/revert.spec.ts: `.mint(buyer.address, tokenAmount)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.blockTransfer(true)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.blockTransfer(false)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Works when ERC20 tokens return falsey values"}
$DIR/test/revert.spec.ts: `.mint(buyer.address, tokenAmount)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.setNoReturnData(true)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.setNoReturnData(false)`
$DIR/test/revert.spec.ts: `.noReturnData()`
{"Reverts when ERC20 tokens return falsey values (via conduit)"}
$DIR/test/revert.spec.ts: `.mint(buyer.address, tokenAmount)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.blockTransfer(true)`
$DIR/test/revert.spec.ts: `.interface.encodeFunctionData(
          "fulfillAdvancedOrder",
          [order, [], conduitKeyOne, ethers.constants.AddressZero]
        )`
$DIR/test/revert.spec.ts: `.populateTransaction({
          from: buyer.address,
          to: marketplaceContract.address,
          value,
          data,
          gasLimit: 30_000_000,
        })`
$DIR/test/revert.spec.ts: `.call(fullTx)`
$DIR/test/revert.spec.ts: `.interface.encodeErrorResult(
          "BadReturnValueFromERC20OnTransfer",
          [testERC20.address, buyer.address, seller.address, amount.mul(1000)]
        )`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
              order,
              [],
              conduitKeyOne,
              ethers.constants.AddressZero,
              {
                value,
              }
            )`
$DIR/test/revert.spec.ts: `.wait()`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.blockTransfer(false)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            conduitKeyOne,
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts when providing non-existent conduit"}
$DIR/test/revert.spec.ts: `.mint(buyer.address, tokenAmount)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.constants.HashZero.slice(0, -1)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            conduitKeyOne,
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts when 1155 tokens are not approved"}
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.connect(owner)`
$DIR/test/revert.spec.ts: `.matchOrders([order, mirrorOrder], fulfillments, {
          value,
        })`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts when token account with no code is supplied"}
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
{"Reverts when 1155 token is not approved via conduit"}
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts when 1155 token with no code is supplied as the token via conduit"}
$DIR/test/revert.spec.ts: `.map(([offerArr, considerationArr]) =>
        toFulfillment(offerArr, considerationArr)
      )`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Reverts if BasicOrderParameters has non-default offset"}
$DIR/test/revert.spec.ts: `.slice(0, 73)`
$DIR/test/revert.spec.ts: `.slice(74)`
$DIR/test/revert.spec.ts: `.join("")`
{"Reverts if additionalRecipients has non-default offset"}
$DIR/test/revert.spec.ts: `.slice(0, 1161)`
$DIR/test/revert.spec.ts: `.slice(1162)`
$DIR/test/revert.spec.ts: `.join(
        ""
      )`
{"Reverts if signature has non-default offset"}
$DIR/test/revert.spec.ts: `.slice(0, 1161)`
$DIR/test/revert.spec.ts: `.slice(1162)`
$DIR/test/revert.spec.ts: `.join(
        ""
      )`
{"Reverts on a reentrant call to fulfillOrder"}
$DIR/test/revert.spec.ts: `.interface.encodeFunctionData(
        "fulfillOrder",
        [order, toKey(0)]
      )`
$DIR/test/revert.spec.ts: `.prepare(
        marketplaceContract.address,
        0,
        callData
      )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on a reentrant call to fulfillBasicOrder"}
$DIR/test/revert.spec.ts: `.interface.encodeFunctionData(
        "fulfillBasicOrder",
        [basicOrderParameters]
      )`
$DIR/test/revert.spec.ts: `.prepare(
        marketplaceContract.address,
        value,
        callData
      )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on a reentrant call to fulfillBasicOrder_efficient_6GL6yc"}
$DIR/test/revert.spec.ts: `.interface.encodeFunctionData(
        "fulfillBasicOrder_efficient_6GL6yc",
        [basicOrderParameters]
      )`
$DIR/test/revert.spec.ts: `.prepare(
        marketplaceContract.address,
        value,
        callData
      )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on a reentrant call to fulfillAdvancedOrder"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.interface.encodeFunctionData(
        "fulfillAdvancedOrder",
        [order, [], toKey(0), ethers.constants.AddressZero]
      )`
$DIR/test/revert.spec.ts: `.prepare(
        marketplaceContract.address,
        value,
        callData
      )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on a reentrant call to fulfillAvailableOrders"}
$DIR/test/revert.spec.ts: `.map(toFulfillmentComponents)`
$DIR/test/revert.spec.ts: `.interface.encodeFunctionData(
        "fulfillAvailableOrders",
        [[order], offerComponents, considerationComponents, toKey(0), 100]
      )`
$DIR/test/revert.spec.ts: `.prepare(
        marketplaceContract.address,
        value,
        callData
      )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on a reentrant call to fulfillAvailableAdvancedOrders"}
$DIR/test/revert.spec.ts: `.interface.encodeFunctionData(
        "fulfillAvailableAdvancedOrders",
        [
          [order],
          [],
          offerComponents,
          considerationComponents,
          toKey(0),
          ethers.constants.AddressZero,
          100,
        ]
      )`
$DIR/test/revert.spec.ts: `.prepare(
        marketplaceContract.address,
        value,
        callData
      )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on a reentrant call to matchOrders"}
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.interface.encodeFunctionData(
        "matchOrders",
        [[order, mirrorOrder], fulfillments]
      )`
$DIR/test/revert.spec.ts: `.prepare(
        marketplaceContract.address,
        value,
        callData
      )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on a reentrant call to matchAdvancedOrders"}
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(1000)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(10)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.mul(20)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.interface.encodeFunctionData(
        "matchAdvancedOrders",
        [
          [order, mirrorObject.mirrorOrder],
          [],
          fulfillments,
          ethers.constants.AddressZero,
        ]
      )`
$DIR/test/revert.spec.ts: `.prepare(
        marketplaceContract.address,
        value,
        callData
      )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on a reentrant call to cancel"}
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.interface.encodeFunctionData(
        "cancel",
        [[orderComponents]]
      )`
$DIR/test/revert.spec.ts: `.prepare(
        marketplaceContract.address,
        0,
        callData
      )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on a reentrant call to validate"}
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.interface.encodeFunctionData(
        "validate",
        [[order]]
      )`
$DIR/test/revert.spec.ts: `.prepare(
        marketplaceContract.address,
        0,
        callData
      )`
$DIR/test/revert.spec.ts: `.wait()`
{"Reverts on a reentrant call to incrementCounter"}
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.interface.encodeFunctionData("incrementCounter")`
$DIR/test/revert.spec.ts: `.prepare(
        marketplaceContract.address,
        0,
        callData
      )`
$DIR/test/revert.spec.ts: `.wait()`
{"matchOrders allows fulfilling with native offer items"}
$DIR/test/revert.spec.ts: `.connect(owner)`
{"matchAdvancedOrders allows fulfilling with native offer items"}
$DIR/test/revert.spec.ts: `.connect(owner)`
{"Fulfillment reverts if contract offerer is an EOA"}
$DIR/test/revert.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/revert.spec.ts: `.address.toLowerCase()`
$DIR/test/revert.spec.ts: `.toHexString()`
$DIR/test/revert.spec.ts: `.slice(2)`
$DIR/test/revert.spec.ts: `.padStart(24, "0")`
{"Fulfillment does not revert when valid"}
$DIR/test/revert.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/revert.spec.ts: `.address.toLowerCase()`
$DIR/test/revert.spec.ts: `.toHexString()`
$DIR/test/revert.spec.ts: `.slice(2)`
$DIR/test/revert.spec.ts: `.padStart(24, "0")`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.connect(buyer)`
$DIR/test/revert.spec.ts: `.fulfillAdvancedOrder(
            order,
            [],
            toKey(0),
            ethers.constants.AddressZero,
            {
              value,
            }
          )`
$DIR/test/revert.spec.ts: `.wait()`
{"Fulfillment reverts if contract offerer returns no data"}
$DIR/test/revert.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/revert.spec.ts: `.address.toLowerCase()`
$DIR/test/revert.spec.ts: `.toHexString()`
$DIR/test/revert.spec.ts: `.slice(2)`
$DIR/test/revert.spec.ts: `.padStart(24, "0")`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Fulfillment bubbles up error if contract offerer reverts with data"}
$DIR/test/revert.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/revert.spec.ts: `.address.toLowerCase()`
$DIR/test/revert.spec.ts: `.toHexString()`
$DIR/test/revert.spec.ts: `.slice(2)`
$DIR/test/revert.spec.ts: `.padStart(24, "0")`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Fulfillment reverts if contract offerer returns with garbage data"}
$DIR/test/revert.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/revert.spec.ts: `.address.toLowerCase()`
$DIR/test/revert.spec.ts: `.toHexString()`
$DIR/test/revert.spec.ts: `.slice(2)`
$DIR/test/revert.spec.ts: `.padStart(24, "0")`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
{"Fulfillment reverts when valid order included with contract order where offerer returns bad data"}
$DIR/test/revert.spec.ts: `.getContractOffererNonce(
          offererContract.address
        )`
$DIR/test/revert.spec.ts: `.address.toLowerCase()`
$DIR/test/revert.spec.ts: `.toHexString()`
$DIR/test/revert.spec.ts: `.slice(2)`
$DIR/test/revert.spec.ts: `.padStart(24, "0")`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash)`
$DIR/test/revert.spec.ts: `.getOrderStatus(orderHash2)`
{"Should be able to fulfill orders through a single Seaport contract"}
$DIR/test/router.spec.ts: `await router.connect(buyer).fulfillAvailableAdvancedOrders(params, {
        value,
      });`
{"Should be able to fulfill orders through multiple Seaport contracts"}
$DIR/test/router.spec.ts: `await router.connect(buyer).fulfillAvailableAdvancedOrders(params, {
        value: value.mul(2),
      });`
{"Should respect maximumFulfilled across multiple Seaport contracts"}
$DIR/test/router.spec.ts: `await router.connect(buyer).fulfillAvailableAdvancedOrders(params, {
        value: value.mul(2),
      });`
{"Should be able to fulfill orders through multiple Seaport contracts using conduit"}
$DIR/test/router.spec.ts: `await set721ApprovalForAll(seller, conduitOne.address, true);`
$DIR/test/router.spec.ts: `await router.connect(buyer).fulfillAvailableAdvancedOrders(params, {
        value: value.mul(2),
      });`
{"Should process valid orders while skipping invalid orders"}
$DIR/test/router.spec.ts: `await router.connect(buyer).fulfillAvailableAdvancedOrders(
        {
          ...params,
          seaportContracts: params.seaportContracts.slice(0, 1),
          advancedOrderParams: params.advancedOrderParams.slice(0, 1),
        },
        {
          value,
        }
      );`
$DIR/test/router.spec.ts: `await router.connect(buyer).fulfillAvailableAdvancedOrders(params, {
        value: value.mul(2),
      });`
{"Should revert if cannot return excess ether value"}
$DIR/test/router.spec.ts: `await tx.wait();`
{"Should not be able to reenter through receive()"}
$DIR/test/router.spec.ts: `await tx.wait();`
{"Should not be able to receive ether from a non-Seaport address"}
$DIR/test/router.spec.ts: `await network.provider.request({
        method: "hardhat_impersonateAccount",
        params: [marketplaceContract.address],
      });`
$DIR/test/router.spec.ts: `await faucet(marketplaceContract.address, provider);`
$DIR/test/router.spec.ts: `await seaportSigner.sendTransaction({ to: router.address, value: 1 });`
{"Should revert on all errors except NoSpecifiedOrdersAvailable()"}
$DIR/test/router.spec.ts: `await router.connect(buyer).fulfillAvailableAdvancedOrders(
      {
        ...params,
        seaportContracts: params.seaportContracts.slice(0, 1),
        advancedOrderParams: params.advancedOrderParams.slice(0, 1),
      },
      {
        value,
      }
    );`
$DIR/test/router.spec.ts: `await router.connect(buyer).fulfillAvailableAdvancedOrders(params, {
      value: value.mul(2),
    });`
$DIR/test/router.spec.ts: `params.advancedOrderParams[0].advancedOrders[0].parameters.orderType = 4;`
{"Should be able to fulfill orders through a single Seaport contract"}
$DIR/test/router.spec.ts: `.connect(buyer)`
$DIR/test/router.spec.ts: `.fulfillAvailableAdvancedOrders(params, {
        value,
      })`
{"Should be able to fulfill orders through multiple Seaport contracts"}
$DIR/test/router.spec.ts: `.connect(buyer)`
$DIR/test/router.spec.ts: `.fulfillAvailableAdvancedOrders(params, {
        value: value.mul(2),
      })`
$DIR/test/router.spec.ts: `.mul(2)`
{"Should respect maximumFulfilled across multiple Seaport contracts"}
$DIR/test/router.spec.ts: `.connect(buyer)`
$DIR/test/router.spec.ts: `.fulfillAvailableAdvancedOrders(params, {
        value: value.mul(2),
      })`
$DIR/test/router.spec.ts: `.mul(2)`
{"Should be able to fulfill orders through multiple Seaport contracts using conduit"}
$DIR/test/router.spec.ts: `.connect(buyer)`
$DIR/test/router.spec.ts: `.fulfillAvailableAdvancedOrders(params, {
        value: value.mul(2),
      })`
$DIR/test/router.spec.ts: `.mul(2)`
{"Should process valid orders while skipping invalid orders"}
$DIR/test/router.spec.ts: `.getBalance(buyer.address)`
$DIR/test/router.spec.ts: `.connect(buyer)`
$DIR/test/router.spec.ts: `.fulfillAvailableAdvancedOrders(
        {
          ...params,
          seaportContracts: params.seaportContracts.slice(0, 1),
          advancedOrderParams: params.advancedOrderParams.slice(0, 1),
        },
        {
          value,
        }
      )`
$DIR/test/router.spec.ts: `.seaportContracts.slice(0, 1)`
$DIR/test/router.spec.ts: `.advancedOrderParams.slice(0, 1)`
$DIR/test/router.spec.ts: `.connect(buyer)`
$DIR/test/router.spec.ts: `.fulfillAvailableAdvancedOrders(params, {
        value: value.mul(2),
      })`
$DIR/test/router.spec.ts: `.mul(2)`
$DIR/test/router.spec.ts: `.getBalance(buyer.address)`
$DIR/test/router.spec.ts: `.sub(value.mul(3))`
$DIR/test/router.spec.ts: `.mul(3)`
{"Should revert if cannot return excess ether value"}
$DIR/test/router.spec.ts: `.prepare(testERC721.address, 0, [])`
$DIR/test/router.spec.ts: `.wait()`
$DIR/test/router.spec.ts: `.interface.encodeFunctionData(
        "fulfillAvailableAdvancedOrders",
        [params]
      )`
{"Should not be able to reenter through receive()"}
$DIR/test/router.spec.ts: `.interface.encodeFunctionData(
        "fulfillAvailableAdvancedOrders",
        [params]
      )`
$DIR/test/router.spec.ts: `.prepare(router.address, 0, callData)`
$DIR/test/router.spec.ts: `.wait()`
$DIR/test/router.spec.ts: `.interface.getSighash("NoReentrantCalls")`
{"Should not be able to receive ether from a non-Seaport address"}
$DIR/test/router.spec.ts: `.signTransaction({
        to: router.address,
        value: 1,
        nonce: await owner.getTransactionCount(),
        gasPrice: await provider.getGasPrice(),
        gasLimit: 50_000,
      })`
$DIR/test/router.spec.ts: `.getTransactionCount()`
$DIR/test/router.spec.ts: `.getGasPrice()`
$DIR/test/router.spec.ts: `.provider.request({
        method: "hardhat_impersonateAccount",
        params: [marketplaceContract.address],
      })`
$DIR/test/router.spec.ts: `.getSigner(marketplaceContract.address)`
$DIR/test/router.spec.ts: `.sendTransaction({ to: router.address, value: 1 })`
{"Should revert on all errors except NoSpecifiedOrdersAvailable()"}
$DIR/test/router.spec.ts: `.getBalance(buyer.address)`
$DIR/test/router.spec.ts: `.connect(buyer)`
$DIR/test/router.spec.ts: `.fulfillAvailableAdvancedOrders(
      {
        ...params,
        seaportContracts: params.seaportContracts.slice(0, 1),
        advancedOrderParams: params.advancedOrderParams.slice(0, 1),
      },
      {
        value,
      }
    )`
$DIR/test/router.spec.ts: `.seaportContracts.slice(0, 1)`
$DIR/test/router.spec.ts: `.advancedOrderParams.slice(0, 1)`
$DIR/test/router.spec.ts: `.connect(buyer)`
$DIR/test/router.spec.ts: `.fulfillAvailableAdvancedOrders(params, {
      value: value.mul(2),
    })`
$DIR/test/router.spec.ts: `.mul(2)`
$DIR/test/router.spec.ts: `.getBalance(buyer.address)`
{"Executes transfers (many token types) with a conduit"}
$DIR/test/transferhelper.spec.ts: `erc20Contracts[i] = tempERC20Contract;`
$DIR/test/transferhelper.spec.ts: `erc20Transfers[i] = erc20Transfer;`
$DIR/test/transferhelper.spec.ts: `erc721Contracts[i] = tempERC721Contract;`
$DIR/test/transferhelper.spec.ts: `erc721Transfers[i] = erc721Transfer;`
$DIR/test/transferhelper.spec.ts: `erc1155Contracts[i] = tempERC1155Contract;`
$DIR/test/transferhelper.spec.ts: `erc1155Transfers[i] = erc1155Transfer;`
$DIR/test/transferhelper.spec.ts: `transfersWithRecipients[0] = createTransferWithRecipient(
        transfers,
        recipient.address,
        true
      );`
$DIR/test/transferhelper.spec.ts: `await tempTransferHelper
        .connect(sender)
        .bulkTransfer(transfersWithRecipients, tempConduitKey);`
{"Cannot execute transfers (many token types) without a conduit"}
$DIR/test/transferhelper.spec.ts: `erc20Contracts[i] = tempERC20Contract;`
$DIR/test/transferhelper.spec.ts: `erc20Transfers[i] = erc20Transfer;`
$DIR/test/transferhelper.spec.ts: `erc721Contracts[i] = tempERC721Contract;`
$DIR/test/transferhelper.spec.ts: `erc721Transfers[i] = erc721Transfer;`
$DIR/test/transferhelper.spec.ts: `erc1155Contracts[i] = tempERC1155Contract;`
$DIR/test/transferhelper.spec.ts: `erc1155Transfers[i] = erc1155Transfer;`
$DIR/test/transferhelper.spec.ts: `transfersWithRecipients[0] = createTransferWithRecipient(
        transfers,
        recipient.address,
        true
      );`
{"Cannot execute ERC721 transfers to a contract recipient without a conduit"}
$DIR/test/transferhelper.spec.ts: `erc721Contracts[i] = tempERC721Contract;`
$DIR/test/transferhelper.spec.ts: `erc721Transfers[i] = erc721Transfer;`
$DIR/test/transferhelper.spec.ts: `transfersWithRecipients[0] = createTransferWithRecipient(
        erc721Transfers,
        erc721Recipient.address,
        true
      );`
{"Reverts when no revert string is returned from call to conduit"}
$DIR/test/transferhelper.spec.ts: `await tempERC1155Contract.connect(owner).mint(sender.address, 0, 100);`
$DIR/test/transferhelper.spec.ts: `await mockConduitController
        .connect(owner)
        .createConduit(mockConduitKey, owner.address);`
$DIR/test/transferhelper.spec.ts: `await tempERC1155Contract
        .connect(sender)
        .setApprovalForAll(mockConduitAddress, true);`
{"Reverts with invalid magic value returned by call to conduit"}
$DIR/test/transferhelper.spec.ts: `await tempERC20Contract.connect(owner).mint(sender.address, 100);`
$DIR/test/transferhelper.spec.ts: `await mockConduitController
        .connect(owner)
        .createConduit(mockConduitKey, owner.address);`
$DIR/test/transferhelper.spec.ts: `await tempERC20Contract.connect(sender).approve(mockConduitAddress, 100);`
{"Reverts with conduit revert data"}
$DIR/test/transferhelper.spec.ts: `await tempERC20Contract.connect(owner).mint(sender.address, 100);`
$DIR/test/transferhelper.spec.ts: `await mockConduitController
        .connect(owner)
        .createConduit(mockConduitKey, owner.address);`
$DIR/test/transferhelper.spec.ts: `await tempERC20Contract.connect(sender).approve(mockConduitAddress, 100);`
{"Executes transfers with multiple recipients (many token types) with a conduit"}
$DIR/test/transferhelper.spec.ts: `erc20Contracts[i] = tempERC20Contract;`
$DIR/test/transferhelper.spec.ts: `erc20Transfers[i] = erc20Transfer;`
$DIR/test/transferhelper.spec.ts: `erc721Contracts[i] = tempERC721Contract;`
$DIR/test/transferhelper.spec.ts: `erc721Transfers[i] = erc721Transfer;`
$DIR/test/transferhelper.spec.ts: `erc1155Contracts[i] = tempERC1155Contract;`
$DIR/test/transferhelper.spec.ts: `erc1155Transfers[i] = erc1155Transfer;`
$DIR/test/transferhelper.spec.ts: `allContracts.push(
          ...erc20Contracts,
          ...erc721Contracts,
          ...erc1155Contracts
        );`
$DIR/test/transferhelper.spec.ts: `transfersWithRecipients[j] = createTransferWithRecipient(
          transfers,
          transferRecipient,
          true
        );`
$DIR/test/transferhelper.spec.ts: `await tempTransferHelper
        .connect(sender)
        .bulkTransfer(transfersWithRecipients, tempConduitKey);`
$DIR/test/transferhelper.spec.ts: `contractsStartingIndex++;`
{"Cannot execute transfers with multiple recipients (many token types) without a conduit"}
$DIR/test/transferhelper.spec.ts: `erc20Contracts[i] = tempERC20Contract;`
$DIR/test/transferhelper.spec.ts: `erc20Transfers[i] = erc20Transfer;`
$DIR/test/transferhelper.spec.ts: `erc721Contracts[i] = tempERC721Contract;`
$DIR/test/transferhelper.spec.ts: `erc721Transfers[i] = erc721Transfer;`
$DIR/test/transferhelper.spec.ts: `erc1155Contracts[i] = tempERC1155Contract;`
$DIR/test/transferhelper.spec.ts: `erc1155Transfers[i] = erc1155Transfer;`
$DIR/test/transferhelper.spec.ts: `allContracts.push(
          ...erc20Contracts,
          ...erc721Contracts,
          ...erc1155Contracts
        );`
$DIR/test/transferhelper.spec.ts: `transfersWithRecipientsNoConduit[j] = createTransferWithRecipient(
          transfers,
          transferRecipient,
          true
        );`
{"Cannot execute ERC721 transfers to multiple contract recipients without a conduit"}
$DIR/test/transferhelper.spec.ts: `erc721Contracts[j] = tempERC721Contract;`
$DIR/test/transferhelper.spec.ts: `erc721Items[j] = erc721Transfer;`
$DIR/test/transferhelper.spec.ts: `transfersWithRecipients[i] = createTransferWithRecipient(
          erc721Items,
          erc721Recipients[i].address,
          true
        );`
$DIR/test/transferhelper.spec.ts: `allContracts.push(...erc721Contracts);`
{"Reverts when no revert string is returned from call to conduit"}
$DIR/test/transferhelper.spec.ts: `await tempERC1155Contract.connect(owner).mint(sender.address, 0, 100);`
$DIR/test/transferhelper.spec.ts: `await mockConduitController
        .connect(owner)
        .createConduit(mockConduitKey, owner.address);`
$DIR/test/transferhelper.spec.ts: `await tempERC1155Contract
        .connect(sender)
        .setApprovalForAll(mockConduitAddress, true);`
{"Reverts with invalid magic value returned by call to conduit"}
$DIR/test/transferhelper.spec.ts: `await tempERC20Contract.connect(owner).mint(sender.address, 100);`
$DIR/test/transferhelper.spec.ts: `await mockConduitController
        .connect(owner)
        .createConduit(mockConduitKey, owner.address);`
$DIR/test/transferhelper.spec.ts: `await tempERC20Contract.connect(sender).approve(mockConduitAddress, 100);`
{"Reverts with conduit revert data"}
$DIR/test/transferhelper.spec.ts: `await tempERC20Contract.connect(owner).mint(sender.address, 100);`
$DIR/test/transferhelper.spec.ts: `await mockConduitController
        .connect(owner)
        .createConduit(mockConduitKey, owner.address);`
$DIR/test/transferhelper.spec.ts: `await tempERC20Contract.connect(sender).approve(mockConduitAddress, 100);`
{"Executes transfers (many token types) with a conduit"}
$DIR/test/transferhelper.spec.ts: `.max(1, randomInt(itemsToCreate - 2))`
$DIR/test/transferhelper.spec.ts: `.max(1, randomInt(itemsToCreate - numERC20s - 1))`
$DIR/test/transferhelper.spec.ts: `.max(1, itemsToCreate - numERC20s - numERC721s)`
$DIR/test/transferhelper.spec.ts: `.connect(sender)`
$DIR/test/transferhelper.spec.ts: `.bulkTransfer(transfersWithRecipients, tempConduitKey)`
{"Cannot execute transfers (many token types) without a conduit"}
$DIR/test/transferhelper.spec.ts: `.max(1, randomInt(itemsToCreate - 2))`
$DIR/test/transferhelper.spec.ts: `.max(1, randomInt(itemsToCreate - numERC20s - 1))`
$DIR/test/transferhelper.spec.ts: `.max(1, itemsToCreate - numERC20s - numERC721s)`
{"Cannot execute ERC721 transfers to a contract recipient without a conduit"}
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "ERC721ReceiverMock"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        Buffer.from("150b7a02", "hex"),
        0
      )`
$DIR/test/transferhelper.spec.ts: `.from("150b7a02", "hex")`
{"Reverts on invalid function selector"}
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "InvalidERC721Recipient"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy()`
{"Reverts on nonexistent conduit"}
$DIR/test/transferhelper.spec.ts: `.connect(sender)`
$DIR/test/transferhelper.spec.ts: `.bulkTransfer(transfers, ethers.utils.formatBytes32String("0xabc"))`
$DIR/test/transferhelper.spec.ts: `.utils.formatBytes32String("0xabc")`
{"Reverts on error in ERC721 receiver"}
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "ERC721ReceiverMock"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        Buffer.from("abcd0000", "hex"),
        1
      )`
$DIR/test/transferhelper.spec.ts: `.from("abcd0000", "hex")`
{"Reverts on error in ERC721 receiver via conduit"}
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "ERC721ReceiverMock"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        Buffer.from("abcd0000", "hex"),
        1
      )`
$DIR/test/transferhelper.spec.ts: `.from("abcd0000", "hex")`
{"Reverts with bubbled up string error from call to conduit"}
$DIR/test/transferhelper.spec.ts: `.toLowerCase()`
{"Reverts when no revert string is returned from call to conduit"}
$DIR/test/transferhelper.spec.ts: `.connect(owner)`
$DIR/test/transferhelper.spec.ts: `.mint(sender.address, 0, 100)`
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "ConduitControllerMock"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        1 // ConduitMockRevertNoReason
      )`
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "TransferHelper"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        mockConduitController.address
      )`
$DIR/test/transferhelper.spec.ts: `.slice(2)`
$DIR/test/transferhelper.spec.ts: `.connect(owner)`
$DIR/test/transferhelper.spec.ts: `.createConduit(mockConduitKey, owner.address)`
$DIR/test/transferhelper.spec.ts: `.getConduit(mockConduitKey)`
$DIR/test/transferhelper.spec.ts: `.connect(sender)`
$DIR/test/transferhelper.spec.ts: `.setApprovalForAll(mockConduitAddress, true)`
$DIR/test/transferhelper.spec.ts: `.toLowerCase()`
{"Reverts with bubbled up panic error from call to conduit"}
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "TestERC20Panic"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy()`
{"Reverts with invalid magic value returned by call to conduit"}
$DIR/test/transferhelper.spec.ts: `.connect(owner)`
$DIR/test/transferhelper.spec.ts: `.mint(sender.address, 100)`
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "ConduitControllerMock"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        2 // ConduitMockInvalidMagic
      )`
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "TransferHelper"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        mockConduitController.address
      )`
$DIR/test/transferhelper.spec.ts: `.slice(2)`
$DIR/test/transferhelper.spec.ts: `.connect(owner)`
$DIR/test/transferhelper.spec.ts: `.createConduit(mockConduitKey, owner.address)`
$DIR/test/transferhelper.spec.ts: `.getConduit(mockConduitKey)`
$DIR/test/transferhelper.spec.ts: `.connect(sender)`
$DIR/test/transferhelper.spec.ts: `.approve(mockConduitAddress, 100)`
$DIR/test/transferhelper.spec.ts: `.toLowerCase()`
{"Reverts with conduit revert data"}
$DIR/test/transferhelper.spec.ts: `.connect(owner)`
$DIR/test/transferhelper.spec.ts: `.mint(sender.address, 100)`
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "ConduitControllerMock"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        3 // ConduitMockRevertBytes
      )`
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "TransferHelper"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        mockConduitController.address
      )`
$DIR/test/transferhelper.spec.ts: `.slice(2)`
$DIR/test/transferhelper.spec.ts: `.connect(owner)`
$DIR/test/transferhelper.spec.ts: `.createConduit(mockConduitKey, owner.address)`
$DIR/test/transferhelper.spec.ts: `.getConduit(mockConduitKey)`
$DIR/test/transferhelper.spec.ts: `.connect(sender)`
$DIR/test/transferhelper.spec.ts: `.approve(mockConduitAddress, 100)`
$DIR/test/transferhelper.spec.ts: `.utils.id("CustomError()")`
$DIR/test/transferhelper.spec.ts: `.slice(0, 10)`
$DIR/test/transferhelper.spec.ts: `.toLowerCase()`
{"Executes transfers with multiple recipients (many token types) with a conduit"}
$DIR/test/transferhelper.spec.ts: `.max(1, randomInt(itemsToCreate - 2))`
$DIR/test/transferhelper.spec.ts: `.max(1, randomInt(itemsToCreate - numERC20s - 1))`
$DIR/test/transferhelper.spec.ts: `.max(1, itemsToCreate - numERC20s - numERC721s)`
$DIR/test/transferhelper.spec.ts: `.push(
          ...erc20Contracts,
          ...erc721Contracts,
          ...erc1155Contracts
        )`
$DIR/test/transferhelper.spec.ts: `.connect(sender)`
$DIR/test/transferhelper.spec.ts: `.bulkTransfer(transfersWithRecipients, tempConduitKey)`
{"Cannot execute transfers with multiple recipients (many token types) without a conduit"}
$DIR/test/transferhelper.spec.ts: `.max(1, randomInt(itemsToCreate - 2))`
$DIR/test/transferhelper.spec.ts: `.max(1, randomInt(itemsToCreate - numERC20s - 1))`
$DIR/test/transferhelper.spec.ts: `.max(1, itemsToCreate - numERC20s - numERC721s)`
$DIR/test/transferhelper.spec.ts: `.push(
          ...erc20Contracts,
          ...erc721Contracts,
          ...erc1155Contracts
        )`
{"Cannot execute ERC721 transfers to multiple contract recipients without a conduit"}
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "ERC721ReceiverMock"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        Buffer.from("150b7a02", "hex"),
        0
      )`
$DIR/test/transferhelper.spec.ts: `.from("150b7a02", "hex")`
$DIR/test/transferhelper.spec.ts: `.deploy(
        Buffer.from("150b7a02", "hex"),
        0
      )`
$DIR/test/transferhelper.spec.ts: `.from("150b7a02", "hex")`
$DIR/test/transferhelper.spec.ts: `.deploy(
        Buffer.from("150b7a02", "hex"),
        0
      )`
$DIR/test/transferhelper.spec.ts: `.from("150b7a02", "hex")`
$DIR/test/transferhelper.spec.ts: `.deploy(
        Buffer.from("150b7a02", "hex"),
        0
      )`
$DIR/test/transferhelper.spec.ts: `.from("150b7a02", "hex")`
$DIR/test/transferhelper.spec.ts: `.deploy(
        Buffer.from("150b7a02", "hex"),
        0
      )`
$DIR/test/transferhelper.spec.ts: `.from("150b7a02", "hex")`
$DIR/test/transferhelper.spec.ts: `.push(...erc721Contracts)`
{"Successful ERC721 receiver contract"}
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "ERC721ReceiverMock"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        "0x150b7a02", // Magic value
        0
      )`
$DIR/test/transferhelper.spec.ts: `.connect(sender)`
{"Reverts on invalid function selector"}
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "InvalidERC721Recipient"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy()`
$DIR/test/transferhelper.spec.ts: `.deploy()`
{"Reverts on nonexistent conduit"}
$DIR/test/transferhelper.spec.ts: `.connect(sender)`
$DIR/test/transferhelper.spec.ts: `.bulkTransfer(
            transferHelperItems,
            ethers.utils.formatBytes32String("0xabc")
          )`
$DIR/test/transferhelper.spec.ts: `.utils.formatBytes32String("0xabc")`
{"Reverts on error in ERC721 receiver"}
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "ERC721ReceiverMock"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        Buffer.from("abcd0000", "hex"),
        1
      )`
$DIR/test/transferhelper.spec.ts: `.from("abcd0000", "hex")`
$DIR/test/transferhelper.spec.ts: `.deploy(
        Buffer.from("abcd6969", "hex"),
        1
      )`
$DIR/test/transferhelper.spec.ts: `.from("abcd6969", "hex")`
$DIR/test/transferhelper.spec.ts: `.deploy(
        Buffer.from("42069abc", "hex"),
        1
      )`
$DIR/test/transferhelper.spec.ts: `.from("42069abc", "hex")`
$DIR/test/transferhelper.spec.ts: `.deploy(
        Buffer.from("abc42069", "hex"),
        1
      )`
$DIR/test/transferhelper.spec.ts: `.from("abc42069", "hex")`
{"Reverts with bubbled up string error from call to conduit"}
$DIR/test/transferhelper.spec.ts: `.toLowerCase()`
{"Reverts when no revert string is returned from call to conduit"}
$DIR/test/transferhelper.spec.ts: `.connect(owner)`
$DIR/test/transferhelper.spec.ts: `.mint(sender.address, 0, 100)`
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "ConduitControllerMock"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        1 // ConduitMockRevertNoReason
      )`
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "TransferHelper"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        mockConduitController.address
      )`
$DIR/test/transferhelper.spec.ts: `.slice(2)`
$DIR/test/transferhelper.spec.ts: `.connect(owner)`
$DIR/test/transferhelper.spec.ts: `.createConduit(mockConduitKey, owner.address)`
$DIR/test/transferhelper.spec.ts: `.getConduit(mockConduitKey)`
$DIR/test/transferhelper.spec.ts: `.connect(sender)`
$DIR/test/transferhelper.spec.ts: `.setApprovalForAll(mockConduitAddress, true)`
$DIR/test/transferhelper.spec.ts: `.toLowerCase()`
{"Reverts with bubbled up panic error from call to conduit"}
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "TestERC20Panic"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy()`
{"Reverts with invalid magic value returned by call to conduit"}
$DIR/test/transferhelper.spec.ts: `.connect(owner)`
$DIR/test/transferhelper.spec.ts: `.mint(sender.address, 100)`
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "ConduitControllerMock"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        2 // ConduitMockInvalidMagic
      )`
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "TransferHelper"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        mockConduitController.address
      )`
$DIR/test/transferhelper.spec.ts: `.slice(2)`
$DIR/test/transferhelper.spec.ts: `.connect(owner)`
$DIR/test/transferhelper.spec.ts: `.createConduit(mockConduitKey, owner.address)`
$DIR/test/transferhelper.spec.ts: `.getConduit(mockConduitKey)`
$DIR/test/transferhelper.spec.ts: `.connect(sender)`
$DIR/test/transferhelper.spec.ts: `.approve(mockConduitAddress, 100)`
$DIR/test/transferhelper.spec.ts: `.toLowerCase()`
{"Reverts with conduit revert data"}
$DIR/test/transferhelper.spec.ts: `.connect(owner)`
$DIR/test/transferhelper.spec.ts: `.mint(sender.address, 100)`
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "ConduitControllerMock"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        3 // ConduitMockRevertBytes
      )`
$DIR/test/transferhelper.spec.ts: `.getContractFactory(
        "TransferHelper"
      )`
$DIR/test/transferhelper.spec.ts: `.deploy(
        mockConduitController.address
      )`
$DIR/test/transferhelper.spec.ts: `.slice(2)`
$DIR/test/transferhelper.spec.ts: `.connect(owner)`
$DIR/test/transferhelper.spec.ts: `.createConduit(mockConduitKey, owner.address)`
$DIR/test/transferhelper.spec.ts: `.getConduit(mockConduitKey)`
$DIR/test/transferhelper.spec.ts: `.connect(sender)`
$DIR/test/transferhelper.spec.ts: `.approve(mockConduitAddress, 100)`
$DIR/test/transferhelper.spec.ts: `.utils.id("CustomError()")`
$DIR/test/transferhelper.spec.ts: `.slice(0, 10)`
$DIR/test/transferhelper.spec.ts: `.toLowerCase()`
{"Code is equal to concatenated type hashes for heights 1-24"}
$DIR/test/typehashdirectory.spec.ts: `.provider.getCode(address)`
{"Assign pauser"}
$DIR/test/zone.spec.ts: `await pausableZoneController.connect(owner).assignPauser(buyer.address);`
{"Revert on deploying a zone with the same salt"}
$DIR/test/zone.spec.ts: `await pausableZoneController.createZone(salt);`
{"Operator of zone can cancel restricted orders"}
$DIR/test/zone.spec.ts: `await pausableZoneController
      .connect(owner)
      .assignOperator(zoneAddr, seller.address);`
$DIR/test/zone.spec.ts: `await zone
      .connect(seller)
      .cancelOrders(marketplaceContract.address, [orderComponents]);`
{"Reverts if non-Zone tries to cancel restricted orders"}
$DIR/test/zone.spec.ts: `await createZone(pausableZoneController);`
{"Lets the Zone Deployer owner transfer ownership via a two-stage process"}
$DIR/test/zone.spec.ts: `await createZone(pausableZoneController);`
$DIR/test/zone.spec.ts: `await pausableZoneController
      .connect(owner)
      .transferOwnership(buyer.address);`
$DIR/test/zone.spec.ts: `await pausableZoneController.connect(owner).cancelOwnershipTransfer();`
$DIR/test/zone.spec.ts: `await pausableZoneController
      .connect(owner)
      .transferOwnership(buyer.address);`
$DIR/test/zone.spec.ts: `await pausableZoneController.connect(buyer).acceptOwnership();`
{"Reverts on fulfill and aggregate multiple orders (ERC-1155) via fulfillAvailableAdvancedOrders (via conduit) with balance checking on validation zone (1.2 Issue - resolved in 1.3)"}
$DIR/test/zone.spec.ts: `orderOne.extraData = ethers.utils.defaultAbiCoder.encode(
      ["bytes32[]"],
      [[orderHashOne, orderHashTwo]]
    );`
$DIR/test/zone.spec.ts: `await withBalanceChecks(
        [orderOne, orderTwo],
        0,
        undefined,
        async () => {
          const tx = marketplaceContract
            .connect(buyer)
            .fulfillAvailableAdvancedOrders(
              [orderOne, orderTwo],
              [],
              offerComponents,
              considerationComponents,
              toKey(0),
              ethers.constants.AddressZero,
              100,
              {
                value: value.mul(2),
              }
            );
          const receipt = await (await tx).wait();
          await checkExpectedEvents(
            tx,
            receipt,
            [
              {
                order: orderOne,
                orderHash: orderHashOne,
                fulfiller: buyer.address,
              },
              {
                order: orderTwo,
                orderHash: orderHashTwo,
                fulfiller: buyer.address,
              },
            ],
            [],
            [],
            false,
            2
          );
          return receipt;
        },
        2
      );`
{"Fulfills an order with a pausable zone"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(owner.address)`
$DIR/test/zone.spec.ts: `.connect(buyer)`
$DIR/test/zone.spec.ts: `.fulfillOrder(order, toKey(0), {
          value,
        })`
$DIR/test/zone.spec.ts: `.wait()`
{"Fulfills an advanced order with criteria with a pausable zone"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(owner.address)`
$DIR/test/zone.spec.ts: `.connect(buyer)`
$DIR/test/zone.spec.ts: `.fulfillAdvancedOrder(
          order,
          criteriaResolvers,
          toKey(0),
          ethers.constants.AddressZero,
          {
            value,
          }
        )`
$DIR/test/zone.spec.ts: `.wait()`
{"Fulfills a PARTIAL_RESTRICTED order with the caller being the offerer"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(owner.address)`
$DIR/test/zone.spec.ts: `.connect(buyer)`
$DIR/test/zone.spec.ts: `.fulfillAdvancedOrder(
          order,
          [],
          toKey(0),
          ethers.constants.AddressZero,
          {
            value,
          }
        )`
$DIR/test/zone.spec.ts: `.wait()`
{"Fulfills an order with executeMatchOrders"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(
      owner.address
    )`
$DIR/test/zone.spec.ts: `.map(([offerArr, considerationArr]) =>
      toFulfillment(offerArr, considerationArr)
    )`
$DIR/test/zone.spec.ts: `.connect(owner)`
$DIR/test/zone.spec.ts: `.callStatic.executeMatchOrders(
        zoneAddr,
        marketplaceContract.address,
        [orderOne, orderTwo, orderThree],
        fulfillments,
        { value: 0 }
      )`
$DIR/test/zone.spec.ts: `.connect(owner)`
$DIR/test/zone.spec.ts: `.executeMatchOrders(
        zoneAddr,
        marketplaceContract.address,
        [orderOne, orderTwo, orderThree],
        fulfillments
      )`
{"Fulfills an order with executeMatchAdvancedOrders"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(
      owner.address
    )`
$DIR/test/zone.spec.ts: `.map(([offerArr, considerationArr]) =>
      toFulfillment(offerArr, considerationArr)
    )`
$DIR/test/zone.spec.ts: `.connect(owner)`
$DIR/test/zone.spec.ts: `.callStatic.executeMatchAdvancedOrders(
        zoneAddr,
        marketplaceContract.address,
        [orderOne, orderTwo, orderThree],
        [],
        fulfillments,
        { value: 0 }
      )`
$DIR/test/zone.spec.ts: `.connect(owner)`
$DIR/test/zone.spec.ts: `.executeMatchAdvancedOrders(
        zoneAddr,
        marketplaceContract.address,
        [orderOne, orderTwo, orderThree],
        [],
        fulfillments
      )`
{"Only the deployer owner can create a zone"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(
      owner.address
    )`
{"Assign pauser"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(
      owner.address
    )`
$DIR/test/zone.spec.ts: `.getContractFactory("PausableZone", owner)`
$DIR/test/zone.spec.ts: `.attach(zoneAddr)`
$DIR/test/zone.spec.ts: `.connect(owner)`
$DIR/test/zone.spec.ts: `.assignPauser(buyer.address)`
$DIR/test/zone.spec.ts: `.connect(buyer)`
$DIR/test/zone.spec.ts: `.pause(zoneAddr)`
{"Revert on deploying a zone with the same salt"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(
      owner.address
    )`
$DIR/test/zone.spec.ts: `.createZone(salt)`
{"Revert on an order with a pausable zone if zone has been paused"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(
      owner.address
    )`
$DIR/test/zone.spec.ts: `.pause(zoneAddr)`
{"Reverts if non-owner tries to self destruct the zone"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(
      owner.address
    )`
$DIR/test/zone.spec.ts: `.connect(buyer)`
$DIR/test/zone.spec.ts: `.pause(zoneAddr)`
{"Zone can cancel restricted orders"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(
      owner.address
    )`
{"Operator of zone can cancel restricted orders"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(
      owner.address
    )`
$DIR/test/zone.spec.ts: `.getContractFactory("PausableZone", owner)`
$DIR/test/zone.spec.ts: `.attach(zoneAddr)`
$DIR/test/zone.spec.ts: `.connect(owner)`
$DIR/test/zone.spec.ts: `.assignOperator(zoneAddr, seller.address)`
$DIR/test/zone.spec.ts: `.connect(seller)`
$DIR/test/zone.spec.ts: `.cancelOrders(marketplaceContract.address, [orderComponents])`
{"Reverts trying to assign operator as non-deployer"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(
      owner.address
    )`
$DIR/test/zone.spec.ts: `.getContractFactory("PausableZone", owner)`
$DIR/test/zone.spec.ts: `.attach(zoneAddr)`
$DIR/test/zone.spec.ts: `.connect(seller)`
$DIR/test/zone.spec.ts: `.assignOperator(seller.address)`
{"Reverts if non-Zone tries to cancel restricted orders"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(
      owner.address
    )`
$DIR/test/zone.spec.ts: `.connect(buyer)`
$DIR/test/zone.spec.ts: `.cancel([orderComponents])`
{"Reverts if non-owner tries to use the zone to cancel restricted orders"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(
      owner.address
    )`
$DIR/test/zone.spec.ts: `.connect(buyer)`
$DIR/test/zone.spec.ts: `.cancelOrders(zoneAddr, marketplaceContract.address, [orderComponents])`
{"Lets the Zone Deployer owner transfer ownership via a two-stage process"}
$DIR/test/zone.spec.ts: `.getContractFactory(
      "PausableZoneController",
      owner
    )`
$DIR/test/zone.spec.ts: `.deploy(
      owner.address
    )`
$DIR/test/zone.spec.ts: `.connect(owner)`
$DIR/test/zone.spec.ts: `.transferOwnership(buyer.address)`
$DIR/test/zone.spec.ts: `.connect(owner)`
$DIR/test/zone.spec.ts: `.cancelOwnershipTransfer()`
$DIR/test/zone.spec.ts: `.connect(owner)`
$DIR/test/zone.spec.ts: `.transferOwnership(buyer.address)`
$DIR/test/zone.spec.ts: `.connect(buyer)`
$DIR/test/zone.spec.ts: `.acceptOwnership()`
{"Fulfills an order with a transfer validation zone"}
$DIR/test/zone.spec.ts: `.getContractFactory(
        "TestTransferValidationZoneOfferer",
        owner
      )`
$DIR/test/zone.spec.ts: `.deploy(
      ethers.constants.AddressZero
    )`
$DIR/test/zone.spec.ts: `.connect(buyer)`
$DIR/test/zone.spec.ts: `.fulfillOrder(order, toKey(0), {
          value,
        })`
$DIR/test/zone.spec.ts: `.wait()`
{"Fulfills an advanced order with criteria with the transfer validation zone"}
$DIR/test/zone.spec.ts: `.getContractFactory(
        "TestTransferValidationZoneOfferer",
        owner
      )`
$DIR/test/zone.spec.ts: `.deploy(
      ethers.constants.AddressZero
    )`
$DIR/test/zone.spec.ts: `.connect(buyer)`
$DIR/test/zone.spec.ts: `.fulfillAdvancedOrder(
          order,
          criteriaResolvers,
          toKey(0),
          ethers.constants.AddressZero,
          {
            value,
          }
        )`
$DIR/test/zone.spec.ts: `.wait()`
{"Fulfills a PARTIAL_RESTRICTED order with the caller being the offerer through the transfer validation zone"}
$DIR/test/zone.spec.ts: `.getContractFactory(
        "TestTransferValidationZoneOfferer",
        owner
      )`
$DIR/test/zone.spec.ts: `.deploy(
      ethers.constants.AddressZero
    )`
$DIR/test/zone.spec.ts: `.connect(buyer)`
$DIR/test/zone.spec.ts: `.fulfillAdvancedOrder(
          order,
          [],
          toKey(0),
          ethers.constants.AddressZero,
          {
            value,
          }
        )`
$DIR/test/zone.spec.ts: `.wait()`
{"Reverts on fulfill and aggregate multiple orders (ERC-1155) via fulfillAvailableAdvancedOrders (via conduit) with balance checking on validation zone (1.2 Issue - resolved in 1.3)"}
$DIR/test/zone.spec.ts: `.div(2)`
$DIR/test/zone.spec.ts: `.div(2)`
$DIR/test/zone.spec.ts: `.getContractFactory(
        "TestTransferValidationZoneOfferer",
        owner
      )`
$DIR/test/zone.spec.ts: `.deploy(
        ethers.constants.AddressZero
      )`
$DIR/test/zone.spec.ts: `.utils.defaultAbiCoder.encode(
      ["bytes32[]"],
      [[orderHashOne, orderHashTwo]]
    )`
$DIR/test/zone.spec.ts: `.map(toFulfillmentComponents)`
$DIR/test/zone.spec.ts: `.connect(buyer)`
$DIR/test/zone.spec.ts: `.fulfillAvailableAdvancedOrders(
              [orderOne, orderTwo],
              [],
              offerComponents,
              considerationComponents,
              toKey(0),
              ethers.constants.AddressZero,
              100,
              {
                value: value.mul(2),
              }
            )`
$DIR/test/zone.spec.ts: `.mul(2)`
$DIR/test/zone.spec.ts: `.wait()`
